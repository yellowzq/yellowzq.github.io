<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>C++ 教程 | 技术栈</title><meta name="description" content="[toc]  符号  using namespace std;   这条指令是一个全新的概念：名字空间   所有标识符都在一个特殊的名字空间 std 中来定义，用以区分不同的命名版本  cout &lt;&lt;    有此指令 std::cout &lt;&lt;     无此指令    让程序访问名称空间 std 的方法  将指令放在函数定义前，让文件中所有函数都能使用名称空间std中所有元素"><meta property="og:type" content="article"><meta property="og:title" content="C++ 教程"><meta property="og:url" content="https://www.rgzzplus.com/2022/03/10/C/index.html"><meta property="og:site_name" content="技术栈"><meta property="og:description" content="[toc]  符号  using namespace std;   这条指令是一个全新的概念：名字空间   所有标识符都在一个特殊的名字空间 std 中来定义，用以区分不同的命名版本  cout &lt;&lt;    有此指令 std::cout &lt;&lt;     无此指令    让程序访问名称空间 std 的方法  将指令放在函数定义前，让文件中所有函数都能使用名称空间std中所有元素"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-03-10T08:32:34.000Z"><meta property="article:modified_time" content="2022-08-01T11:17:39.865Z"><meta property="article:author" content="rgzzplus"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.rgzzplus.com/2022/03/10/C/index.html"><link rel="alternate" href="/atom.xml" title="技术栈" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/rgzz-zq" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">人工智障plus</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Wuhan, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎来到技术栈！</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%94%B6%E8%97%8F%E5%A4%B9/">收藏夹</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/">经验交流</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/">题库/作业</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/">高级搜索</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/ASLR/" style="font-size:13px">ASLR</a> <a href="/tags/C/" style="font-size:13px">C++</a> <a href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" style="font-size:13.33px">C和指针</a> <a href="/tags/DEP/" style="font-size:13px">DEP</a> <a href="/tags/GS/" style="font-size:13px">GS</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/HeapSpary/" style="font-size:13px">HeapSpary</a> <a href="/tags/IDA/" style="font-size:13.33px">IDA</a> <a href="/tags/LNMP/" style="font-size:13px">LNMP</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" style="font-size:13px">Linux保护机制</a> <a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size:13px">Linux常用命令</a> <a href="/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/" style="font-size:13px">Linux汇编伪指令</a> <a href="/tags/QT/" style="font-size:13.33px">QT</a> <a href="/tags/ROP/" style="font-size:13px">ROP</a> <a href="/tags/SEHOP/" style="font-size:13px">SEHOP</a> <a href="/tags/SafeSEH/" style="font-size:13px">SafeSEH</a> <a href="/tags/c/" style="font-size:13px">c</a> <a href="/tags/gdb/" style="font-size:14px">gdb</a> <a href="/tags/glibc%E7%89%88%E6%9C%AC%E5%8F%B7/" style="font-size:13px">glibc版本号</a> <a href="/tags/hexo/" style="font-size:13.33px">hexo</a> <a href="/tags/libc/" style="font-size:13px">libc</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" style="font-size:13px">linux命令行大全</a> <a href="/tags/linux%E9%97%AE%E9%A2%98/" style="font-size:13px">linux问题</a> <a href="/tags/ollydebug/" style="font-size:13px">ollydebug</a> <a href="/tags/pwn/" style="font-size:13px">pwn</a> <a href="/tags/pwnstack/" style="font-size:13px">pwnstack</a> <a href="/tags/ret2libc/" style="font-size:13px">ret2libc</a> <a href="/tags/ret2shellcode/" style="font-size:13px">ret2shellcode</a> <a href="/tags/ret2syscall/" style="font-size:13px">ret2syscall</a> <a href="/tags/ret2text/" style="font-size:13px">ret2text</a> <a href="/tags/ret2win/" style="font-size:13px">ret2win</a> <a href="/tags/reverse/" style="font-size:13.33px">reverse</a> <a href="/tags/shellcode/" style="font-size:13.67px">shellcode</a> <a href="/tags/task-struct/" style="font-size:13px">task_struct</a> <a href="/tags/typora/" style="font-size:13px">typora</a> <a href="/tags/ubuntu/" style="font-size:13.67px">ubuntu</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" style="font-size:13px">中国知网</a> <a href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" style="font-size:13px">互斥锁</a> <a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="font-size:13px">信号量</a> <a href="/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/" style="font-size:13px">其它类型的漏洞</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size:13px">内存大小端</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" style="font-size:13px">内存攻击</a> <a href="/tags/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/" style="font-size:13px">内核版本</a> <a href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" style="font-size:13px">函数指针</a> <a href="/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" style="font-size:13px">同步互斥</a> <a href="/tags/%E5%A0%86/" style="font-size:13.67px">堆</a> <a href="/tags/%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96/" style="font-size:13px">安装包依赖</a> <a href="/tags/%E5%B1%8F%E9%9A%9C/" style="font-size:13px">屏障</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size:13px">建站</a> <a href="/tags/%E5%BF%83%E8%B7%AF/" style="font-size:13px">心路</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" style="font-size:13px">搜索引擎</a> <a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size:13.33px">攻防世界</a> <a href="/tags/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/" style="font-size:13px">数组越界</a> <a href="/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" style="font-size:13px">整数安全</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size:13px">杂谈</a> <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" style="font-size:13px">条件变量</a> <a href="/tags/%E6%A0%88/" style="font-size:13px">栈</a> <a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" style="font-size:13px">栈溢出</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">格式化字符串</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size:13px">正则表达式</a> <a href="/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" style="font-size:13px">汇编指令</a> <a href="/tags/%E6%BC%8F%E6%B4%9E/" style="font-size:14px">漏洞</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/" style="font-size:13px">系统进程</a> <a href="/tags/%E8%87%AA%E6%97%8B%E9%94%81/" style="font-size:13px">自旋锁</a> <a href="/tags/%E8%AE%BA%E5%9D%9B-%E5%8D%9A%E5%AE%A2/" style="font-size:13px">论坛&博客</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size:13px">读写锁</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">16</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/10/17/QTCreater%E9%A3%9F%E7%94%A8%E6%8A%80%E5%B7%A7/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/c/">c++</a></p><p class="item-title"><a href="/2022/10/17/QTCreater%E9%A3%9F%E7%94%A8%E6%8A%80%E5%B7%A7/" class="title">QTCreater食用技巧</a></p><p class="item-date"><time datetime="2022-10-17T00:24:14.000Z" itemprop="datePublished">2022-10-17</time></p></div></li><li><div class="item-thumb"><a href="/2022/10/17/QT%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></p><p class="item-title"><a href="/2022/10/17/QT%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="title">QT安装教程</a></p><p class="item-date"><time datetime="2022-10-17T00:22:14.000Z" itemprop="datePublished">2022-10-17</time></p></div></li><li><div class="item-thumb"><a href="/2022/10/14/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/">高级搜索</a></p><p class="item-title"><a href="/2022/10/14/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/" class="title">高级搜索</a></p><p class="item-date"><time datetime="2022-10-14T12:32:53.000Z" itemprop="datePublished">2022-10-14</time></p></div></li><li><div class="item-thumb"><a href="/2022/10/03/pwnstack/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/10/03/pwnstack/" class="title">pwnstack</a></p><p class="item-date"><time datetime="2022-10-03T01:38:34.000Z" itemprop="datePublished">2022-10-03</time></p></div></li><li><div class="item-thumb"><a href="/2022/10/03/PWN%E9%A2%98%E7%9B%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84glibc/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/10/03/PWN%E9%A2%98%E7%9B%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84glibc/" class="title">PWN题目加载指定版本的glibc</a></p><p class="item-date"><time datetime="2022-10-03T01:38:08.000Z" itemprop="datePublished">2022-10-03</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.</span> <span class="toc-text">符号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using-namespace-std"><span class="toc-number">1.1.</span> <span class="toc-text">using namespace std;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cout"><span class="toc-number">1.2.</span> <span class="toc-text">cout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">&lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cin"><span class="toc-number">1.4.</span> <span class="toc-text">cin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">1.5.</span> <span class="toc-text">&gt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">const 限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#endl"><span class="toc-number">1.7.</span> <span class="toc-text">endl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-3"><span class="toc-number">1.8.</span> <span class="toc-text">&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-4"><span class="toc-number">1.9.</span> <span class="toc-text">{}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-5"><span class="toc-number">1.10.</span> <span class="toc-text">：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%AD%97%E7%AC%A6"><span class="toc-number">1.11.</span> <span class="toc-text">其它字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">C++基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%9D%80%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">传值，传址和传引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.6.</span> <span class="toc-text">联合，枚举和类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">函数指针和指针函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">C++高级教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.</span> <span class="toc-text">链接和作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">容器和算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A%E8%B0%83%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text">错误处理及调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">4.4.</span> <span class="toc-text">动态内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">命名空间和模块化编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.6.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.7.</span> <span class="toc-text">高级强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87"><span class="toc-number">5.</span> <span class="toc-text">疑难杂症</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8cin%E8%BE%93%E5%85%A5%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%8D%E8%B7%B3%E8%BF%87%E4%BB%BB%E6%84%8F%E5%9C%B0%E6%96%B9%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E6%8D%A2%E8%A1%8C"><span class="toc-number">5.1.</span> <span class="toc-text">用cin输入时如何让不跳过任意地方的空格和换行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82"><span class="toc-number">5.2.</span> <span class="toc-text">函数引用传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%E4%B8%8Enull"><span class="toc-number">5.3.</span> <span class="toc-text">nullptr与NULL</span></a></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-C" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">C++ 教程</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/03/10/C/" class="article-date"><time datetime="2022-03-10T08:32:34.000Z" itemprop="datePublished">2022-03-10</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/C/" rel="tag">C++</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/03/10/C/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 13.8k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 49(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>[toc]</p><h2 id="符号"><a class="markdownIt-Anchor" href="#符号"></a> 符号</h2><h3 id="using-namespace-std"><a class="markdownIt-Anchor" href="#using-namespace-std"></a> using namespace std;</h3><ul><li><p>这条指令是一个全新的概念：名字空间</p></li><li><p>所有标识符都在一个特殊的名字空间 <code>std</code> 中来定义，用以区分不同的命名版本</p><ul><li><code>cout &lt;&lt;</code> 有此指令</li><li><code>std::cout &lt;&lt;</code> 无此指令</li></ul></li><li><p>让程序访问名称空间 <code>std</code> 的方法</p><ul><li>将指令放在函数定义前，让文件中所有函数都能使用名称空间std中所有元素</li><li>将指令放在特定的函数定义中，让该函数能够使用名称空间std中所有元素</li><li>在特定的函数中使用类似 <code>using std::cout;</code> 这样编译指令，让该函数使用指定的元素，如 <code>cout</code></li><li>完全不使用编译指令 <code>using</code> ，而在需要使用名称空间std中的元素时，使用前缀 <code>std::</code></li></ul></li></ul><h3 id="cout"><a class="markdownIt-Anchor" href="#cout"></a> cout</h3><ul><li>全名 <code>console out</code> ，<code>cout</code> 是一个输出流对象</li></ul><h3><a class="markdownIt-Anchor" href="#"></a> &lt;&lt;</h3><ul><li>名称：插入运算符</li><li>在 c 中是左移操作符</li><li>在 c++ 中它有另一个特点：支持重载。</li><li>重载，即同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。</li></ul><h3 id="cin"><a class="markdownIt-Anchor" href="#cin"></a> cin</h3><ul><li>流对象，从用户终端读取数据</li></ul><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> &gt;&gt;</h3><ul><li>输入操作符又称提取符，它一次从输入流对象 <code>cin</code> 提取一个元素</li><li>如果用户不进行键盘输入，则程序会阻塞。</li></ul><h3 id="const-限定符"><a class="markdownIt-Anchor" href="#const-限定符"></a> const 限定符</h3><ul><li><p>作用：只要一个变量前面用 <code>const</code> 来修饰，该变量里的数据可以被访问，不能被修改，也就是只读。<code>const</code> 与 宏定义（<code>define</code>）效果差不多</p></li><li><p>只要一个变量前面用 <code>const</code> 来修饰，该变量里的数据可以被访问，不能被修改，也就是只读。<code>const</code> 与 宏定义（<code>define</code>）效果差不多</p></li><li><p>规则：<code>const</code> 离谁近，谁就不能被修改；比较复杂时，从右往左读</p><ul><li><p><code>const</code> 修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。</p></li><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">const</span> type name = value；
&lt;!--code￼<span class="hljs-number">0</span>--&gt;

</code></pre></li></ul></li></ul><p>//下面给出正确的赋值方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> pi=<span class="number">3.141592</span>;            <span class="comment">//圆周率的值用pi表示</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;圆周率的近似值是&quot;</span>&lt;&lt;pi&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>与 <code>define</code> 相比</p><ul><li>可以明确指定类型</li><li>可以使用作用域规则将定义限制在特定的函数或文件中</li><li>可以将 <code>const</code> 用于更复杂的类型</li></ul></li></ul><h3 id="endl"><a class="markdownIt-Anchor" href="#endl"></a> endl</h3><ul><li>名称：控制符。作用：重起一行。光标将被移到下一行开头。</li><li><code>\n</code> 也可以用，不过，使用它不能保证程序继续运行前将其立即显示在屏幕上</li></ul><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> =</h3><ul><li>名称：赋值运算符，在 c 和 c++ 中可以连续使用，如 <code>a=b=c=1</code></li></ul><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> {}</h3><ul><li><p>大括号初始化器，使用它初始化时，可以使用等号（=），也可以不使用</p><ul><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> emus&#123;<span class="hljs-number">7</span>&#125;;
&lt;!--code￼<span class="hljs-number">2</span>--&gt;

</code></pre></li></ul></li><li><p>大括号中可以不包含任何东西，变量将被初始化为0；</p><ul><li><pre class="highlight"><code class="c++"><span class="hljs-keyword">int</span> rocs=&#123;&#125;；
&lt;!--code￼<span class="hljs-number">3</span>--&gt;

</code></pre></li></ul></li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> ：</h3><ul><li><p>1、类构造函数 (Constructor) 的初始化列表</p><ul><li><p>在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号 (,) 隔开。下面举个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="built_in">myClass</span>();<span class="comment">// 构造函数，无返回类型，可以有参数列表，这里省去</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">myClass</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myClass::<span class="built_in">myClass</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">1</span>)<span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：</p><ul><li><p>1)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。</p><ul><li><p>在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myClass::myClass（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;<span class="comment">// 没错，效果相当于在初始化列表中进行初始化</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span>;<span class="comment">// 出错，const变量不能进行赋值操作；</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2）初始化的顺序与成员变量声名的顺序相同。</p><ul><li><p>先看一下下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myClass::<span class="built_in">myClass</span>():<span class="built_in">b</span>(<span class="number">1</span>),<span class="built_in">a</span>(b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。</p></li></ul></li><li><p>3）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。</p></li></ul></li><li><p>2、声明基类。</p><ul><li><p>假设我们重新定义一个类，继承自myClass类。定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class derivedClass : public myClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 略去</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的冒号起到的就是声名基类的作用，在基类类名前面可以加 public\private\protected 等标签，用于标识继承的类型，也可以省略，省略的话，用 class 定义的类默认为 private ，用 struct 定义的类默认为 public ，至于具体各个标签有什么区别这里就不说了。</p></li><li><p>与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。</p></li></ul></li></ul><h3 id="其它字符"><a class="markdownIt-Anchor" href="#其它字符"></a> 其它字符</h3><ul><li>\n 换行符</li><li>\t 水平制表符</li><li>\v 垂直制表符</li><li>\b 退格</li><li>\r 回车</li><li>\a 振铃</li><li>\ 反斜杠 \</li></ul><h2 id="c基本语法"><a class="markdownIt-Anchor" href="#c基本语法"></a> C++基本语法</h2><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><ul><li><p>cin</p><ul><li><code>cin.peek();</code>就是返回输入流里面的第一个字符，但是不会像 <code>get</code> 那样取出来</li><li><code>cin.get(数组名，长度，结束符);</code>会提取出输入的第一个字符</li><li><code>cin.ignore(长度，结束符);</code> 从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用的</li><li><code>cin.getline(数组名，长度，结束符);</code>提取一行</li><li><code>cin.read(buf,20);</code>把数据读入数据流中</li><li><code>cin.clear();</code> 清理错误表示符</li></ul></li><li><p>cout</p><ul><li><code>cout.precision();</code>精度</li><li><code>cout.width();</code>长度</li></ul></li><li><p><code>cint(小数);</code>将此小数四舍五入<br>其它方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2.6</span>;</span><br><span class="line"><span class="type">int</span> i=(<span class="type">int</span>)(x+<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h3><ul><li><code>in</code>，<code>out</code></li><li><code>getc()</code> 函数一次从输入流（stdin）读取一个字符，返回值是int类型。</li><li><code>putc()</code>函数把这个字符写入到输出流（stdout）</li><li>EOF 宏定义 <code>end of file</code> 一般是文件的结尾，值为 <code>-1</code></li><li><code>open()</code></li></ul><h3 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h3><ul><li><p>概念：地址是计算机内存中的某个位置，指针是专门用来存放地址的特殊类型变量</p></li><li><p>形式：<code>type *pointerName;</code></p><ul><li>允许void类型指针</li></ul></li><li><p>内存：程序在硬盘上以文件的形式存在，但它们的运行在计算机的内存中发生的</p></li><li><p>对齐：变量类型是根据它们的自然边界进行对齐的。不同操作系统对齐字节不同</p><ul><li>文件对齐，内存对齐<ul><li>程序在编译链接后会被分割成一个一个的区块，而区块在文件和内存中要按照一定的规律来对齐</li></ul></li></ul></li><li><p>寻址</p><ul><li><p>通过变量名</p></li><li><p>通过变量地址</p><ul><li>变量的地址在程序执行期间是不会发生变化的</li><li>不过，同一个程序不同时间加载到内存中，同一个变量的地址是会改变的</li></ul></li><li><p>’&amp;‘ 取址操作符，给变量取别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt;<span class="string">&quot;Address is :&quot;</span> &lt;&lt;&amp;var;</span><br></pre></td></tr></table></figure></li><li><p>可以把地址赋值给一种称为指针的特殊变量</p></li><li><p>指针类型必与由它保存其地址的变量的类型一致</p></li><li><p>’*‘ 解引用符</p></li><li><p>c++ 允许指针群 p ，就是多个指针有同样的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p1=&amp;myInt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>*p2=&amp;myInt;</span><br></pre></td></tr></table></figure></li><li><p>c++支持无类型（void）指针，就是没有被声明为某种特定类型的指针</p><p><code>void*vPointer;</code></p></li></ul></li><li><p><code>reinterpret_cast&lt;type&gt; (expr): reinterpret_cast</code> 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。</p></li><li><p>数组的名字同时也是一个指向其第一个元素（基地址）的指针。</p></li></ul><h3 id="传值传址和传引用"><a class="markdownIt-Anchor" href="#传值传址和传引用"></a> 传值，传址和传引用</h3><ul><li><p>在默认情况下，参数只能以值传递的方式给函数</p><ul><li>被传递到函数的只是 { 变量的值 }，永远不会是变量本身</li></ul></li><li><p>如何绕开“传值”？</p><ul><li><p>传地址</p><ul><li>向函数 { 传递变量的地址 } 取代它的值</li><li>想要 { 获取某个变量的地址 } 只需要在它前面加“取址符”【&amp;】</li><li>注意：如果传的是地址，在函数中必须要通过【*】对指针进行解引用</li></ul></li><li><p>引用传递</p><ul><li>声明时：<code>swap(int &amp;x，int &amp;y);</code></li><li>用函数时：<code>swap(num1，num2);</code></li></ul></li><li><p>反汇编</p></li></ul></li></ul><h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3><ul><li><p>定义结构的语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">name</span></span><br><span class="line">&#123;</span><br><span class="line">	type varName1;</span><br><span class="line">	type varName2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用 “ . &quot; 对结构成员进行赋值</p></li><li><p>结构与指针</p><ul><li><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FishOil</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string id;</span><br><span class="line">	<span class="type">char</span> sex;             <span class="comment">//F==Female,M=Male</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//创建一个 FishOil 类型的变量</span></span><br><span class="line">FishOil Jiayu=&#123;<span class="string">&quot;小甲鱼”,&quot;</span>fishc_00000<span class="string">&quot;,&#x27;M&#x27;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//创建一个指向该结构的指针</span></span><br><span class="line"><span class="string">FishOil *pJiayu=&amp;Jiayu;</span></span><br><span class="line"><span class="string">/*注意：因为指针的类型必须与指向的地址的变量的类型一致，所以pJiayu指针的类型也是FishOil */</span></span><br></pre></td></tr></table></figure></li><li><p>通过指针访问结构成员</p><ul><li><p>对指针进行解引用来访问相应的变量值</p><ul><li><code>(*pJiayu).name=&quot;黑夜&quot;;</code></li><li><code>(*pJiayu).id=&quot;fishc_00001&quot;;</code></li></ul></li><li><p>用箭头</p><ul><li><code>pJiayu-&gt;name=&quot;黑夜&quot;;</code></li><li><code>pJiayu-&gt;id=&quot;fishc_00001&quot;;</code></li></ul></li><li><p>区分&quot;.“与”-&gt;&quot;</p><ul><li>把(*pJiayu)当作结构变量时用&quot;.&quot;</li><li>把 pJiayu 当作指针时用&quot;-&gt;&quot;</li></ul></li></ul></li></ul></li></ul><h3 id="联合枚举和类型别名"><a class="markdownIt-Anchor" href="#联合枚举和类型别名"></a> 联合，枚举和类型别名</h3><ul><li><p>联合（union)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">mima</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> birthday;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ssn;</span><br><span class="line">	<span class="type">char</span>* pet;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建该类型的变量</span></span><br><span class="line">mima mima_1;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">mima_1.birthday=<span class="number">20010101</span>；</span><br><span class="line">mima_1.pet=<span class="string">&quot;Chaozai&quot;</span>;</span><br><span class="line"><span class="comment">//这个联合将把“Chaozai&quot;存入mima_1联合的pet成员，并丢弃birthday成员里的值</span></span><br></pre></td></tr></table></figure><ul><li>联合也可以容纳多种不同类型的值，但是它每次只能存储这些值中的某一个</li></ul></li><li><p>枚举(enum)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用枚举来创建一个可取值列表</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">weekdays</span>&#123; Monday,Tuesday,Wednesday,Thursday,Friday&#125;;</span><br><span class="line"><span class="comment">//创建变量</span></span><br><span class="line">weekdays today;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">today = Thursday;</span><br></pre></td></tr></table></figure><ul><li><p>注意：不用引号，因为枚举值不是字符串</p></li><li><p>编译器会按照枚举值在定义时出现的先后顺序把它们与0~n-1的整数（n是枚举值的总个数）分别关联起来</p></li><li><p>优点</p><ul><li>它们可以限制变量的可取值</li><li>它们可以用作switch条件语句的case标号</li></ul></li></ul></li><li><p>类型别名</p><p><code>typedef int* intPointer;</code></p><ul><li>Typedef，为一个类型定义别名</li></ul></li></ul><h3 id="函数指针和指针函数"><a class="markdownIt-Anchor" href="#函数指针和指针函数"></a> 函数指针和指针函数</h3><ul><li><p>函数指针：指向函数首地址的指针变量称为函数指针</p><ul><li>声明 <code>int (*p)( );</code></li></ul></li><li><p>指针函数：一个函数可以带回一个整型数据的值，字符类型值和实型类型的值，还可以带回指针类型的数据，使其指向某个地址单元</p></li></ul><h2 id="面对对象"><a class="markdownIt-Anchor" href="#面对对象"></a> 面对对象</h2><h3 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h3><ul><li><p>类和对象基础</p><ul><li><p>类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。</p></li><li><p>操作文件的对象</p><ul><li><p>ifstream，（input file stream）</p><p><code>ifstream in;</code><br><code>in.open(&quot;test.txt&quot;);</code></p><p>等价于 <code>ifstream in(&quot;test.txt&quot;);</code> 默认操作为打开</p><ul><li><p>两个参数 <code>ifstream in(char* filename,int open_mode);</code></p><ul><li><p>filename 文件名称，它是一个字符串</p></li><li><p>open_mode 打开模式，其值用来定义以怎样的方式打开文件</p><ul><li><p>常见的打开模式</p><ul><li>ios::in–打开一个可读取文件</li><li>ios::out–打开一个可写入文件</li><li>ios::binary–以二进制的形式打开一个文件</li><li>ios::app–写入的所有数据将被追加到文件的末尾</li><li>ios::trunk–删除文件原来已存在的内容</li><li>ios::nocreate–如果要打开的文件并不存在，那么以此参数调用open函数将无法进行</li><li>ios::noreplace–如果要打开的文件已存在，试图用open函数打开时将返回一个错误</li><li>ios::beg–使得文件指针指向文件头</li><li>ios::end–使得文件指针指向文件尾</li></ul></li></ul></li><li><p>并行操作OR符号 “ | ”</p></li></ul></li></ul></li><li><p>ofstream,（output file stream）</p><p><code>ofstream in;</code><br><code>out.open(&quot;text.txt&quot;);</code></p><p>等价于 <code>ofstream in(&quot;test.txt&quot;);</code></p></li></ul></li><li><p>区分类和结构</p><ul><li>对象内部可以有变量和函数</li><li>结构通常只由各种变量构成</li></ul></li><li><p>声明一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		std::string color;</span><br><span class="line">		std::string engine;</span><br><span class="line">		  <span class="type">float</span> gas_tank;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Wheel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill_tank</span><span class="params">(<span class="type">float</span> liter)</span></span>;</span><br><span class="line"><span class="comment">//方法的声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法的定义通常安排在类声明的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::fill_tank</span><span class="params">(<span class="type">float</span> liter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gas_tank +=liter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：类名的第一个字母大写是一种习惯上的标准，但不是硬性规定，在类声明末尾必须有一个分号【;】</p></li><li><p>类由变量和函数组成，对象将使用那些变量来存储信息，调用那些函数来完成操作</p><ul><li>类里的变量成为属性，函数成为方法</li></ul></li><li><p>作用域解析操作符【::】，作用是告诉编译器这个方法存在于何处，或者说属于哪一个类</p></li></ul></li><li><p>定义构造器——类的构造函数</p><ul><li><p>面向对象的编程技术开发程序最基本步骤</p><ul><li>定义一个由属性和方法的类（模板）</li><li>为该类创建一个变量（实现）</li></ul></li><li><p>区别</p><ul><li>构造器的名字必须和它所在的类的名字一样</li><li>系统在创建某个类的实例时会第一时间自动调用这个类的构造器</li><li>构造器永远不会返回任何值，并且构造函数没有声明类型</li></ul></li><li><p>创建构造器，需要先把它的声明添加到类里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	<span class="built_in">Car</span>(<span class="type">void</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意大小写与类名保持一致。在结束声明之后开始定义构造器本身</span></span><br><span class="line">Car::<span class="built_in">Car</span>(<span class="type">void</span>)    <span class="comment">//不用写void Car::Car(void)</span></span><br><span class="line">&#123;</span><br><span class="line">	color = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">	engine = <span class="string">&quot;V8&quot;</span>;</span><br><span class="line">	wheel = <span class="number">4</span>;</span><br><span class="line">	gas_tank = FULL_GAS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造对象数组：数组可以是任何一种数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car mycar[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//调用语法</span></span><br><span class="line">mycar[x].running;</span><br><span class="line"><span class="comment">//注：x代表着给定数组元素的下标</span></span><br></pre></td></tr></table></figure></li><li><p>每个类至少有一个构造器，如果你没有在类里定义一个构造器，编译器就会替你定义一个没有代码内容的空构造器：<code>ClassName::ClassName()&#123;&#125;</code> 除此之外编译器还会替你创建一个副本构造器。</p></li></ul></li><li><p>定义析构器——类的析构函数</p><ul><li><p>析构器：在销毁一个对象时，系统会调用析构器来达到效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Car</span>(<span class="type">void</span>);</span><br><span class="line">	~<span class="built_in">Car</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器用来完成事先的初始化和准备工作（申请分配内存），析构器用来完成事后所需的清理工作（清理内存）</p></li><li><p>特点</p><ul><li>析构器也永远不返回任何值</li><li>析构器不带任何参数，格式：<code>~ClassName();</code></li></ul></li><li><p>在复杂的类里，析构器往往至关重要（可能引起内存泄漏）</p></li></ul></li><li><p>副本构造器</p><ul><li><p>可以把一个对象赋值给一个类型与之相同的变量</p><ul><li>编译器将生成必要的代码把“源”对象各属性的值分别赋值给“目标”对象的对应成员。这种赋值行为叫逐位复制</li></ul></li><li><p>问题：源对象的成员变量是指针，对象成员进行逐位复制的结果是你将拥有两个一摸一样的实例，而这两个副本里的同名指针会指向相同的地址。当删除其中一个对象时，它包含的指针也将被删除，但万一此时另一个副本（对象）还在引用这个指针，就会出现问题！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2;</span><br><span class="line">obj2=obj1;</span><br></pre></td></tr></table></figure><ul><li><p>解决思路：重载操作符</p></li><li><p>重载“=“操作符，在其中对指针进行处理</p><ul><li>语法：<code>MyClass &amp;operator = (const Myclass &amp;rhs);</code>//这个方法预期的输入参数是一个MyClass类型的、不可改变的引用</li><li>因为这里使用的参数是一个引用，所以编译器在传递输入参数时就不会再为它创建另外一个副本（否则可能导致无限递归）</li><li>返回一个引用，该引用指向一个MyClass类的对象，这样做的好处时方便我们把一组赋值语句串联起来，如a=b=c；</li></ul></li><li><pre class="highlight"><code class="c++">例<span class="hljs-number">2</span>

MyClass obj1;
MyClass obj2=obj1;
&lt;!--code￼<span class="hljs-number">20</span>--&gt;

</code></pre></li></ul></li><li><p>在程序中，调用其函数时，该函数在编译时被替代，而不像一般函数那样是在运行时被调用</p></li><li><p>类模板和函数模板的创建过程几乎没什么区别</p><ul><li>把相关代码放在一起，这条规则同样适用于类模板</li><li>不管是什么模板，编译器都必须看到全部的代码才能为一种给定的类型创建出一个新的实现来</li><li>在创建类模板时，避免类声明和类定义相分离的一个好办法是使用内联方法</li><li>在类里，内联方法的基本含义是在声明该方法的同时还对它进行定义</li><li>语法</li></ul></li><li><p>使用内联模板的好处：让程序员少打字并让源代码的可读性变得更好</p><ul><li>使用Stack模板前，一定要给它添加一个副本构造器和一个赋值操作符重载</li><li>因为代码缺少错误处理功能，例如在栈满时调用 push() 方法，或者在栈为空的时候调用 pop() 方法，会导致程序运行出错</li></ul></li><li><p>在C++里可以使用多个类型占位符，如果类模板需要一种以上的类型，根据具体情况多使用几个占位符即可</p></li></ul></li><li><p>this指针</p><ul><li><p>this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在对象的地址</p></li><li><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">	<span class="type">char</span> fishc;</span><br><span class="line">	<span class="built_in">Human</span>(<span class="type">char</span> fishc);</span><br><span class="line">&#125;;</span><br><span class="line">Human::<span class="built_in">Human</span>(<span class="type">char</span> fishc)&#123;</span><br><span class="line">	fishc = fishc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>this指向当前类的属性</p></li><li><p>改为<code>this-&gt;fishc = fishc;</code> //左边为当前对象的fishc属性，右边为构造器的传入来的fishc参数</p></li><li><p>注意：使用this指针的基本原则，如果代码不存在二义性，就不用this指针</p></li></ul></li><li><p>静态属性和静态方法</p><ul><li><p>面对对象编程技术的一个重要特征是用一个对象把数据和对数据处理的方法封装在一起</p></li><li><p>如果我们所需的功能或数据不属于某个特征的对象，而是属于整个类的，该怎么办？</p></li><li><p>c++允许我们把一个或多个成员声明为属于某个类，而不是仅属于该类的对象。</p><ul><li><p>好处</p><ul><li>程序员可以在没有创建任何对象的情况下调用有关的方法</li><li>能够让有关的数据仍在该类的所有对象间共享</li></ul></li></ul></li><li><p>创建一个静态属性和静态方法：</p><ul><li>只需要在它的声明前加上static保留字即可</li></ul></li><li><p>static</p><ul><li>隐藏：static作为函数的前缀时，可以对其它源文件隐藏该函数</li><li>保持变量内容持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也就是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，与全局变量比起来，static可以控制变量的可见范围，说起来还是隐藏</li><li>默认初始化为0，全局变量和static定义的变量都有这个作用</li></ul></li><li><p>静态方法与this指针的关系</p><ul><li>this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在对象的地址</li><li>在任何一个方法里都可以使用this指针。从本质上讲，c++ 中的对象其实是一种特殊的结构–出了变量，还包含着一些函数的特殊结构</li><li>在程序运行时，对象的属性（变量）和方法（函数）都是保存在内存里，这就意味着它们各自都有与之箱关联的地址</li><li>这些地址都可以通过指针来访问，而this指针时保存着对象本身的地址</li><li>因为静态方法不是属于某个特定的对象，而是由全体对象共享的，这就意味着它们无法访问this指针。所以，我们才无法在静态方法里访问非静态的类成员</li><li>在使用静态属性时，不要忘记为它们分配内存。只要在类声明的外部对静态属性做出声明（就像声明一个变量一样）</li><li>调用：<code>ClassName::methodName();</code></li></ul></li></ul></li></ul><h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3><ul><li><p>类的继承</p><ul><li><p>运用：可以创建一个类的堆叠层次结构，每个子类均将继承它的积累里定义的方法和属性。简单说，通过继承机制，可以对现有的代码进行扩展，并应用在新的程序中</p></li><li><p>基类：可以派生出其它的类，也称为父类或超类。</p></li><li><p>子类：子类是从基类派生出来的类。</p><ul><li>方法-&gt;动作，属性-&gt;状态</li></ul></li><li><p>例子</p><p><code>class SubClass:public SuperClass&#123;...&#125;</code><br><code>class Pig:public Animal&#123;...&#125;</code></p></li></ul></li><li><p>继承机制中的构造器和解析器</p><ul><li><p>构造器带着输入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>(std::string theName);</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>:<span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Pig</span>(std::string theName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法定义</span></span><br><span class="line">Animal::<span class="built_in">Animal</span>(std::string theName)&#123;</span><br><span class="line">	name = theName;</span><br><span class="line">&#125;</span><br><span class="line">Pig::<span class="built_in">Pig</span>(std::string theName):<span class="built_in">Animal</span>(theName)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类的构造器定义里的<code>:Animal(theName)</code>语法含义是：</p><ul><li>当调用Pig（）构造器时（以 theName 作为输入参数），Animal（）构造器也将被调用（theName 输入参数将传递给它）</li><li>当我们调用Pig pig(“小猪猪”);将把字符串&quot;小猪猪&quot;传递给Pig()和Animal()，赋值动作将实际发生在Animal（）方法里</li></ul></li><li><p>基类的构造器在使用子类构造器之前被调用</p></li><li><p>与基类构造器相反，基类的析构器将在子类的最后一条语句执行完毕后才被调用。</p></li><li><p>注意</p><ul><li>初学者常犯的一个错误是用一个毫不相干的类去派生另一个毫不相干的子类</li><li>基本原则：基类和子类之间的关系应该自然和清晰</li><li>构造器的设计越简明越好！我们应该只用它来初始化各种有关的属性</li><li>基本原则：在设计、定义和使用一个类的时候，应该让它的每个组成部分简单到不能再简单</li><li>析构器的基本用途是对前面所做的事情进行清理</li></ul></li></ul></li><li><p>关于从基类继承来的方法和属性的保护：-class Pig : public Animal {…}</p><ul><li><p>c++不仅允许对类里定义的方法和属性实施访问控制，还允许控制子类可以访问基类里的哪些方法和属性</p></li><li><p>public</p><ul><li>是在告诉编译器：继承的方法和属性的访问级别不发生变化——即public仍可以被所有代码访问，protected只能由基类的子类访问，private只能由基类本身访问</li></ul></li><li><p>protected</p><ul><li>把基类的访问级别改为protected，如果原来是public的话，这将使得这个子类外部的代码无法通过子类去访问基类中的public</li></ul></li><li><p>private</p><ul><li>是在告诉编译器从基类继承来的每一个成员都当成private来对待，这意味着只有这个子类可以使用它从基类继承来的元素</li></ul></li><li><p>覆盖方法</p><ul><li>例如当我们需要在基类里提供一个通用的函数，但在它的某个子类里需要修改这个方法的实现，在c++中，覆盖（overriding）就可以做到</li><li>语法：在子类中声明并定义一个与基类中同名的成员</li></ul></li><li><p>重载方法</p><ul><li>重载机制使你可以定义多个同名的方法（函数），只是它们的输入参数必须不同</li></ul></li><li><p>注意：</p><ul><li>对方法（函数）进行重载一定要有的放矢，重载的方法（函数）越多，程序就越不容易看懂</li><li>在对方法进行覆盖（注意区分覆盖和重载）时一定要看仔细，因为只要声明的输入参数和返回值与原来不一致，你编写出来的就将是一个重载方法而不是覆盖方法。而且这种错误往往很难调试</li><li>对从基类继承来的方法进行重载，程序永远不会像你预期的那样工作</li></ul></li></ul></li></ul><h3 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h3><ul><li><p>函数的重载</p><ul><li><p>定义：使用同样的函数名，定义一个有着不同参数，但有着同样用途的函数。可以时参数个数的不同，也可以是参数数据类型的不同</p></li><li><p>注意</p><ul><li>对函数（方法）进行重载一定要谨慎</li><li>重载越多，程序越不容易看懂</li><li>注意区分重载和覆盖</li><li>我们只能通过不同参数进行重载，但不能通过不同的返回值重载（尽管后者也是一种区别</li><li>重载的目的：方便对不同数据类型进行同样的处理</li></ul></li></ul></li><li><p>运算符重载</p><ul><li><p>运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就会自动调用该函数，以实现相应的算法</p></li><li><p>运算符重载是通过定义函数实现的，运算符重载实际上是函数的重载</p></li><li><p>重载规则</p><ul><li><p>c<ins>不允许用户自己定义新的运算符，只能对已有的c</ins>运算符进行重载</p></li><li><p>除了一下五个运算符不允许重载外，其它运算符允许重载</p><ul><li>【.】成员访问运算符</li><li>【.*】成员指针访问运算符</li><li>【::】域运算符</li><li>【sizeof】尺寸运算符</li><li>【?:】条件运算符</li></ul></li><li><p>重载不能改变运算符运算对象（操作数）个数</p></li><li><p>重载不能改变运算符的优先级别</p></li><li><p>重载不能改变运算符的结合性</p></li><li><p>重载运算符的函数不能有默认的参数</p></li><li><p>重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象或类对象的引用。（也就是说，参数不能全部是c++标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符性质）</p></li></ul></li><li><p>运算符重载函数作为类友元函数</p><ul><li>目的：为了访问类的私有成员</li><li>由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符作为成员函数</li></ul></li><li><p>重载运算符目的：让代码更容易阅读和理解</p><ul><li>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。Box operator+(const Box&amp;);</li></ul></li><li><p>重载&lt;&lt;操作符</p><ul><li><p>&lt;&lt; 插入器</p></li><li><p>operator&lt;&lt;()函数的原型</p><ul><li><code>std::ostream&amp;operator&lt;&lt;(std::ostream&amp; os , Rational f );</code></li><li>第一个输入参数os是将要向他写数据的那个流，它是以“引用传递”方式传递的</li><li>第二个输入参数是打算写道那个流里的数据值，不同的operator&lt;&lt;()重载函数就是因为这个输入参数才相互区别的</li><li>返回类型是ostream流的引用。一般来说，在调用operator&lt;&lt;()重载函数时传递给它的是哪一个流，它返回的就应该是那个流的一个引用</li></ul></li></ul></li><li><p>多继承（multiple inheritance)</p><ul><li><p>什么时候用多继承？</p><ul><li>遇到的问题无法只用一个”是一个“关系描述的时候，就要用多继承</li><li>基本语法：<code>class TeachingStudent : public Student,public Teacher&#123;...&#125;</code></li></ul></li></ul></li></ul></li></ul><h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3><ul><li><p>多态性</p><ul><li><p>多态性：指用一个名字定义不同的函数，调用同一个名字的函数，却执行不同的操作，从而实现“一个接口，多种方法”</p></li><li><p>多态是如何实现绑定的？</p><ul><li><p>编译时的多态性：通过重载实现</p><ul><li>编译时多态的特点是运行速度快</li></ul></li><li><p>运行时的多态：通过虚函数实现</p><ul><li>运行时多态的特点是高度灵活和抽象</li></ul></li></ul></li></ul></li><li><p>虚方法(虚函数)</p><ul><li><p>指针（以前的做法）：创建一个变量，再把这个变量的地址赋值给一个指针。</p></li><li><p>问题：使用指向对象的指针</p><ul><li><p>直接创建一个指针并让它指向新分配的内存块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pointer = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*pointer= <span class="number">110</span>;</span><br><span class="line">std :: cout &lt;&lt; *pointer;</span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>虚函数声明：只要在其原型前加上 virtual 保留字即可【virtual void play();】</p></li><li><p>虚函数：在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><ul><li>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</li></ul></li><li><p>注意：虚方法是继承的，一旦在基类里把某个方法声明为虚方法，在子类里就不可能再把它声明为一个虚方法了</p></li><li><p>技巧</p><ul><li>如果拿不准要不要把某个方法声明为虚方法，那么就把它声明为虚方法</li><li>在基类里把所有的方法都声明为虚方法会让最终生成的可执行代码的速度慢一些，但好处是可以一劳永逸地确保程序的行为符合你的预期</li><li>在实现一个多层次的类继承关系的时候，最顶级的基类应该只有虚方法</li></ul></li><li><p>析构器都是虚方法是为了当一个基类的指针删除一个派生类的对象时，派生类的析构函数可以被正确调用</p></li><li><p>当类里有虚函数的时候，编译器会给类添加一个虚函数表，里面存放着虚函数指针。为了节省资源，只有当一个类被用来作为基类的时候，我们才把析构函数写成虚函数</p></li></ul></li><li><p>虚继承（virtual inheritance）</p><ul><li>通过虚继承某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例</li><li>虚继承语法：<code>class Teacher:virtual public Person&#123;...&#125;</code></li></ul></li><li><p>抽象方法</p><ul><li>抽象方法：把某个方法声明为一个抽象方法等于告诉编译器，这个方法必不可少，但我现在（在这个基类里）还不能为它提供一个实现</li><li>纯虚函数：【virtual void funtion1()=0;】 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</li></ul></li></ul><h2 id="c高级教程"><a class="markdownIt-Anchor" href="#c高级教程"></a> C++高级教程</h2><h3 id="链接和作用域"><a class="markdownIt-Anchor" href="#链接和作用域"></a> 链接和作用域</h3><ul><li><p>链接，当同时编译多个文件时： <code>g++ -o test main.cpp rational.cpp</code></p><ul><li>每个源文件都被称为一个翻译单元（translation unit），在某一个翻译单元里定义的东西在另一个翻译单元里使用正是链接发挥作用的地方</li></ul></li><li><p>存储类（storage class）</p><ul><li><p>每个变量都有一个存储类，它决定着程序将把变量的值存储在计算上的哪个地方、如何存储，以及变量应该有着怎样的作用域</p></li><li><p>分类</p><ul><li><p>默认的存储类是auto（自动）</p></li><li><p>自动变量储存称为栈（stack）的临时内存里并有着最小的作用域，当程序执行到语句块或函数末尾的有花括号时，它门将被系统回收（栈回收），不复存在</p></li><li><p>static 变量在程序的生命期内将一直保有它的值不会消亡，存储在静态存储区，生命周期为从申请到程序退出（和全局变量一样）</p><ul><li>一个static 变量可以有external或internal链接</li></ul></li><li><p>extern 它在有多个翻译单元时非常重要。它用来把另一个翻译单元里的某个变量声明为本翻译单元里的一个同名全局变量</p><ul><li>编译器不会为extern变量分配内存，因为它在其它的地方已经分配过内存</li></ul></li><li><p>register 它要求编译器把一个变量存储在CPU的寄存器里，但有着与自动变量相同的作用域</p><ul><li>register变量存储速度最快</li></ul></li></ul></li></ul></li><li><p>用编译器建立程序</p><ul><li><p>1、执行预处理器指令</p><ul><li>把#include指令替换为相应的头文件里的代码</li></ul></li><li><p>2、把 .cpp文件编译成 .o文件</p><ul><li>把C++代码转换为一个编译目标文件，在这一步骤里，编译器将为文件里的变量分配必要的内存并进行各种错误检查</li></ul></li><li><p>3、把 .o文件链接成一个可执行文件</p><ul><li>如果只有一个C++源文件，步骤三只是增加一些标准库代码和生成一个可执行文件</li><li>但当同时编译多个源文件来生成一个可执行文件的时候，在编译好每一个组件之后，编译器还需要把它们链接在一起次才能生成最终的可执行文件</li></ul></li></ul></li><li><p>问题：当一个编译好的对象（即翻译单元）引用一个肯能不存在于另一个翻译单元里的东西时，潜在的混乱就开始出现了</p></li><li><p>链接分三种情况，凡是有名字的东西（函数，类，常量，变量，模板，命名空间）必然属于其中之一：外链接（external），内链接（internal)和无链接（none)</p><ul><li>外链接：每个翻译单元都可以访问这个东西（前提时只要它知道这个东西存在）。普通的函数，变量，模板和命名空间都有外链接</li><li>内链接：在某个翻译单元里定义的东西只能在翻译单元里使用，在任何函数以外定义的静态变量都有内链接</li><li>无链接：在函数里定义的变量只存在于该函数的内部，根本没有任何链接</li></ul></li></ul><h3 id="容器和算法"><a class="markdownIt-Anchor" href="#容器和算法"></a> 容器和算法</h3><ul><li><p>在C++标准库里面有许多现成的容器，它们都经过了老一辈精心设计和测试，可以直接拿来用</p></li><li><p>C++标准库提供的向量（vector）类型从根本上解决了数组先天不足的问题<br><code>std::vector&lt;type&gt;vectorName;</code></p></li><li><p>向量容器：向量可以动态地随着添加元素而无限增大（前提是有足够的可用内存）</p><ul><li>可以用它的size（）方法查知向量的当前长度（它包含的元素个数）</li><li>用push_back()方法来添加元素</li><li>还可以用访问数组元素的语法来访问某个给定向量里的元素</li></ul></li><li><p>迭代器</p><ul><li>遍历向量允许使用下标访问符来访问它的各个元素：nemes[x]</li><li>迭代器也可以遍历容器里的各个元素</li><li>迭代器是一种功能非常有限却很实用的函数，提供一些基本操作符：*、++、==、!=、=</li><li>迭代器是个智能指针，具有遍历复杂数据结构的能力，每种容器都支持</li><li>通过使用迭代器，当在程序里改用另一种容器的时候就不用修改那么多代码了</li><li>每种容器都必须提供自己的迭代器，事实上每种容器都将其迭代器以嵌套的方式定义于内部</li><li>因此各种迭代器的接口相同，型号却不同，这就是所谓泛型程序设计的概念：所有操作行为都使用相同接口，虽然它们的具体实现不同</li><li>好处：迭代器可以和所有的容器配合使用，而使用迭代器去访问容器元素的算法可以和任何一种容器配合使用</li></ul></li></ul><h3 id="错误处理及调试"><a class="markdownIt-Anchor" href="#错误处理及调试"></a> 错误处理及调试</h3><ul><li><p>编译时错误</p><ul><li><p>培养并保持一种编程风格</p></li><li><p>认真对待编译器给出的错误/警告信息</p></li><li><p>三思而后行</p><ul><li>开始写代码前先画流程图</li><li>编译错误不要立刻修改源代码，应该先完整地审阅一遍源代码，再开始纠正错误</li></ul></li><li><p>注意检查最基本地语法</p></li><li><p>把可能有问题地代码行改为注释</p></li><li><p>换一个环境或开发工具</p></li><li><p>检查自己是否已经把所有必要的头文件全部include进来</p></li><li><p>留意变量的作用域和命名空间</p></li><li><p>休息一下</p></li><li><p>使用调试工具</p></li><li><p>把调试好的代码另外保存起来并不再改动它，然后把代码划分成各个模块，用它们来搭建新的应用程序。</p></li></ul></li><li><p>运行时错误</p><ul><li>培养并保持一种良好的编程风格</li><li>多用注释，用好注释</li><li>注意操作符的优先级</li><li>不要忘记对用户输入和文件输入进行合法性检查</li><li>不要做任何假设</li><li>把程序划分成一些比较小的单元模块来测试</li></ul></li><li><p>让函数返回错误代码</p><ul><li><p>创建一些测试函数：专门测试某种条件并根据测试结果返回一个代码来表示当前函数的执行状态</p><ul><li>climits头文件把每种数据类型的最大值和最小值都分别定义为一个常量供我们比较 ，SHORT_MAX</li></ul></li></ul></li><li><p>assert函数</p><ul><li>专门为调试准备的工具函数，被包含在C语言的assert.h库文件内，包含到C++里用#include<cassert></cassert></li><li>assert()函数需要有一个参数，它将测试这个输入参数的真or假状态</li><li>assert()可以用在某个程序里的关键假设不成立时立即停止该程序的执行并报错</li><li>除了assert（）函数，还可以用cout语句来报告在程序里正在发生的事情</li><li>原则：最终用户看到的错误信息应该既专业有清晰，不能轻易中断程序，不能充满技术细节</li></ul></li><li><p>捕获异常</p><ul><li><p>异常（exception）就是与预期不相符的反常现象</p></li><li><p>基本使用思路</p><ul><li>1.安排一些C++代码（try 语句）去尝试某件事，尤其是那些可能会失败的事</li><li>2.如果发生问题，就抛出一个异常（throw语句）</li><li>3.在安排一些代码（catch语句）去捕获这个异常并进行相应的处理</li></ul></li><li><p>基本语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Do something.</span></span><br><span class="line">	<span class="comment">//Throw an exception on error.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Do whatever.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：每条try语句至少要有一条配对的catch语句，必须定义catch语句以便让它接收一个特定类型的参数</p></li><li><p>C++还允许我们定义多条catch语句，让每条catch语句分别对应着一种可能的异常</p><ul><li><code>catch(int e)&#123;...&#125;</code></li><li><code>catch(bool e)&#123;...&#125;</code></li><li><code>catch(...)&#123;...&#125;</code></li></ul></li><li><p>最后一条catch语句可以捕获任何类型的异常</p></li></ul></li><li><p>在程序里，我们可以用throw保留字来抛出一个异常：throw1；</p></li><li><p>在某个try语句块里执行过throw语句，它后面的所有语句（截止到这个try语句块末尾）将永远不会被执行</p></li><li><p>与使用一个条件语句或return语句相比，采用异常处理机制的好处是它可以把程序的正常功能与逻辑与出错处理部分清晰地划分开来而不是让他们混在一起</p></li><li><p>定义一个函数时可以明确地表明你想让它抛出哪种类型地异常</p><ul><li><code>type functionName(arguments)throw(type)</code></li><li>如果没有使用这种语法来定义函数，就意味着函数可以抛出任意类型的异常</li></ul></li></ul></li><li><p>TIPS</p><ul><li><p>使用异常的基本原则：应该只用它们来处理确实可能不整常的情况</p><ul><li>在构造器和析构器里不应该使用异常</li><li>如果try语句块无法找到一个与之匹配的 catch 语句块，它抛出的异常将中止程序的执行</li></ul></li><li><p>在C++标准库里有个名为 exception 的文件，该文件声明了一个 exception 的基类，可以用这个基类来创建个人的子类以管理异常</p></li><li><p>如此抛出和捕获的是 exception 类或其子类的对象</p></li><li><p>如果你打算使用对象作为异常，请记住这样一个原则：以“值传递”方式抛出对象，以“引用传递”方式捕获对象</p></li></ul></li></ul><h3 id="动态内存"><a class="markdownIt-Anchor" href="#动态内存"></a> 动态内存</h3><ul><li><p>动态内存管理</p><ul><li><p>动态内存支持创建和使用种种能够根据具体需要扩大和缩小的数据结构，它们只受限于计算机硬件的内存总量和系统特殊约束</p></li><li><p>静态内存：变量（包括指针变量）、固定长度的数组、某给定的对象，指内存块的长度在程序编译时被设定为一个固定的值，而这个值无法改变</p></li><li><p>动态内存是由一些没有名字、只有地址的内存块构成，那些内存块是在【程序运行期间】动态分配的</p></li><li><p>new</p><p><code>int *i = new int;</code><br><code>delete i;</code><br><code>i = NULL;</code></p><ul><li><p>从内存池申请一些内存需要用new语句，它将根据你提供的数据类型分配一块大小适当的内存</p><ul><li>申请成功，new语句将返回新分配地址块的起始地址</li><li>申请失败，new语句将抛出 std::bad_alloc 异常</li></ul></li><li><p>注意在使用完内存块后，应用 delete语句 把它还给内存池。另外作为一种附加的保险措施，在释放了内存块之后还应该把与之关联的指针设置为 NULL</p></li><li><p>NULL 指针</p><ul><li>当把一个指针变量设置为 NULL 时，它的含义是那个指针将不再指向任何东西</li></ul></li><li><p>new 语句返回的内存块很可能充满“垃圾“数据，所以我们通常先往里面鞋一些东西覆盖，再访问它们，或者在类直接写一个构造器来初始化</p></li><li><p>原则：每条 new 语句都必须与之配对的 delete语句，没有或者有两个 delete语句都属于编程漏洞</p></li></ul></li><li><p>为对象分配内存</p><ul><li><p>为对象分配内存和为各种基本数据类型（int，char，float）分配内存在做法上完全一样</p><ul><li>用new向内存池申请内存</li><li>用delete来释放内存</li></ul></li><li><p>注意</p><ul><li>把方法声明为虚方法</li><li>在重新使用某个指针之前要调用delete语句，如果不这样做，那个指针将得到一个新内存块的地址，而程序将永远也无法释放原先那个内存块，应为它的地址已经被覆盖掉了</li><li>delete语句只释放给定指针变量正指向的内存块，不影响这个指针。在执行delete语句之后，那个内存块被释放了，但指针变量还依然健在</li></ul></li></ul></li></ul></li><li><p>动态数组</p><ul><li><p>数组名和下标操作符[ ]的组合可以被替换成一个指向该数组的基地址的指针和对应的指针运算</p></li><li><p>建立一个动态数组</p><ul><li>把一个数组声明传递给 new 语句将使它返回一个该数组基类型的指针</li><li>把数组下标操作符和该指针变量的名字搭配使用就可以像对待一个数组那样使用new语句为这个数组那样使用 new 语句为这个数组分配的内存块</li></ul></li><li><p>删除一个动态数组</p><ul><li>用来保存数组地址的变量只是一个简单的指针，所以需要明确地告诉编译器它应该删除一个数组</li><li>做法：在delete保留字地后面加上一对方括号：delete[]x;</li></ul></li></ul></li><li><p>从函数或方法返回内存</p><ul><li><p>动态内存的另一个常见用途是让函数申请并返回一个指向内存块地指针</p></li><li><p>基本思路</p><ul><li><p>在函数里调用 new 语句为某种对象或某种基本数据类型分配一块内存，再把那块内存的地址返回给程序的主代码，主代码将使用那块内存并再完成有关操作后立刻释放</p></li><li><p>变量作用域的概念：函数或方法有它们自己的变量，这些变量只能在这个函数的内部使用，这些变量我们称为局部变量（local variable）</p></li><li><p>为什么不应该让函数返回一个指向局部变量的指针？</p><ul><li>任何一个函数都不应该把它自己的局部变量则指针作为它的返回值，因为局部变量在栈里，函数结束自动会释放</li><li>如果你想让一个函数在不会留下任何隐患的情况下返回一个指针，那它只能是一个动态分配的内存块的基地址</li></ul></li></ul></li></ul></li><li><p>避免内存泄露</p><ul><li><p>编程漏洞被称为内存泄漏（memory leak）</p><ul><li>new语句所返回的地址时访问这个内存块的唯一线索，同时也是delete语用来把这个内存块归还给内存池的唯一线索</li></ul></li><li><p>情况一：new的地址值丢失了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="type">int</span> [<span class="number">3000</span>];</span><br><span class="line">x=<span class="keyword">new</span> <span class="type">int</span> [<span class="number">4000</span>];</span><br><span class="line"><span class="keyword">delete</span>[]x;</span><br><span class="line">x=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>情况二：用来保存内存块地址的指针变量作用域的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	My Class *x;</span><br><span class="line">	x = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解决一：在函数返回（结束）前delete x;</li><li>解决二：让函数返回内存块的地址</li></ul></li><li><p>内存作用域</p><ul><li><p>变量都有一个作用域：规定了它们可以在程序的哪些部分使用</p><ul><li>全局作用域：把变量定义在函数的外部，它可以整个程序的所有函数里使用</li></ul></li><li><p>动态内存，没有作用域，一旦被分配，内存块可以在程序的任何地方使用</p><ul><li>需要跟踪它们的使用情况，并在不需要用到它们时把它们及时归还给系统</li><li>但是用来保存其地址的指针变量是受作用域的影响</li></ul></li></ul></li></ul></li></ul><h3 id="命名空间和模块化编程"><a class="markdownIt-Anchor" href="#命名空间和模块化编程"></a> 命名空间和模块化编程</h3><ul><li><p>模块化（modularizat）</p><ul><li>把程序划分为多个组成部分</li><li>通过把程序代码分散到多个文件里，等编译程序时再把那些文件重新组合在一起实现的</li></ul></li><li><p>命名空间（namespace）</p></li><li><p>头文件</p><ul><li><p>借助C++的预编译和编译器的能力，把一个复杂的应用程序划分成多个不同文件，而仍保持它在类和功能上的完整</p></li><li><p>头文件的基本用途是提供必要的函数声明和类声明</p><ul><li>系统头文件：定义系统级功能，要使用这些功能就必须要把相应的头文件包含过来</li><li>自定义头文件<br>#include&quot;fishc.h&quot;</li></ul></li><li><p>头文件是一些以.h作为扩展名的标准文本文件，一般情况下，都应该把自定义的头文件和其余的程序文件放在同一个子目录里，或者在主程序目录下专门创建一个子文件夹来集中存放它们</p></li><li><p>用头文件来保存程序的任何一段代码，如函数或类的声明，但一定不要用头文件来保存它的定义（实现）</p></li><li><p>头文件里应该注释说明：创建日期，文件用途，创建者姓名，最后一次修改日期，有什么限制，前提条件。另外头文件里的每一个类和函数也应该有说明</p></li><li><p>提示</p><ul><li>头文件经典的做法是只保存函数声明、用户自定义类型数据（结构和类）、模板和全局性的常量</li><li>头文件应该只包含最必要的代码，比如只声明一个类或只包含一组彼此相关的函数</li></ul></li><li><p>使用</p><ul><li>在创建了头文件后，用双引号引用文件名<br><code>#include&quot;fishc.h&quot;</code></li><li>如果没有给出路径名，编译器将到当前子目录以及当前开发环境中的其他逻辑子目录里去寻找头文件</li><li>导入头文件可以用相对路径<br><code>#include&quot;./fishc.h&quot;</code></li><li>如果头文件位于某个下级子目录里，那么以下级子目录的名字开头<br><code>#include &quot;includes/fishc.h&quot;</code></li><li>如果头文件位于某个与当前子目录平行的”兄弟“子目录里<br><code>#include &quot;../includes/fishc.h&quot;</code></li></ul></li></ul></li><li><p>创建实现文件</p><ul><li><p>代码模块化规则：接口（函数的原型）和实现（函数体的定义）分开</p></li><li><p>头文件的重要性不仅体现在它们可以告诉编译器某个类、结构或函数将有怎样的行为，还体现在它们可以把这些消息告诉给程序员。</p></li><li><p>C++预处理器</p><ul><li>#if —如果表达式为真，执行代码</li><li>#else —如果前面的 #if 表达式为假，执行代码</li><li>#elif —相当于”elseif“</li><li>#endif —用来标志一个条件指令的结束</li><li>#ifdef —如果本指令所引用的定义已存在，执行代码</li><li>#ifndef —如果本指令所引用的定义不存在，执行代码</li><li>格式<br>#if<br>//代码<br>#endif</li><li>#ifndef LOVE_FISHC<br>#define LOVE_FISHC<br>#endif<br>如果 LOVE_FISHC 还没有定义则定义它</li></ul></li></ul></li><li><p>命名空间</p><ul><li><p>创建的每一个类、函数和变量都只能在一定的区域内使用</p></li><li><p>最大的区域是全局作用域，最小的区域是一个代码块</p></li><li><p>命名空间就是由用户定义的范围，同一个命名空间里的东西只要在这个命名空间有独一无二的名字就行</p></li><li><p>创建命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myNamespace</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//全部东西</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意在最末尾不需要加分号</span></span><br></pre></td></tr></table></figure></li><li><p>如果某个东西在命名空间里定义的，程序将不能立刻使用它</p></li><li><p>意义：把东西放在它们自己的小盒子里，不让他们域可能有着相同名字的其它东西发生冲突</p></li><li><p>使用命名空间方法</p><ul><li>方法一：<code>std::cout&lt;&lt;</code></li><li>方法二：<code>using namespace std;</code><br><code>cout&lt;&lt;&quot;&quot;;</code></li><li>方法三：<code>using std::cout;</code><br><code>cout&lt;&lt;&quot;&quot;;</code></li><li>注意：using 指令的出现位置决定着从命名空间里提取出来的东西能在哪个作用域内使用</li><li>如果 using 放在所有函数前面，它将拥有全局性，如果你把它放在某个函数里，那它将旨在这一个函数里使用</li></ul></li></ul></li></ul><h3 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3><ul><li><p>函数模板</p><ul><li><p>模板可以没有任何类型：它们可以处理的数据并不仅限于某种特定的数据类型</p></li><li><p>当程序需要用到这些函数中的某一个时，编译器将根据即时生成一个能够对特定数据类型进行处理的代码版本</p></li><li><p>泛型编程技术可以让程序员用一个解决方案解决多个问题</p></li><li><p>STL库</p></li><li><p>定义函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行代码里，在尖括号里有一个class T，用来告诉编译器：字母T将在接下来的函数里代表一种不确定的数据类型</li><li>关键字class并不意味着这个是类，只是一种约定俗成的写法</li><li>在告诉计算机 T 是一种类型之后，就可以像对待一种普通数据类型那样使用它了</li></ul></li><li><p>注意：</p><ul><li><p>创建模板时，还可以用<code>template&lt;Typename T&gt;</code>来代替 <code>template&lt;class T&gt;</code>,它们的含义是一样的。</p></li><li><p>不要把函数模板分成原型和实现两个部分</p></li><li><p>为了明确表明<code>swap()</code>是一个函数模板，还可以使用<code>swap&lt;int&gt;(i1,i2)</code>语法来调用这个函数，它将明确地告诉编译器它应该使用哪一种类型</p></li><li><p>如果某个函数对所有数据类型都将进行同样地处理，就应该把它编写成一个模板</p></li><li><p>如果某个函数对不同的数据类型将进行不同的处理，就应该重载</p></li></ul></li></ul></li><li><p>类模板</p><ul><li><p>先编写一个类的模板，再由编译器在你第一次使用这个模板时生成实际代码</p></li><li><p>语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">MyClass</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器实现</p><ul><li><pre class="highlight"><code>MyClass&lt;T&gt;::MyClass()
&#123;
	//初始化操作
&#125;
</code></pre><p>应为MyClass是一个类模板，所以不能只写出MyClass::MyClass()，编译器需要知道与MyClass()配合使用的数据类型，必须在尖括号里提供它，因为没有确定的数据类型可以提供，所以使用一个T作为占位符即可</p></li></ul></li></ul></li></ul><h3 id="高级强制类型转换"><a class="markdownIt-Anchor" href="#高级强制类型转换"></a> 高级强制类型转换</h3><ul><li><p>传统的强制类型转换：把需要的指针类型放在一对圆括号之间，然后写出将被强制转换的地址值</p><p><code>Company *company = new Company(“APPLE”，“Iphone”);</code><br><code>TechCompany *techCompany = company；</code></p><ul><li>注意：不能既删除company，又删除tecCompany。因为强制类型转换操作不会创建一个副本拷贝，它只告诉编译器把有关变量解释为另一种类型组合形式，所以他们指向的是同一个地址</li></ul></li><li><p>万一被强制转换的类型和目标类型结构完全不同，怎么办？</p><ul><li><p>强制类型转换操作符</p><ul><li><p><code>conset_cast&lt;MyClass*&gt;(value)</code></p><ul><li>用来改变value的“常量性”</li></ul></li><li><p><code>dynamic_cast&lt;MyClass*&gt;(value)</code></p><ul><li>用来把一种类型的对象指针安全地强制转换为另一种类型的对象指针。注意：如果value的类型不是一个MyClass类（或MyClass的子类）的指针，这个操作将返回NULL</li></ul></li><li><p><code>reinterpret_case&lt;T&gt;(value)</code></p><ul><li>在不进行任何实质性的转换的情况下，把一种类型的指针解释为另一种类型的指针或把一种整数解释为另一种整数</li></ul></li><li><p><code>static_case&lt;T&gt;(value)</code></p></li><li><p>用来进行强制类型转换而不做任何运行时检查，老式强制类型转换操作的替代品</p></li></ul></li></ul></li></ul><h2 id="疑难杂症"><a class="markdownIt-Anchor" href="#疑难杂症"></a> 疑难杂症</h2><h3 id="用cin输入时如何让不跳过任意地方的空格和换行"><a class="markdownIt-Anchor" href="#用cin输入时如何让不跳过任意地方的空格和换行"></a> 用cin输入时如何让不跳过任意地方的空格和换行？</h3><ul><li>操作符noskipws会令输入运算符读取空白符，而不是跳过它们。</li><li>cin&gt;&gt;noskipws;//设置cin读取空白符</li><li>cin&gt;&gt;skipws;//将cin恢复到默认状态，从而丢弃空白符</li></ul><h3 id="函数引用传参"><a class="markdownIt-Anchor" href="#函数引用传参"></a> 函数引用传参</h3><ul><li>&amp;a，a是实参，即传递过来的那个变量。该变 a 其变量也会变</li><li>数组 array[6];<br>swap(int &amp;a,int n);<br>当a是数组的第一个变量时，可以用*(&amp;a+1)来访问第二个变量</li></ul><h3 id="nullptr与null"><a class="markdownIt-Anchor" href="#nullptr与null"></a> nullptr与NULL</h3><ul><li><p>C++不允许void*隐式转换成其它类型的指针</p><p>#ifdef __cplusplus<br>#define NULL 0<br>#else<br>#define NULL ((void *)0)<br>#endif</p></li><li><p>然而这样用NULL代替0表示空指针在函数重载时会出现问题</p></li><li><p>为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，使用nullptr作为实参。</p></li></ul></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://www.rgzzplus.com/2022/03/10/C/" title="C++ 教程" target="_blank" rel="external">https://www.rgzzplus.com/2022/03/10/C/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/rgzz-zq" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/rgzz-zq" target="_blank"><span class="text-dark">人工智障plus</span><small class="ml-1x"></small></a></h3><div>一只网安菜鸟。</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2022/03/11/hello-world/" title="起源"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2022/03/10/typora%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="typora快捷键"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2022 rgzzplus<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"57d553a3572bd138df53",clientSecret:"f68b8f839d80ce3c3f13201f2d26843d46fc1ade",repo:"rgzz-zq.github.io",owner:"rgzz-zq",admin:["rgzz-zq"],id:md5(location.pathname),distractionFreeMode:!0,language:"zh-CN",enableHotKey:"true",proxy:"https://vercel.rgzzplus.com/github_access_token"});gitalk.render("comments")</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a,t,n=$(this),e=n.attr("alt"),r=n.parent("a");r.length<1&&(-1!=(t=(a=this.getAttribute("src")).lastIndexOf("?"))&&(a=a.substring(0,t)),r=n.wrap('<a href="'+a+'"></a>').parent("a")),r.attr("data-fancybox","images"),e&&r.attr("data-caption",e)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?94cb135e2b01d42780f4972cb63e3884";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>