<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>堆的工作原理 | 技术栈</title><meta name="description" content="堆的工作原理  堆与栈的区别 1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。 2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。 下图是经典的32位系统内存布局，暂时"><meta property="og:type" content="article"><meta property="og:title" content="堆的工作原理"><meta property="og:url" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="堆的工作原理  堆与栈的区别 1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。 2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。 下图是经典的32位系统内存布局，暂时"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IMG_20220409_195211_edit_83875143527305-16495052455141.jpg"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200726403-1240549290.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201103609-1511021026.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200831038-1026261350.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201041134-343961699.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200833202-1162551076.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409211555625.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213629819.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213958164.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409214641325.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409215907248.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222324238.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222035349.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409225639561.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409230535578.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409231557916.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410002226029.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410003750233.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410004537472.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410005451386.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410011617319.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410010737681.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410110935922.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410112022799.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134129670.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134256430.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134354214.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134512823.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410135353770.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410140303715.png"><meta property="article:published_time" content="2022-04-10T06:27:47.000Z"><meta property="article:modified_time" content="2022-04-10T06:34:45.051Z"><meta property="article:author" content="rgzzplus"><meta property="article:tag" content="堆"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"><link rel="canonical" href="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/index.html"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/rgzz-zq" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">人工智障plus</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Wuhan, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎来到技术栈！</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/">经验交流</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/">题库/作业</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" rel="tag">C和指针</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="tag">Linux常用命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" rel="tag">linux命令行大全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E9%97%AE%E9%A2%98/" rel="tag">linux问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ollydebug/" rel="tag">ollydebug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task-struct/" rel="tag">task_struct</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" rel="tag">中国知网</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" rel="tag">内存大小端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E7%AB%99/" rel="tag">建站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E8%B7%AF/" rel="tag">心路</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/C/" style="font-size:13px">C++</a> <a href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" style="font-size:13.5px">C和指针</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size:13px">Linux常用命令</a> <a href="/tags/hexo/" style="font-size:13.5px">hexo</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" style="font-size:13px">linux命令行大全</a> <a href="/tags/linux%E9%97%AE%E9%A2%98/" style="font-size:13px">linux问题</a> <a href="/tags/ollydebug/" style="font-size:13px">ollydebug</a> <a href="/tags/task-struct/" style="font-size:13px">task_struct</a> <a href="/tags/typora/" style="font-size:13px">typora</a> <a href="/tags/ubuntu/" style="font-size:14px">ubuntu</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" style="font-size:13px">中国知网</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size:13px">内存大小端</a> <a href="/tags/%E5%A0%86/" style="font-size:13.5px">堆</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size:13px">建站</a> <a href="/tags/%E5%BF%83%E8%B7%AF/" style="font-size:13px">心路</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size:13px">杂谈</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">16</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a></p><p class="item-title"><a href="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/" class="title">堆溢出</a></p><p class="item-date"><time datetime="2022-04-15T15:32:13.000Z" itemprop="datePublished">2022-04-15</time></p></div></li><li><div class="item-thumb"><a href="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/">经验交流</a></p><p class="item-title"><a href="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="title">使用linux时的问题总结</a></p><p class="item-date"><time datetime="2022-04-10T06:39:47.000Z" itemprop="datePublished">2022-04-10</time></p></div></li><li><div class="item-thumb"><a href="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p><p class="item-title"><a href="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/" class="title">linux命令行</a></p><p class="item-date"><time datetime="2022-04-10T06:37:19.000Z" itemprop="datePublished">2022-04-10</time></p></div></li><li><div class="item-thumb"><a href="/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p><p class="item-title"><a href="/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/" class="title">内存的大小端问题</a></p><p class="item-date"><time datetime="2022-04-10T06:28:47.000Z" itemprop="datePublished">2022-04-10</time></p></div></li><li><div class="item-thumb"><a href="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a></p><p class="item-title"><a href="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="title">堆的工作原理</a></p><p class="item-date"><time datetime="2022-04-10T06:27:47.000Z" itemprop="datePublished">2022-04-10</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">堆的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">堆与栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">堆的数据结构与管理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">堆表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">堆表的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A9%BA%E8%A1%A8"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">空闲双向链表（空表）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%8D%95%E5%90%91%E8%A1%A8%E5%BF%AB%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">快速单向表（快表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">堆中的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%88%86%E9%85%8D"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">堆块分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E9%87%8A%E6%94%BE"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">堆块释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%90%88%E5%B9%B6"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">堆块合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9D%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">堆块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E5%A0%86%E4%B8%AD%E6%BC%AB%E6%B8%B8"><span class="toc-number">2.</span> <span class="toc-text">在堆中漫游</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">堆分配函数之间的调用关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">堆的调试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">实验代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%88%86%E9%85%8D-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">堆块分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E9%87%8A%E6%94%BE-2"><span class="toc-number">2.2.4.</span> <span class="toc-text">堆块释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%90%88%E5%B9%B6-2"><span class="toc-number">2.2.5.</span> <span class="toc-text">堆块合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">快表的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">实验代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-2"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">调试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-堆的工作原理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">堆的工作原理</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="article-date"><time datetime="2022-04-10T06:27:47.000Z" itemprop="datePublished">2022-04-10</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E5%A0%86/" rel="tag">堆</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="leancloud_visitors" data-flag-title="堆的工作原理">0</span> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 5.1k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 18(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="堆的工作原理"><a class="markdownIt-Anchor" href="#堆的工作原理"></a> 堆的工作原理</h1><h2 id="堆与栈的区别"><a class="markdownIt-Anchor" href="#堆与栈的区别"></a> 堆与栈的区别</h2><p>1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。</p><p>2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。</p><p>下图是经典的32位系统内存布局，暂时我们只需要记住栈和堆的增长方向即可，后面实验部分会用到。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="img-32位系统内存布局"></p><table><thead><tr><th></th><th>堆内存</th><th>栈内存</th></tr></thead><tbody><tr><td>典型用例</td><td>动态增长的链表等数据结构</td><td>函数局部数据</td></tr><tr><td>申请方式</td><td>函数申请，通过返回指针使用，<br>如 p = malloc(8);</td><td>程序中直接声名，<br>如 char buffer[8];</td></tr><tr><td>释放方式</td><td>需要指针传给专用的释放函数，如 free</td><td>函数返回时，由系统自动回收</td></tr><tr><td>管理方式</td><td>需要程序员处理申请与释放</td><td>申请后直接使用，申请与释放由<br>系统自动完成，最后到达栈区平衡</td></tr><tr><td>所处位置</td><td>变化范围很大 0x0012XXXX</td><td></td></tr><tr><td>增长方向</td><td>由内存低地址向高地址排列（不考虑碎片等情况）</td><td>由内存高址向低址增加</td></tr></tbody></table><h2 id="堆的数据结构与管理策略"><a class="markdownIt-Anchor" href="#堆的数据结构与管理策略"></a> 堆的数据结构与管理策略</h2><p>程序员使用堆只做三件事：</p><ul><li>申请一定大小的内存</li><li>使用内存</li><li>释放内存</li></ul><p>堆管理系统响应申请，就意味着要在 “`杂乱无章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>]” 的内存中 “辨识<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>” 出空闲的内存，“寻找” 一片 “恰当<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>” 的空闲内存区域，以指针的形式返回给程序。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IMG_20220409_195211_edit_83875143527305-16495052455141.jpg" alt="img-堆的数据结构"></p><p><code>堆表</code>：堆表一般位于堆区的<code>起始位置</code>，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构,用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p><p><code>堆块</code>：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：<code>块首</code>和<code>块身</code>。块首位于一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。</p><p>堆的内存组织如下图：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200726403-1240549290.png" alt="img-堆的内存组织"></p><p>在 Windows 中，占用态<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的堆块被使用它的程序索引，而堆表只索引所有 空闲态<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 的堆块。</p><h3 id="堆表"><a class="markdownIt-Anchor" href="#堆表"></a> 堆表</h3><h4 id="堆表的实现"><a class="markdownIt-Anchor" href="#堆表的实现"></a> 堆表的实现</h4><p>在 Windows 中，堆表实现方法两种：<code>空闲双向链表</code> Free list（简称空表）和<code>快速单向链表</code> Look aside（简称快表）</p><h5 id="空闲双向链表空表"><a class="markdownIt-Anchor" href="#空闲双向链表空表"></a> 空闲双向链表（空表）</h5><p>堆区一开始的堆表区中有一个<code>128</code>项的指针数组，被称做<code>空表索引（Freelist array）</code>。该数组的每一项包括两个指针，用双向链表组织一条空表,如下图。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201103609-1511021026.png" alt="img-空闲双向链表"></p><p><code>空表索引</code>的第二项（<code>free[1]</code>）链接了堆中所有大小为<code>8字节</code>的空闲堆块，之后每个索引项链接的空闲堆块大小递增8字节，例如，<code>free[2]</code>链接大小为16字节的空闲堆块，<code>free[3]</code>链接大小为24字节的空闲堆块，<code>free[127]</code>标识大小为1016字节的空闲堆块。因此有：</p><p><strong>空闲堆块的大小＝索引项（ID）×8（字节）</strong></p><p><code>空表索引</code>的第一项（<code>free[0]</code>）所标识的空表相对比较特殊。这条双向链表链接了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去.把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索。</p><h4 id="快速单向表快表"><a class="markdownIt-Anchor" href="#快速单向表快表"></a> 快速单向表（快表）</h4><p>快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并,快表也有128条，组织结构与空表类似,只是其中的堆块按照<code>单链表</code>组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p><p>快表结构：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200831038-1026261350.png" alt="img-快表"></p><h3 id="堆中的操作"><a class="markdownIt-Anchor" href="#堆中的操作"></a> 堆中的操作</h3><p>堆中的操作分为三种：堆块分配，堆块释放，堆块合并。（其中 “分配” 和 “释放” 是在程序提交申请时执行的，而堆块合并是由堆管理系统自动完成）</p><h4 id="堆块分配"><a class="markdownIt-Anchor" href="#堆块分配"></a> 堆块分配</h4><p>堆块分配分为三类：</p><ul><li><code>快表分配</code>：找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用；</li><li><code>普通空表分配</code>： 首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>，即最小的能够满足要求的空闲块；</li><li><code>零号空表（free[0]）</code>：先从 free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配。</li></ul><h4 id="堆块释放"><a class="markdownIt-Anchor" href="#堆块释放"></a> 堆块释放</h4><p>释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入<code>堆表的末尾</code>，分配的时候也先从堆表末尾拿。<code>快表最多只有4项</code></p><h4 id="堆块合并"><a class="markdownIt-Anchor" href="#堆块合并"></a> 堆块合并</h4><p>条件：当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。</p><p><code>堆块合并</code>将两个块从空闲链表中 “卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。</p><h3 id="堆块"><a class="markdownIt-Anchor" href="#堆块"></a> 堆块</h3><p>根据堆块是否被占用分为<code>占用态</code>堆块和<code>空闲态</code>堆块。</p><p><code>占用态</code>堆块的数据结构如下：<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201041134-343961699.png" alt="img-占用态堆块"></p><p><code>空闲态</code>堆块的数据结构如下：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200833202-1162551076.png" alt="img-空闲态堆块"></p><p>对比上面两图可知，空闲态堆块和占用态堆块的块首结构基本一致。相对于占用态的堆块来说，空闲态堆块的块首后8个字节存放了两个指针地址，分别指向前驱堆块和后驱堆块。</p><p>Self Size：块整体的大小，包括块首和块身的大小</p><p>Previous chunk size：上一个块的大小</p><p>Segment Index：段索引</p><p>Flags：标志位，用于标志块的状态，即空闲态，占用态等等</p><p>Unused bytes：</p><h1 id="在堆中漫游"><a class="markdownIt-Anchor" href="#在堆中漫游"></a> 在堆中漫游</h1><h2 id="堆分配函数之间的调用关系"><a class="markdownIt-Anchor" href="#堆分配函数之间的调用关系"></a> 堆分配函数之间的调用关系</h2><p>Windows 堆分配的 API 调用关系</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409211555625.png" alt="img-Windows 堆分配的 API 调用关系"></p><p>所有的堆分配函数最终都将使用位于 ntdll.dll 中的 RtlAllocateHeap() 函数进行分配。</p><h2 id="堆的调试方法"><a class="markdownIt-Anchor" href="#堆的调试方法"></a> 堆的调试方法</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h3 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">3</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">5</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">6</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">19</span>);</span><br><span class="line">	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//free block and prevent coaleses</span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3); <span class="comment">//free to freelist[2] </span></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h5); <span class="comment">//free to freelist[4]</span></span><br><span class="line">	</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h4); <span class="comment">//coalese h3,h4,h5,link the large block to freelist[8]</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：_asm int 3 是中断指令，用来中断程序，因为如果直接加载程序到 Ollydbg ，程序将使用调试态堆管理策略，而调试态堆管理策略和常态堆管理策略有很大不同：<br>（1）调试堆不使用快表，只用空表分配。<br>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。<br>（3）块首的标志位不同。</p><h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3><p>在调试前我们先将我们的调试工具 Ollydbg 设为默认调试器</p><ol><li>首先以管理员身份打开 Ollydbg</li><li>在菜单栏下找到 选项 --&gt; 选项</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213629819.png" alt="img-2"></p><ol start="3"><li>在选项的菜单栏中找到<code>杂项</code>，勾选<code>将这份x64dbg设为即时调试器</code>，然后保存</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213958164.png" alt="img-3"></p><p>设置完成后，直接进入vc++6.0，编译成功后，我们直接双击运行，如下</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409214641325.png" alt="image-断点"></p><p>单击 “否” ，将自动打开 Ollydbg 并附加上进程，并在断点处停下来。<br>根据源码可知，中断是发生在<code>HeapCreate</code>函数执行完成后的，<code>HeapCreate</code>执行后会返回堆地址，结果保存在<code>eax</code>中，我们在调试器发现eax值是：<code>0x003A0000</code></p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409215907248.png" alt="image-断点处"></p><p>也就是说<code>HeapCreate</code>创建的堆区起始位置在<code>003A0000</code>，即堆表从此位置开始，堆表中依次为<code>段表索引（Segment List）</code>、<code>虚表索引(Virtual Allocation list)</code>、<code>空表使用标识（freelist usage bitmap）</code>和<code>空表索引区</code>。</p><p>此处我们只关心堆偏移<code>0x178</code> 处的空表索引区，这个偏移是堆表起始的位置（根据上次我们介绍的堆表结构，堆表包含128的8个字节的<code>flink</code>和<code>blink</code>地址。所以堆表的结束位置在：128*8=1024=0x400,加上偏移，0x178+0x400=0x578）</p><p>加上堆基址<code>0x003A0000</code>+<code>0x178</code>=<code>0x003A0178</code>，单击内存1，在内存1中按<code>ctrl+G</code>，输入刚刚计算出的地址，回车，我们来到了这个地址。<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222324238.png" alt="image-内存1"><br>如图，这个地址便是free[0]，占8个字节，<code>flink</code>和<code>blink</code>指向的地址都是<code>0x003a0688</code>。后面的依次是free[1]、free[2]，依次类推，我们发现free[1]、free[2]…free[127]都指向自身，根据链表的特点可知，它们都是空链表。</p><blockquote><p>所以当一个堆刚刚被初始化时，只包含一个空闲态的大块，这个块也叫为&quot;尾块&quot; free[0]指向这个&quot;尾块&quot;</p></blockquote><p>我们转到&quot;尾块&quot;的位置去看看（因为这里只有一个堆块，即free[0]指向的地址，free[0]=<code>0x003a0688</code>）<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222035349.png" alt="image-尾块"></p><p>上面，我们讲过，空闲态的堆块有8个字节的 flink 与 blink ，分别指向前驱节点与后继节点，此处的值均为<code>0x003a0178</code>,这个地址是堆表 free[0] 的地址，可知，实验与理论相符。</p><p>实际上。在上面我们有提到，堆管理系统返回的堆地址是指向<code>块身</code>的。在其前面还有8个字节的<code>块首</code>，所以这个堆块起始于<code>0x003a0680</code>, 根据上面谈到的块首的结构。前2个字节为块大小，此处值是<code>0x130</code>, 堆的计算单位是8字节，也就是<code>0x980</code>字节。</p><blockquote><p>注意：堆大小包含块首在内。</p></blockquote><h3 id="堆块分配-2"><a class="markdownIt-Anchor" href="#堆块分配-2"></a> 堆块分配</h3><p>通过上面的调试，我们应该了解以下堆块分配细节</p><ul><li>堆块的大小包括了块首在内，即如果请求32字节，实际会分配的堆块为40字节：8字节块首＋32字节块身；</li><li>堆块的单位是8字节，不足8字节的部分按8字节分配；</li><li>初始状态下，快表和空表都为空，不存在精确分配。请求将使用 “次优块” 进行分配（这个“次优块”就是位于偏移 <code>0x0688</code> 处的尾块，见上一节最后一张图）</li><li>由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的 size 信息，最后把 freelist[0] 指向新的尾块位置。</li></ul><p>内存请求分配情况</p><table><thead><tr><th style="text-align:center">堆句柄</th><th style="text-align:center">请求字节数</th><th style="text-align:center">实际分配（堆单位）</th><th style="text-align:center">实际分配（字节）</th></tr></thead><tbody><tr><td style="text-align:center">h1</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h3</td><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h4</td><td style="text-align:center">8</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h5</td><td style="text-align:center">19</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">h6</td><td style="text-align:center">24</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr></tbody></table><p>在调试器中，我们单步走过第一<code>个HeapAlloc</code>，然后观察内存空间。</p><blockquote><p>tips: 对于我们主动设置的int 3指令，如果调试器忽略异常后仍无法步过的话，可以在下一行代码处右键，此处设为新的eip。</p></blockquote><p>按上面的分析，执行完<code>h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);</code>后，<br>会从<code>0x3a0680</code>地址开始切出一块大小为2个单位（16字节）的空间分配给h1,<br>新的尾块起始地址则为<code>0x003a0690</code>,<br>flink与blink地址位于<code>0x003a0698</code>和<code>0x003a069c</code>,其值<code>0x003a0178</code>指向<code>freelist[0]</code>,<br><code>freelist[0]</code>则指向新的起始地址<code>0x003a0698</code>，(<code>003a0690+8</code>字节的块首，我们上面有提到过指向块身。)</p><p>尾块起始处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409225639561.png" alt="img-尾块1"></p><p>另外，尾块的大小为<code>0x12e</code>， 等于原来的130减去分配出去的2个单位，还剩下<code>0x130-2=0x12e</code>个单位（堆的单位，不是字节），如上图，也可以验证。<br>h1所指向的堆块起始位置则是<code>0x003a0680</code>，如上图可知，大小为2个单位</p><p>堆表 freelist[0] 处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409230535578.png" alt="image-freelist[0]"></p><p>接着，会执行<code>h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);</code> 按分配原则，会从尾块中再切一块大小为2个单位（16字节）的空间给h2,然后freelist[0]指向新的尾块起始地址，新的尾块仍指向 freelist[0]，剩下的尾块大小为<code>12e-2=12c</code>个单位。<br>剩下的依次类推，</p><p>当执行完<code>h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);</code>后，堆分配情况如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409231557916.png" alt="image-分配完"></p><p>剩下的堆大小为 <code>130-2-2-2-2-4-4=120</code>单位，尾块扔指向 freelist[0]（<code>0x003a0178</code>）,我们去看下 freelist[0] 的值，此时应该指向，尾块的块首<code>0x003a0708</code>，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410002226029.png" alt="image-块尾"></p><p>到此，堆的分配则执行完了。根据上面的理论可知，堆表中仍只有一个尾块，不存在其它的堆块。</p><h3 id="堆块释放-2"><a class="markdownIt-Anchor" href="#堆块释放-2"></a> 堆块释放</h3><p>由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小， h1 和 h3 为16字节，则被链入 freelist[2]， h5 为 32字节，则被链入 freelist[4]。</p><p>当执行<code>HeapFree(hp, 0, h1)</code>后，h1 会被链入 freelist[2]，所以我们来看看 freelist[2] 的地址；<br>由于 freelist[0] 的地址为<code>0x003a0178</code>，所以 freelist[2] 的地址为<code>0x003a0178 + 2*0x8 = 0x003a0188</code></p><p>执行前，如下图，freelist[2] 指向自己，还是空表<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410003750233.png" alt="img-freelist[0]执行前"></p><p>执行后，根据链表规则freelist[2]会指向h1的地址，如下图，h1则会指向freelist[2]<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410004537472.png" alt="image-freelist[2]，执行后"></p><p>执行后，原来h1所指向的堆块变为空闲态并指向freelist[2]。如下图，flink与blink都指向freelist[2]，因为此时只有链表中就一个节点<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410005451386.png" alt="image-h1，执行后"></p><p>接着会释放h3,执行<code>HeapFree(hp, 0, h3)</code>，执行完后，h3所指向的堆块会被链入到freelist[2]，并插入到整个链表的末尾。如下图所示，原来h3所在的堆块的blink（地址0x003a06ac）指向前一个堆块，即原来的h1，h3的flink则指向freelist[2]，因为它是最后一个元素。原来的h1的blink指向freelist[2]，flink指向h3<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410011617319.png" alt="image-h3"></p><p>执行后的freelist[2]（<code>0x003a0188</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410010737681.png" alt="image-freelist[2]执行后"></p><p>形成的链表大概如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freelist[2] &lt;---&gt; h1 &lt;---&gt; h3</span><br></pre></td></tr></table></figure><blockquote><p>注h3的flink与freelist[2]的blink未给出。</p></blockquote><p>再下一步，执行<code>HeapFree(hp, 0, h5);</code>，释放h5所在的堆块，并链入freelist[4]</p><h3 id="堆块合并-2"><a class="markdownIt-Anchor" href="#堆块合并-2"></a> 堆块合并</h3><p>条件：当两个空闲块彼此相邻，释放这两个相邻的空闲块会发生堆块合并操作</p><p>步骤：</p><ol><li>进行第四步RtlFreeHeap()，释放 h4 后，进行堆块合并</li><li>首先将从空表中摘下 h3,h4,h5 三个空闲块</li><li>然后重新计算合并后新堆块的大小，<code>2+2+4=8</code>(堆单位：8字节)</li><li>最后按照合并后的大小把新块连入链表，根据大小，新块将被链入 freelist[8]</li></ol><p>我们来看看 freelist[8]（<code>0x003a01b8</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410110935922.png" alt="image-freelist[8]"><br>可以看到，<code>0x003a06a8</code>已经被链入freelist[8]中了，<br>freelist[2]（<code>003a0188</code>)中也只剩下 h1（<code>003a0688</code>)，因为 h3 在合并时被摘下了，<br>freelist[4]（<code>00ea0198</code>)也指向自身了，因为 h5 在合并时也被摘下来了</p><p>进入<code>0x003a06a8</code>，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410112022799.png" alt="image-0x003a06a8"><br>可以看到，合并只修改了块首的数据，原来的块身基本不变，大小变成了<code>0x0008</code>，空表指针指向<code>0x003a01b8</code>（就是freelist[8])</p><blockquote><p>注意：</p><ul><li>堆块合并只发生在空表中<br>因为堆块合并要修改多处指针，比较耗时，所以在强调分配效率的快表中，禁止堆块合并</li><li>空表中的第一个块不会向前合并，最后一个不会向后合并</li></ul></blockquote><h3 id="快表的使用"><a class="markdownIt-Anchor" href="#快表的使用"></a> 快表的使用</h3><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h4 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	HLOCAL h1,h2,h3,h4;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">	HeapFree(hp, <span class="number">0</span>, h1);</span><br><span class="line">	HeapFree(hp, <span class="number">0</span>, h2);</span><br><span class="line">	HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">	HeapFree(hp, <span class="number">0</span>, h4);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用快表后，堆结构会发生变化，最主要的变化是 “尾块” 不在位于堆 0x0688 偏移处了，这个位置被快表霸占。</p></blockquote><h4 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h4><p>我们先来看看空表索引区发生了哪些变化，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134129670.png" alt="image-空表索引区"><br>可以看到，在<code>0x003a0178</code>处变为了<code>003a1e90</code>，不再是<code>0x03a0688</code></p><p>现在我们来看看快表（<code>0x003a0688</code>），在偏移 <code>ox0688</code>处，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134256430.png" alt="image-快表"><br>可以看到，堆刚初始化，快表是空的</p><p>然后我们将将代码调试到，释放完 h4之后，如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134354214.png" alt="image-代码"></p><p>根据四个堆块大小我们可以知道，h1,h2 将会被插入到 Lookaside[1]中，h3 会被插入到 Lookaside[2]中，h4会被插入到 Lookaside[4]中，快表区状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134512823.png" alt="image-快表"><br>可以看到，<code>003a1ea0</code>是 8字节堆块地址，<code>003a1eb0</code>是16字节堆地址，<code>003a1ec8</code>是24字节堆地址</p><p>进入<code>003a1ea0</code>，来看看堆块状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410135353770.png" alt="image-003a1ea0"><br>紫色框的为下一堆块指针，红色框为堆块状态，<code>ox01</code>表示是 Busy 状态<br>块首只存指向下一堆块的指针，不存再指向前一堆块的指针。</p><p>接着申请 16 字节的空间，系统会从 Lookaside[2]中卸载一个堆块分配给程序，同时修改 Lookaside[2] 表头，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410140303715.png" alt="image-lookaside[2]"></p><p>可以看到，Lookaside[2]（<code>0x003a0718</code>)处变为空了。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>堆的数据结构： <code>堆块</code>、<code>堆表</code></li><li>堆块：包含<code>块首</code>、<code>块身</code></li><li><code>堆表</code>：<code>空闲双向链表（freelist）</code>、<code>快速单向链表(lookaside)</code></li><li>占用态的堆块：<code>8字节的块首+块身</code></li><li>空闲态的堆块：<code>16字节的块首（多了flink与blink）+块身</code>。空闲态的堆块变为占用态时，flink与blink所在的空间将变为data区。</li></ul><hr><blockquote><p>参考：</p><ul><li><p>《0day,软件安全漏洞分析技术》</p></li><li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hslim/p/15530690.html#14-%E6%80%BB%E7%BB%93">《深入分析 win32 堆结构与管理策略》</a></p></li></ul></blockquote><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>“杂乱” 是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能 呈现出大小不等且空闲块、占用块相间隔的凌乱状态。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>“辨别” 是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>“恰当” 是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用 8 个字节，而返回给用户一片 512 字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>”占用态” 是指已经被分配给用户程序的内存 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>“空闲态” 是指未被分配给用户程序的内存 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>&quot;次优分配“ 发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" title="堆的工作原理" target="_blank" rel="external">https://www.rgzzplus.com/2022/04/10/堆的工作原理/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/rgzz-zq" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/rgzz-zq" target="_blank"><span class="text-dark">人工智障plus</span><small class="ml-1x"></small></a></h3><div>一只网安菜鸟。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/" title="内存的大小端问题"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/" title="ubuntu命令行编C语言"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span></span> <span class="post-meta-divider"><br></span><span id="busuanzi_container_site_uv">总访客数：<span id="busuanzi_value_site_uv" </span>人</div><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer src="https://cdn1.lncld.net/static/js/av-min-1.2.1.js"></script><script defer>function showTime(e){var t=new AV.Query(e),n=$(".leancloud_visitors");t.greaterThanOrEqualTo("time",0),t.find({success:function(e){var r;0!=e.length&&(r=e,n.each(function(){for(var e=$(this).attr("id").trim(),t=0;t<r.length;t++){var n=r[t],o=n.get("time");e==n.get("url")&&$(this).text(o)}}))},error:function(e,t){console.log("Error: "+t.code+" "+t.message)}})}function addCount(o){o=AV.Object.extend("Counter");url=$(".leancloud_visitors").attr("id").trim(),title=$(".leancloud_visitors").attr("data-flag-title").trim();var e=new AV.Query(o);e.equalTo("url",url),e.find({success:function(e){var t,n;0<e.length?((t=e[0]).fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){var t=e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})):((n=new o).set("title",title),n.set("url",url),n.set("time",1),n.save(null,{success:function(e){console.log("newcounter.get('time')="+e.get("time"));var t=e.get("time");$(document.getElementById(url)).text(t)},error:function(e,t){console.log("Failed to create")}}))},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}AV.init({appId:"Ese7lhBjjv43UJw6zLdiIfS0-gzGzoHsz",appKey:"FF6J9UoHgtozwmftxTYfrvqn"}),$(function(){var e=AV.Object.extend("Counter");(1==$(".leancloud_visitors").length?addCount:showTime)(e)})</script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!0,notify:!0,appId:"Ese7lhBjjv43UJw6zLdiIfS0-gzGzoHsz",appKey:"FF6J9UoHgtozwmftxTYfrvqn",placeholder:"说点什么吧！",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a,t,n=$(this),e=n.attr("alt"),r=n.parent("a");r.length<1&&(-1!=(t=(a=this.getAttribute("src")).lastIndexOf("?"))&&(a=a.substring(0,t)),r=n.wrap('<a href="'+a+'"></a>').parent("a")),r.attr("data-fancybox","images"),e&&r.attr("data-caption",e)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?94cb135e2b01d42780f4972cb63e3884";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>